(function(define){var __define; typeof define === "function" && (__define=define,define=null);
// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles

(function (modules, entry, mainEntry, parcelRequireName, globalName) {
  /* eslint-disable no-undef */
  var globalObject =
    typeof globalThis !== 'undefined'
      ? globalThis
      : typeof self !== 'undefined'
      ? self
      : typeof window !== 'undefined'
      ? window
      : typeof global !== 'undefined'
      ? global
      : {};
  /* eslint-enable no-undef */

  // Save the require from previous bundle to this closure if any
  var previousRequire =
    typeof globalObject[parcelRequireName] === 'function' &&
    globalObject[parcelRequireName];

  var cache = previousRequire.cache || {};
  // Do not use `require` to prevent Webpack from trying to bundle this call
  var nodeRequire =
    typeof module !== 'undefined' &&
    typeof module.require === 'function' &&
    module.require.bind(module);

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire =
          typeof globalObject[parcelRequireName] === 'function' &&
          globalObject[parcelRequireName];
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error("Cannot find module '" + name + "'");
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = (cache[name] = new newRequire.Module(name));

      modules[name][0].call(
        module.exports,
        localRequire,
        module,
        module.exports,
        this
      );
    }

    return cache[name].exports;

    function localRequire(x) {
      var res = localRequire.resolve(x);
      return res === false ? {} : newRequire(res);
    }

    function resolve(x) {
      var id = modules[name][1][x];
      return id != null ? id : x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.register = function (id, exports) {
    modules[id] = [
      function (require, module) {
        module.exports = exports;
      },
      {},
    ];
  };

  Object.defineProperty(newRequire, 'root', {
    get: function () {
      return globalObject[parcelRequireName];
    },
  });

  globalObject[parcelRequireName] = newRequire;

  for (var i = 0; i < entry.length; i++) {
    newRequire(entry[i]);
  }

  if (mainEntry) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(mainEntry);

    // CommonJS
    if (typeof exports === 'object' && typeof module !== 'undefined') {
      module.exports = mainExports;

      // RequireJS
    } else if (typeof define === 'function' && define.amd) {
      define(function () {
        return mainExports;
      });

      // <script>
    } else if (globalName) {
      this[globalName] = mainExports;
    }
  }
})({"9oFvy":[function(require,module,exports) {
var global = arguments[3];
var W = Object.create;
var D = Object.defineProperty;
var V = Object.getOwnPropertyDescriptor;
var G = Object.getOwnPropertyNames;
var X = Object.getPrototypeOf, J = Object.prototype.hasOwnProperty;
var q = (e, t, o, r)=>{
    if (t && typeof t == "object" || typeof t == "function") for (let s of G(t))!J.call(e, s) && s !== o && D(e, s, {
        get: ()=>t[s],
        enumerable: !(r = V(t, s)) || r.enumerable
    });
    return e;
};
var z = (e, t, o)=>(o = e != null ? W(X(e)) : {}, q(t || !e || !e.__esModule ? D(o, "default", {
        value: e,
        enumerable: !0
    }) : o, e));
var _ = typeof globalThis.process < "u" ? globalThis.process.argv : [];
var T = ()=>typeof globalThis.process < "u" ? globalThis.process.env : {};
var K = new Set(_), w = (e)=>K.has(e), ue = _.filter((e)=>e.startsWith("--") && e.includes("=")).map((e)=>e.split("=")).reduce((e, [t, o])=>(e[t] = o, e), {});
var de = w("--dry-run"), A = ()=>w("--verbose") || T().VERBOSE === "true", fe = A();
var x = (e = "", ...t)=>console.log(e.padEnd(9), "|", ...t);
var L = (...e)=>console.error("\uD83D\uDD34 ERROR".padEnd(9), "|", ...e), k = (...e)=>x("\uD83D\uDD35 INFO", ...e), R = (...e)=>x("\uD83D\uDFE0 WARN", ...e), Q = 0, p = (...e)=>A() && x(`\u{1F7E1} ${Q++}`, ...e);
var c = {
    "isContentScript": false,
    "isBackground": false,
    "isReact": false,
    "runtimes": [
        "page-runtime"
    ],
    "host": "localhost",
    "port": 1815,
    "entryFilePath": "/Users/davidzimberknopf/Documents/Apps/vue-plasmo-text/.plasmo/static/popup.ts",
    "bundleId": "8e90d8397e394c8b",
    "envHash": "e792fbbdaa78ee84",
    "verbose": "false",
    "secure": false,
    "serverPort": 52712
};
module.bundle.HMR_BUNDLE_ID = c.bundleId;
globalThis.process = {
    argv: [],
    env: {
        VERBOSE: c.verbose
    }
};
var Y = module.bundle.Module;
function Z(e) {
    Y.call(this, e), this.hot = {
        data: module.bundle.hotData[e],
        _acceptCallbacks: [],
        _disposeCallbacks: [],
        accept: function(t) {
            this._acceptCallbacks.push(t || function() {});
        },
        dispose: function(t) {
            this._disposeCallbacks.push(t);
        }
    }, module.bundle.hotData[e] = void 0;
}
module.bundle.Module = Z;
module.bundle.hotData = {};
var d = globalThis.browser || globalThis.chrome || null;
async function m(e = !1) {
    e ? (p("Triggering full reload"), d.runtime.sendMessage({
        __plasmo_full_reload__: !0
    })) : globalThis.location?.reload?.();
}
function h() {
    return !c.host || c.host === "0.0.0.0" ? location.protocol.indexOf("http") === 0 ? location.hostname : "localhost" : c.host;
}
function f() {
    return c.port || location.port;
}
var S = "__plasmo_runtime_page_";
var i = {
    checkedAssets: {},
    assetsToDispose: [],
    assetsToAccept: []
}, B = ()=>{
    i.checkedAssets = {}, i.assetsToDispose = [], i.assetsToAccept = [];
};
function u(e, t) {
    let { modules: o } = e;
    if (!o) return [];
    let r = [], s, n, a;
    for(s in o)for(n in o[s][1])a = o[s][1][n], (a === t || Array.isArray(a) && a[a.length - 1] === t) && r.push([
        e,
        s
    ]);
    return e.parent && (r = r.concat(u(e.parent, t))), r;
}
function E(e, t, o) {
    if (C(e, t, o)) return !0;
    let r = u(module.bundle.root, t), s = !1;
    for(; r.length > 0;){
        let [n, a] = r.shift();
        if (C(n, a, null)) s = !0;
        else {
            let y = u(module.bundle.root, a);
            if (y.length === 0) {
                s = !1;
                break;
            }
            r.push(...y);
        }
    }
    return s;
}
function C(e, t, o) {
    let { modules: r } = e;
    if (!r) return !1;
    if (o && !o[e.HMR_BUNDLE_ID]) return e.parent ? E(e.parent, t, o) : !0;
    if (i.checkedAssets[t]) return !0;
    i.checkedAssets[t] = !0;
    let s = e.cache[t];
    return i.assetsToDispose.push([
        e,
        t
    ]), !s || s.hot && s.hot._acceptCallbacks.length ? (i.assetsToAccept.push([
        e,
        t
    ]), !0) : !1;
}
function M(e, t) {
    let { modules: o } = e;
    return o ? !!o[t] : !1;
}
function ee(e) {
    if (e.type === "js" && typeof document < "u") return new Promise((t, o)=>{
        let r = document.createElement("script");
        r.src = `${e.url}?t=${Date.now()}`, e.outputFormat === "esmodule" && (r.type = "module"), r.addEventListener("load", ()=>t(r)), r.addEventListener("error", ()=>o(new Error(`Failed to download asset: ${e.id}`))), document.head?.appendChild(r);
    });
}
var P = !1;
try {
    (0, eval)('throw new Error("test"); //# sourceURL=test.js');
} catch (e) {
    P = e.stack.includes("test.js");
}
async function O(e) {
    global.parcelHotUpdate = Object.create(null), e.forEach((o)=>{
        o.url = d.runtime.getURL("/__plasmo_hmr_proxy__?url=" + encodeURIComponent(`${o.url}?t=${Date.now()}`));
    });
    let t = await Promise.all(P ? [] : e.map(ee));
    try {
        e.forEach(function(o) {
            $(module.bundle.root, o);
        });
    } finally{
        delete global.parcelHotUpdate, t && t.forEach((o)=>{
            o && document.head?.removeChild(o);
        });
    }
}
function te(e) {
    let t = e.cloneNode();
    t.onload = function() {
        e.parentNode !== null && e.parentNode.removeChild(e);
    }, t.setAttribute("href", e.getAttribute("href").split("?")[0] + "?" + Date.now()), e.parentNode.insertBefore(t, e.nextSibling);
}
var b = null;
function oe() {
    b || (b = setTimeout(function() {
        let e = document.querySelectorAll('link[rel="stylesheet"]');
        for(var t = 0; t < e.length; t++){
            let o = e[t].getAttribute("href"), r = h(), s = r === "localhost" ? new RegExp("^(https?:\\/\\/(0.0.0.0|127.0.0.1)|localhost):" + f()).test(o) : o.indexOf(r + ":" + f());
            /^https?:\/\//i.test(o) && o.indexOf(location.origin) !== 0 && !s || te(e[t]);
        }
        b = null;
    }, 47));
}
function $(e, t) {
    let { modules: o } = e;
    if (o) {
        if (t.type === "css") oe();
        else if (t.type === "js") {
            let r = t.depsByBundle[e.HMR_BUNDLE_ID];
            if (r) {
                if (o[t.id]) {
                    let n = o[t.id][1];
                    for(let a in n)if (!r[a] || r[a] !== n[a]) {
                        let l = n[a];
                        u(module.bundle.root, l).length === 1 && v(module.bundle.root, l);
                    }
                }
                P && (0, eval)(t.output);
                let s = global.parcelHotUpdate[t.id];
                o[t.id] = [
                    s,
                    r
                ];
            } else e.parent && $(e.parent, t);
        }
    }
}
function v(e, t) {
    let o = e.modules;
    if (o) {
        if (o[t]) {
            let r = o[t][1], s = [];
            for(let n in r)u(module.bundle.root, r[n]).length === 1 && s.push(r[n]);
            delete o[t], delete e.cache[t], s.forEach((n)=>{
                v(module.bundle.root, n);
            });
        } else e.parent && v(e.parent, t);
    }
}
function H(e, t) {
    let o = e.cache[t];
    e.hotData[t] = {}, o && o.hot && (o.hot.data = e.hotData[t]), o && o.hot && o.hot._disposeCallbacks.length && o.hot._disposeCallbacks.forEach(function(r) {
        r(e.hotData[t]);
    }), delete e.cache[t];
}
function j(e, t) {
    e(t);
    let o = e.cache[t];
    if (o && o.hot && o.hot._acceptCallbacks.length) {
        let r = u(module.bundle.root, t);
        o.hot._acceptCallbacks.forEach(function(s) {
            let n = s(()=>r);
            n && n.length && (n.forEach(([a, l])=>{
                H(a, l);
            }), i.assetsToAccept.push.apply(i.assetsToAccept, n));
        });
    }
}
function re(e = f()) {
    let t = h();
    return `${c.secure || location.protocol === "https:" && !/localhost|127.0.0.1|0.0.0.0/.test(t) ? "wss" : "ws"}://${t}:${e}/`;
}
function se(e) {
    typeof e.message == "string" && L("[plasmo/parcel-runtime]: " + e.message);
}
function I(e) {
    if (typeof globalThis.WebSocket > "u") return;
    let t = new WebSocket(re());
    return t.addEventListener("message", async function(o) {
        let r = JSON.parse(o.data);
        if (r.type === "update" && await e(r.assets), r.type === "error") for (let s of r.diagnostics.ansi){
            let n = s.codeframe || s.stack;
            R("[plasmo/parcel-runtime]: " + s.message + `
` + n + `

` + s.hints.join(`
`));
        }
    }), t.addEventListener("error", se), t.addEventListener("open", ()=>{
        k(`[plasmo/parcel-runtime]: Connected to HMR server for ${c.entryFilePath}`);
    }), t.addEventListener("close", ()=>{
        R(`[plasmo/parcel-runtime]: Connection to the HMR server is closed for ${c.entryFilePath}`);
    }), t;
}
var N = z(require("ace498fb6184116f"));
async function U() {
    N.default.injectIntoGlobalHook(window), window.$RefreshReg$ = function() {}, window.$RefreshSig$ = function() {
        return function(e) {
            return e;
        };
    };
}
var ne = `${S}${module.id}__`, g, F = module.bundle.parent;
if (!F || !F.isParcelRequire) {
    try {
        g = d?.runtime.connect({
            name: ne
        }), g.onDisconnect.addListener(()=>{
            m();
        }), c.isReact || g.onMessage.addListener(()=>{
            m();
        });
    } catch (e) {
        p(e);
    }
    I(async (e)=>{
        if (p("Page runtime - On HMR Update"), c.isReact) {
            B();
            let t = e.filter((r)=>r.envHash === c.envHash);
            if (t.some((r)=>r.type === "css" || r.type === "js" && E(module.bundle.root, r.id, r.depsByBundle))) try {
                await O(t);
                let r = {};
                for (let [n, a] of i.assetsToDispose)r[a] || (H(n, a), r[a] = !0);
                let s = {};
                for(let n = 0; n < i.assetsToAccept.length; n++){
                    let [a, l] = i.assetsToAccept[n];
                    s[l] || (j(a, l), s[l] = !0);
                }
            } catch (r) {
                c.verbose === "true" && (console.trace(r), alert(JSON.stringify(r))), await m(!0);
            }
        } else {
            let t = e.filter((o)=>o.envHash === c.envHash).some((o)=>M(module.bundle, o.id));
            p("Page runtime -", {
                sourceChanged: t
            }), t && g.postMessage({
                __plasmo_page_changed__: !0
            });
        }
    });
}
c.isReact && (p("Injecting react refresh"), U());

},{"ace498fb6184116f":"iZhE1"}],"iZhE1":[function(require,module,exports) {
var oe = Object.create;
var H = Object.defineProperty;
var ae = Object.getOwnPropertyDescriptor;
var ue = Object.getOwnPropertyNames;
var se = Object.getPrototypeOf, le = Object.prototype.hasOwnProperty;
var z = (o, f)=>()=>(f || o((f = {
            exports: {}
        }).exports, f), f.exports), ce = (o, f)=>{
    for(var s in f)H(o, s, {
        get: f[s],
        enumerable: !0
    });
}, D = (o, f, s, y)=>{
    if (f && typeof f == "object" || typeof f == "function") for (let m of ue(f))!le.call(o, m) && m !== s && H(o, m, {
        get: ()=>f[m],
        enumerable: !(y = ae(f, m)) || y.enumerable
    });
    return o;
}, S = (o, f, s)=>(D(o, f, "default"), s && D(s, f, "default")), G = (o, f, s)=>(s = o != null ? oe(se(o)) : {}, D(f || !o || !o.__esModule ? H(s, "default", {
        value: o,
        enumerable: !0
    }) : s, o)), de = (o)=>D(H({}, "__esModule", {
        value: !0
    }), o);
var N = z((h)=>{
    "use strict";
    (function() {
        "use strict";
        var o = Symbol.for("react.forward_ref"), f = Symbol.for("react.memo"), s = typeof WeakMap == "function" ? WeakMap : Map, y = new Map, m = new s, b = new s, j = new s, E = [], C = new Map, O = new Map, p = new Set, _ = new Set, F = typeof WeakMap == "function" ? new WeakMap : null, T = !1;
        function B(e) {
            if (e.fullKey !== null) return e.fullKey;
            var r = e.ownKey, n;
            try {
                n = e.getCustomHooks();
            } catch (i) {
                return e.forceReset = !0, e.fullKey = r, r;
            }
            for(var t = 0; t < n.length; t++){
                var l = n[t];
                if (typeof l != "function") return e.forceReset = !0, e.fullKey = r, r;
                var d = b.get(l);
                if (d !== void 0) {
                    var a = B(d);
                    d.forceReset && (e.forceReset = !0), r += `
---
` + a;
                }
            }
            return e.fullKey = r, r;
        }
        function q(e, r) {
            var n = b.get(e), t = b.get(r);
            return n === void 0 && t === void 0 ? !0 : !(n === void 0 || t === void 0 || B(n) !== B(t) || t.forceReset);
        }
        function $(e) {
            return e.prototype && e.prototype.isReactComponent;
        }
        function k(e, r) {
            return $(e) || $(r) ? !1 : !!q(e, r);
        }
        function Y(e) {
            return j.get(e);
        }
        function Z(e) {
            var r = new Map;
            return e.forEach(function(n, t) {
                r.set(t, n);
            }), r;
        }
        function W(e) {
            var r = new Set;
            return e.forEach(function(n) {
                r.add(n);
            }), r;
        }
        function M(e, r) {
            try {
                return e[r];
            } catch (n) {
                return;
            }
        }
        function J() {
            if (E.length === 0 || T) return null;
            T = !0;
            try {
                var e = new Set, r = new Set, n = E;
                E = [], n.forEach(function(u) {
                    var c = u[0], v = u[1], R = c.current;
                    j.set(R, c), j.set(v, c), c.current = v, k(R, v) ? r.add(c) : e.add(c);
                });
                var t = {
                    updatedFamilies: r,
                    staleFamilies: e
                };
                C.forEach(function(u) {
                    u.setRefreshHandler(Y);
                });
                var l = !1, d = null, a = W(_), i = W(p), g = Z(O);
                if (a.forEach(function(u) {
                    var c = g.get(u);
                    if (c === void 0) throw new Error("Could not find helpers for a root. This is a bug in React Refresh.");
                    if (_.has(u), F !== null && F.has(u)) {
                        var v = F.get(u);
                        try {
                            c.scheduleRoot(u, v);
                        } catch (R) {
                            l || (l = !0, d = R);
                        }
                    }
                }), i.forEach(function(u) {
                    var c = g.get(u);
                    if (c === void 0) throw new Error("Could not find helpers for a root. This is a bug in React Refresh.");
                    p.has(u);
                    try {
                        c.scheduleRefresh(u, t);
                    } catch (v) {
                        l || (l = !0, d = v);
                    }
                }), l) throw d;
                return t;
            } finally{
                T = !1;
            }
        }
        function P(e, r) {
            if (e === null || typeof e != "function" && typeof e != "object" || m.has(e)) return;
            var n = y.get(r);
            if (n === void 0 ? (n = {
                current: e
            }, y.set(r, n)) : E.push([
                n,
                e
            ]), m.set(e, n), typeof e == "object" && e !== null) switch(M(e, "$$typeof")){
                case o:
                    P(e.render, r + "$render");
                    break;
                case f:
                    P(e.type, r + "$type");
                    break;
            }
        }
        function K(e, r) {
            var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1, t = arguments.length > 3 ? arguments[3] : void 0;
            if (b.has(e) || b.set(e, {
                forceReset: n,
                ownKey: r,
                fullKey: null,
                getCustomHooks: t || function() {
                    return [];
                }
            }), typeof e == "object" && e !== null) switch(M(e, "$$typeof")){
                case o:
                    K(e.render, r, n, t);
                    break;
                case f:
                    K(e.type, r, n, t);
                    break;
            }
        }
        function x(e) {
            var r = b.get(e);
            r !== void 0 && B(r);
        }
        function Q(e) {
            return y.get(e);
        }
        function X(e) {
            return m.get(e);
        }
        function ee(e) {
            var r = new Set;
            return p.forEach(function(n) {
                var t = O.get(n);
                if (t === void 0) throw new Error("Could not find helpers for a root. This is a bug in React Refresh.");
                var l = t.findHostInstancesForRefresh(n, e);
                l.forEach(function(d) {
                    r.add(d);
                });
            }), r;
        }
        function re(e) {
            var r = e.__REACT_DEVTOOLS_GLOBAL_HOOK__;
            if (r === void 0) {
                var n = 0;
                e.__REACT_DEVTOOLS_GLOBAL_HOOK__ = r = {
                    renderers: new Map,
                    supportsFiber: !0,
                    inject: function(a) {
                        return n++;
                    },
                    onScheduleFiberRoot: function(a, i, g) {},
                    onCommitFiberRoot: function(a, i, g, u) {},
                    onCommitFiberUnmount: function() {}
                };
            }
            if (r.isDisabled) {
                console.warn("Something has shimmed the React DevTools global hook (__REACT_DEVTOOLS_GLOBAL_HOOK__). Fast Refresh is not compatible with this shim and will be disabled.");
                return;
            }
            var t = r.inject;
            r.inject = function(a) {
                var i = t.apply(this, arguments);
                return typeof a.scheduleRefresh == "function" && typeof a.setRefreshHandler == "function" && C.set(i, a), i;
            }, r.renderers.forEach(function(a, i) {
                typeof a.scheduleRefresh == "function" && typeof a.setRefreshHandler == "function" && C.set(i, a);
            });
            var l = r.onCommitFiberRoot, d = r.onScheduleFiberRoot || function() {};
            r.onScheduleFiberRoot = function(a, i, g) {
                return T || (_.delete(i), F !== null && F.set(i, g)), d.apply(this, arguments);
            }, r.onCommitFiberRoot = function(a, i, g, u) {
                var c = C.get(a);
                if (c !== void 0) {
                    O.set(i, c);
                    var v = i.current, R = v.alternate;
                    if (R !== null) {
                        var L = R.memoizedState != null && R.memoizedState.element != null && p.has(i), A = v.memoizedState != null && v.memoizedState.element != null;
                        !L && A ? (p.add(i), _.delete(i)) : L && A || (L && !A ? (p.delete(i), u ? _.add(i) : O.delete(i)) : !L && !A && u && _.add(i));
                    } else p.add(i);
                }
                return l.apply(this, arguments);
            };
        }
        function ne() {
            return !1;
        }
        function te() {
            return p.size;
        }
        function fe() {
            var e, r, n = !1;
            return function(t, l, d, a) {
                if (typeof l == "string") return e || (e = t, r = typeof a == "function"), t != null && (typeof t == "function" || typeof t == "object") && K(t, l, d, a), t;
                !n && r && (n = !0, x(e));
            };
        }
        function ie(e) {
            switch(typeof e){
                case "function":
                    if (e.prototype != null) {
                        if (e.prototype.isReactComponent) return !0;
                        var r = Object.getOwnPropertyNames(e.prototype);
                        if (r.length > 1 || r[0] !== "constructor" || e.prototype.__proto__ !== Object.prototype) return !1;
                    }
                    var n = e.name || e.displayName;
                    return typeof n == "string" && /^[A-Z]/.test(n);
                case "object":
                    if (e != null) switch(M(e, "$$typeof")){
                        case o:
                        case f:
                            return !0;
                        default:
                            return !1;
                    }
                    return !1;
                default:
                    return !1;
            }
        }
        h._getMountedRootCount = te, h.collectCustomHooksForSignature = x, h.createSignatureFunctionForTransform = fe, h.findAffectedHostInstances = ee, h.getFamilyByID = Q, h.getFamilyByType = X, h.hasUnrecoverableErrors = ne, h.injectIntoGlobalHook = re, h.isLikelyComponentType = ie, h.performReactRefresh = J, h.register = P, h.setSignature = K;
    })();
});
var I = z((pe, V)=>{
    "use strict";
    V.exports = N();
});
var w = {};
ce(w, {
    default: ()=>he
});
module.exports = de(w);
var U = G(I());
S(w, G(I()), module.exports);
var he = U.default; /*! Bundled license information:

react-refresh/cjs/react-refresh-runtime.development.js:
  (**
   * @license React
   * react-refresh-runtime.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)
*/ 

},{}],"4z694":[function(require,module,exports) {
var _vue = require("vue");
// @ts-ignore
var _popupVue = require("../../src/popup.vue");
var _vue1 = require("@plasmo-static-common/vue");
document.addEventListener("DOMContentLoaded", ()=>{
    const app = (0, _vue.createApp)(_popupVue.default);
    _popupVue.default.prepare?.(app);
    app.mount("#__plasmo");
});

},{"vue":"dmrjI","../../src/popup.vue":"43z63","@plasmo-static-common/vue":"4j7Mh"}],"dmrjI":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "compile", ()=>compile);
var _runtimeDom = require("@vue/runtime-dom");
parcelHelpers.exportAll(_runtimeDom, exports);
function initDev() {
    (0, _runtimeDom.initCustomFormatter)();
}
initDev();
const compile = ()=>{
    (0, _runtimeDom.warn)(`Runtime compilation is not supported in this build of Vue.` + ` Configure your bundler to alias "vue" to "vue/dist/vue.esm-bundler.js".`);
};

},{"@vue/runtime-dom":"illZR","@parcel/transformer-js/src/esmodule-helpers.js":"boKlo"}],"illZR":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Transition", ()=>Transition);
parcelHelpers.export(exports, "TransitionGroup", ()=>TransitionGroup);
parcelHelpers.export(exports, "VueElement", ()=>VueElement);
parcelHelpers.export(exports, "createApp", ()=>createApp);
parcelHelpers.export(exports, "createSSRApp", ()=>createSSRApp);
parcelHelpers.export(exports, "defineCustomElement", ()=>defineCustomElement);
parcelHelpers.export(exports, "defineSSRCustomElement", ()=>defineSSRCustomElement);
parcelHelpers.export(exports, "hydrate", ()=>hydrate);
parcelHelpers.export(exports, "initDirectivesForSSR", ()=>initDirectivesForSSR);
parcelHelpers.export(exports, "render", ()=>render);
parcelHelpers.export(exports, "useCssModule", ()=>useCssModule);
parcelHelpers.export(exports, "useCssVars", ()=>useCssVars);
parcelHelpers.export(exports, "vModelCheckbox", ()=>vModelCheckbox);
parcelHelpers.export(exports, "vModelDynamic", ()=>vModelDynamic);
parcelHelpers.export(exports, "vModelRadio", ()=>vModelRadio);
parcelHelpers.export(exports, "vModelSelect", ()=>vModelSelect);
parcelHelpers.export(exports, "vModelText", ()=>vModelText);
parcelHelpers.export(exports, "vShow", ()=>vShow);
parcelHelpers.export(exports, "withKeys", ()=>withKeys);
parcelHelpers.export(exports, "withModifiers", ()=>withModifiers);
var _runtimeCore = require("@vue/runtime-core");
parcelHelpers.exportAll(_runtimeCore, exports);
var _shared = require("@vue/shared");
const svgNS = "http://www.w3.org/2000/svg";
const doc = typeof document !== "undefined" ? document : null;
const templateContainer = doc && /* @__PURE__ */ doc.createElement("template");
const nodeOps = {
    insert: (child, parent, anchor)=>{
        parent.insertBefore(child, anchor || null);
    },
    remove: (child)=>{
        const parent = child.parentNode;
        if (parent) parent.removeChild(child);
    },
    createElement: (tag, isSVG, is, props)=>{
        const el = isSVG ? doc.createElementNS(svgNS, tag) : doc.createElement(tag, is ? {
            is
        } : void 0);
        if (tag === "select" && props && props.multiple != null) el.setAttribute("multiple", props.multiple);
        return el;
    },
    createText: (text)=>doc.createTextNode(text),
    createComment: (text)=>doc.createComment(text),
    setText: (node, text)=>{
        node.nodeValue = text;
    },
    setElementText: (el, text)=>{
        el.textContent = text;
    },
    parentNode: (node)=>node.parentNode,
    nextSibling: (node)=>node.nextSibling,
    querySelector: (selector)=>doc.querySelector(selector),
    setScopeId (el, id) {
        el.setAttribute(id, "");
    },
    // __UNSAFE__
    // Reason: innerHTML.
    // Static content here can only come from compiled templates.
    // As long as the user only uses trusted templates, this is safe.
    insertStaticContent (content, parent, anchor, isSVG, start, end) {
        const before = anchor ? anchor.previousSibling : parent.lastChild;
        if (start && (start === end || start.nextSibling)) while(true){
            parent.insertBefore(start.cloneNode(true), anchor);
            if (start === end || !(start = start.nextSibling)) break;
        }
        else {
            templateContainer.innerHTML = isSVG ? `<svg>${content}</svg>` : content;
            const template = templateContainer.content;
            if (isSVG) {
                const wrapper = template.firstChild;
                while(wrapper.firstChild)template.appendChild(wrapper.firstChild);
                template.removeChild(wrapper);
            }
            parent.insertBefore(template, anchor);
        }
        return [
            // first
            before ? before.nextSibling : parent.firstChild,
            // last
            anchor ? anchor.previousSibling : parent.lastChild
        ];
    }
};
function patchClass(el, value, isSVG) {
    const transitionClasses = el._vtc;
    if (transitionClasses) value = (value ? [
        value,
        ...transitionClasses
    ] : [
        ...transitionClasses
    ]).join(" ");
    if (value == null) el.removeAttribute("class");
    else if (isSVG) el.setAttribute("class", value);
    else el.className = value;
}
function patchStyle(el, prev, next) {
    const style = el.style;
    const isCssString = (0, _shared.isString)(next);
    if (next && !isCssString) {
        if (prev && !(0, _shared.isString)(prev)) {
            for(const key in prev)if (next[key] == null) setStyle(style, key, "");
        }
        for(const key in next)setStyle(style, key, next[key]);
    } else {
        const currentDisplay = style.display;
        if (isCssString) {
            if (prev !== next) style.cssText = next;
        } else if (prev) el.removeAttribute("style");
        if ("_vod" in el) style.display = currentDisplay;
    }
}
const semicolonRE = /[^\\];\s*$/;
const importantRE = /\s*!important$/;
function setStyle(style, name, val) {
    if ((0, _shared.isArray)(val)) val.forEach((v)=>setStyle(style, name, v));
    else {
        if (val == null) val = "";
        if (semicolonRE.test(val)) (0, _runtimeCore.warn)(`Unexpected semicolon at the end of '${name}' style value: '${val}'`);
        if (name.startsWith("--")) style.setProperty(name, val);
        else {
            const prefixed = autoPrefix(style, name);
            if (importantRE.test(val)) style.setProperty((0, _shared.hyphenate)(prefixed), val.replace(importantRE, ""), "important");
            else style[prefixed] = val;
        }
    }
}
const prefixes = [
    "Webkit",
    "Moz",
    "ms"
];
const prefixCache = {};
function autoPrefix(style, rawName) {
    const cached = prefixCache[rawName];
    if (cached) return cached;
    let name = (0, _runtimeCore.camelize)(rawName);
    if (name !== "filter" && name in style) return prefixCache[rawName] = name;
    name = (0, _shared.capitalize)(name);
    for(let i = 0; i < prefixes.length; i++){
        const prefixed = prefixes[i] + name;
        if (prefixed in style) return prefixCache[rawName] = prefixed;
    }
    return rawName;
}
const xlinkNS = "http://www.w3.org/1999/xlink";
function patchAttr(el, key, value, isSVG, instance) {
    if (isSVG && key.startsWith("xlink:")) {
        if (value == null) el.removeAttributeNS(xlinkNS, key.slice(6, key.length));
        else el.setAttributeNS(xlinkNS, key, value);
    } else {
        const isBoolean = (0, _shared.isSpecialBooleanAttr)(key);
        if (value == null || isBoolean && !(0, _shared.includeBooleanAttr)(value)) el.removeAttribute(key);
        else el.setAttribute(key, isBoolean ? "" : value);
    }
}
function patchDOMProp(el, key, value, prevChildren, parentComponent, parentSuspense, unmountChildren) {
    if (key === "innerHTML" || key === "textContent") {
        if (prevChildren) unmountChildren(prevChildren, parentComponent, parentSuspense);
        el[key] = value == null ? "" : value;
        return;
    }
    const tag = el.tagName;
    if (key === "value" && tag !== "PROGRESS" && // custom elements may use _value internally
    !tag.includes("-")) {
        el._value = value;
        const oldValue = tag === "OPTION" ? el.getAttribute("value") : el.value;
        const newValue = value == null ? "" : value;
        if (oldValue !== newValue) el.value = newValue;
        if (value == null) el.removeAttribute(key);
        return;
    }
    let needRemove = false;
    if (value === "" || value == null) {
        const type = typeof el[key];
        if (type === "boolean") value = (0, _shared.includeBooleanAttr)(value);
        else if (value == null && type === "string") {
            value = "";
            needRemove = true;
        } else if (type === "number") {
            value = 0;
            needRemove = true;
        }
    }
    try {
        el[key] = value;
    } catch (e) {
        if (!needRemove) (0, _runtimeCore.warn)(`Failed setting prop "${key}" on <${tag.toLowerCase()}>: value ${value} is invalid.`, e);
    }
    needRemove && el.removeAttribute(key);
}
function addEventListener(el, event, handler, options) {
    el.addEventListener(event, handler, options);
}
function removeEventListener(el, event, handler, options) {
    el.removeEventListener(event, handler, options);
}
function patchEvent(el, rawName, prevValue, nextValue, instance = null) {
    const invokers = el._vei || (el._vei = {});
    const existingInvoker = invokers[rawName];
    if (nextValue && existingInvoker) existingInvoker.value = nextValue;
    else {
        const [name, options] = parseName(rawName);
        if (nextValue) {
            const invoker = invokers[rawName] = createInvoker(nextValue, instance);
            addEventListener(el, name, invoker, options);
        } else if (existingInvoker) {
            removeEventListener(el, name, existingInvoker, options);
            invokers[rawName] = void 0;
        }
    }
}
const optionsModifierRE = /(?:Once|Passive|Capture)$/;
function parseName(name) {
    let options;
    if (optionsModifierRE.test(name)) {
        options = {};
        let m;
        while(m = name.match(optionsModifierRE)){
            name = name.slice(0, name.length - m[0].length);
            options[m[0].toLowerCase()] = true;
        }
    }
    const event = name[2] === ":" ? name.slice(3) : (0, _shared.hyphenate)(name.slice(2));
    return [
        event,
        options
    ];
}
let cachedNow = 0;
const p = /* @__PURE__ */ Promise.resolve();
const getNow = ()=>cachedNow || (p.then(()=>cachedNow = 0), cachedNow = Date.now());
function createInvoker(initialValue, instance) {
    const invoker = (e)=>{
        if (!e._vts) e._vts = Date.now();
        else if (e._vts <= invoker.attached) return;
        (0, _runtimeCore.callWithAsyncErrorHandling)(patchStopImmediatePropagation(e, invoker.value), instance, 5, [
            e
        ]);
    };
    invoker.value = initialValue;
    invoker.attached = getNow();
    return invoker;
}
function patchStopImmediatePropagation(e, value) {
    if ((0, _shared.isArray)(value)) {
        const originalStop = e.stopImmediatePropagation;
        e.stopImmediatePropagation = ()=>{
            originalStop.call(e);
            e._stopped = true;
        };
        return value.map((fn)=>(e2)=>!e2._stopped && fn && fn(e2));
    } else return value;
}
const nativeOnRE = /^on[a-z]/;
const patchProp = (el, key, prevValue, nextValue, isSVG = false, prevChildren, parentComponent, parentSuspense, unmountChildren)=>{
    if (key === "class") patchClass(el, nextValue, isSVG);
    else if (key === "style") patchStyle(el, prevValue, nextValue);
    else if ((0, _shared.isOn)(key)) {
        if (!(0, _shared.isModelListener)(key)) patchEvent(el, key, prevValue, nextValue, parentComponent);
    } else if (key[0] === "." ? (key = key.slice(1), true) : key[0] === "^" ? (key = key.slice(1), false) : shouldSetAsProp(el, key, nextValue, isSVG)) patchDOMProp(el, key, nextValue, prevChildren, parentComponent, parentSuspense, unmountChildren);
    else {
        if (key === "true-value") el._trueValue = nextValue;
        else if (key === "false-value") el._falseValue = nextValue;
        patchAttr(el, key, nextValue, isSVG);
    }
};
function shouldSetAsProp(el, key, value, isSVG) {
    if (isSVG) {
        if (key === "innerHTML" || key === "textContent") return true;
        if (key in el && nativeOnRE.test(key) && (0, _shared.isFunction)(value)) return true;
        return false;
    }
    if (key === "spellcheck" || key === "draggable" || key === "translate") return false;
    if (key === "form") return false;
    if (key === "list" && el.tagName === "INPUT") return false;
    if (key === "type" && el.tagName === "TEXTAREA") return false;
    if (nativeOnRE.test(key) && (0, _shared.isString)(value)) return false;
    return key in el;
}
function defineCustomElement(options, hydrate2) {
    const Comp = (0, _runtimeCore.defineComponent)(options);
    class VueCustomElement extends VueElement {
        constructor(initialProps){
            super(Comp, initialProps, hydrate2);
        }
    }
    VueCustomElement.def = Comp;
    return VueCustomElement;
}
const defineSSRCustomElement = (options)=>{
    return defineCustomElement(options, hydrate);
};
const BaseClass = typeof HTMLElement !== "undefined" ? HTMLElement : class {
};
class VueElement extends BaseClass {
    constructor(_def, _props = {}, hydrate2){
        super();
        this._def = _def;
        this._props = _props;
        /**
     * @internal
     */ this._instance = null;
        this._connected = false;
        this._resolved = false;
        this._numberProps = null;
        if (this.shadowRoot && hydrate2) hydrate2(this._createVNode(), this.shadowRoot);
        else {
            if (0, this.shadowRoot) (0, _runtimeCore.warn)(`Custom element has pre-rendered declarative shadow root but is not defined as hydratable. Use \`defineSSRCustomElement\`.`);
            this.attachShadow({
                mode: "open"
            });
            if (!this._def.__asyncLoader) this._resolveProps(this._def);
        }
    }
    connectedCallback() {
        this._connected = true;
        if (!this._instance) {
            if (this._resolved) this._update();
            else this._resolveDef();
        }
    }
    disconnectedCallback() {
        this._connected = false;
        (0, _runtimeCore.nextTick)(()=>{
            if (!this._connected) {
                render(null, this.shadowRoot);
                this._instance = null;
            }
        });
    }
    /**
   * resolve inner component definition (handle possible async component)
   */ _resolveDef() {
        this._resolved = true;
        for(let i = 0; i < this.attributes.length; i++)this._setAttr(this.attributes[i].name);
        new MutationObserver((mutations)=>{
            for (const m of mutations)this._setAttr(m.attributeName);
        }).observe(this, {
            attributes: true
        });
        const resolve = (def, isAsync = false)=>{
            const { props, styles } = def;
            let numberProps;
            if (props && !(0, _shared.isArray)(props)) for(const key in props){
                const opt = props[key];
                if (opt === Number || opt && opt.type === Number) {
                    if (key in this._props) this._props[key] = (0, _shared.toNumber)(this._props[key]);
                    (numberProps || (numberProps = /* @__PURE__ */ Object.create(null)))[(0, _shared.camelize)(key)] = true;
                }
            }
            this._numberProps = numberProps;
            if (isAsync) this._resolveProps(def);
            this._applyStyles(styles);
            this._update();
        };
        const asyncDef = this._def.__asyncLoader;
        if (asyncDef) asyncDef().then((def)=>resolve(def, true));
        else resolve(this._def);
    }
    _resolveProps(def) {
        const { props } = def;
        const declaredPropKeys = (0, _shared.isArray)(props) ? props : Object.keys(props || {});
        for (const key of Object.keys(this))if (key[0] !== "_" && declaredPropKeys.includes(key)) this._setProp(key, this[key], true, false);
        for (const key of declaredPropKeys.map((0, _shared.camelize)))Object.defineProperty(this, key, {
            get () {
                return this._getProp(key);
            },
            set (val) {
                this._setProp(key, val);
            }
        });
    }
    _setAttr(key) {
        let value = this.getAttribute(key);
        const camelKey = (0, _shared.camelize)(key);
        if (this._numberProps && this._numberProps[camelKey]) value = (0, _shared.toNumber)(value);
        this._setProp(camelKey, value, false);
    }
    /**
   * @internal
   */ _getProp(key) {
        return this._props[key];
    }
    /**
   * @internal
   */ _setProp(key, val, shouldReflect = true, shouldUpdate = true) {
        if (val !== this._props[key]) {
            this._props[key] = val;
            if (shouldUpdate && this._instance) this._update();
            if (shouldReflect) {
                if (val === true) this.setAttribute((0, _shared.hyphenate)(key), "");
                else if (typeof val === "string" || typeof val === "number") this.setAttribute((0, _shared.hyphenate)(key), val + "");
                else if (!val) this.removeAttribute((0, _shared.hyphenate)(key));
            }
        }
    }
    _update() {
        render(this._createVNode(), this.shadowRoot);
    }
    _createVNode() {
        const vnode = (0, _runtimeCore.createVNode)(this._def, (0, _shared.extend)({}, this._props));
        if (!this._instance) vnode.ce = (instance)=>{
            this._instance = instance;
            instance.isCE = true;
            instance.ceReload = (newStyles)=>{
                if (this._styles) {
                    this._styles.forEach((s)=>this.shadowRoot.removeChild(s));
                    this._styles.length = 0;
                }
                this._applyStyles(newStyles);
                this._instance = null;
                this._update();
            };
            const dispatch = (event, args)=>{
                this.dispatchEvent(new CustomEvent(event, {
                    detail: args
                }));
            };
            instance.emit = (event, ...args)=>{
                dispatch(event, args);
                if ((0, _shared.hyphenate)(event) !== event) dispatch((0, _shared.hyphenate)(event), args);
            };
            let parent = this;
            while(parent = parent && (parent.parentNode || parent.host))if (parent instanceof VueElement) {
                instance.parent = parent._instance;
                instance.provides = parent._instance.provides;
                break;
            }
        };
        return vnode;
    }
    _applyStyles(styles) {
        if (styles) styles.forEach((css)=>{
            const s = document.createElement("style");
            s.textContent = css;
            this.shadowRoot.appendChild(s);
            (this._styles || (this._styles = [])).push(s);
        });
    }
}
function useCssModule(name = "$style") {
    {
        const instance = (0, _runtimeCore.getCurrentInstance)();
        if (!instance) {
            (0, _runtimeCore.warn)(`useCssModule must be called inside setup()`);
            return 0, _shared.EMPTY_OBJ;
        }
        const modules = instance.type.__cssModules;
        if (!modules) {
            (0, _runtimeCore.warn)(`Current instance does not have CSS modules injected.`);
            return 0, _shared.EMPTY_OBJ;
        }
        const mod = modules[name];
        if (!mod) {
            (0, _runtimeCore.warn)(`Current instance does not have CSS module named "${name}".`);
            return 0, _shared.EMPTY_OBJ;
        }
        return mod;
    }
}
function useCssVars(getter) {
    const instance = (0, _runtimeCore.getCurrentInstance)();
    if (!instance) {
        (0, _runtimeCore.warn)(`useCssVars is called without current active component instance.`);
        return;
    }
    const updateTeleports = instance.ut = (vars = getter(instance.proxy))=>{
        Array.from(document.querySelectorAll(`[data-v-owner="${instance.uid}"]`)).forEach((node)=>setVarsOnNode(node, vars));
    };
    const setVars = ()=>{
        const vars = getter(instance.proxy);
        setVarsOnVNode(instance.subTree, vars);
        updateTeleports(vars);
    };
    (0, _runtimeCore.watchPostEffect)(setVars);
    (0, _runtimeCore.onMounted)(()=>{
        const ob = new MutationObserver(setVars);
        ob.observe(instance.subTree.el.parentNode, {
            childList: true
        });
        (0, _runtimeCore.onUnmounted)(()=>ob.disconnect());
    });
}
function setVarsOnVNode(vnode, vars) {
    if (vnode.shapeFlag & 128) {
        const suspense = vnode.suspense;
        vnode = suspense.activeBranch;
        if (suspense.pendingBranch && !suspense.isHydrating) suspense.effects.push(()=>{
            setVarsOnVNode(suspense.activeBranch, vars);
        });
    }
    while(vnode.component)vnode = vnode.component.subTree;
    if (vnode.shapeFlag & 1 && vnode.el) setVarsOnNode(vnode.el, vars);
    else if (vnode.type === (0, _runtimeCore.Fragment)) vnode.children.forEach((c)=>setVarsOnVNode(c, vars));
    else if (vnode.type === (0, _runtimeCore.Static)) {
        let { el, anchor } = vnode;
        while(el){
            setVarsOnNode(el, vars);
            if (el === anchor) break;
            el = el.nextSibling;
        }
    }
}
function setVarsOnNode(el, vars) {
    if (el.nodeType === 1) {
        const style = el.style;
        for(const key in vars)style.setProperty(`--${key}`, vars[key]);
    }
}
const TRANSITION = "transition";
const ANIMATION = "animation";
const Transition = (props, { slots })=>(0, _runtimeCore.h)((0, _runtimeCore.BaseTransition), resolveTransitionProps(props), slots);
Transition.displayName = "Transition";
const DOMTransitionPropsValidators = {
    name: String,
    type: String,
    css: {
        type: Boolean,
        default: true
    },
    duration: [
        String,
        Number,
        Object
    ],
    enterFromClass: String,
    enterActiveClass: String,
    enterToClass: String,
    appearFromClass: String,
    appearActiveClass: String,
    appearToClass: String,
    leaveFromClass: String,
    leaveActiveClass: String,
    leaveToClass: String
};
const TransitionPropsValidators = Transition.props = /* @__PURE__ */ (0, _shared.extend)({}, (0, _runtimeCore.BaseTransitionPropsValidators), DOMTransitionPropsValidators);
const callHook = (hook, args = [])=>{
    if ((0, _shared.isArray)(hook)) hook.forEach((h2)=>h2(...args));
    else if (hook) hook(...args);
};
const hasExplicitCallback = (hook)=>{
    return hook ? (0, _shared.isArray)(hook) ? hook.some((h2)=>h2.length > 1) : hook.length > 1 : false;
};
function resolveTransitionProps(rawProps) {
    const baseProps = {};
    for(const key in rawProps)if (!(key in DOMTransitionPropsValidators)) baseProps[key] = rawProps[key];
    if (rawProps.css === false) return baseProps;
    const { name = "v", type, duration, enterFromClass = `${name}-enter-from`, enterActiveClass = `${name}-enter-active`, enterToClass = `${name}-enter-to`, appearFromClass = enterFromClass, appearActiveClass = enterActiveClass, appearToClass = enterToClass, leaveFromClass = `${name}-leave-from`, leaveActiveClass = `${name}-leave-active`, leaveToClass = `${name}-leave-to` } = rawProps;
    const durations = normalizeDuration(duration);
    const enterDuration = durations && durations[0];
    const leaveDuration = durations && durations[1];
    const { onBeforeEnter, onEnter, onEnterCancelled, onLeave, onLeaveCancelled, onBeforeAppear = onBeforeEnter, onAppear = onEnter, onAppearCancelled = onEnterCancelled } = baseProps;
    const finishEnter = (el, isAppear, done)=>{
        removeTransitionClass(el, isAppear ? appearToClass : enterToClass);
        removeTransitionClass(el, isAppear ? appearActiveClass : enterActiveClass);
        done && done();
    };
    const finishLeave = (el, done)=>{
        el._isLeaving = false;
        removeTransitionClass(el, leaveFromClass);
        removeTransitionClass(el, leaveToClass);
        removeTransitionClass(el, leaveActiveClass);
        done && done();
    };
    const makeEnterHook = (isAppear)=>{
        return (el, done)=>{
            const hook = isAppear ? onAppear : onEnter;
            const resolve = ()=>finishEnter(el, isAppear, done);
            callHook(hook, [
                el,
                resolve
            ]);
            nextFrame(()=>{
                removeTransitionClass(el, isAppear ? appearFromClass : enterFromClass);
                addTransitionClass(el, isAppear ? appearToClass : enterToClass);
                if (!hasExplicitCallback(hook)) whenTransitionEnds(el, type, enterDuration, resolve);
            });
        };
    };
    return (0, _shared.extend)(baseProps, {
        onBeforeEnter (el) {
            callHook(onBeforeEnter, [
                el
            ]);
            addTransitionClass(el, enterFromClass);
            addTransitionClass(el, enterActiveClass);
        },
        onBeforeAppear (el) {
            callHook(onBeforeAppear, [
                el
            ]);
            addTransitionClass(el, appearFromClass);
            addTransitionClass(el, appearActiveClass);
        },
        onEnter: makeEnterHook(false),
        onAppear: makeEnterHook(true),
        onLeave (el, done) {
            el._isLeaving = true;
            const resolve = ()=>finishLeave(el, done);
            addTransitionClass(el, leaveFromClass);
            forceReflow();
            addTransitionClass(el, leaveActiveClass);
            nextFrame(()=>{
                if (!el._isLeaving) return;
                removeTransitionClass(el, leaveFromClass);
                addTransitionClass(el, leaveToClass);
                if (!hasExplicitCallback(onLeave)) whenTransitionEnds(el, type, leaveDuration, resolve);
            });
            callHook(onLeave, [
                el,
                resolve
            ]);
        },
        onEnterCancelled (el) {
            finishEnter(el, false);
            callHook(onEnterCancelled, [
                el
            ]);
        },
        onAppearCancelled (el) {
            finishEnter(el, true);
            callHook(onAppearCancelled, [
                el
            ]);
        },
        onLeaveCancelled (el) {
            finishLeave(el);
            callHook(onLeaveCancelled, [
                el
            ]);
        }
    });
}
function normalizeDuration(duration) {
    if (duration == null) return null;
    else if ((0, _shared.isObject)(duration)) return [
        NumberOf(duration.enter),
        NumberOf(duration.leave)
    ];
    else {
        const n = NumberOf(duration);
        return [
            n,
            n
        ];
    }
}
function NumberOf(val) {
    const res = (0, _shared.toNumber)(val);
    (0, _runtimeCore.assertNumber)(res, "<transition> explicit duration");
    return res;
}
function addTransitionClass(el, cls) {
    cls.split(/\s+/).forEach((c)=>c && el.classList.add(c));
    (el._vtc || (el._vtc = /* @__PURE__ */ new Set())).add(cls);
}
function removeTransitionClass(el, cls) {
    cls.split(/\s+/).forEach((c)=>c && el.classList.remove(c));
    const { _vtc } = el;
    if (_vtc) {
        _vtc.delete(cls);
        if (!_vtc.size) el._vtc = void 0;
    }
}
function nextFrame(cb) {
    requestAnimationFrame(()=>{
        requestAnimationFrame(cb);
    });
}
let endId = 0;
function whenTransitionEnds(el, expectedType, explicitTimeout, resolve) {
    const id = el._endId = ++endId;
    const resolveIfNotStale = ()=>{
        if (id === el._endId) resolve();
    };
    if (explicitTimeout) return setTimeout(resolveIfNotStale, explicitTimeout);
    const { type, timeout, propCount } = getTransitionInfo(el, expectedType);
    if (!type) return resolve();
    const endEvent = type + "end";
    let ended = 0;
    const end = ()=>{
        el.removeEventListener(endEvent, onEnd);
        resolveIfNotStale();
    };
    const onEnd = (e)=>{
        if (e.target === el && ++ended >= propCount) end();
    };
    setTimeout(()=>{
        if (ended < propCount) end();
    }, timeout + 1);
    el.addEventListener(endEvent, onEnd);
}
function getTransitionInfo(el, expectedType) {
    const styles = window.getComputedStyle(el);
    const getStyleProperties = (key)=>(styles[key] || "").split(", ");
    const transitionDelays = getStyleProperties(`${TRANSITION}Delay`);
    const transitionDurations = getStyleProperties(`${TRANSITION}Duration`);
    const transitionTimeout = getTimeout(transitionDelays, transitionDurations);
    const animationDelays = getStyleProperties(`${ANIMATION}Delay`);
    const animationDurations = getStyleProperties(`${ANIMATION}Duration`);
    const animationTimeout = getTimeout(animationDelays, animationDurations);
    let type = null;
    let timeout = 0;
    let propCount = 0;
    if (expectedType === TRANSITION) {
        if (transitionTimeout > 0) {
            type = TRANSITION;
            timeout = transitionTimeout;
            propCount = transitionDurations.length;
        }
    } else if (expectedType === ANIMATION) {
        if (animationTimeout > 0) {
            type = ANIMATION;
            timeout = animationTimeout;
            propCount = animationDurations.length;
        }
    } else {
        timeout = Math.max(transitionTimeout, animationTimeout);
        type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;
        propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;
    }
    const hasTransform = type === TRANSITION && /\b(transform|all)(,|$)/.test(getStyleProperties(`${TRANSITION}Property`).toString());
    return {
        type,
        timeout,
        propCount,
        hasTransform
    };
}
function getTimeout(delays, durations) {
    while(delays.length < durations.length)delays = delays.concat(delays);
    return Math.max(...durations.map((d, i)=>toMs(d) + toMs(delays[i])));
}
function toMs(s) {
    return Number(s.slice(0, -1).replace(",", ".")) * 1e3;
}
function forceReflow() {
    return document.body.offsetHeight;
}
const positionMap = /* @__PURE__ */ new WeakMap();
const newPositionMap = /* @__PURE__ */ new WeakMap();
const TransitionGroupImpl = {
    name: "TransitionGroup",
    props: /* @__PURE__ */ (0, _shared.extend)({}, TransitionPropsValidators, {
        tag: String,
        moveClass: String
    }),
    setup (props, { slots }) {
        const instance = (0, _runtimeCore.getCurrentInstance)();
        const state = (0, _runtimeCore.useTransitionState)();
        let prevChildren;
        let children;
        (0, _runtimeCore.onUpdated)(()=>{
            if (!prevChildren.length) return;
            const moveClass = props.moveClass || `${props.name || "v"}-move`;
            if (!hasCSSTransform(prevChildren[0].el, instance.vnode.el, moveClass)) return;
            prevChildren.forEach(callPendingCbs);
            prevChildren.forEach(recordPosition);
            const movedChildren = prevChildren.filter(applyTranslation);
            forceReflow();
            movedChildren.forEach((c)=>{
                const el = c.el;
                const style = el.style;
                addTransitionClass(el, moveClass);
                style.transform = style.webkitTransform = style.transitionDuration = "";
                const cb = el._moveCb = (e)=>{
                    if (e && e.target !== el) return;
                    if (!e || /transform$/.test(e.propertyName)) {
                        el.removeEventListener("transitionend", cb);
                        el._moveCb = null;
                        removeTransitionClass(el, moveClass);
                    }
                };
                el.addEventListener("transitionend", cb);
            });
        });
        return ()=>{
            const rawProps = (0, _runtimeCore.toRaw)(props);
            const cssTransitionProps = resolveTransitionProps(rawProps);
            let tag = rawProps.tag || (0, _runtimeCore.Fragment);
            prevChildren = children;
            children = slots.default ? (0, _runtimeCore.getTransitionRawChildren)(slots.default()) : [];
            for(let i = 0; i < children.length; i++){
                const child = children[i];
                if (child.key != null) (0, _runtimeCore.setTransitionHooks)(child, (0, _runtimeCore.resolveTransitionHooks)(child, cssTransitionProps, state, instance));
                else (0, _runtimeCore.warn)(`<TransitionGroup> children must be keyed.`);
            }
            if (prevChildren) for(let i = 0; i < prevChildren.length; i++){
                const child = prevChildren[i];
                (0, _runtimeCore.setTransitionHooks)(child, (0, _runtimeCore.resolveTransitionHooks)(child, cssTransitionProps, state, instance));
                positionMap.set(child, child.el.getBoundingClientRect());
            }
            return (0, _runtimeCore.createVNode)(tag, null, children);
        };
    }
};
const removeMode = (props)=>delete props.mode;
/* @__PURE__ */ removeMode(TransitionGroupImpl.props);
const TransitionGroup = TransitionGroupImpl;
function callPendingCbs(c) {
    const el = c.el;
    if (el._moveCb) el._moveCb();
    if (el._enterCb) el._enterCb();
}
function recordPosition(c) {
    newPositionMap.set(c, c.el.getBoundingClientRect());
}
function applyTranslation(c) {
    const oldPos = positionMap.get(c);
    const newPos = newPositionMap.get(c);
    const dx = oldPos.left - newPos.left;
    const dy = oldPos.top - newPos.top;
    if (dx || dy) {
        const s = c.el.style;
        s.transform = s.webkitTransform = `translate(${dx}px,${dy}px)`;
        s.transitionDuration = "0s";
        return c;
    }
}
function hasCSSTransform(el, root, moveClass) {
    const clone = el.cloneNode();
    if (el._vtc) el._vtc.forEach((cls)=>{
        cls.split(/\s+/).forEach((c)=>c && clone.classList.remove(c));
    });
    moveClass.split(/\s+/).forEach((c)=>c && clone.classList.add(c));
    clone.style.display = "none";
    const container = root.nodeType === 1 ? root : root.parentNode;
    container.appendChild(clone);
    const { hasTransform } = getTransitionInfo(clone);
    container.removeChild(clone);
    return hasTransform;
}
const getModelAssigner = (vnode)=>{
    const fn = vnode.props["onUpdate:modelValue"] || false;
    return (0, _shared.isArray)(fn) ? (value)=>(0, _shared.invokeArrayFns)(fn, value) : fn;
};
function onCompositionStart(e) {
    e.target.composing = true;
}
function onCompositionEnd(e) {
    const target = e.target;
    if (target.composing) {
        target.composing = false;
        target.dispatchEvent(new Event("input"));
    }
}
const vModelText = {
    created (el, { modifiers: { lazy, trim, number } }, vnode) {
        el._assign = getModelAssigner(vnode);
        const castToNumber = number || vnode.props && vnode.props.type === "number";
        addEventListener(el, lazy ? "change" : "input", (e)=>{
            if (e.target.composing) return;
            let domValue = el.value;
            if (trim) domValue = domValue.trim();
            if (castToNumber) domValue = (0, _shared.looseToNumber)(domValue);
            el._assign(domValue);
        });
        if (trim) addEventListener(el, "change", ()=>{
            el.value = el.value.trim();
        });
        if (!lazy) {
            addEventListener(el, "compositionstart", onCompositionStart);
            addEventListener(el, "compositionend", onCompositionEnd);
            addEventListener(el, "change", onCompositionEnd);
        }
    },
    // set value on mounted so it's after min/max for type="range"
    mounted (el, { value }) {
        el.value = value == null ? "" : value;
    },
    beforeUpdate (el, { value, modifiers: { lazy, trim, number } }, vnode) {
        el._assign = getModelAssigner(vnode);
        if (el.composing) return;
        if (document.activeElement === el && el.type !== "range") {
            if (lazy) return;
            if (trim && el.value.trim() === value) return;
            if ((number || el.type === "number") && (0, _shared.looseToNumber)(el.value) === value) return;
        }
        const newValue = value == null ? "" : value;
        if (el.value !== newValue) el.value = newValue;
    }
};
const vModelCheckbox = {
    // #4096 array checkboxes need to be deep traversed
    deep: true,
    created (el, _, vnode) {
        el._assign = getModelAssigner(vnode);
        addEventListener(el, "change", ()=>{
            const modelValue = el._modelValue;
            const elementValue = getValue(el);
            const checked = el.checked;
            const assign = el._assign;
            if ((0, _shared.isArray)(modelValue)) {
                const index = (0, _shared.looseIndexOf)(modelValue, elementValue);
                const found = index !== -1;
                if (checked && !found) assign(modelValue.concat(elementValue));
                else if (!checked && found) {
                    const filtered = [
                        ...modelValue
                    ];
                    filtered.splice(index, 1);
                    assign(filtered);
                }
            } else if ((0, _shared.isSet)(modelValue)) {
                const cloned = new Set(modelValue);
                if (checked) cloned.add(elementValue);
                else cloned.delete(elementValue);
                assign(cloned);
            } else assign(getCheckboxValue(el, checked));
        });
    },
    // set initial checked on mount to wait for true-value/false-value
    mounted: setChecked,
    beforeUpdate (el, binding, vnode) {
        el._assign = getModelAssigner(vnode);
        setChecked(el, binding, vnode);
    }
};
function setChecked(el, { value, oldValue }, vnode) {
    el._modelValue = value;
    if ((0, _shared.isArray)(value)) el.checked = (0, _shared.looseIndexOf)(value, vnode.props.value) > -1;
    else if ((0, _shared.isSet)(value)) el.checked = value.has(vnode.props.value);
    else if (value !== oldValue) el.checked = (0, _shared.looseEqual)(value, getCheckboxValue(el, true));
}
const vModelRadio = {
    created (el, { value }, vnode) {
        el.checked = (0, _shared.looseEqual)(value, vnode.props.value);
        el._assign = getModelAssigner(vnode);
        addEventListener(el, "change", ()=>{
            el._assign(getValue(el));
        });
    },
    beforeUpdate (el, { value, oldValue }, vnode) {
        el._assign = getModelAssigner(vnode);
        if (value !== oldValue) el.checked = (0, _shared.looseEqual)(value, vnode.props.value);
    }
};
const vModelSelect = {
    // <select multiple> value need to be deep traversed
    deep: true,
    created (el, { value, modifiers: { number } }, vnode) {
        const isSetModel = (0, _shared.isSet)(value);
        addEventListener(el, "change", ()=>{
            const selectedVal = Array.prototype.filter.call(el.options, (o)=>o.selected).map((o)=>number ? (0, _shared.looseToNumber)(getValue(o)) : getValue(o));
            el._assign(el.multiple ? isSetModel ? new Set(selectedVal) : selectedVal : selectedVal[0]);
        });
        el._assign = getModelAssigner(vnode);
    },
    // set value in mounted & updated because <select> relies on its children
    // <option>s.
    mounted (el, { value }) {
        setSelected(el, value);
    },
    beforeUpdate (el, _binding, vnode) {
        el._assign = getModelAssigner(vnode);
    },
    updated (el, { value }) {
        setSelected(el, value);
    }
};
function setSelected(el, value) {
    const isMultiple = el.multiple;
    if (isMultiple && !(0, _shared.isArray)(value) && !(0, _shared.isSet)(value)) {
        (0, _runtimeCore.warn)(`<select multiple v-model> expects an Array or Set value for its binding, but got ${Object.prototype.toString.call(value).slice(8, -1)}.`);
        return;
    }
    for(let i = 0, l = el.options.length; i < l; i++){
        const option = el.options[i];
        const optionValue = getValue(option);
        if (isMultiple) {
            if ((0, _shared.isArray)(value)) option.selected = (0, _shared.looseIndexOf)(value, optionValue) > -1;
            else option.selected = value.has(optionValue);
        } else if ((0, _shared.looseEqual)(getValue(option), value)) {
            if (el.selectedIndex !== i) el.selectedIndex = i;
            return;
        }
    }
    if (!isMultiple && el.selectedIndex !== -1) el.selectedIndex = -1;
}
function getValue(el) {
    return "_value" in el ? el._value : el.value;
}
function getCheckboxValue(el, checked) {
    const key = checked ? "_trueValue" : "_falseValue";
    return key in el ? el[key] : checked;
}
const vModelDynamic = {
    created (el, binding, vnode) {
        callModelHook(el, binding, vnode, null, "created");
    },
    mounted (el, binding, vnode) {
        callModelHook(el, binding, vnode, null, "mounted");
    },
    beforeUpdate (el, binding, vnode, prevVNode) {
        callModelHook(el, binding, vnode, prevVNode, "beforeUpdate");
    },
    updated (el, binding, vnode, prevVNode) {
        callModelHook(el, binding, vnode, prevVNode, "updated");
    }
};
function resolveDynamicModel(tagName, type) {
    switch(tagName){
        case "SELECT":
            return vModelSelect;
        case "TEXTAREA":
            return vModelText;
        default:
            switch(type){
                case "checkbox":
                    return vModelCheckbox;
                case "radio":
                    return vModelRadio;
                default:
                    return vModelText;
            }
    }
}
function callModelHook(el, binding, vnode, prevVNode, hook) {
    const modelToUse = resolveDynamicModel(el.tagName, vnode.props && vnode.props.type);
    const fn = modelToUse[hook];
    fn && fn(el, binding, vnode, prevVNode);
}
function initVModelForSSR() {
    vModelText.getSSRProps = ({ value })=>({
            value
        });
    vModelRadio.getSSRProps = ({ value }, vnode)=>{
        if (vnode.props && (0, _shared.looseEqual)(vnode.props.value, value)) return {
            checked: true
        };
    };
    vModelCheckbox.getSSRProps = ({ value }, vnode)=>{
        if ((0, _shared.isArray)(value)) {
            if (vnode.props && (0, _shared.looseIndexOf)(value, vnode.props.value) > -1) return {
                checked: true
            };
        } else if ((0, _shared.isSet)(value)) {
            if (vnode.props && value.has(vnode.props.value)) return {
                checked: true
            };
        } else if (value) return {
            checked: true
        };
    };
    vModelDynamic.getSSRProps = (binding, vnode)=>{
        if (typeof vnode.type !== "string") return;
        const modelToUse = resolveDynamicModel(// resolveDynamicModel expects an uppercase tag name, but vnode.type is lowercase
        vnode.type.toUpperCase(), vnode.props && vnode.props.type);
        if (modelToUse.getSSRProps) return modelToUse.getSSRProps(binding, vnode);
    };
}
const systemModifiers = [
    "ctrl",
    "shift",
    "alt",
    "meta"
];
const modifierGuards = {
    stop: (e)=>e.stopPropagation(),
    prevent: (e)=>e.preventDefault(),
    self: (e)=>e.target !== e.currentTarget,
    ctrl: (e)=>!e.ctrlKey,
    shift: (e)=>!e.shiftKey,
    alt: (e)=>!e.altKey,
    meta: (e)=>!e.metaKey,
    left: (e)=>"button" in e && e.button !== 0,
    middle: (e)=>"button" in e && e.button !== 1,
    right: (e)=>"button" in e && e.button !== 2,
    exact: (e, modifiers)=>systemModifiers.some((m)=>e[`${m}Key`] && !modifiers.includes(m))
};
const withModifiers = (fn, modifiers)=>{
    return (event, ...args)=>{
        for(let i = 0; i < modifiers.length; i++){
            const guard = modifierGuards[modifiers[i]];
            if (guard && guard(event, modifiers)) return;
        }
        return fn(event, ...args);
    };
};
const keyNames = {
    esc: "escape",
    space: " ",
    up: "arrow-up",
    left: "arrow-left",
    right: "arrow-right",
    down: "arrow-down",
    delete: "backspace"
};
const withKeys = (fn, modifiers)=>{
    return (event)=>{
        if (!("key" in event)) return;
        const eventKey = (0, _shared.hyphenate)(event.key);
        if (modifiers.some((k)=>k === eventKey || keyNames[k] === eventKey)) return fn(event);
    };
};
const vShow = {
    beforeMount (el, { value }, { transition }) {
        el._vod = el.style.display === "none" ? "" : el.style.display;
        if (transition && value) transition.beforeEnter(el);
        else setDisplay(el, value);
    },
    mounted (el, { value }, { transition }) {
        if (transition && value) transition.enter(el);
    },
    updated (el, { value, oldValue }, { transition }) {
        if (!value === !oldValue) return;
        if (transition) {
            if (value) {
                transition.beforeEnter(el);
                setDisplay(el, true);
                transition.enter(el);
            } else transition.leave(el, ()=>{
                setDisplay(el, false);
            });
        } else setDisplay(el, value);
    },
    beforeUnmount (el, { value }) {
        setDisplay(el, value);
    }
};
function setDisplay(el, value) {
    el.style.display = value ? el._vod : "none";
}
function initVShowForSSR() {
    vShow.getSSRProps = ({ value })=>{
        if (!value) return {
            style: {
                display: "none"
            }
        };
    };
}
const rendererOptions = /* @__PURE__ */ (0, _shared.extend)({
    patchProp
}, nodeOps);
let renderer;
let enabledHydration = false;
function ensureRenderer() {
    return renderer || (renderer = (0, _runtimeCore.createRenderer)(rendererOptions));
}
function ensureHydrationRenderer() {
    renderer = enabledHydration ? renderer : (0, _runtimeCore.createHydrationRenderer)(rendererOptions);
    enabledHydration = true;
    return renderer;
}
const render = (...args)=>{
    ensureRenderer().render(...args);
};
const hydrate = (...args)=>{
    ensureHydrationRenderer().hydrate(...args);
};
const createApp = (...args)=>{
    const app = ensureRenderer().createApp(...args);
    injectNativeTagCheck(app);
    injectCompilerOptionsCheck(app);
    const { mount } = app;
    app.mount = (containerOrSelector)=>{
        const container = normalizeContainer(containerOrSelector);
        if (!container) return;
        const component = app._component;
        if (!(0, _shared.isFunction)(component) && !component.render && !component.template) component.template = container.innerHTML;
        container.innerHTML = "";
        const proxy = mount(container, false, container instanceof SVGElement);
        if (container instanceof Element) {
            container.removeAttribute("v-cloak");
            container.setAttribute("data-v-app", "");
        }
        return proxy;
    };
    return app;
};
const createSSRApp = (...args)=>{
    const app = ensureHydrationRenderer().createApp(...args);
    injectNativeTagCheck(app);
    injectCompilerOptionsCheck(app);
    const { mount } = app;
    app.mount = (containerOrSelector)=>{
        const container = normalizeContainer(containerOrSelector);
        if (container) return mount(container, true, container instanceof SVGElement);
    };
    return app;
};
function injectNativeTagCheck(app) {
    Object.defineProperty(app.config, "isNativeTag", {
        value: (tag)=>(0, _shared.isHTMLTag)(tag) || (0, _shared.isSVGTag)(tag),
        writable: false
    });
}
function injectCompilerOptionsCheck(app) {
    if ((0, _runtimeCore.isRuntimeOnly)()) {
        const isCustomElement = app.config.isCustomElement;
        Object.defineProperty(app.config, "isCustomElement", {
            get () {
                return isCustomElement;
            },
            set () {
                (0, _runtimeCore.warn)(`The \`isCustomElement\` config option is deprecated. Use \`compilerOptions.isCustomElement\` instead.`);
            }
        });
        const compilerOptions = app.config.compilerOptions;
        const msg = `The \`compilerOptions\` config option is only respected when using a build of Vue.js that includes the runtime compiler (aka "full build"). Since you are using the runtime-only build, \`compilerOptions\` must be passed to \`@vue/compiler-dom\` in the build setup instead.
- For vue-loader: pass it via vue-loader's \`compilerOptions\` loader option.
- For vue-cli: see https://cli.vuejs.org/guide/webpack.html#modifying-options-of-a-loader
- For vite: pass it via @vitejs/plugin-vue options. See https://github.com/vitejs/vite-plugin-vue/tree/main/packages/plugin-vue#example-for-passing-options-to-vuecompiler-sfc`;
        Object.defineProperty(app.config, "compilerOptions", {
            get () {
                (0, _runtimeCore.warn)(msg);
                return compilerOptions;
            },
            set () {
                (0, _runtimeCore.warn)(msg);
            }
        });
    }
}
function normalizeContainer(container) {
    if ((0, _shared.isString)(container)) {
        const res = document.querySelector(container);
        if (!res) (0, _runtimeCore.warn)(`Failed to mount app: mount target selector "${container}" returned null.`);
        return res;
    }
    if ((0, window.ShadowRoot) && container instanceof window.ShadowRoot && container.mode === "closed") (0, _runtimeCore.warn)(`mounting on a ShadowRoot with \`{mode: "closed"}\` may lead to unpredictable bugs`);
    return container;
}
let ssrDirectiveInitialized = false;
const initDirectivesForSSR = ()=>{
    if (!ssrDirectiveInitialized) {
        ssrDirectiveInitialized = true;
        initVModelForSSR();
        initVShowForSSR();
    }
};

},{"@vue/runtime-core":"6EA3u","@vue/shared":"5YL8y","@parcel/transformer-js/src/esmodule-helpers.js":"boKlo"}],"6EA3u":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "EffectScope", ()=>(0, _reactivity.EffectScope));
parcelHelpers.export(exports, "ReactiveEffect", ()=>(0, _reactivity.ReactiveEffect));
parcelHelpers.export(exports, "customRef", ()=>(0, _reactivity.customRef));
parcelHelpers.export(exports, "effect", ()=>(0, _reactivity.effect));
parcelHelpers.export(exports, "effectScope", ()=>(0, _reactivity.effectScope));
parcelHelpers.export(exports, "getCurrentScope", ()=>(0, _reactivity.getCurrentScope));
parcelHelpers.export(exports, "isProxy", ()=>(0, _reactivity.isProxy));
parcelHelpers.export(exports, "isReactive", ()=>(0, _reactivity.isReactive));
parcelHelpers.export(exports, "isReadonly", ()=>(0, _reactivity.isReadonly));
parcelHelpers.export(exports, "isRef", ()=>(0, _reactivity.isRef));
parcelHelpers.export(exports, "isShallow", ()=>(0, _reactivity.isShallow));
parcelHelpers.export(exports, "markRaw", ()=>(0, _reactivity.markRaw));
parcelHelpers.export(exports, "onScopeDispose", ()=>(0, _reactivity.onScopeDispose));
parcelHelpers.export(exports, "proxyRefs", ()=>(0, _reactivity.proxyRefs));
parcelHelpers.export(exports, "reactive", ()=>(0, _reactivity.reactive));
parcelHelpers.export(exports, "readonly", ()=>(0, _reactivity.readonly));
parcelHelpers.export(exports, "ref", ()=>(0, _reactivity.ref));
parcelHelpers.export(exports, "shallowReactive", ()=>(0, _reactivity.shallowReactive));
parcelHelpers.export(exports, "shallowReadonly", ()=>(0, _reactivity.shallowReadonly));
parcelHelpers.export(exports, "shallowRef", ()=>(0, _reactivity.shallowRef));
parcelHelpers.export(exports, "stop", ()=>(0, _reactivity.stop));
parcelHelpers.export(exports, "toRaw", ()=>(0, _reactivity.toRaw));
parcelHelpers.export(exports, "toRef", ()=>(0, _reactivity.toRef));
parcelHelpers.export(exports, "toRefs", ()=>(0, _reactivity.toRefs));
parcelHelpers.export(exports, "toValue", ()=>(0, _reactivity.toValue));
parcelHelpers.export(exports, "triggerRef", ()=>(0, _reactivity.triggerRef));
parcelHelpers.export(exports, "unref", ()=>(0, _reactivity.unref));
parcelHelpers.export(exports, "camelize", ()=>(0, _shared.camelize));
parcelHelpers.export(exports, "capitalize", ()=>(0, _shared.capitalize));
parcelHelpers.export(exports, "normalizeClass", ()=>(0, _shared.normalizeClass));
parcelHelpers.export(exports, "normalizeProps", ()=>(0, _shared.normalizeProps));
parcelHelpers.export(exports, "normalizeStyle", ()=>(0, _shared.normalizeStyle));
parcelHelpers.export(exports, "toDisplayString", ()=>(0, _shared.toDisplayString));
parcelHelpers.export(exports, "toHandlerKey", ()=>(0, _shared.toHandlerKey));
parcelHelpers.export(exports, "BaseTransition", ()=>BaseTransition);
parcelHelpers.export(exports, "BaseTransitionPropsValidators", ()=>BaseTransitionPropsValidators);
parcelHelpers.export(exports, "Comment", ()=>Comment);
parcelHelpers.export(exports, "Fragment", ()=>Fragment);
parcelHelpers.export(exports, "KeepAlive", ()=>KeepAlive);
parcelHelpers.export(exports, "Static", ()=>Static);
parcelHelpers.export(exports, "Suspense", ()=>Suspense);
parcelHelpers.export(exports, "Teleport", ()=>Teleport);
parcelHelpers.export(exports, "Text", ()=>Text);
parcelHelpers.export(exports, "assertNumber", ()=>assertNumber);
parcelHelpers.export(exports, "callWithAsyncErrorHandling", ()=>callWithAsyncErrorHandling);
parcelHelpers.export(exports, "callWithErrorHandling", ()=>callWithErrorHandling);
parcelHelpers.export(exports, "cloneVNode", ()=>cloneVNode);
parcelHelpers.export(exports, "compatUtils", ()=>compatUtils);
parcelHelpers.export(exports, "computed", ()=>computed);
parcelHelpers.export(exports, "createBlock", ()=>createBlock);
parcelHelpers.export(exports, "createCommentVNode", ()=>createCommentVNode);
parcelHelpers.export(exports, "createElementBlock", ()=>createElementBlock);
parcelHelpers.export(exports, "createElementVNode", ()=>createBaseVNode);
parcelHelpers.export(exports, "createHydrationRenderer", ()=>createHydrationRenderer);
parcelHelpers.export(exports, "createPropsRestProxy", ()=>createPropsRestProxy);
parcelHelpers.export(exports, "createRenderer", ()=>createRenderer);
parcelHelpers.export(exports, "createSlots", ()=>createSlots);
parcelHelpers.export(exports, "createStaticVNode", ()=>createStaticVNode);
parcelHelpers.export(exports, "createTextVNode", ()=>createTextVNode);
parcelHelpers.export(exports, "createVNode", ()=>createVNode);
parcelHelpers.export(exports, "defineAsyncComponent", ()=>defineAsyncComponent);
parcelHelpers.export(exports, "defineComponent", ()=>defineComponent);
parcelHelpers.export(exports, "defineEmits", ()=>defineEmits);
parcelHelpers.export(exports, "defineExpose", ()=>defineExpose);
parcelHelpers.export(exports, "defineModel", ()=>defineModel);
parcelHelpers.export(exports, "defineOptions", ()=>defineOptions);
parcelHelpers.export(exports, "defineProps", ()=>defineProps);
parcelHelpers.export(exports, "defineSlots", ()=>defineSlots);
parcelHelpers.export(exports, "devtools", ()=>devtools);
parcelHelpers.export(exports, "getCurrentInstance", ()=>getCurrentInstance);
parcelHelpers.export(exports, "getTransitionRawChildren", ()=>getTransitionRawChildren);
parcelHelpers.export(exports, "guardReactiveProps", ()=>guardReactiveProps);
parcelHelpers.export(exports, "h", ()=>h);
parcelHelpers.export(exports, "handleError", ()=>handleError);
parcelHelpers.export(exports, "hasInjectionContext", ()=>hasInjectionContext);
parcelHelpers.export(exports, "initCustomFormatter", ()=>initCustomFormatter);
parcelHelpers.export(exports, "inject", ()=>inject);
parcelHelpers.export(exports, "isMemoSame", ()=>isMemoSame);
parcelHelpers.export(exports, "isRuntimeOnly", ()=>isRuntimeOnly);
parcelHelpers.export(exports, "isVNode", ()=>isVNode);
parcelHelpers.export(exports, "mergeDefaults", ()=>mergeDefaults);
parcelHelpers.export(exports, "mergeModels", ()=>mergeModels);
parcelHelpers.export(exports, "mergeProps", ()=>mergeProps);
parcelHelpers.export(exports, "nextTick", ()=>nextTick);
parcelHelpers.export(exports, "onActivated", ()=>onActivated);
parcelHelpers.export(exports, "onBeforeMount", ()=>onBeforeMount);
parcelHelpers.export(exports, "onBeforeUnmount", ()=>onBeforeUnmount);
parcelHelpers.export(exports, "onBeforeUpdate", ()=>onBeforeUpdate);
parcelHelpers.export(exports, "onDeactivated", ()=>onDeactivated);
parcelHelpers.export(exports, "onErrorCaptured", ()=>onErrorCaptured);
parcelHelpers.export(exports, "onMounted", ()=>onMounted);
parcelHelpers.export(exports, "onRenderTracked", ()=>onRenderTracked);
parcelHelpers.export(exports, "onRenderTriggered", ()=>onRenderTriggered);
parcelHelpers.export(exports, "onServerPrefetch", ()=>onServerPrefetch);
parcelHelpers.export(exports, "onUnmounted", ()=>onUnmounted);
parcelHelpers.export(exports, "onUpdated", ()=>onUpdated);
parcelHelpers.export(exports, "openBlock", ()=>openBlock);
parcelHelpers.export(exports, "popScopeId", ()=>popScopeId);
parcelHelpers.export(exports, "provide", ()=>provide);
parcelHelpers.export(exports, "pushScopeId", ()=>pushScopeId);
parcelHelpers.export(exports, "queuePostFlushCb", ()=>queuePostFlushCb);
parcelHelpers.export(exports, "registerRuntimeCompiler", ()=>registerRuntimeCompiler);
parcelHelpers.export(exports, "renderList", ()=>renderList);
parcelHelpers.export(exports, "renderSlot", ()=>renderSlot);
parcelHelpers.export(exports, "resolveComponent", ()=>resolveComponent);
parcelHelpers.export(exports, "resolveDirective", ()=>resolveDirective);
parcelHelpers.export(exports, "resolveDynamicComponent", ()=>resolveDynamicComponent);
parcelHelpers.export(exports, "resolveFilter", ()=>resolveFilter);
parcelHelpers.export(exports, "resolveTransitionHooks", ()=>resolveTransitionHooks);
parcelHelpers.export(exports, "setBlockTracking", ()=>setBlockTracking);
parcelHelpers.export(exports, "setDevtoolsHook", ()=>setDevtoolsHook);
parcelHelpers.export(exports, "setTransitionHooks", ()=>setTransitionHooks);
parcelHelpers.export(exports, "ssrContextKey", ()=>ssrContextKey);
parcelHelpers.export(exports, "ssrUtils", ()=>ssrUtils);
parcelHelpers.export(exports, "toHandlers", ()=>toHandlers);
parcelHelpers.export(exports, "transformVNodeArgs", ()=>transformVNodeArgs);
parcelHelpers.export(exports, "useAttrs", ()=>useAttrs);
parcelHelpers.export(exports, "useModel", ()=>useModel);
parcelHelpers.export(exports, "useSSRContext", ()=>useSSRContext);
parcelHelpers.export(exports, "useSlots", ()=>useSlots);
parcelHelpers.export(exports, "useTransitionState", ()=>useTransitionState);
parcelHelpers.export(exports, "version", ()=>version);
parcelHelpers.export(exports, "warn", ()=>warn);
parcelHelpers.export(exports, "watch", ()=>watch);
parcelHelpers.export(exports, "watchEffect", ()=>watchEffect);
parcelHelpers.export(exports, "watchPostEffect", ()=>watchPostEffect);
parcelHelpers.export(exports, "watchSyncEffect", ()=>watchSyncEffect);
parcelHelpers.export(exports, "withAsyncContext", ()=>withAsyncContext);
parcelHelpers.export(exports, "withCtx", ()=>withCtx);
parcelHelpers.export(exports, "withDefaults", ()=>withDefaults);
parcelHelpers.export(exports, "withDirectives", ()=>withDirectives);
parcelHelpers.export(exports, "withMemo", ()=>withMemo);
parcelHelpers.export(exports, "withScopeId", ()=>withScopeId);
var _reactivity = require("@vue/reactivity");
var _shared = require("@vue/shared");
const stack = [];
function pushWarningContext(vnode) {
    stack.push(vnode);
}
function popWarningContext() {
    stack.pop();
}
function warn(msg, ...args) {
    (0, _reactivity.pauseTracking)();
    const instance = stack.length ? stack[stack.length - 1].component : null;
    const appWarnHandler = instance && instance.appContext.config.warnHandler;
    const trace = getComponentTrace();
    if (appWarnHandler) callWithErrorHandling(appWarnHandler, instance, 11, [
        msg + args.join(""),
        instance && instance.proxy,
        trace.map(({ vnode })=>`at <${formatComponentName(instance, vnode.type)}>`).join("\n"),
        trace
    ]);
    else {
        const warnArgs = [
            `[Vue warn]: ${msg}`,
            ...args
        ];
        if (trace.length && // avoid spamming console during tests
        true) warnArgs.push(`
`, ...formatTrace(trace));
        console.warn(...warnArgs);
    }
    (0, _reactivity.resetTracking)();
}
function getComponentTrace() {
    let currentVNode = stack[stack.length - 1];
    if (!currentVNode) return [];
    const normalizedStack = [];
    while(currentVNode){
        const last = normalizedStack[0];
        if (last && last.vnode === currentVNode) last.recurseCount++;
        else normalizedStack.push({
            vnode: currentVNode,
            recurseCount: 0
        });
        const parentInstance = currentVNode.component && currentVNode.component.parent;
        currentVNode = parentInstance && parentInstance.vnode;
    }
    return normalizedStack;
}
function formatTrace(trace) {
    const logs = [];
    trace.forEach((entry, i)=>{
        logs.push(...i === 0 ? [] : [
            `
`
        ], ...formatTraceEntry(entry));
    });
    return logs;
}
function formatTraceEntry({ vnode, recurseCount }) {
    const postfix = recurseCount > 0 ? `... (${recurseCount} recursive calls)` : ``;
    const isRoot = vnode.component ? vnode.component.parent == null : false;
    const open = ` at <${formatComponentName(vnode.component, vnode.type, isRoot)}`;
    const close = `>` + postfix;
    return vnode.props ? [
        open,
        ...formatProps(vnode.props),
        close
    ] : [
        open + close
    ];
}
function formatProps(props) {
    const res = [];
    const keys = Object.keys(props);
    keys.slice(0, 3).forEach((key)=>{
        res.push(...formatProp(key, props[key]));
    });
    if (keys.length > 3) res.push(` ...`);
    return res;
}
function formatProp(key, value1, raw) {
    if ((0, _shared.isString)(value1)) {
        value1 = JSON.stringify(value1);
        return raw ? value1 : [
            `${key}=${value1}`
        ];
    } else if (typeof value1 === "number" || typeof value1 === "boolean" || value1 == null) return raw ? value1 : [
        `${key}=${value1}`
    ];
    else if ((0, _reactivity.isRef)(value1)) {
        value1 = formatProp(key, (0, _reactivity.toRaw)(value1.value), true);
        return raw ? value1 : [
            `${key}=Ref<`,
            value1,
            `>`
        ];
    } else if ((0, _shared.isFunction)(value1)) return [
        `${key}=fn${value1.name ? `<${value1.name}>` : ``}`
    ];
    else {
        value1 = (0, _reactivity.toRaw)(value1);
        return raw ? value1 : [
            `${key}=`,
            value1
        ];
    }
}
function assertNumber(val, type) {
    if (val === void 0) return;
    else if (typeof val !== "number") warn(`${type} is not a valid number - got ${JSON.stringify(val)}.`);
    else if (isNaN(val)) warn(`${type} is NaN - the duration expression might be incorrect.`);
}
const ErrorTypeStrings = {
    ["sp"]: "serverPrefetch hook",
    ["bc"]: "beforeCreate hook",
    ["c"]: "created hook",
    ["bm"]: "beforeMount hook",
    ["m"]: "mounted hook",
    ["bu"]: "beforeUpdate hook",
    ["u"]: "updated",
    ["bum"]: "beforeUnmount hook",
    ["um"]: "unmounted hook",
    ["a"]: "activated hook",
    ["da"]: "deactivated hook",
    ["ec"]: "errorCaptured hook",
    ["rtc"]: "renderTracked hook",
    ["rtg"]: "renderTriggered hook",
    [0]: "setup function",
    [1]: "render function",
    [2]: "watcher getter",
    [3]: "watcher callback",
    [4]: "watcher cleanup function",
    [5]: "native event handler",
    [6]: "component event handler",
    [7]: "vnode hook",
    [8]: "directive hook",
    [9]: "transition hook",
    [10]: "app errorHandler",
    [11]: "app warnHandler",
    [12]: "ref function",
    [13]: "async component loader",
    [14]: "scheduler flush. This is likely a Vue internals bug. Please open an issue at https://new-issue.vuejs.org/?repo=vuejs/core"
};
function callWithErrorHandling(fn, instance, type, args) {
    let res;
    try {
        res = args ? fn(...args) : fn();
    } catch (err) {
        handleError(err, instance, type);
    }
    return res;
}
function callWithAsyncErrorHandling(fn, instance, type, args) {
    if ((0, _shared.isFunction)(fn)) {
        const res = callWithErrorHandling(fn, instance, type, args);
        if (res && (0, _shared.isPromise)(res)) res.catch((err)=>{
            handleError(err, instance, type);
        });
        return res;
    }
    const values = [];
    for(let i = 0; i < fn.length; i++)values.push(callWithAsyncErrorHandling(fn[i], instance, type, args));
    return values;
}
function handleError(err, instance, type, throwInDev = true) {
    const contextVNode = instance ? instance.vnode : null;
    if (instance) {
        let cur = instance.parent;
        const exposedInstance = instance.proxy;
        const errorInfo = (0, ErrorTypeStrings[type]);
        while(cur){
            const errorCapturedHooks = cur.ec;
            if (errorCapturedHooks) for(let i = 0; i < errorCapturedHooks.length; i++){
                if (errorCapturedHooks[i](err, exposedInstance, errorInfo) === false) return;
            }
            cur = cur.parent;
        }
        const appErrorHandler = instance.appContext.config.errorHandler;
        if (appErrorHandler) {
            callWithErrorHandling(appErrorHandler, null, 10, [
                err,
                exposedInstance,
                errorInfo
            ]);
            return;
        }
    }
    logError(err, type, contextVNode, throwInDev);
}
function logError(err, type, contextVNode, throwInDev = true) {
    {
        const info = ErrorTypeStrings[type];
        if (contextVNode) pushWarningContext(contextVNode);
        warn(`Unhandled error${info ? ` during execution of ${info}` : ``}`);
        if (contextVNode) popWarningContext();
        if (throwInDev) throw err;
        else console.error(err);
    }
}
let isFlushing = false;
let isFlushPending = false;
const queue = [];
let flushIndex = 0;
const pendingPostFlushCbs = [];
let activePostFlushCbs = null;
let postFlushIndex = 0;
const resolvedPromise = /* @__PURE__ */ Promise.resolve();
let currentFlushPromise = null;
const RECURSION_LIMIT = 100;
function nextTick(fn) {
    const p = currentFlushPromise || resolvedPromise;
    return fn ? p.then(this ? fn.bind(this) : fn) : p;
}
function findInsertionIndex(id) {
    let start = flushIndex + 1;
    let end = queue.length;
    while(start < end){
        const middle = start + end >>> 1;
        const middleJobId = getId(queue[middle]);
        middleJobId < id ? start = middle + 1 : end = middle;
    }
    return start;
}
function queueJob(job) {
    if (!queue.length || !queue.includes(job, isFlushing && job.allowRecurse ? flushIndex + 1 : flushIndex)) {
        if (job.id == null) queue.push(job);
        else queue.splice(findInsertionIndex(job.id), 0, job);
        queueFlush();
    }
}
function queueFlush() {
    if (!isFlushing && !isFlushPending) {
        isFlushPending = true;
        currentFlushPromise = resolvedPromise.then(flushJobs);
    }
}
function invalidateJob(job) {
    const i = queue.indexOf(job);
    if (i > flushIndex) queue.splice(i, 1);
}
function queuePostFlushCb(cb) {
    if (!(0, _shared.isArray)(cb)) {
        if (!activePostFlushCbs || !activePostFlushCbs.includes(cb, cb.allowRecurse ? postFlushIndex + 1 : postFlushIndex)) pendingPostFlushCbs.push(cb);
    } else pendingPostFlushCbs.push(...cb);
    queueFlush();
}
function flushPreFlushCbs(seen, i = isFlushing ? flushIndex + 1 : 0) {
    seen = seen || /* @__PURE__ */ new Map();
    for(; i < queue.length; i++){
        const cb = queue[i];
        if (cb && cb.pre) {
            if (checkRecursiveUpdates(seen, cb)) continue;
            queue.splice(i, 1);
            i--;
            cb();
        }
    }
}
function flushPostFlushCbs(seen) {
    if (pendingPostFlushCbs.length) {
        const deduped = [
            ...new Set(pendingPostFlushCbs)
        ];
        pendingPostFlushCbs.length = 0;
        if (activePostFlushCbs) {
            activePostFlushCbs.push(...deduped);
            return;
        }
        activePostFlushCbs = deduped;
        seen = seen || /* @__PURE__ */ new Map();
        activePostFlushCbs.sort((a, b)=>getId(a) - getId(b));
        for(postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++){
            if (checkRecursiveUpdates(seen, activePostFlushCbs[postFlushIndex])) continue;
            activePostFlushCbs[postFlushIndex]();
        }
        activePostFlushCbs = null;
        postFlushIndex = 0;
    }
}
const getId = (job)=>job.id == null ? Infinity : job.id;
const comparator = (a, b)=>{
    const diff = getId(a) - getId(b);
    if (diff === 0) {
        if (a.pre && !b.pre) return -1;
        if (b.pre && !a.pre) return 1;
    }
    return diff;
};
function flushJobs(seen) {
    isFlushPending = false;
    isFlushing = true;
    seen = seen || /* @__PURE__ */ new Map();
    queue.sort(comparator);
    const check = (job)=>checkRecursiveUpdates(seen, job);
    try {
        for(flushIndex = 0; flushIndex < queue.length; flushIndex++){
            const job = queue[flushIndex];
            if (job && job.active !== false) {
                if (check(job)) continue;
                callWithErrorHandling(job, null, 14);
            }
        }
    } finally{
        flushIndex = 0;
        queue.length = 0;
        flushPostFlushCbs(seen);
        isFlushing = false;
        currentFlushPromise = null;
        if (queue.length || pendingPostFlushCbs.length) flushJobs(seen);
    }
}
function checkRecursiveUpdates(seen, fn) {
    if (!seen.has(fn)) seen.set(fn, 1);
    else {
        const count = seen.get(fn);
        if (count > RECURSION_LIMIT) {
            const instance = fn.ownerInstance;
            const componentName = instance && getComponentName(instance.type);
            warn(`Maximum recursive updates exceeded${componentName ? ` in component <${componentName}>` : ``}. This means you have a reactive effect that is mutating its own dependencies and thus recursively triggering itself. Possible sources include component template, render function, updated hook or watcher source function.`);
            return true;
        } else seen.set(fn, count + 1);
    }
}
let isHmrUpdating = false;
const hmrDirtyComponents = /* @__PURE__ */ new Set();
(0, _shared.getGlobalThis)().__VUE_HMR_RUNTIME__ = {
    createRecord: tryWrap(createRecord),
    rerender: tryWrap(rerender),
    reload: tryWrap(reload)
};
const map = /* @__PURE__ */ new Map();
function registerHMR(instance) {
    const id = instance.type.__hmrId;
    let record = map.get(id);
    if (!record) {
        createRecord(id, instance.type);
        record = map.get(id);
    }
    record.instances.add(instance);
}
function unregisterHMR(instance) {
    map.get(instance.type.__hmrId).instances.delete(instance);
}
function createRecord(id, initialDef) {
    if (map.has(id)) return false;
    map.set(id, {
        initialDef: normalizeClassComponent(initialDef),
        instances: /* @__PURE__ */ new Set()
    });
    return true;
}
function normalizeClassComponent(component) {
    return isClassComponent(component) ? component.__vccOpts : component;
}
function rerender(id, newRender) {
    const record = map.get(id);
    if (!record) return;
    record.initialDef.render = newRender;
    [
        ...record.instances
    ].forEach((instance)=>{
        if (newRender) {
            instance.render = newRender;
            normalizeClassComponent(instance.type).render = newRender;
        }
        instance.renderCache = [];
        isHmrUpdating = true;
        instance.update();
        isHmrUpdating = false;
    });
}
function reload(id, newComp) {
    const record = map.get(id);
    if (!record) return;
    newComp = normalizeClassComponent(newComp);
    updateComponentDef(record.initialDef, newComp);
    const instances = [
        ...record.instances
    ];
    for (const instance of instances){
        const oldComp = normalizeClassComponent(instance.type);
        if (!hmrDirtyComponents.has(oldComp)) {
            if (oldComp !== record.initialDef) updateComponentDef(oldComp, newComp);
            hmrDirtyComponents.add(oldComp);
        }
        instance.appContext.propsCache.delete(instance.type);
        instance.appContext.emitsCache.delete(instance.type);
        instance.appContext.optionsCache.delete(instance.type);
        if (instance.ceReload) {
            hmrDirtyComponents.add(oldComp);
            instance.ceReload(newComp.styles);
            hmrDirtyComponents.delete(oldComp);
        } else if (instance.parent) queueJob(instance.parent.update);
        else if (instance.appContext.reload) instance.appContext.reload();
        else if (typeof window !== "undefined") window.location.reload();
        else console.warn("[HMR] Root or manually mounted instance modified. Full reload required.");
    }
    queuePostFlushCb(()=>{
        for (const instance of instances)hmrDirtyComponents.delete(normalizeClassComponent(instance.type));
    });
}
function updateComponentDef(oldComp, newComp) {
    (0, _shared.extend)(oldComp, newComp);
    for(const key in oldComp)if (key !== "__file" && !(key in newComp)) delete oldComp[key];
}
function tryWrap(fn) {
    return (id, arg)=>{
        try {
            return fn(id, arg);
        } catch (e) {
            console.error(e);
            console.warn(`[HMR] Something went wrong during Vue component hot-reload. Full reload required.`);
        }
    };
}
let devtools;
let buffer = [];
let devtoolsNotInstalled = false;
function emit$1(event, ...args) {
    if (devtools) devtools.emit(event, ...args);
    else if (!devtoolsNotInstalled) buffer.push({
        event,
        args
    });
}
function setDevtoolsHook(hook, target) {
    var _a, _b;
    devtools = hook;
    if (devtools) {
        devtools.enabled = true;
        buffer.forEach(({ event, args })=>devtools.emit(event, ...args));
        buffer = [];
    } else if (// handle late devtools injection - only do this if we are in an actual
    // browser environment to avoid the timer handle stalling test runner exit
    // (#4815)
    typeof window !== "undefined" && // some envs mock window but not fully
    window.HTMLElement && // also exclude jsdom
    !((_b = (_a = window.navigator) == null ? void 0 : _a.userAgent) == null ? void 0 : _b.includes("jsdom"))) {
        const replay = target.__VUE_DEVTOOLS_HOOK_REPLAY__ = target.__VUE_DEVTOOLS_HOOK_REPLAY__ || [];
        replay.push((newHook)=>{
            setDevtoolsHook(newHook, target);
        });
        setTimeout(()=>{
            if (!devtools) {
                target.__VUE_DEVTOOLS_HOOK_REPLAY__ = null;
                devtoolsNotInstalled = true;
                buffer = [];
            }
        }, 3e3);
    } else {
        devtoolsNotInstalled = true;
        buffer = [];
    }
}
function devtoolsInitApp(app, version) {
    emit$1("app:init" /* APP_INIT */ , app, version, {
        Fragment,
        Text,
        Comment,
        Static
    });
}
function devtoolsUnmountApp(app) {
    emit$1("app:unmount" /* APP_UNMOUNT */ , app);
}
const devtoolsComponentAdded = /* @__PURE__ */ createDevtoolsComponentHook("component:added" /* COMPONENT_ADDED */ );
const devtoolsComponentUpdated = /* @__PURE__ */ createDevtoolsComponentHook("component:updated" /* COMPONENT_UPDATED */ );
const _devtoolsComponentRemoved = /* @__PURE__ */ createDevtoolsComponentHook("component:removed" /* COMPONENT_REMOVED */ );
const devtoolsComponentRemoved = (component)=>{
    if (devtools && typeof devtools.cleanupBuffer === "function" && // remove the component if it wasn't buffered
    !devtools.cleanupBuffer(component)) _devtoolsComponentRemoved(component);
};
function createDevtoolsComponentHook(hook) {
    return (component)=>{
        emit$1(hook, component.appContext.app, component.uid, component.parent ? component.parent.uid : void 0, component);
    };
}
const devtoolsPerfStart = /* @__PURE__ */ createDevtoolsPerformanceHook("perf:start" /* PERFORMANCE_START */ );
const devtoolsPerfEnd = /* @__PURE__ */ createDevtoolsPerformanceHook("perf:end" /* PERFORMANCE_END */ );
function createDevtoolsPerformanceHook(hook) {
    return (component, type, time)=>{
        emit$1(hook, component.appContext.app, component.uid, component, type, time);
    };
}
function devtoolsComponentEmit(component, event, params) {
    emit$1("component:emit" /* COMPONENT_EMIT */ , component.appContext.app, component, event, params);
}
function emit(instance, event, ...rawArgs) {
    if (instance.isUnmounted) return;
    const props = instance.vnode.props || (0, _shared.EMPTY_OBJ);
    {
        const { emitsOptions, propsOptions: [propsOptions] } = instance;
        if (emitsOptions) {
            if (!(event in emitsOptions) && true) {
                if (!propsOptions || !((0, _shared.toHandlerKey)(event) in propsOptions)) warn(`Component emitted event "${event}" but it is neither declared in the emits option nor as an "${(0, _shared.toHandlerKey)(event)}" prop.`);
            } else {
                const validator = emitsOptions[event];
                if ((0, _shared.isFunction)(validator)) {
                    const isValid = validator(...rawArgs);
                    if (!isValid) warn(`Invalid event arguments: event validation failed for event "${event}".`);
                }
            }
        }
    }
    let args = rawArgs;
    const isModelListener = event.startsWith("update:");
    const modelArg = isModelListener && event.slice(7);
    if (modelArg && modelArg in props) {
        const modifiersKey = `${modelArg === "modelValue" ? "model" : modelArg}Modifiers`;
        const { number, trim } = props[modifiersKey] || (0, _shared.EMPTY_OBJ);
        if (trim) args = rawArgs.map((a)=>(0, _shared.isString)(a) ? a.trim() : a);
        if (number) args = rawArgs.map((0, _shared.looseToNumber));
    }
    devtoolsComponentEmit(instance, event, args);
    {
        const lowerCaseEvent = event.toLowerCase();
        if (lowerCaseEvent !== event && props[(0, _shared.toHandlerKey)(lowerCaseEvent)]) warn(`Event "${lowerCaseEvent}" is emitted in component ${formatComponentName(instance, instance.type)} but the handler is registered for "${event}". Note that HTML attributes are case-insensitive and you cannot use v-on to listen to camelCase events when using in-DOM templates. You should probably use "${(0, _shared.hyphenate)(event)}" instead of "${event}".`);
    }
    let handlerName;
    let handler = props[handlerName = (0, _shared.toHandlerKey)(event)] || // also try camelCase event handler (#2249)
    props[handlerName = (0, _shared.toHandlerKey)((0, _shared.camelize)(event))];
    if (!handler && isModelListener) handler = props[handlerName = (0, _shared.toHandlerKey)((0, _shared.hyphenate)(event))];
    if (handler) callWithAsyncErrorHandling(handler, instance, 6, args);
    const onceHandler = props[handlerName + `Once`];
    if (onceHandler) {
        if (!instance.emitted) instance.emitted = {};
        else if (instance.emitted[handlerName]) return;
        instance.emitted[handlerName] = true;
        callWithAsyncErrorHandling(onceHandler, instance, 6, args);
    }
}
function normalizeEmitsOptions(comp, appContext, asMixin = false) {
    const cache = appContext.emitsCache;
    const cached = cache.get(comp);
    if (cached !== void 0) return cached;
    const raw = comp.emits;
    let normalized = {};
    let hasExtends = false;
    if (__VUE_OPTIONS_API__ && !(0, _shared.isFunction)(comp)) {
        const extendEmits = (raw2)=>{
            const normalizedFromExtend = normalizeEmitsOptions(raw2, appContext, true);
            if (normalizedFromExtend) {
                hasExtends = true;
                (0, _shared.extend)(normalized, normalizedFromExtend);
            }
        };
        if (!asMixin && appContext.mixins.length) appContext.mixins.forEach(extendEmits);
        if (comp.extends) extendEmits(comp.extends);
        if (comp.mixins) comp.mixins.forEach(extendEmits);
    }
    if (!raw && !hasExtends) {
        if ((0, _shared.isObject)(comp)) cache.set(comp, null);
        return null;
    }
    if ((0, _shared.isArray)(raw)) raw.forEach((key)=>normalized[key] = null);
    else (0, _shared.extend)(normalized, raw);
    if ((0, _shared.isObject)(comp)) cache.set(comp, normalized);
    return normalized;
}
function isEmitListener(options, key) {
    if (!options || !(0, _shared.isOn)(key)) return false;
    key = key.slice(2).replace(/Once$/, "");
    return (0, _shared.hasOwn)(options, key[0].toLowerCase() + key.slice(1)) || (0, _shared.hasOwn)(options, (0, _shared.hyphenate)(key)) || (0, _shared.hasOwn)(options, key);
}
let currentRenderingInstance = null;
let currentScopeId = null;
function setCurrentRenderingInstance(instance) {
    const prev = currentRenderingInstance;
    currentRenderingInstance = instance;
    currentScopeId = instance && instance.type.__scopeId || null;
    return prev;
}
function pushScopeId(id) {
    currentScopeId = id;
}
function popScopeId() {
    currentScopeId = null;
}
const withScopeId = (_id)=>withCtx;
function withCtx(fn, ctx = currentRenderingInstance, isNonScopedSlot) {
    if (!ctx) return fn;
    if (fn._n) return fn;
    const renderFnWithContext = (...args)=>{
        if (renderFnWithContext._d) setBlockTracking(-1);
        const prevInstance = setCurrentRenderingInstance(ctx);
        let res;
        try {
            res = fn(...args);
        } finally{
            setCurrentRenderingInstance(prevInstance);
            if (renderFnWithContext._d) setBlockTracking(1);
        }
        devtoolsComponentUpdated(ctx);
        return res;
    };
    renderFnWithContext._n = true;
    renderFnWithContext._c = true;
    renderFnWithContext._d = true;
    return renderFnWithContext;
}
let accessedAttrs = false;
function markAttrsAccessed() {
    accessedAttrs = true;
}
function renderComponentRoot(instance) {
    const { type: Component, vnode, proxy, withProxy, props, propsOptions: [propsOptions], slots, attrs, emit, render, renderCache, data, setupState, ctx, inheritAttrs } = instance;
    let result;
    let fallthroughAttrs;
    const prev = setCurrentRenderingInstance(instance);
    accessedAttrs = false;
    try {
        if (vnode.shapeFlag & 4) {
            const proxyToUse = withProxy || proxy;
            result = normalizeVNode(render.call(proxyToUse, proxyToUse, renderCache, props, setupState, data, ctx));
            fallthroughAttrs = attrs;
        } else {
            const render2 = Component;
            if (attrs === props) markAttrsAccessed();
            result = normalizeVNode(render2.length > 1 ? render2(props, {
                get attrs () {
                    markAttrsAccessed();
                    return attrs;
                },
                slots,
                emit
            }) : render2(props, null));
            fallthroughAttrs = Component.props ? attrs : getFunctionalFallthrough(attrs);
        }
    } catch (err) {
        blockStack.length = 0;
        handleError(err, instance, 1);
        result = createVNode(Comment);
    }
    let root = result;
    let setRoot = void 0;
    if (result.patchFlag > 0 && result.patchFlag & 2048) [root, setRoot] = getChildRoot(result);
    if (fallthroughAttrs && inheritAttrs !== false) {
        const keys = Object.keys(fallthroughAttrs);
        const { shapeFlag } = root;
        if (keys.length) {
            if (shapeFlag & 7) {
                if (propsOptions && keys.some((0, _shared.isModelListener))) fallthroughAttrs = filterModelListeners(fallthroughAttrs, propsOptions);
                root = cloneVNode(root, fallthroughAttrs);
            } else if (!accessedAttrs && root.type !== Comment) {
                const allAttrs = Object.keys(attrs);
                const eventAttrs = [];
                const extraAttrs = [];
                for(let i = 0, l = allAttrs.length; i < l; i++){
                    const key = allAttrs[i];
                    if ((0, _shared.isOn)(key)) {
                        if (!(0, _shared.isModelListener)(key)) eventAttrs.push(key[2].toLowerCase() + key.slice(3));
                    } else extraAttrs.push(key);
                }
                if (extraAttrs.length) warn(`Extraneous non-props attributes (${extraAttrs.join(", ")}) were passed to component but could not be automatically inherited because component renders fragment or text root nodes.`);
                if (eventAttrs.length) warn(`Extraneous non-emits event listeners (${eventAttrs.join(", ")}) were passed to component but could not be automatically inherited because component renders fragment or text root nodes. If the listener is intended to be a component custom event listener only, declare it using the "emits" option.`);
            }
        }
    }
    if (vnode.dirs) {
        if (!isElementRoot(root)) warn(`Runtime directive used on component with non-element root node. The directives will not function as intended.`);
        root = cloneVNode(root);
        root.dirs = root.dirs ? root.dirs.concat(vnode.dirs) : vnode.dirs;
    }
    if (vnode.transition) {
        if (!isElementRoot(root)) warn(`Component inside <Transition> renders non-element root node that cannot be animated.`);
        root.transition = vnode.transition;
    }
    if (setRoot) setRoot(root);
    else result = root;
    setCurrentRenderingInstance(prev);
    return result;
}
const getChildRoot = (vnode)=>{
    const rawChildren = vnode.children;
    const dynamicChildren = vnode.dynamicChildren;
    const childRoot = filterSingleRoot(rawChildren);
    if (!childRoot) return [
        vnode,
        void 0
    ];
    const index = rawChildren.indexOf(childRoot);
    const dynamicIndex = dynamicChildren ? dynamicChildren.indexOf(childRoot) : -1;
    const setRoot = (updatedRoot)=>{
        rawChildren[index] = updatedRoot;
        if (dynamicChildren) {
            if (dynamicIndex > -1) dynamicChildren[dynamicIndex] = updatedRoot;
            else if (updatedRoot.patchFlag > 0) vnode.dynamicChildren = [
                ...dynamicChildren,
                updatedRoot
            ];
        }
    };
    return [
        normalizeVNode(childRoot),
        setRoot
    ];
};
function filterSingleRoot(children) {
    let singleRoot;
    for(let i = 0; i < children.length; i++){
        const child = children[i];
        if (isVNode(child)) {
            if (child.type !== Comment || child.children === "v-if") {
                if (singleRoot) return;
                else singleRoot = child;
            }
        } else return;
    }
    return singleRoot;
}
const getFunctionalFallthrough = (attrs)=>{
    let res;
    for(const key in attrs)if (key === "class" || key === "style" || (0, _shared.isOn)(key)) (res || (res = {}))[key] = attrs[key];
    return res;
};
const filterModelListeners = (attrs, props)=>{
    const res = {};
    for(const key in attrs)if (!(0, _shared.isModelListener)(key) || !(key.slice(9) in props)) res[key] = attrs[key];
    return res;
};
const isElementRoot = (vnode)=>{
    return vnode.shapeFlag & 7 || vnode.type === Comment;
};
function shouldUpdateComponent(prevVNode, nextVNode, optimized) {
    const { props: prevProps, children: prevChildren, component } = prevVNode;
    const { props: nextProps, children: nextChildren, patchFlag } = nextVNode;
    const emits = component.emitsOptions;
    if ((prevChildren || nextChildren) && isHmrUpdating) return true;
    if (nextVNode.dirs || nextVNode.transition) return true;
    if (optimized && patchFlag >= 0) {
        if (patchFlag & 1024) return true;
        if (patchFlag & 16) {
            if (!prevProps) return !!nextProps;
            return hasPropsChanged(prevProps, nextProps, emits);
        } else if (patchFlag & 8) {
            const dynamicProps = nextVNode.dynamicProps;
            for(let i = 0; i < dynamicProps.length; i++){
                const key = dynamicProps[i];
                if (nextProps[key] !== prevProps[key] && !isEmitListener(emits, key)) return true;
            }
        }
    } else {
        if (prevChildren || nextChildren) {
            if (!nextChildren || !nextChildren.$stable) return true;
        }
        if (prevProps === nextProps) return false;
        if (!prevProps) return !!nextProps;
        if (!nextProps) return true;
        return hasPropsChanged(prevProps, nextProps, emits);
    }
    return false;
}
function hasPropsChanged(prevProps, nextProps, emitsOptions) {
    const nextKeys = Object.keys(nextProps);
    if (nextKeys.length !== Object.keys(prevProps).length) return true;
    for(let i = 0; i < nextKeys.length; i++){
        const key = nextKeys[i];
        if (nextProps[key] !== prevProps[key] && !isEmitListener(emitsOptions, key)) return true;
    }
    return false;
}
function updateHOCHostEl({ vnode, parent }, el) {
    while(parent && parent.subTree === vnode){
        (vnode = parent.vnode).el = el;
        parent = parent.parent;
    }
}
const isSuspense = (type)=>type.__isSuspense;
const SuspenseImpl = {
    name: "Suspense",
    // In order to make Suspense tree-shakable, we need to avoid importing it
    // directly in the renderer. The renderer checks for the __isSuspense flag
    // on a vnode's type and calls the `process` method, passing in renderer
    // internals.
    __isSuspense: true,
    process (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals) {
        if (n1 == null) mountSuspense(n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals);
        else patchSuspense(n1, n2, container, anchor, parentComponent, isSVG, slotScopeIds, optimized, rendererInternals);
    },
    hydrate: hydrateSuspense,
    create: createSuspenseBoundary,
    normalize: normalizeSuspenseChildren
};
const Suspense = SuspenseImpl;
function triggerEvent(vnode, name) {
    const eventListener = vnode.props && vnode.props[name];
    if ((0, _shared.isFunction)(eventListener)) eventListener();
}
function mountSuspense(vnode, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals) {
    const { p: patch, o: { createElement } } = rendererInternals;
    const hiddenContainer = createElement("div");
    const suspense = vnode.suspense = createSuspenseBoundary(vnode, parentSuspense, parentComponent, container, hiddenContainer, anchor, isSVG, slotScopeIds, optimized, rendererInternals);
    patch(null, suspense.pendingBranch = vnode.ssContent, hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds);
    if (suspense.deps > 0) {
        triggerEvent(vnode, "onPending");
        triggerEvent(vnode, "onFallback");
        patch(null, vnode.ssFallback, container, anchor, parentComponent, null, // fallback tree will not have suspense context
        isSVG, slotScopeIds);
        setActiveBranch(suspense, vnode.ssFallback);
    } else suspense.resolve(false, true);
}
function patchSuspense(n1, n2, container, anchor, parentComponent, isSVG, slotScopeIds, optimized, { p: patch, um: unmount, o: { createElement } }) {
    const suspense = n2.suspense = n1.suspense;
    suspense.vnode = n2;
    n2.el = n1.el;
    const newBranch = n2.ssContent;
    const newFallback = n2.ssFallback;
    const { activeBranch, pendingBranch, isInFallback, isHydrating } = suspense;
    if (pendingBranch) {
        suspense.pendingBranch = newBranch;
        if (isSameVNodeType(newBranch, pendingBranch)) {
            patch(pendingBranch, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);
            if (suspense.deps <= 0) suspense.resolve();
            else if (isInFallback) {
                patch(activeBranch, newFallback, container, anchor, parentComponent, null, // fallback tree will not have suspense context
                isSVG, slotScopeIds, optimized);
                setActiveBranch(suspense, newFallback);
            }
        } else {
            suspense.pendingId++;
            if (isHydrating) {
                suspense.isHydrating = false;
                suspense.activeBranch = pendingBranch;
            } else unmount(pendingBranch, parentComponent, suspense);
            suspense.deps = 0;
            suspense.effects.length = 0;
            suspense.hiddenContainer = createElement("div");
            if (isInFallback) {
                patch(null, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);
                if (suspense.deps <= 0) suspense.resolve();
                else {
                    patch(activeBranch, newFallback, container, anchor, parentComponent, null, // fallback tree will not have suspense context
                    isSVG, slotScopeIds, optimized);
                    setActiveBranch(suspense, newFallback);
                }
            } else if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {
                patch(activeBranch, newBranch, container, anchor, parentComponent, suspense, isSVG, slotScopeIds, optimized);
                suspense.resolve(true);
            } else {
                patch(null, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);
                if (suspense.deps <= 0) suspense.resolve();
            }
        }
    } else if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {
        patch(activeBranch, newBranch, container, anchor, parentComponent, suspense, isSVG, slotScopeIds, optimized);
        setActiveBranch(suspense, newBranch);
    } else {
        triggerEvent(n2, "onPending");
        suspense.pendingBranch = newBranch;
        suspense.pendingId++;
        patch(null, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);
        if (suspense.deps <= 0) suspense.resolve();
        else {
            const { timeout, pendingId } = suspense;
            if (timeout > 0) setTimeout(()=>{
                if (suspense.pendingId === pendingId) suspense.fallback(newFallback);
            }, timeout);
            else if (timeout === 0) suspense.fallback(newFallback);
        }
    }
}
let hasWarned = false;
function createSuspenseBoundary(vnode, parentSuspense, parentComponent, container, hiddenContainer, anchor, isSVG, slotScopeIds, optimized, rendererInternals, isHydrating = false) {
    if (!hasWarned) {
        hasWarned = true;
        console[console.info ? "info" : "log"](`<Suspense> is an experimental feature and its API will likely change.`);
    }
    const { p: patch, m: move, um: unmount, n: next, o: { parentNode, remove } } = rendererInternals;
    let parentSuspenseId;
    const isSuspensible = isVNodeSuspensible(vnode);
    if (isSuspensible) {
        if (parentSuspense == null ? void 0 : parentSuspense.pendingBranch) {
            parentSuspenseId = parentSuspense.pendingId;
            parentSuspense.deps++;
        }
    }
    const timeout = vnode.props ? (0, _shared.toNumber)(vnode.props.timeout) : void 0;
    assertNumber(timeout, `Suspense timeout`);
    const suspense = {
        vnode,
        parent: parentSuspense,
        parentComponent,
        isSVG,
        container,
        hiddenContainer,
        anchor,
        deps: 0,
        pendingId: 0,
        timeout: typeof timeout === "number" ? timeout : -1,
        activeBranch: null,
        pendingBranch: null,
        isInFallback: true,
        isHydrating,
        isUnmounted: false,
        effects: [],
        resolve (resume = false, sync = false) {
            if (!resume && !suspense.pendingBranch) throw new Error(`suspense.resolve() is called without a pending branch.`);
            if (suspense.isUnmounted) throw new Error(`suspense.resolve() is called on an already unmounted suspense boundary.`);
            const { vnode: vnode2, activeBranch, pendingBranch, pendingId, effects, parentComponent: parentComponent2, container: container2 } = suspense;
            if (suspense.isHydrating) suspense.isHydrating = false;
            else if (!resume) {
                const delayEnter = activeBranch && pendingBranch.transition && pendingBranch.transition.mode === "out-in";
                if (delayEnter) activeBranch.transition.afterLeave = ()=>{
                    if (pendingId === suspense.pendingId) move(pendingBranch, container2, anchor2, 0);
                };
                let { anchor: anchor2 } = suspense;
                if (activeBranch) {
                    anchor2 = next(activeBranch);
                    unmount(activeBranch, parentComponent2, suspense, true);
                }
                if (!delayEnter) move(pendingBranch, container2, anchor2, 0);
            }
            setActiveBranch(suspense, pendingBranch);
            suspense.pendingBranch = null;
            suspense.isInFallback = false;
            let parent = suspense.parent;
            let hasUnresolvedAncestor = false;
            while(parent){
                if (parent.pendingBranch) {
                    parent.effects.push(...effects);
                    hasUnresolvedAncestor = true;
                    break;
                }
                parent = parent.parent;
            }
            if (!hasUnresolvedAncestor) queuePostFlushCb(effects);
            suspense.effects = [];
            if (isSuspensible) {
                if (parentSuspense && parentSuspense.pendingBranch && parentSuspenseId === parentSuspense.pendingId) {
                    parentSuspense.deps--;
                    if (parentSuspense.deps === 0 && !sync) parentSuspense.resolve();
                }
            }
            triggerEvent(vnode2, "onResolve");
        },
        fallback (fallbackVNode) {
            if (!suspense.pendingBranch) return;
            const { vnode: vnode2, activeBranch, parentComponent: parentComponent2, container: container2, isSVG: isSVG2 } = suspense;
            triggerEvent(vnode2, "onFallback");
            const anchor2 = next(activeBranch);
            const mountFallback = ()=>{
                if (!suspense.isInFallback) return;
                patch(null, fallbackVNode, container2, anchor2, parentComponent2, null, // fallback tree will not have suspense context
                isSVG2, slotScopeIds, optimized);
                setActiveBranch(suspense, fallbackVNode);
            };
            const delayEnter = fallbackVNode.transition && fallbackVNode.transition.mode === "out-in";
            if (delayEnter) activeBranch.transition.afterLeave = mountFallback;
            suspense.isInFallback = true;
            unmount(activeBranch, parentComponent2, null, // no suspense so unmount hooks fire now
            true);
            if (!delayEnter) mountFallback();
        },
        move (container2, anchor2, type) {
            suspense.activeBranch && move(suspense.activeBranch, container2, anchor2, type);
            suspense.container = container2;
        },
        next () {
            return suspense.activeBranch && next(suspense.activeBranch);
        },
        registerDep (instance, setupRenderEffect) {
            const isInPendingSuspense = !!suspense.pendingBranch;
            if (isInPendingSuspense) suspense.deps++;
            const hydratedEl = instance.vnode.el;
            instance.asyncDep.catch((err)=>{
                handleError(err, instance, 0);
            }).then((asyncSetupResult)=>{
                if (instance.isUnmounted || suspense.isUnmounted || suspense.pendingId !== instance.suspenseId) return;
                instance.asyncResolved = true;
                const { vnode: vnode2 } = instance;
                pushWarningContext(vnode2);
                handleSetupResult(instance, asyncSetupResult, false);
                if (hydratedEl) vnode2.el = hydratedEl;
                const placeholder = !hydratedEl && instance.subTree.el;
                setupRenderEffect(instance, vnode2, // component may have been moved before resolve.
                // if this is not a hydration, instance.subTree will be the comment
                // placeholder.
                parentNode(hydratedEl || instance.subTree.el), // anchor will not be used if this is hydration, so only need to
                // consider the comment placeholder case.
                hydratedEl ? null : next(instance.subTree), suspense, isSVG, optimized);
                if (placeholder) remove(placeholder);
                updateHOCHostEl(instance, vnode2.el);
                popWarningContext();
                if (isInPendingSuspense && --suspense.deps === 0) suspense.resolve();
            });
        },
        unmount (parentSuspense2, doRemove) {
            suspense.isUnmounted = true;
            if (suspense.activeBranch) unmount(suspense.activeBranch, parentComponent, parentSuspense2, doRemove);
            if (suspense.pendingBranch) unmount(suspense.pendingBranch, parentComponent, parentSuspense2, doRemove);
        }
    };
    return suspense;
}
function hydrateSuspense(node, vnode, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals, hydrateNode) {
    const suspense = vnode.suspense = createSuspenseBoundary(vnode, parentSuspense, parentComponent, node.parentNode, document.createElement("div"), null, isSVG, slotScopeIds, optimized, rendererInternals, true);
    const result = hydrateNode(node, suspense.pendingBranch = vnode.ssContent, parentComponent, suspense, slotScopeIds, optimized);
    if (suspense.deps === 0) suspense.resolve(false, true);
    return result;
}
function normalizeSuspenseChildren(vnode) {
    const { shapeFlag, children } = vnode;
    const isSlotChildren = shapeFlag & 32;
    vnode.ssContent = normalizeSuspenseSlot(isSlotChildren ? children.default : children);
    vnode.ssFallback = isSlotChildren ? normalizeSuspenseSlot(children.fallback) : createVNode(Comment);
}
function normalizeSuspenseSlot(s) {
    let block;
    if ((0, _shared.isFunction)(s)) {
        const trackBlock = isBlockTreeEnabled && s._c;
        if (trackBlock) {
            s._d = false;
            openBlock();
        }
        s = s();
        if (trackBlock) {
            s._d = true;
            block = currentBlock;
            closeBlock();
        }
    }
    if ((0, _shared.isArray)(s)) {
        const singleChild = filterSingleRoot(s);
        if (!singleChild) warn(`<Suspense> slots expect a single root node.`);
        s = singleChild;
    }
    s = normalizeVNode(s);
    if (block && !s.dynamicChildren) s.dynamicChildren = block.filter((c)=>c !== s);
    return s;
}
function queueEffectWithSuspense(fn, suspense) {
    if (suspense && suspense.pendingBranch) {
        if ((0, _shared.isArray)(fn)) suspense.effects.push(...fn);
        else suspense.effects.push(fn);
    } else queuePostFlushCb(fn);
}
function setActiveBranch(suspense, branch) {
    suspense.activeBranch = branch;
    const { vnode, parentComponent } = suspense;
    const el = vnode.el = branch.el;
    if (parentComponent && parentComponent.subTree === vnode) {
        parentComponent.vnode.el = el;
        updateHOCHostEl(parentComponent, el);
    }
}
function isVNodeSuspensible(vnode) {
    var _a;
    return ((_a = vnode.props) == null ? void 0 : _a.suspensible) != null && vnode.props.suspensible !== false;
}
function watchEffect(effect, options) {
    return doWatch(effect, null, options);
}
function watchPostEffect(effect, options) {
    return doWatch(effect, null, (0, _shared.extend)({}, options, {
        flush: "post"
    }));
}
function watchSyncEffect(effect, options) {
    return doWatch(effect, null, (0, _shared.extend)({}, options, {
        flush: "sync"
    }));
}
const INITIAL_WATCHER_VALUE = {};
function watch(source, cb, options) {
    if (!(0, _shared.isFunction)(cb)) warn(`\`watch(fn, options?)\` signature has been moved to a separate API. Use \`watchEffect(fn, options?)\` instead. \`watch\` now only supports \`watch(source, cb, options?) signature.`);
    return doWatch(source, cb, options);
}
function doWatch(source, cb, { immediate, deep, flush, onTrack, onTrigger } = (0, _shared.EMPTY_OBJ)) {
    var _a;
    if (!cb) {
        if (immediate !== void 0) warn(`watch() "immediate" option is only respected when using the watch(source, callback, options?) signature.`);
        if (deep !== void 0) warn(`watch() "deep" option is only respected when using the watch(source, callback, options?) signature.`);
    }
    const warnInvalidSource = (s)=>{
        warn(`Invalid watch source: `, s, `A watch source can only be a getter/effect function, a ref, a reactive object, or an array of these types.`);
    };
    const instance = (0, _reactivity.getCurrentScope)() === ((_a = currentInstance) == null ? void 0 : _a.scope) ? currentInstance : null;
    let getter;
    let forceTrigger = false;
    let isMultiSource = false;
    if ((0, _reactivity.isRef)(source)) {
        getter = ()=>source.value;
        forceTrigger = (0, _reactivity.isShallow)(source);
    } else if ((0, _reactivity.isReactive)(source)) {
        getter = ()=>source;
        deep = true;
    } else if ((0, _shared.isArray)(source)) {
        isMultiSource = true;
        forceTrigger = source.some((s)=>(0, _reactivity.isReactive)(s) || (0, _reactivity.isShallow)(s));
        getter = ()=>source.map((s)=>{
                if ((0, _reactivity.isRef)(s)) return s.value;
                else if ((0, _reactivity.isReactive)(s)) return traverse(s);
                else if ((0, _shared.isFunction)(s)) return callWithErrorHandling(s, instance, 2);
                else warnInvalidSource(s);
            });
    } else if ((0, _shared.isFunction)(source)) {
        if (cb) getter = ()=>callWithErrorHandling(source, instance, 2);
        else getter = ()=>{
            if (instance && instance.isUnmounted) return;
            if (cleanup) cleanup();
            return callWithAsyncErrorHandling(source, instance, 3, [
                onCleanup
            ]);
        };
    } else {
        getter = (0, _shared.NOOP);
        warnInvalidSource(source);
    }
    if (cb && deep) {
        const baseGetter = getter;
        getter = ()=>traverse(baseGetter());
    }
    let cleanup;
    let onCleanup = (fn)=>{
        cleanup = effect.onStop = ()=>{
            callWithErrorHandling(fn, instance, 4);
        };
    };
    let ssrCleanup;
    if (isInSSRComponentSetup) {
        onCleanup = (0, _shared.NOOP);
        if (!cb) getter();
        else if (immediate) callWithAsyncErrorHandling(cb, instance, 3, [
            getter(),
            isMultiSource ? [] : void 0,
            onCleanup
        ]);
        if (flush === "sync") {
            const ctx = useSSRContext();
            ssrCleanup = ctx.__watcherHandles || (ctx.__watcherHandles = []);
        } else return 0, _shared.NOOP;
    }
    let oldValue = isMultiSource ? new Array(source.length).fill(INITIAL_WATCHER_VALUE) : INITIAL_WATCHER_VALUE;
    const job = ()=>{
        if (!effect.active) return;
        if (cb) {
            const newValue = effect.run();
            if (deep || forceTrigger || (isMultiSource ? newValue.some((v1, i)=>(0, _shared.hasChanged)(v1, oldValue[i])) : (0, _shared.hasChanged)(newValue, oldValue)) || false) {
                if (cleanup) cleanup();
                callWithAsyncErrorHandling(cb, instance, 3, [
                    newValue,
                    // pass undefined as the old value when it's changed for the first time
                    oldValue === INITIAL_WATCHER_VALUE ? void 0 : isMultiSource && oldValue[0] === INITIAL_WATCHER_VALUE ? [] : oldValue,
                    onCleanup
                ]);
                oldValue = newValue;
            }
        } else effect.run();
    };
    job.allowRecurse = !!cb;
    let scheduler;
    if (flush === "sync") scheduler = job;
    else if (flush === "post") scheduler = ()=>queuePostRenderEffect(job, instance && instance.suspense);
    else {
        job.pre = true;
        if (instance) job.id = instance.uid;
        scheduler = ()=>queueJob(job);
    }
    const effect = new (0, _reactivity.ReactiveEffect)(getter, scheduler);
    effect.onTrack = onTrack;
    effect.onTrigger = onTrigger;
    if (cb) {
        if (immediate) job();
        else oldValue = effect.run();
    } else if (flush === "post") queuePostRenderEffect(effect.run.bind(effect), instance && instance.suspense);
    else effect.run();
    const unwatch = ()=>{
        effect.stop();
        if (instance && instance.scope) (0, _shared.remove)(instance.scope.effects, effect);
    };
    if (ssrCleanup) ssrCleanup.push(unwatch);
    return unwatch;
}
function instanceWatch(source, value1, options) {
    const publicThis = this.proxy;
    const getter = (0, _shared.isString)(source) ? source.includes(".") ? createPathGetter(publicThis, source) : ()=>publicThis[source] : source.bind(publicThis, publicThis);
    let cb;
    if ((0, _shared.isFunction)(value1)) cb = value1;
    else {
        cb = value1.handler;
        options = value1;
    }
    const cur = currentInstance;
    setCurrentInstance(this);
    const res = doWatch(getter, cb.bind(publicThis), options);
    if (cur) setCurrentInstance(cur);
    else unsetCurrentInstance();
    return res;
}
function createPathGetter(ctx, path) {
    const segments = path.split(".");
    return ()=>{
        let cur = ctx;
        for(let i = 0; i < segments.length && cur; i++)cur = cur[segments[i]];
        return cur;
    };
}
function traverse(value1, seen) {
    if (!(0, _shared.isObject)(value1) || value1["__v_skip"]) return value1;
    seen = seen || /* @__PURE__ */ new Set();
    if (seen.has(value1)) return value1;
    seen.add(value1);
    if ((0, _reactivity.isRef)(value1)) traverse(value1.value, seen);
    else if ((0, _shared.isArray)(value1)) for(let i = 0; i < value1.length; i++)traverse(value1[i], seen);
    else if ((0, _shared.isSet)(value1) || (0, _shared.isMap)(value1)) value1.forEach((v1)=>{
        traverse(v1, seen);
    });
    else if ((0, _shared.isPlainObject)(value1)) for(const key in value1)traverse(value1[key], seen);
    return value1;
}
function validateDirectiveName(name) {
    if ((0, _shared.isBuiltInDirective)(name)) warn("Do not use built-in directive ids as custom directive id: " + name);
}
function withDirectives(vnode, directives) {
    const internalInstance = currentRenderingInstance;
    if (internalInstance === null) {
        warn(`withDirectives can only be used inside render functions.`);
        return vnode;
    }
    const instance = getExposeProxy(internalInstance) || internalInstance.proxy;
    const bindings = vnode.dirs || (vnode.dirs = []);
    for(let i = 0; i < directives.length; i++){
        let [dir, value1, arg, modifiers = (0, _shared.EMPTY_OBJ)] = directives[i];
        if (dir) {
            if ((0, _shared.isFunction)(dir)) dir = {
                mounted: dir,
                updated: dir
            };
            if (dir.deep) traverse(value1);
            bindings.push({
                dir,
                instance,
                value: value1,
                oldValue: void 0,
                arg,
                modifiers
            });
        }
    }
    return vnode;
}
function invokeDirectiveHook(vnode, prevVNode, instance, name) {
    const bindings = vnode.dirs;
    const oldBindings = prevVNode && prevVNode.dirs;
    for(let i = 0; i < bindings.length; i++){
        const binding = bindings[i];
        if (oldBindings) binding.oldValue = oldBindings[i].value;
        let hook = binding.dir[name];
        if (hook) {
            (0, _reactivity.pauseTracking)();
            callWithAsyncErrorHandling(hook, instance, 8, [
                vnode.el,
                binding,
                vnode,
                prevVNode
            ]);
            (0, _reactivity.resetTracking)();
        }
    }
}
function useTransitionState() {
    const state = {
        isMounted: false,
        isLeaving: false,
        isUnmounting: false,
        leavingVNodes: /* @__PURE__ */ new Map()
    };
    onMounted(()=>{
        state.isMounted = true;
    });
    onBeforeUnmount(()=>{
        state.isUnmounting = true;
    });
    return state;
}
const TransitionHookValidator = [
    Function,
    Array
];
const BaseTransitionPropsValidators = {
    mode: String,
    appear: Boolean,
    persisted: Boolean,
    // enter
    onBeforeEnter: TransitionHookValidator,
    onEnter: TransitionHookValidator,
    onAfterEnter: TransitionHookValidator,
    onEnterCancelled: TransitionHookValidator,
    // leave
    onBeforeLeave: TransitionHookValidator,
    onLeave: TransitionHookValidator,
    onAfterLeave: TransitionHookValidator,
    onLeaveCancelled: TransitionHookValidator,
    // appear
    onBeforeAppear: TransitionHookValidator,
    onAppear: TransitionHookValidator,
    onAfterAppear: TransitionHookValidator,
    onAppearCancelled: TransitionHookValidator
};
const BaseTransitionImpl = {
    name: `BaseTransition`,
    props: BaseTransitionPropsValidators,
    setup (props, { slots }) {
        const instance = getCurrentInstance();
        const state = useTransitionState();
        let prevTransitionKey;
        return ()=>{
            const children = slots.default && getTransitionRawChildren(slots.default(), true);
            if (!children || !children.length) return;
            let child = children[0];
            if (children.length > 1) {
                let hasFound = false;
                for (const c of children)if (c.type !== Comment) {
                    if (hasFound) {
                        warn("<transition> can only be used on a single element or component. Use <transition-group> for lists.");
                        break;
                    }
                    child = c;
                    hasFound = true;
                }
            }
            const rawProps = (0, _reactivity.toRaw)(props);
            const { mode } = rawProps;
            if (mode && mode !== "in-out" && mode !== "out-in" && mode !== "default") warn(`invalid <transition> mode: ${mode}`);
            if (state.isLeaving) return emptyPlaceholder(child);
            const innerChild = getKeepAliveChild(child);
            if (!innerChild) return emptyPlaceholder(child);
            const enterHooks = resolveTransitionHooks(innerChild, rawProps, state, instance);
            setTransitionHooks(innerChild, enterHooks);
            const oldChild = instance.subTree;
            const oldInnerChild = oldChild && getKeepAliveChild(oldChild);
            let transitionKeyChanged = false;
            const { getTransitionKey } = innerChild.type;
            if (getTransitionKey) {
                const key = getTransitionKey();
                if (prevTransitionKey === void 0) prevTransitionKey = key;
                else if (key !== prevTransitionKey) {
                    prevTransitionKey = key;
                    transitionKeyChanged = true;
                }
            }
            if (oldInnerChild && oldInnerChild.type !== Comment && (!isSameVNodeType(innerChild, oldInnerChild) || transitionKeyChanged)) {
                const leavingHooks = resolveTransitionHooks(oldInnerChild, rawProps, state, instance);
                setTransitionHooks(oldInnerChild, leavingHooks);
                if (mode === "out-in") {
                    state.isLeaving = true;
                    leavingHooks.afterLeave = ()=>{
                        state.isLeaving = false;
                        if (instance.update.active !== false) instance.update();
                    };
                    return emptyPlaceholder(child);
                } else if (mode === "in-out" && innerChild.type !== Comment) leavingHooks.delayLeave = (el, earlyRemove, delayedLeave)=>{
                    const leavingVNodesCache = getLeavingNodesForType(state, oldInnerChild);
                    leavingVNodesCache[String(oldInnerChild.key)] = oldInnerChild;
                    el._leaveCb = ()=>{
                        earlyRemove();
                        el._leaveCb = void 0;
                        delete enterHooks.delayedLeave;
                    };
                    enterHooks.delayedLeave = delayedLeave;
                };
            }
            return child;
        };
    }
};
const BaseTransition = BaseTransitionImpl;
function getLeavingNodesForType(state, vnode) {
    const { leavingVNodes } = state;
    let leavingVNodesCache = leavingVNodes.get(vnode.type);
    if (!leavingVNodesCache) {
        leavingVNodesCache = /* @__PURE__ */ Object.create(null);
        leavingVNodes.set(vnode.type, leavingVNodesCache);
    }
    return leavingVNodesCache;
}
function resolveTransitionHooks(vnode, props, state, instance) {
    const { appear, mode, persisted = false, onBeforeEnter, onEnter, onAfterEnter, onEnterCancelled, onBeforeLeave, onLeave, onAfterLeave, onLeaveCancelled, onBeforeAppear, onAppear, onAfterAppear, onAppearCancelled } = props;
    const key = String(vnode.key);
    const leavingVNodesCache = getLeavingNodesForType(state, vnode);
    const callHook = (hook, args)=>{
        hook && callWithAsyncErrorHandling(hook, instance, 9, args);
    };
    const callAsyncHook = (hook, args)=>{
        const done = args[1];
        callHook(hook, args);
        if ((0, _shared.isArray)(hook)) {
            if (hook.every((hook2)=>hook2.length <= 1)) done();
        } else if (hook.length <= 1) done();
    };
    const hooks = {
        mode,
        persisted,
        beforeEnter (el) {
            let hook = onBeforeEnter;
            if (!state.isMounted) {
                if (appear) hook = onBeforeAppear || onBeforeEnter;
                else return;
            }
            if (el._leaveCb) el._leaveCb(true);
            const leavingVNode = leavingVNodesCache[key];
            if (leavingVNode && isSameVNodeType(vnode, leavingVNode) && leavingVNode.el._leaveCb) leavingVNode.el._leaveCb();
            callHook(hook, [
                el
            ]);
        },
        enter (el) {
            let hook = onEnter;
            let afterHook = onAfterEnter;
            let cancelHook = onEnterCancelled;
            if (!state.isMounted) {
                if (appear) {
                    hook = onAppear || onEnter;
                    afterHook = onAfterAppear || onAfterEnter;
                    cancelHook = onAppearCancelled || onEnterCancelled;
                } else return;
            }
            let called = false;
            const done = el._enterCb = (cancelled)=>{
                if (called) return;
                called = true;
                if (cancelled) callHook(cancelHook, [
                    el
                ]);
                else callHook(afterHook, [
                    el
                ]);
                if (hooks.delayedLeave) hooks.delayedLeave();
                el._enterCb = void 0;
            };
            if (hook) callAsyncHook(hook, [
                el,
                done
            ]);
            else done();
        },
        leave (el, remove) {
            const key2 = String(vnode.key);
            if (el._enterCb) el._enterCb(true);
            if (state.isUnmounting) return remove();
            callHook(onBeforeLeave, [
                el
            ]);
            let called = false;
            const done = el._leaveCb = (cancelled)=>{
                if (called) return;
                called = true;
                remove();
                if (cancelled) callHook(onLeaveCancelled, [
                    el
                ]);
                else callHook(onAfterLeave, [
                    el
                ]);
                el._leaveCb = void 0;
                if (leavingVNodesCache[key2] === vnode) delete leavingVNodesCache[key2];
            };
            leavingVNodesCache[key2] = vnode;
            if (onLeave) callAsyncHook(onLeave, [
                el,
                done
            ]);
            else done();
        },
        clone (vnode2) {
            return resolveTransitionHooks(vnode2, props, state, instance);
        }
    };
    return hooks;
}
function emptyPlaceholder(vnode) {
    if (isKeepAlive(vnode)) {
        vnode = cloneVNode(vnode);
        vnode.children = null;
        return vnode;
    }
}
function getKeepAliveChild(vnode) {
    return isKeepAlive(vnode) ? vnode.children ? vnode.children[0] : void 0 : vnode;
}
function setTransitionHooks(vnode, hooks) {
    if (vnode.shapeFlag & 6 && vnode.component) setTransitionHooks(vnode.component.subTree, hooks);
    else if (vnode.shapeFlag & 128) {
        vnode.ssContent.transition = hooks.clone(vnode.ssContent);
        vnode.ssFallback.transition = hooks.clone(vnode.ssFallback);
    } else vnode.transition = hooks;
}
function getTransitionRawChildren(children, keepComment = false, parentKey) {
    let ret = [];
    let keyedFragmentCount = 0;
    for(let i = 0; i < children.length; i++){
        let child = children[i];
        const key = parentKey == null ? child.key : String(parentKey) + String(child.key != null ? child.key : i);
        if (child.type === Fragment) {
            if (child.patchFlag & 128) keyedFragmentCount++;
            ret = ret.concat(getTransitionRawChildren(child.children, keepComment, key));
        } else if (keepComment || child.type !== Comment) ret.push(key != null ? cloneVNode(child, {
            key
        }) : child);
    }
    if (keyedFragmentCount > 1) for(let i = 0; i < ret.length; i++)ret[i].patchFlag = -2;
    return ret;
}
function defineComponent(options, extraOptions) {
    return (0, _shared.isFunction)(options) ? // #8326: extend call and options.name access are considered side-effects
    // by Rollup, so we have to wrap it in a pure-annotated IIFE.
    /* @__PURE__ */ (()=>(0, _shared.extend)({
            name: options.name
        }, extraOptions, {
            setup: options
        }))() : options;
}
const isAsyncWrapper = (i)=>!!i.type.__asyncLoader;
function defineAsyncComponent(source) {
    if ((0, _shared.isFunction)(source)) source = {
        loader: source
    };
    const { loader, loadingComponent, errorComponent, delay = 200, timeout, // undefined = never times out
    suspensible = true, onError: userOnError } = source;
    let pendingRequest = null;
    let resolvedComp;
    let retries = 0;
    const retry = ()=>{
        retries++;
        pendingRequest = null;
        return load();
    };
    const load = ()=>{
        let thisRequest;
        return pendingRequest || (thisRequest = pendingRequest = loader().catch((err)=>{
            err = err instanceof Error ? err : new Error(String(err));
            if (userOnError) return new Promise((resolve, reject)=>{
                const userRetry = ()=>resolve(retry());
                const userFail = ()=>reject(err);
                userOnError(err, userRetry, userFail, retries + 1);
            });
            else throw err;
        }).then((comp)=>{
            if (thisRequest !== pendingRequest && pendingRequest) return pendingRequest;
            if (!comp) warn(`Async component loader resolved to undefined. If you are using retry(), make sure to return its return value.`);
            if (comp && (comp.__esModule || comp[Symbol.toStringTag] === "Module")) comp = comp.default;
            if (comp && !(0, _shared.isObject)(comp) && !(0, _shared.isFunction)(comp)) throw new Error(`Invalid async component load result: ${comp}`);
            resolvedComp = comp;
            return comp;
        }));
    };
    return defineComponent({
        name: "AsyncComponentWrapper",
        __asyncLoader: load,
        get __asyncResolved () {
            return resolvedComp;
        },
        setup () {
            const instance = currentInstance;
            if (resolvedComp) return ()=>createInnerComp(resolvedComp, instance);
            const onError = (err)=>{
                pendingRequest = null;
                handleError(err, instance, 13, !errorComponent);
            };
            if (suspensible && instance.suspense || isInSSRComponentSetup) return load().then((comp)=>{
                return ()=>createInnerComp(comp, instance);
            }).catch((err)=>{
                onError(err);
                return ()=>errorComponent ? createVNode(errorComponent, {
                        error: err
                    }) : null;
            });
            const loaded = (0, _reactivity.ref)(false);
            const error = (0, _reactivity.ref)();
            const delayed = (0, _reactivity.ref)(!!delay);
            if (delay) setTimeout(()=>{
                delayed.value = false;
            }, delay);
            if (timeout != null) setTimeout(()=>{
                if (!loaded.value && !error.value) {
                    const err = new Error(`Async component timed out after ${timeout}ms.`);
                    onError(err);
                    error.value = err;
                }
            }, timeout);
            load().then(()=>{
                loaded.value = true;
                if (instance.parent && isKeepAlive(instance.parent.vnode)) queueJob(instance.parent.update);
            }).catch((err)=>{
                onError(err);
                error.value = err;
            });
            return ()=>{
                if (loaded.value && resolvedComp) return createInnerComp(resolvedComp, instance);
                else if (error.value && errorComponent) return createVNode(errorComponent, {
                    error: error.value
                });
                else if (loadingComponent && !delayed.value) return createVNode(loadingComponent);
            };
        }
    });
}
function createInnerComp(comp, parent) {
    const { ref: ref2, props, children, ce } = parent.vnode;
    const vnode = createVNode(comp, props, children);
    vnode.ref = ref2;
    vnode.ce = ce;
    delete parent.vnode.ce;
    return vnode;
}
const isKeepAlive = (vnode)=>vnode.type.__isKeepAlive;
const KeepAliveImpl = {
    name: `KeepAlive`,
    // Marker for special handling inside the renderer. We are not using a ===
    // check directly on KeepAlive in the renderer, because importing it directly
    // would prevent it from being tree-shaken.
    __isKeepAlive: true,
    props: {
        include: [
            String,
            RegExp,
            Array
        ],
        exclude: [
            String,
            RegExp,
            Array
        ],
        max: [
            String,
            Number
        ]
    },
    setup (props, { slots }) {
        const instance = getCurrentInstance();
        const sharedContext = instance.ctx;
        if (!sharedContext.renderer) return ()=>{
            const children = slots.default && slots.default();
            return children && children.length === 1 ? children[0] : children;
        };
        const cache = /* @__PURE__ */ new Map();
        const keys = /* @__PURE__ */ new Set();
        let current = null;
        instance.__v_cache = cache;
        const parentSuspense = instance.suspense;
        const { renderer: { p: patch, m: move, um: _unmount, o: { createElement } } } = sharedContext;
        const storageContainer = createElement("div");
        sharedContext.activate = (vnode, container, anchor, isSVG, optimized)=>{
            const instance2 = vnode.component;
            move(vnode, container, anchor, 0, parentSuspense);
            patch(instance2.vnode, vnode, container, anchor, instance2, parentSuspense, isSVG, vnode.slotScopeIds, optimized);
            queuePostRenderEffect(()=>{
                instance2.isDeactivated = false;
                if (instance2.a) (0, _shared.invokeArrayFns)(instance2.a);
                const vnodeHook = vnode.props && vnode.props.onVnodeMounted;
                if (vnodeHook) invokeVNodeHook(vnodeHook, instance2.parent, vnode);
            }, parentSuspense);
            devtoolsComponentAdded(instance2);
        };
        sharedContext.deactivate = (vnode)=>{
            const instance2 = vnode.component;
            move(vnode, storageContainer, null, 1, parentSuspense);
            queuePostRenderEffect(()=>{
                if (instance2.da) (0, _shared.invokeArrayFns)(instance2.da);
                const vnodeHook = vnode.props && vnode.props.onVnodeUnmounted;
                if (vnodeHook) invokeVNodeHook(vnodeHook, instance2.parent, vnode);
                instance2.isDeactivated = true;
            }, parentSuspense);
            devtoolsComponentAdded(instance2);
        };
        function unmount(vnode) {
            resetShapeFlag(vnode);
            _unmount(vnode, instance, parentSuspense, true);
        }
        function pruneCache(filter) {
            cache.forEach((vnode, key)=>{
                const name = getComponentName(vnode.type);
                if (name && (!filter || !filter(name))) pruneCacheEntry(key);
            });
        }
        function pruneCacheEntry(key) {
            const cached = cache.get(key);
            if (!current || !isSameVNodeType(cached, current)) unmount(cached);
            else if (current) resetShapeFlag(current);
            cache.delete(key);
            keys.delete(key);
        }
        watch(()=>[
                props.include,
                props.exclude
            ], ([include, exclude])=>{
            include && pruneCache((name)=>matches(include, name));
            exclude && pruneCache((name)=>!matches(exclude, name));
        }, // prune post-render after `current` has been updated
        {
            flush: "post",
            deep: true
        });
        let pendingCacheKey = null;
        const cacheSubtree = ()=>{
            if (pendingCacheKey != null) cache.set(pendingCacheKey, getInnerChild(instance.subTree));
        };
        onMounted(cacheSubtree);
        onUpdated(cacheSubtree);
        onBeforeUnmount(()=>{
            cache.forEach((cached)=>{
                const { subTree, suspense } = instance;
                const vnode = getInnerChild(subTree);
                if (cached.type === vnode.type && cached.key === vnode.key) {
                    resetShapeFlag(vnode);
                    const da = vnode.component.da;
                    da && queuePostRenderEffect(da, suspense);
                    return;
                }
                unmount(cached);
            });
        });
        return ()=>{
            pendingCacheKey = null;
            if (!slots.default) return null;
            const children = slots.default();
            const rawVNode = children[0];
            if (children.length > 1) {
                warn(`KeepAlive should contain exactly one component child.`);
                current = null;
                return children;
            } else if (!isVNode(rawVNode) || !(rawVNode.shapeFlag & 4) && !(rawVNode.shapeFlag & 128)) {
                current = null;
                return rawVNode;
            }
            let vnode = getInnerChild(rawVNode);
            const comp = vnode.type;
            const name = getComponentName(isAsyncWrapper(vnode) ? vnode.type.__asyncResolved || {} : comp);
            const { include, exclude, max } = props;
            if (include && (!name || !matches(include, name)) || exclude && name && matches(exclude, name)) {
                current = vnode;
                return rawVNode;
            }
            const key = vnode.key == null ? comp : vnode.key;
            const cachedVNode = cache.get(key);
            if (vnode.el) {
                vnode = cloneVNode(vnode);
                if (rawVNode.shapeFlag & 128) rawVNode.ssContent = vnode;
            }
            pendingCacheKey = key;
            if (cachedVNode) {
                vnode.el = cachedVNode.el;
                vnode.component = cachedVNode.component;
                if (vnode.transition) setTransitionHooks(vnode, vnode.transition);
                vnode.shapeFlag |= 512;
                keys.delete(key);
                keys.add(key);
            } else {
                keys.add(key);
                if (max && keys.size > parseInt(max, 10)) pruneCacheEntry(keys.values().next().value);
            }
            vnode.shapeFlag |= 256;
            current = vnode;
            return isSuspense(rawVNode.type) ? rawVNode : vnode;
        };
    }
};
const KeepAlive = KeepAliveImpl;
function matches(pattern, name) {
    if ((0, _shared.isArray)(pattern)) return pattern.some((p)=>matches(p, name));
    else if ((0, _shared.isString)(pattern)) return pattern.split(",").includes(name);
    else if ((0, _shared.isRegExp)(pattern)) return pattern.test(name);
    return false;
}
function onActivated(hook, target) {
    registerKeepAliveHook(hook, "a", target);
}
function onDeactivated(hook, target) {
    registerKeepAliveHook(hook, "da", target);
}
function registerKeepAliveHook(hook, type, target = currentInstance) {
    const wrappedHook = hook.__wdc || (hook.__wdc = ()=>{
        let current = target;
        while(current){
            if (current.isDeactivated) return;
            current = current.parent;
        }
        return hook();
    });
    injectHook(type, wrappedHook, target);
    if (target) {
        let current = target.parent;
        while(current && current.parent){
            if (isKeepAlive(current.parent.vnode)) injectToKeepAliveRoot(wrappedHook, type, target, current);
            current = current.parent;
        }
    }
}
function injectToKeepAliveRoot(hook, type, target, keepAliveRoot) {
    const injected = injectHook(type, hook, keepAliveRoot, true);
    onUnmounted(()=>{
        (0, _shared.remove)(keepAliveRoot[type], injected);
    }, target);
}
function resetShapeFlag(vnode) {
    vnode.shapeFlag &= -257;
    vnode.shapeFlag &= -513;
}
function getInnerChild(vnode) {
    return vnode.shapeFlag & 128 ? vnode.ssContent : vnode;
}
function injectHook(type, hook, target = currentInstance, prepend = false) {
    if (target) {
        const hooks = target[type] || (target[type] = []);
        const wrappedHook = hook.__weh || (hook.__weh = (...args)=>{
            if (target.isUnmounted) return;
            (0, _reactivity.pauseTracking)();
            setCurrentInstance(target);
            const res = callWithAsyncErrorHandling(hook, target, type, args);
            unsetCurrentInstance();
            (0, _reactivity.resetTracking)();
            return res;
        });
        if (prepend) hooks.unshift(wrappedHook);
        else hooks.push(wrappedHook);
        return wrappedHook;
    } else {
        const apiName = (0, _shared.toHandlerKey)(ErrorTypeStrings[type].replace(/ hook$/, ""));
        warn(`${apiName} is called when there is no active component instance to be associated with. Lifecycle injection APIs can only be used during execution of setup().` + ` If you are using async setup(), make sure to register lifecycle hooks before the first await statement.`);
    }
}
const createHook = (lifecycle)=>(hook, target = currentInstance)=>// post-create lifecycle registrations are noops during SSR (except for serverPrefetch)
        (!isInSSRComponentSetup || lifecycle === "sp") && injectHook(lifecycle, (...args)=>hook(...args), target);
const onBeforeMount = createHook("bm");
const onMounted = createHook("m");
const onBeforeUpdate = createHook("bu");
const onUpdated = createHook("u");
const onBeforeUnmount = createHook("bum");
const onUnmounted = createHook("um");
const onServerPrefetch = createHook("sp");
const onRenderTriggered = createHook("rtg");
const onRenderTracked = createHook("rtc");
function onErrorCaptured(hook, target = currentInstance) {
    injectHook("ec", hook, target);
}
const COMPONENTS = "components";
const DIRECTIVES = "directives";
function resolveComponent(name, maybeSelfReference) {
    return resolveAsset(COMPONENTS, name, true, maybeSelfReference) || name;
}
const NULL_DYNAMIC_COMPONENT = Symbol.for("v-ndc");
function resolveDynamicComponent(component) {
    if ((0, _shared.isString)(component)) return resolveAsset(COMPONENTS, component, false) || component;
    else return component || NULL_DYNAMIC_COMPONENT;
}
function resolveDirective(name) {
    return resolveAsset(DIRECTIVES, name);
}
function resolveAsset(type, name, warnMissing = true, maybeSelfReference = false) {
    const instance = currentRenderingInstance || currentInstance;
    if (instance) {
        const Component = instance.type;
        if (type === COMPONENTS) {
            const selfName = getComponentName(Component, false);
            if (selfName && (selfName === name || selfName === (0, _shared.camelize)(name) || selfName === (0, _shared.capitalize)((0, _shared.camelize)(name)))) return Component;
        }
        const res = // local registration
        // check instance[type] first which is resolved for options API
        resolve(instance[type] || Component[type], name) || // global registration
        resolve(instance.appContext[type], name);
        if (!res && maybeSelfReference) return Component;
        if (warnMissing && !res) {
            const extra = type === COMPONENTS ? `
If this is a native custom element, make sure to exclude it from component resolution via compilerOptions.isCustomElement.` : ``;
            warn(`Failed to resolve ${type.slice(0, -1)}: ${name}${extra}`);
        }
        return res;
    } else warn(`resolve${(0, _shared.capitalize)(type.slice(0, -1))} can only be used in render() or setup().`);
}
function resolve(registry, name) {
    return registry && (registry[name] || registry[(0, _shared.camelize)(name)] || registry[(0, _shared.capitalize)((0, _shared.camelize)(name))]);
}
function renderList(source, renderItem, cache, index) {
    let ret;
    const cached = cache && cache[index];
    if ((0, _shared.isArray)(source) || (0, _shared.isString)(source)) {
        ret = new Array(source.length);
        for(let i = 0, l = source.length; i < l; i++)ret[i] = renderItem(source[i], i, void 0, cached && cached[i]);
    } else if (typeof source === "number") {
        if (!Number.isInteger(source)) warn(`The v-for range expect an integer value but got ${source}.`);
        ret = new Array(source);
        for(let i = 0; i < source; i++)ret[i] = renderItem(i + 1, i, void 0, cached && cached[i]);
    } else if ((0, _shared.isObject)(source)) {
        if (source[Symbol.iterator]) ret = Array.from(source, (item, i)=>renderItem(item, i, void 0, cached && cached[i]));
        else {
            const keys = Object.keys(source);
            ret = new Array(keys.length);
            for(let i = 0, l = keys.length; i < l; i++){
                const key = keys[i];
                ret[i] = renderItem(source[key], key, i, cached && cached[i]);
            }
        }
    } else ret = [];
    if (cache) cache[index] = ret;
    return ret;
}
function createSlots(slots, dynamicSlots) {
    for(let i = 0; i < dynamicSlots.length; i++){
        const slot = dynamicSlots[i];
        if ((0, _shared.isArray)(slot)) for(let j = 0; j < slot.length; j++)slots[slot[j].name] = slot[j].fn;
        else if (slot) slots[slot.name] = slot.key ? (...args)=>{
            const res = slot.fn(...args);
            if (res) res.key = slot.key;
            return res;
        } : slot.fn;
    }
    return slots;
}
function renderSlot(slots, name, props = {}, fallback, noSlotted) {
    if (currentRenderingInstance.isCE || currentRenderingInstance.parent && isAsyncWrapper(currentRenderingInstance.parent) && currentRenderingInstance.parent.isCE) {
        if (name !== "default") props.name = name;
        return createVNode("slot", props, fallback && fallback());
    }
    let slot = slots[name];
    if (slot && slot.length > 1) {
        warn(`SSR-optimized slot function detected in a non-SSR-optimized render function. You need to mark this component with $dynamic-slots in the parent template.`);
        slot = ()=>[];
    }
    if (slot && slot._c) slot._d = false;
    openBlock();
    const validSlotContent = slot && ensureValidVNode(slot(props));
    const rendered = createBlock(Fragment, {
        key: props.key || // slot content array of a dynamic conditional slot may have a branch
        // key attached in the `createSlots` helper, respect that
        validSlotContent && validSlotContent.key || `_${name}`
    }, validSlotContent || (fallback ? fallback() : []), validSlotContent && slots._ === 1 ? 64 : -2);
    if (!noSlotted && rendered.scopeId) rendered.slotScopeIds = [
        rendered.scopeId + "-s"
    ];
    if (slot && slot._c) slot._d = true;
    return rendered;
}
function ensureValidVNode(vnodes) {
    return vnodes.some((child)=>{
        if (!isVNode(child)) return true;
        if (child.type === Comment) return false;
        if (child.type === Fragment && !ensureValidVNode(child.children)) return false;
        return true;
    }) ? vnodes : null;
}
function toHandlers(obj, preserveCaseIfNecessary) {
    const ret = {};
    if (!(0, _shared.isObject)(obj)) {
        warn(`v-on with no argument expects an object value.`);
        return ret;
    }
    for(const key in obj)ret[preserveCaseIfNecessary && /[A-Z]/.test(key) ? `on:${key}` : (0, _shared.toHandlerKey)(key)] = obj[key];
    return ret;
}
const getPublicInstance = (i)=>{
    if (!i) return null;
    if (isStatefulComponent(i)) return getExposeProxy(i) || i.proxy;
    return getPublicInstance(i.parent);
};
const publicPropertiesMap = // Move PURE marker to new line to workaround compiler discarding it
// due to type annotation
/* @__PURE__ */ (0, _shared.extend)(/* @__PURE__ */ Object.create(null), {
    $: (i)=>i,
    $el: (i)=>i.vnode.el,
    $data: (i)=>i.data,
    $props: (i)=>(0, _reactivity.shallowReadonly)(i.props),
    $attrs: (i)=>(0, _reactivity.shallowReadonly)(i.attrs),
    $slots: (i)=>(0, _reactivity.shallowReadonly)(i.slots),
    $refs: (i)=>(0, _reactivity.shallowReadonly)(i.refs),
    $parent: (i)=>getPublicInstance(i.parent),
    $root: (i)=>getPublicInstance(i.root),
    $emit: (i)=>i.emit,
    $options: (i)=>__VUE_OPTIONS_API__ ? resolveMergedOptions(i) : i.type,
    $forceUpdate: (i)=>i.f || (i.f = ()=>queueJob(i.update)),
    $nextTick: (i)=>i.n || (i.n = nextTick.bind(i.proxy)),
    $watch: (i)=>__VUE_OPTIONS_API__ ? instanceWatch.bind(i) : (0, _shared.NOOP)
});
const isReservedPrefix = (key)=>key === "_" || key === "$";
const hasSetupBinding = (state, key)=>state !== (0, _shared.EMPTY_OBJ) && !state.__isScriptSetup && (0, _shared.hasOwn)(state, key);
const PublicInstanceProxyHandlers = {
    get ({ _: instance }, key) {
        const { ctx, setupState, data, props, accessCache, type, appContext } = instance;
        if (key === "__isVue") return true;
        let normalizedProps;
        if (key[0] !== "$") {
            const n = accessCache[key];
            if (n !== void 0) switch(n){
                case 1 /* SETUP */ :
                    return setupState[key];
                case 2 /* DATA */ :
                    return data[key];
                case 4 /* CONTEXT */ :
                    return ctx[key];
                case 3 /* PROPS */ :
                    return props[key];
            }
            else if (hasSetupBinding(setupState, key)) {
                accessCache[key] = 1 /* SETUP */ ;
                return setupState[key];
            } else if (data !== (0, _shared.EMPTY_OBJ) && (0, _shared.hasOwn)(data, key)) {
                accessCache[key] = 2 /* DATA */ ;
                return data[key];
            } else if (// only cache other properties when instance has declared (thus stable)
            // props
            (normalizedProps = instance.propsOptions[0]) && (0, _shared.hasOwn)(normalizedProps, key)) {
                accessCache[key] = 3 /* PROPS */ ;
                return props[key];
            } else if (ctx !== (0, _shared.EMPTY_OBJ) && (0, _shared.hasOwn)(ctx, key)) {
                accessCache[key] = 4 /* CONTEXT */ ;
                return ctx[key];
            } else if (!__VUE_OPTIONS_API__ || shouldCacheAccess) accessCache[key] = 0 /* OTHER */ ;
        }
        const publicGetter = publicPropertiesMap[key];
        let cssModule, globalProperties;
        if (publicGetter) {
            if (key === "$attrs") {
                (0, _reactivity.track)(instance, "get", key);
                markAttrsAccessed();
            } else if (key === "$slots") (0, _reactivity.track)(instance, "get", key);
            return publicGetter(instance);
        } else if (// css module (injected by vue-loader)
        (cssModule = type.__cssModules) && (cssModule = cssModule[key])) return cssModule;
        else if (ctx !== (0, _shared.EMPTY_OBJ) && (0, _shared.hasOwn)(ctx, key)) {
            accessCache[key] = 4 /* CONTEXT */ ;
            return ctx[key];
        } else if (// global properties
        globalProperties = appContext.config.globalProperties, (0, _shared.hasOwn)(globalProperties, key)) return globalProperties[key];
        else if (currentRenderingInstance && (!(0, _shared.isString)(key) || // #1091 avoid internal isRef/isVNode checks on component instance leading
        // to infinite warning loop
        key.indexOf("__v") !== 0)) {
            if (data !== (0, _shared.EMPTY_OBJ) && isReservedPrefix(key[0]) && (0, _shared.hasOwn)(data, key)) warn(`Property ${JSON.stringify(key)} must be accessed via $data because it starts with a reserved character ("$" or "_") and is not proxied on the render context.`);
            else if (instance === currentRenderingInstance) warn(`Property ${JSON.stringify(key)} was accessed during render but is not defined on instance.`);
        }
    },
    set ({ _: instance }, key, value1) {
        const { data, setupState, ctx } = instance;
        if (hasSetupBinding(setupState, key)) {
            setupState[key] = value1;
            return true;
        } else if ((0, setupState.__isScriptSetup) && (0, _shared.hasOwn)(setupState, key)) {
            warn(`Cannot mutate <script setup> binding "${key}" from Options API.`);
            return false;
        } else if (data !== (0, _shared.EMPTY_OBJ) && (0, _shared.hasOwn)(data, key)) {
            data[key] = value1;
            return true;
        } else if ((0, _shared.hasOwn)(instance.props, key)) {
            warn(`Attempting to mutate prop "${key}". Props are readonly.`);
            return false;
        }
        if (key[0] === "$" && key.slice(1) in instance) {
            warn(`Attempting to mutate public property "${key}". Properties starting with $ are reserved and readonly.`);
            return false;
        } else if (key in instance.appContext.config.globalProperties) Object.defineProperty(ctx, key, {
            enumerable: true,
            configurable: true,
            value: value1
        });
        else ctx[key] = value1;
        return true;
    },
    has ({ _: { data, setupState, accessCache, ctx, appContext, propsOptions } }, key) {
        let normalizedProps;
        return !!accessCache[key] || data !== (0, _shared.EMPTY_OBJ) && (0, _shared.hasOwn)(data, key) || hasSetupBinding(setupState, key) || (normalizedProps = propsOptions[0]) && (0, _shared.hasOwn)(normalizedProps, key) || (0, _shared.hasOwn)(ctx, key) || (0, _shared.hasOwn)(publicPropertiesMap, key) || (0, _shared.hasOwn)(appContext.config.globalProperties, key);
    },
    defineProperty (target, key, descriptor) {
        if (descriptor.get != null) target._.accessCache[key] = 0;
        else if ((0, _shared.hasOwn)(descriptor, "value")) this.set(target, key, descriptor.value, null);
        return Reflect.defineProperty(target, key, descriptor);
    }
};
PublicInstanceProxyHandlers.ownKeys = (target)=>{
    warn(`Avoid app logic that relies on enumerating keys on a component instance. The keys will be empty in production mode to avoid performance overhead.`);
    return Reflect.ownKeys(target);
};
const RuntimeCompiledPublicInstanceProxyHandlers = /* @__PURE__ */ (0, _shared.extend)({}, PublicInstanceProxyHandlers, {
    get (target, key) {
        if (key === Symbol.unscopables) return;
        return PublicInstanceProxyHandlers.get(target, key, target);
    },
    has (_, key) {
        const has = key[0] !== "_" && !(0, _shared.isGloballyWhitelisted)(key);
        if (!has && PublicInstanceProxyHandlers.has(_, key)) warn(`Property ${JSON.stringify(key)} should not start with _ which is a reserved prefix for Vue internals.`);
        return has;
    }
});
function createDevRenderContext(instance) {
    const target = {};
    Object.defineProperty(target, `_`, {
        configurable: true,
        enumerable: false,
        get: ()=>instance
    });
    Object.keys(publicPropertiesMap).forEach((key)=>{
        Object.defineProperty(target, key, {
            configurable: true,
            enumerable: false,
            get: ()=>publicPropertiesMap[key](instance),
            // intercepted by the proxy so no need for implementation,
            // but needed to prevent set errors
            set: (0, _shared.NOOP)
        });
    });
    return target;
}
function exposePropsOnRenderContext(instance) {
    const { ctx, propsOptions: [propsOptions] } = instance;
    if (propsOptions) Object.keys(propsOptions).forEach((key)=>{
        Object.defineProperty(ctx, key, {
            enumerable: true,
            configurable: true,
            get: ()=>instance.props[key],
            set: (0, _shared.NOOP)
        });
    });
}
function exposeSetupStateOnRenderContext(instance) {
    const { ctx, setupState } = instance;
    Object.keys((0, _reactivity.toRaw)(setupState)).forEach((key)=>{
        if (!setupState.__isScriptSetup) {
            if (isReservedPrefix(key[0])) {
                warn(`setup() return property ${JSON.stringify(key)} should not start with "$" or "_" which are reserved prefixes for Vue internals.`);
                return;
            }
            Object.defineProperty(ctx, key, {
                enumerable: true,
                configurable: true,
                get: ()=>setupState[key],
                set: (0, _shared.NOOP)
            });
        }
    });
}
const warnRuntimeUsage = (method)=>warn(`${method}() is a compiler-hint helper that is only usable inside <script setup> of a single file component. Its arguments should be compiled away and passing it at runtime has no effect.`);
function defineProps() {
    warnRuntimeUsage(`defineProps`);
    return null;
}
function defineEmits() {
    warnRuntimeUsage(`defineEmits`);
    return null;
}
function defineExpose(exposed) {
    warnRuntimeUsage(`defineExpose`);
}
function defineOptions(options) {
    warnRuntimeUsage(`defineOptions`);
}
function defineSlots() {
    warnRuntimeUsage(`defineSlots`);
    return null;
}
function defineModel() {
    warnRuntimeUsage("defineModel");
}
function withDefaults(props, defaults) {
    warnRuntimeUsage(`withDefaults`);
    return null;
}
function useSlots() {
    return getContext().slots;
}
function useAttrs() {
    return getContext().attrs;
}
function useModel(props, name, options) {
    const i = getCurrentInstance();
    if (!i) {
        warn(`useModel() called without active instance.`);
        return (0, _reactivity.ref)();
    }
    if (!i.propsOptions[0][name]) {
        warn(`useModel() called with prop "${name}" which is not declared.`);
        return (0, _reactivity.ref)();
    }
    if (options && options.local) {
        const proxy = (0, _reactivity.ref)(props[name]);
        watch(()=>props[name], (v1)=>proxy.value = v1);
        watch(proxy, (value1)=>{
            if (value1 !== props[name]) i.emit(`update:${name}`, value1);
        });
        return proxy;
    } else return {
        __v_isRef: true,
        get value () {
            return props[name];
        },
        set value (value){
            i.emit(`update:${name}`, value);
        }
    };
}
function getContext() {
    const i = getCurrentInstance();
    if (!i) warn(`useContext() called without active instance.`);
    return i.setupContext || (i.setupContext = createSetupContext(i));
}
function normalizePropsOrEmits(props) {
    return (0, _shared.isArray)(props) ? props.reduce((normalized, p)=>(normalized[p] = null, normalized), {}) : props;
}
function mergeDefaults(raw, defaults) {
    const props = normalizePropsOrEmits(raw);
    for(const key in defaults){
        if (key.startsWith("__skip")) continue;
        let opt = props[key];
        if (opt) {
            if ((0, _shared.isArray)(opt) || (0, _shared.isFunction)(opt)) opt = props[key] = {
                type: opt,
                default: defaults[key]
            };
            else opt.default = defaults[key];
        } else if (opt === null) opt = props[key] = {
            default: defaults[key]
        };
        else warn(`props default key "${key}" has no corresponding declaration.`);
        if (opt && defaults[`__skip_${key}`]) opt.skipFactory = true;
    }
    return props;
}
function mergeModels(a, b) {
    if (!a || !b) return a || b;
    if ((0, _shared.isArray)(a) && (0, _shared.isArray)(b)) return a.concat(b);
    return (0, _shared.extend)({}, normalizePropsOrEmits(a), normalizePropsOrEmits(b));
}
function createPropsRestProxy(props, excludedKeys) {
    const ret = {};
    for(const key in props)if (!excludedKeys.includes(key)) Object.defineProperty(ret, key, {
        enumerable: true,
        get: ()=>props[key]
    });
    return ret;
}
function withAsyncContext(getAwaitable) {
    const ctx = getCurrentInstance();
    if (!ctx) warn(`withAsyncContext called without active current instance. This is likely a bug.`);
    let awaitable = getAwaitable();
    unsetCurrentInstance();
    if ((0, _shared.isPromise)(awaitable)) awaitable = awaitable.catch((e)=>{
        setCurrentInstance(ctx);
        throw e;
    });
    return [
        awaitable,
        ()=>setCurrentInstance(ctx)
    ];
}
function createDuplicateChecker() {
    const cache = /* @__PURE__ */ Object.create(null);
    return (type, key)=>{
        if (cache[key]) warn(`${type} property "${key}" is already defined in ${cache[key]}.`);
        else cache[key] = type;
    };
}
let shouldCacheAccess = true;
function applyOptions(instance) {
    const options = resolveMergedOptions(instance);
    const publicThis = instance.proxy;
    const ctx = instance.ctx;
    shouldCacheAccess = false;
    if (options.beforeCreate) callHook(options.beforeCreate, instance, "bc");
    const { // state
    data: dataOptions, computed: computedOptions, methods, watch: watchOptions, provide: provideOptions, inject: injectOptions, // lifecycle
    created, beforeMount, mounted, beforeUpdate, updated, activated, deactivated, beforeDestroy, beforeUnmount, destroyed, unmounted, render, renderTracked, renderTriggered, errorCaptured, serverPrefetch, // public API
    expose, inheritAttrs, // assets
    components, directives, filters } = options;
    const checkDuplicateProperties = createDuplicateChecker();
    {
        const [propsOptions] = instance.propsOptions;
        if (propsOptions) for(const key in propsOptions)checkDuplicateProperties("Props" /* PROPS */ , key);
    }
    if (injectOptions) resolveInjections(injectOptions, ctx, checkDuplicateProperties);
    if (methods) for(const key in methods){
        const methodHandler = methods[key];
        if ((0, _shared.isFunction)(methodHandler)) {
            Object.defineProperty(ctx, key, {
                value: methodHandler.bind(publicThis),
                configurable: true,
                enumerable: true,
                writable: true
            });
            checkDuplicateProperties("Methods" /* METHODS */ , key);
        } else warn(`Method "${key}" has type "${typeof methodHandler}" in the component definition. Did you reference the function correctly?`);
    }
    if (dataOptions) {
        if (!(0, _shared.isFunction)(dataOptions)) warn(`The data option must be a function. Plain object usage is no longer supported.`);
        const data = dataOptions.call(publicThis, publicThis);
        if ((0, _shared.isPromise)(data)) warn(`data() returned a Promise - note data() cannot be async; If you intend to perform data fetching before component renders, use async setup() + <Suspense>.`);
        if (!(0, _shared.isObject)(data)) warn(`data() should return an object.`);
        else {
            instance.data = (0, _reactivity.reactive)(data);
            for(const key in data){
                checkDuplicateProperties("Data" /* DATA */ , key);
                if (!isReservedPrefix(key[0])) Object.defineProperty(ctx, key, {
                    configurable: true,
                    enumerable: true,
                    get: ()=>data[key],
                    set: (0, _shared.NOOP)
                });
            }
        }
    }
    shouldCacheAccess = true;
    if (computedOptions) for(const key in computedOptions){
        const opt = computedOptions[key];
        const get = (0, _shared.isFunction)(opt) ? opt.bind(publicThis, publicThis) : (0, _shared.isFunction)(opt.get) ? opt.get.bind(publicThis, publicThis) : (0, _shared.NOOP);
        if (get === (0, _shared.NOOP)) warn(`Computed property "${key}" has no getter.`);
        const set = !(0, _shared.isFunction)(opt) && (0, _shared.isFunction)(opt.set) ? opt.set.bind(publicThis) : ()=>{
            warn(`Write operation failed: computed property "${key}" is readonly.`);
        };
        const c = computed({
            get,
            set
        });
        Object.defineProperty(ctx, key, {
            enumerable: true,
            configurable: true,
            get: ()=>c.value,
            set: (v1)=>c.value = v1
        });
        checkDuplicateProperties("Computed" /* COMPUTED */ , key);
    }
    if (watchOptions) for(const key in watchOptions)createWatcher(watchOptions[key], ctx, publicThis, key);
    if (provideOptions) {
        const provides = (0, _shared.isFunction)(provideOptions) ? provideOptions.call(publicThis) : provideOptions;
        Reflect.ownKeys(provides).forEach((key)=>{
            provide(key, provides[key]);
        });
    }
    if (created) callHook(created, instance, "c");
    function registerLifecycleHook(register, hook) {
        if ((0, _shared.isArray)(hook)) hook.forEach((_hook)=>register(_hook.bind(publicThis)));
        else if (hook) register(hook.bind(publicThis));
    }
    registerLifecycleHook(onBeforeMount, beforeMount);
    registerLifecycleHook(onMounted, mounted);
    registerLifecycleHook(onBeforeUpdate, beforeUpdate);
    registerLifecycleHook(onUpdated, updated);
    registerLifecycleHook(onActivated, activated);
    registerLifecycleHook(onDeactivated, deactivated);
    registerLifecycleHook(onErrorCaptured, errorCaptured);
    registerLifecycleHook(onRenderTracked, renderTracked);
    registerLifecycleHook(onRenderTriggered, renderTriggered);
    registerLifecycleHook(onBeforeUnmount, beforeUnmount);
    registerLifecycleHook(onUnmounted, unmounted);
    registerLifecycleHook(onServerPrefetch, serverPrefetch);
    if ((0, _shared.isArray)(expose)) {
        if (expose.length) {
            const exposed = instance.exposed || (instance.exposed = {});
            expose.forEach((key)=>{
                Object.defineProperty(exposed, key, {
                    get: ()=>publicThis[key],
                    set: (val)=>publicThis[key] = val
                });
            });
        } else if (!instance.exposed) instance.exposed = {};
    }
    if (render && instance.render === (0, _shared.NOOP)) instance.render = render;
    if (inheritAttrs != null) instance.inheritAttrs = inheritAttrs;
    if (components) instance.components = components;
    if (directives) instance.directives = directives;
}
function resolveInjections(injectOptions, ctx, checkDuplicateProperties = (0, _shared.NOOP)) {
    if ((0, _shared.isArray)(injectOptions)) injectOptions = normalizeInject(injectOptions);
    for(const key in injectOptions){
        const opt = injectOptions[key];
        let injected;
        if ((0, _shared.isObject)(opt)) {
            if ("default" in opt) injected = inject(opt.from || key, opt.default, true);
            else injected = inject(opt.from || key);
        } else injected = inject(opt);
        if ((0, _reactivity.isRef)(injected)) Object.defineProperty(ctx, key, {
            enumerable: true,
            configurable: true,
            get: ()=>injected.value,
            set: (v1)=>injected.value = v1
        });
        else ctx[key] = injected;
        checkDuplicateProperties("Inject" /* INJECT */ , key);
    }
}
function callHook(hook, instance, type) {
    callWithAsyncErrorHandling((0, _shared.isArray)(hook) ? hook.map((h)=>h.bind(instance.proxy)) : hook.bind(instance.proxy), instance, type);
}
function createWatcher(raw, ctx, publicThis, key) {
    const getter = key.includes(".") ? createPathGetter(publicThis, key) : ()=>publicThis[key];
    if ((0, _shared.isString)(raw)) {
        const handler = ctx[raw];
        if ((0, _shared.isFunction)(handler)) watch(getter, handler);
        else warn(`Invalid watch handler specified by key "${raw}"`, handler);
    } else if ((0, _shared.isFunction)(raw)) watch(getter, raw.bind(publicThis));
    else if ((0, _shared.isObject)(raw)) {
        if ((0, _shared.isArray)(raw)) raw.forEach((r)=>createWatcher(r, ctx, publicThis, key));
        else {
            const handler = (0, _shared.isFunction)(raw.handler) ? raw.handler.bind(publicThis) : ctx[raw.handler];
            if ((0, _shared.isFunction)(handler)) watch(getter, handler, raw);
            else warn(`Invalid watch handler specified by key "${raw.handler}"`, handler);
        }
    } else warn(`Invalid watch option: "${key}"`, raw);
}
function resolveMergedOptions(instance) {
    const base = instance.type;
    const { mixins, extends: extendsOptions } = base;
    const { mixins: globalMixins, optionsCache: cache, config: { optionMergeStrategies } } = instance.appContext;
    const cached = cache.get(base);
    let resolved;
    if (cached) resolved = cached;
    else if (!globalMixins.length && !mixins && !extendsOptions) resolved = base;
    else {
        resolved = {};
        if (globalMixins.length) globalMixins.forEach((m)=>mergeOptions(resolved, m, optionMergeStrategies, true));
        mergeOptions(resolved, base, optionMergeStrategies);
    }
    if ((0, _shared.isObject)(base)) cache.set(base, resolved);
    return resolved;
}
function mergeOptions(to, from, strats, asMixin = false) {
    const { mixins, extends: extendsOptions } = from;
    if (extendsOptions) mergeOptions(to, extendsOptions, strats, true);
    if (mixins) mixins.forEach((m)=>mergeOptions(to, m, strats, true));
    for(const key in from)if (asMixin && key === "expose") warn(`"expose" option is ignored when declared in mixins or extends. It should only be declared in the base component itself.`);
    else {
        const strat = internalOptionMergeStrats[key] || strats && strats[key];
        to[key] = strat ? strat(to[key], from[key]) : from[key];
    }
    return to;
}
const internalOptionMergeStrats = {
    data: mergeDataFn,
    props: mergeEmitsOrPropsOptions,
    emits: mergeEmitsOrPropsOptions,
    // objects
    methods: mergeObjectOptions,
    computed: mergeObjectOptions,
    // lifecycle
    beforeCreate: mergeAsArray,
    created: mergeAsArray,
    beforeMount: mergeAsArray,
    mounted: mergeAsArray,
    beforeUpdate: mergeAsArray,
    updated: mergeAsArray,
    beforeDestroy: mergeAsArray,
    beforeUnmount: mergeAsArray,
    destroyed: mergeAsArray,
    unmounted: mergeAsArray,
    activated: mergeAsArray,
    deactivated: mergeAsArray,
    errorCaptured: mergeAsArray,
    serverPrefetch: mergeAsArray,
    // assets
    components: mergeObjectOptions,
    directives: mergeObjectOptions,
    // watch
    watch: mergeWatchOptions,
    // provide / inject
    provide: mergeDataFn,
    inject: mergeInject
};
function mergeDataFn(to, from) {
    if (!from) return to;
    if (!to) return from;
    return function mergedDataFn() {
        return (0, _shared.extend)((0, _shared.isFunction)(to) ? to.call(this, this) : to, (0, _shared.isFunction)(from) ? from.call(this, this) : from);
    };
}
function mergeInject(to, from) {
    return mergeObjectOptions(normalizeInject(to), normalizeInject(from));
}
function normalizeInject(raw) {
    if ((0, _shared.isArray)(raw)) {
        const res = {};
        for(let i = 0; i < raw.length; i++)res[raw[i]] = raw[i];
        return res;
    }
    return raw;
}
function mergeAsArray(to, from) {
    return to ? [
        ...new Set([].concat(to, from))
    ] : from;
}
function mergeObjectOptions(to, from) {
    return to ? (0, _shared.extend)(/* @__PURE__ */ Object.create(null), to, from) : from;
}
function mergeEmitsOrPropsOptions(to, from) {
    if (to) {
        if ((0, _shared.isArray)(to) && (0, _shared.isArray)(from)) return [
            .../* @__PURE__ */ new Set([
                ...to,
                ...from
            ])
        ];
        return (0, _shared.extend)(/* @__PURE__ */ Object.create(null), normalizePropsOrEmits(to), normalizePropsOrEmits(from != null ? from : {}));
    } else return from;
}
function mergeWatchOptions(to, from) {
    if (!to) return from;
    if (!from) return to;
    const merged = (0, _shared.extend)(/* @__PURE__ */ Object.create(null), to);
    for(const key in from)merged[key] = mergeAsArray(to[key], from[key]);
    return merged;
}
function createAppContext() {
    return {
        app: null,
        config: {
            isNativeTag: (0, _shared.NO),
            performance: false,
            globalProperties: {},
            optionMergeStrategies: {},
            errorHandler: void 0,
            warnHandler: void 0,
            compilerOptions: {}
        },
        mixins: [],
        components: {},
        directives: {},
        provides: /* @__PURE__ */ Object.create(null),
        optionsCache: /* @__PURE__ */ new WeakMap(),
        propsCache: /* @__PURE__ */ new WeakMap(),
        emitsCache: /* @__PURE__ */ new WeakMap()
    };
}
let uid$1 = 0;
function createAppAPI(render, hydrate) {
    return function createApp(rootComponent, rootProps = null) {
        if (!(0, _shared.isFunction)(rootComponent)) rootComponent = (0, _shared.extend)({}, rootComponent);
        if (rootProps != null && !(0, _shared.isObject)(rootProps)) {
            warn(`root props passed to app.mount() must be an object.`);
            rootProps = null;
        }
        const context = createAppContext();
        Object.defineProperty(context.config, "unwrapInjectedRef", {
            get () {
                return true;
            },
            set () {
                warn(`app.config.unwrapInjectedRef has been deprecated. 3.3 now alawys unwraps injected refs in Options API.`);
            }
        });
        const installedPlugins = /* @__PURE__ */ new Set();
        let isMounted = false;
        const app = context.app = {
            _uid: uid$1++,
            _component: rootComponent,
            _props: rootProps,
            _container: null,
            _context: context,
            _instance: null,
            version,
            get config () {
                return context.config;
            },
            set config (v){
                warn(`app.config cannot be replaced. Modify individual options instead.`);
            },
            use (plugin, ...options) {
                if (installedPlugins.has(plugin)) warn(`Plugin has already been applied to target app.`);
                else if (plugin && (0, _shared.isFunction)(plugin.install)) {
                    installedPlugins.add(plugin);
                    plugin.install(app, ...options);
                } else if ((0, _shared.isFunction)(plugin)) {
                    installedPlugins.add(plugin);
                    plugin(app, ...options);
                } else warn(`A plugin must either be a function or an object with an "install" function.`);
                return app;
            },
            mixin (mixin) {
                if (__VUE_OPTIONS_API__) {
                    if (!context.mixins.includes(mixin)) context.mixins.push(mixin);
                    else warn("Mixin has already been applied to target app" + (mixin.name ? `: ${mixin.name}` : ""));
                } else warn("Mixins are only available in builds supporting Options API");
                return app;
            },
            component (name, component) {
                validateComponentName(name, context.config);
                if (!component) return context.components[name];
                if (0, context.components[name]) warn(`Component "${name}" has already been registered in target app.`);
                context.components[name] = component;
                return app;
            },
            directive (name, directive) {
                validateDirectiveName(name);
                if (!directive) return context.directives[name];
                if (0, context.directives[name]) warn(`Directive "${name}" has already been registered in target app.`);
                context.directives[name] = directive;
                return app;
            },
            mount (rootContainer, isHydrate, isSVG) {
                if (!isMounted) {
                    if (0, rootContainer.__vue_app__) warn(`There is already an app instance mounted on the host container.
 If you want to mount another app on the same host container, you need to unmount the previous app by calling \`app.unmount()\` first.`);
                    const vnode = createVNode(rootComponent, rootProps);
                    vnode.appContext = context;
                    context.reload = ()=>{
                        render(cloneVNode(vnode), rootContainer, isSVG);
                    };
                    if (isHydrate && hydrate) hydrate(vnode, rootContainer);
                    else render(vnode, rootContainer, isSVG);
                    isMounted = true;
                    app._container = rootContainer;
                    rootContainer.__vue_app__ = app;
                    app._instance = vnode.component;
                    devtoolsInitApp(app, version);
                    return getExposeProxy(vnode.component) || vnode.component.proxy;
                } else warn(`App has already been mounted.
If you want to remount the same app, move your app creation logic into a factory function and create fresh app instances for each mount - e.g. \`const createMyApp = () => createApp(App)\``);
            },
            unmount () {
                if (isMounted) {
                    render(null, app._container);
                    app._instance = null;
                    devtoolsUnmountApp(app);
                    delete app._container.__vue_app__;
                } else warn(`Cannot unmount an app that is not mounted.`);
            },
            provide (key, value1) {
                if (key in context.provides) warn(`App already provides property with key "${String(key)}". It will be overwritten with the new value.`);
                context.provides[key] = value1;
                return app;
            },
            runWithContext (fn) {
                currentApp = app;
                try {
                    return fn();
                } finally{
                    currentApp = null;
                }
            }
        };
        return app;
    };
}
let currentApp = null;
function provide(key, value1) {
    if (!currentInstance) warn(`provide() can only be used inside setup().`);
    else {
        let provides = currentInstance.provides;
        const parentProvides = currentInstance.parent && currentInstance.parent.provides;
        if (parentProvides === provides) provides = currentInstance.provides = Object.create(parentProvides);
        provides[key] = value1;
    }
}
function inject(key, defaultValue, treatDefaultAsFactory = false) {
    const instance = currentInstance || currentRenderingInstance;
    if (instance || currentApp) {
        const provides = instance ? instance.parent == null ? instance.vnode.appContext && instance.vnode.appContext.provides : instance.parent.provides : currentApp._context.provides;
        if (provides && key in provides) return provides[key];
        else if (arguments.length > 1) return treatDefaultAsFactory && (0, _shared.isFunction)(defaultValue) ? defaultValue.call(instance && instance.proxy) : defaultValue;
        else warn(`injection "${String(key)}" not found.`);
    } else warn(`inject() can only be used inside setup() or functional components.`);
}
function hasInjectionContext() {
    return !!(currentInstance || currentRenderingInstance || currentApp);
}
function initProps(instance, rawProps, isStateful, isSSR = false) {
    const props = {};
    const attrs = {};
    (0, _shared.def)(attrs, InternalObjectKey, 1);
    instance.propsDefaults = /* @__PURE__ */ Object.create(null);
    setFullProps(instance, rawProps, props, attrs);
    for(const key in instance.propsOptions[0])if (!(key in props)) props[key] = void 0;
    validateProps(rawProps || {}, props, instance);
    if (isStateful) instance.props = isSSR ? props : (0, _reactivity.shallowReactive)(props);
    else if (!instance.type.props) instance.props = attrs;
    else instance.props = props;
    instance.attrs = attrs;
}
function isInHmrContext(instance) {
    while(instance){
        if (instance.type.__hmrId) return true;
        instance = instance.parent;
    }
}
function updateProps(instance, rawProps, rawPrevProps, optimized) {
    const { props, attrs, vnode: { patchFlag } } = instance;
    const rawCurrentProps = (0, _reactivity.toRaw)(props);
    const [options] = instance.propsOptions;
    let hasAttrsChanged = false;
    if (// always force full diff in dev
    // - #1942 if hmr is enabled with sfc component
    // - vite#872 non-sfc component used by sfc component
    !isInHmrContext(instance) && (optimized || patchFlag > 0) && !(patchFlag & 16)) {
        if (patchFlag & 8) {
            const propsToUpdate = instance.vnode.dynamicProps;
            for(let i = 0; i < propsToUpdate.length; i++){
                let key = propsToUpdate[i];
                if (isEmitListener(instance.emitsOptions, key)) continue;
                const value1 = rawProps[key];
                if (options) {
                    if ((0, _shared.hasOwn)(attrs, key)) {
                        if (value1 !== attrs[key]) {
                            attrs[key] = value1;
                            hasAttrsChanged = true;
                        }
                    } else {
                        const camelizedKey = (0, _shared.camelize)(key);
                        props[camelizedKey] = resolvePropValue(options, rawCurrentProps, camelizedKey, value1, instance, false);
                    }
                } else if (value1 !== attrs[key]) {
                    attrs[key] = value1;
                    hasAttrsChanged = true;
                }
            }
        }
    } else {
        if (setFullProps(instance, rawProps, props, attrs)) hasAttrsChanged = true;
        let kebabKey;
        for(const key in rawCurrentProps)if (!rawProps || // for camelCase
        !(0, _shared.hasOwn)(rawProps, key) && // it's possible the original props was passed in as kebab-case
        // and converted to camelCase (#955)
        ((kebabKey = (0, _shared.hyphenate)(key)) === key || !(0, _shared.hasOwn)(rawProps, kebabKey))) {
            if (options) {
                if (rawPrevProps && // for camelCase
                (rawPrevProps[key] !== void 0 || // for kebab-case
                rawPrevProps[kebabKey] !== void 0)) props[key] = resolvePropValue(options, rawCurrentProps, key, void 0, instance, true);
            } else delete props[key];
        }
        if (attrs !== rawCurrentProps) {
            for(const key in attrs)if (!rawProps || !(0, _shared.hasOwn)(rawProps, key) && true) {
                delete attrs[key];
                hasAttrsChanged = true;
            }
        }
    }
    if (hasAttrsChanged) (0, _reactivity.trigger)(instance, "set", "$attrs");
    validateProps(rawProps || {}, props, instance);
}
function setFullProps(instance, rawProps, props, attrs) {
    const [options, needCastKeys] = instance.propsOptions;
    let hasAttrsChanged = false;
    let rawCastValues;
    if (rawProps) for(let key in rawProps){
        if ((0, _shared.isReservedProp)(key)) continue;
        const value1 = rawProps[key];
        let camelKey;
        if (options && (0, _shared.hasOwn)(options, camelKey = (0, _shared.camelize)(key))) {
            if (!needCastKeys || !needCastKeys.includes(camelKey)) props[camelKey] = value1;
            else (rawCastValues || (rawCastValues = {}))[camelKey] = value1;
        } else if (!isEmitListener(instance.emitsOptions, key)) {
            if (!(key in attrs) || value1 !== attrs[key]) {
                attrs[key] = value1;
                hasAttrsChanged = true;
            }
        }
    }
    if (needCastKeys) {
        const rawCurrentProps = (0, _reactivity.toRaw)(props);
        const castValues = rawCastValues || (0, _shared.EMPTY_OBJ);
        for(let i = 0; i < needCastKeys.length; i++){
            const key = needCastKeys[i];
            props[key] = resolvePropValue(options, rawCurrentProps, key, castValues[key], instance, !(0, _shared.hasOwn)(castValues, key));
        }
    }
    return hasAttrsChanged;
}
function resolvePropValue(options, props, key, value1, instance, isAbsent) {
    const opt = options[key];
    if (opt != null) {
        const hasDefault = (0, _shared.hasOwn)(opt, "default");
        if (hasDefault && value1 === void 0) {
            const defaultValue = opt.default;
            if (opt.type !== Function && !opt.skipFactory && (0, _shared.isFunction)(defaultValue)) {
                const { propsDefaults } = instance;
                if (key in propsDefaults) value1 = propsDefaults[key];
                else {
                    setCurrentInstance(instance);
                    value1 = propsDefaults[key] = defaultValue.call(null, props);
                    unsetCurrentInstance();
                }
            } else value1 = defaultValue;
        }
        if (opt[0 /* shouldCast */ ]) {
            if (isAbsent && !hasDefault) value1 = false;
            else if (opt[1 /* shouldCastTrue */ ] && (value1 === "" || value1 === (0, _shared.hyphenate)(key))) value1 = true;
        }
    }
    return value1;
}
function normalizePropsOptions(comp, appContext, asMixin = false) {
    const cache = appContext.propsCache;
    const cached = cache.get(comp);
    if (cached) return cached;
    const raw = comp.props;
    const normalized = {};
    const needCastKeys = [];
    let hasExtends = false;
    if (__VUE_OPTIONS_API__ && !(0, _shared.isFunction)(comp)) {
        const extendProps = (raw2)=>{
            hasExtends = true;
            const [props, keys] = normalizePropsOptions(raw2, appContext, true);
            (0, _shared.extend)(normalized, props);
            if (keys) needCastKeys.push(...keys);
        };
        if (!asMixin && appContext.mixins.length) appContext.mixins.forEach(extendProps);
        if (comp.extends) extendProps(comp.extends);
        if (comp.mixins) comp.mixins.forEach(extendProps);
    }
    if (!raw && !hasExtends) {
        if ((0, _shared.isObject)(comp)) cache.set(comp, (0, _shared.EMPTY_ARR));
        return 0, _shared.EMPTY_ARR;
    }
    if ((0, _shared.isArray)(raw)) for(let i = 0; i < raw.length; i++){
        if (!(0, _shared.isString)(raw[i])) warn(`props must be strings when using array syntax.`, raw[i]);
        const normalizedKey = (0, _shared.camelize)(raw[i]);
        if (validatePropName(normalizedKey)) normalized[normalizedKey] = (0, _shared.EMPTY_OBJ);
    }
    else if (raw) {
        if (!(0, _shared.isObject)(raw)) warn(`invalid props options`, raw);
        for(const key in raw){
            const normalizedKey = (0, _shared.camelize)(key);
            if (validatePropName(normalizedKey)) {
                const opt = raw[key];
                const prop = normalized[normalizedKey] = (0, _shared.isArray)(opt) || (0, _shared.isFunction)(opt) ? {
                    type: opt
                } : (0, _shared.extend)({}, opt);
                if (prop) {
                    const booleanIndex = getTypeIndex(Boolean, prop.type);
                    const stringIndex = getTypeIndex(String, prop.type);
                    prop[0 /* shouldCast */ ] = booleanIndex > -1;
                    prop[1 /* shouldCastTrue */ ] = stringIndex < 0 || booleanIndex < stringIndex;
                    if (booleanIndex > -1 || (0, _shared.hasOwn)(prop, "default")) needCastKeys.push(normalizedKey);
                }
            }
        }
    }
    const res = [
        normalized,
        needCastKeys
    ];
    if ((0, _shared.isObject)(comp)) cache.set(comp, res);
    return res;
}
function validatePropName(key) {
    if (key[0] !== "$") return true;
    else warn(`Invalid prop name: "${key}" is a reserved property.`);
    return false;
}
function getType(ctor) {
    const match = ctor && ctor.toString().match(/^\s*(function|class) (\w+)/);
    return match ? match[2] : ctor === null ? "null" : "";
}
function isSameType(a, b) {
    return getType(a) === getType(b);
}
function getTypeIndex(type, expectedTypes) {
    if ((0, _shared.isArray)(expectedTypes)) return expectedTypes.findIndex((t)=>isSameType(t, type));
    else if ((0, _shared.isFunction)(expectedTypes)) return isSameType(expectedTypes, type) ? 0 : -1;
    return -1;
}
function validateProps(rawProps, props, instance) {
    const resolvedValues = (0, _reactivity.toRaw)(props);
    const options = instance.propsOptions[0];
    for(const key in options){
        let opt = options[key];
        if (opt == null) continue;
        validateProp(key, resolvedValues[key], opt, !(0, _shared.hasOwn)(rawProps, key) && !(0, _shared.hasOwn)(rawProps, (0, _shared.hyphenate)(key)));
    }
}
function validateProp(name, value1, prop, isAbsent) {
    const { type, required, validator, skipCheck } = prop;
    if (required && isAbsent) {
        warn('Missing required prop: "' + name + '"');
        return;
    }
    if (value1 == null && !required) return;
    if (type != null && type !== true && !skipCheck) {
        let isValid = false;
        const types = (0, _shared.isArray)(type) ? type : [
            type
        ];
        const expectedTypes = [];
        for(let i = 0; i < types.length && !isValid; i++){
            const { valid, expectedType } = assertType(value1, types[i]);
            expectedTypes.push(expectedType || "");
            isValid = valid;
        }
        if (!isValid) {
            warn(getInvalidTypeMessage(name, value1, expectedTypes));
            return;
        }
    }
    if (validator && !validator(value1)) warn('Invalid prop: custom validator check failed for prop "' + name + '".');
}
const isSimpleType = /* @__PURE__ */ (0, _shared.makeMap)("String,Number,Boolean,Function,Symbol,BigInt");
function assertType(value1, type) {
    let valid;
    const expectedType = getType(type);
    if (isSimpleType(expectedType)) {
        const t = typeof value1;
        valid = t === expectedType.toLowerCase();
        if (!valid && t === "object") valid = value1 instanceof type;
    } else if (expectedType === "Object") valid = (0, _shared.isObject)(value1);
    else if (expectedType === "Array") valid = (0, _shared.isArray)(value1);
    else if (expectedType === "null") valid = value1 === null;
    else valid = value1 instanceof type;
    return {
        valid,
        expectedType
    };
}
function getInvalidTypeMessage(name, value1, expectedTypes) {
    let message = `Invalid prop: type check failed for prop "${name}". Expected ${expectedTypes.map((0, _shared.capitalize)).join(" | ")}`;
    const expectedType = expectedTypes[0];
    const receivedType = (0, _shared.toRawType)(value1);
    const expectedValue = styleValue(value1, expectedType);
    const receivedValue = styleValue(value1, receivedType);
    if (expectedTypes.length === 1 && isExplicable(expectedType) && !isBoolean(expectedType, receivedType)) message += ` with value ${expectedValue}`;
    message += `, got ${receivedType} `;
    if (isExplicable(receivedType)) message += `with value ${receivedValue}.`;
    return message;
}
function styleValue(value1, type) {
    if (type === "String") return `"${value1}"`;
    else if (type === "Number") return `${Number(value1)}`;
    else return `${value1}`;
}
function isExplicable(type) {
    const explicitTypes = [
        "string",
        "number",
        "boolean"
    ];
    return explicitTypes.some((elem)=>type.toLowerCase() === elem);
}
function isBoolean(...args) {
    return args.some((elem)=>elem.toLowerCase() === "boolean");
}
const isInternalKey = (key)=>key[0] === "_" || key === "$stable";
const normalizeSlotValue = (value1)=>(0, _shared.isArray)(value1) ? value1.map(normalizeVNode) : [
        normalizeVNode(value1)
    ];
const normalizeSlot = (key, rawSlot, ctx)=>{
    if (rawSlot._n) return rawSlot;
    const normalized = withCtx((...args)=>{
        if (currentInstance) warn(`Slot "${key}" invoked outside of the render function: this will not track dependencies used in the slot. Invoke the slot function inside the render function instead.`);
        return normalizeSlotValue(rawSlot(...args));
    }, ctx);
    normalized._c = false;
    return normalized;
};
const normalizeObjectSlots = (rawSlots, slots, instance)=>{
    const ctx = rawSlots._ctx;
    for(const key in rawSlots){
        if (isInternalKey(key)) continue;
        const value1 = rawSlots[key];
        if ((0, _shared.isFunction)(value1)) slots[key] = normalizeSlot(key, value1, ctx);
        else if (value1 != null) {
            warn(`Non-function value encountered for slot "${key}". Prefer function slots for better performance.`);
            const normalized = normalizeSlotValue(value1);
            slots[key] = ()=>normalized;
        }
    }
};
const normalizeVNodeSlots = (instance, children)=>{
    if (!isKeepAlive(instance.vnode) && true) warn(`Non-function value encountered for default slot. Prefer function slots for better performance.`);
    const normalized = normalizeSlotValue(children);
    instance.slots.default = ()=>normalized;
};
const initSlots = (instance, children)=>{
    if (instance.vnode.shapeFlag & 32) {
        const type = children._;
        if (type) {
            instance.slots = (0, _reactivity.toRaw)(children);
            (0, _shared.def)(children, "_", type);
        } else normalizeObjectSlots(children, instance.slots = {});
    } else {
        instance.slots = {};
        if (children) normalizeVNodeSlots(instance, children);
    }
    (0, _shared.def)(instance.slots, InternalObjectKey, 1);
};
const updateSlots = (instance, children, optimized)=>{
    const { vnode, slots } = instance;
    let needDeletionCheck = true;
    let deletionComparisonTarget = (0, _shared.EMPTY_OBJ);
    if (vnode.shapeFlag & 32) {
        const type = children._;
        if (type) {
            if (isHmrUpdating) {
                (0, _shared.extend)(slots, children);
                (0, _reactivity.trigger)(instance, "set", "$slots");
            } else if (optimized && type === 1) needDeletionCheck = false;
            else {
                (0, _shared.extend)(slots, children);
                if (!optimized && type === 1) delete slots._;
            }
        } else {
            needDeletionCheck = !children.$stable;
            normalizeObjectSlots(children, slots);
        }
        deletionComparisonTarget = children;
    } else if (children) {
        normalizeVNodeSlots(instance, children);
        deletionComparisonTarget = {
            default: 1
        };
    }
    if (needDeletionCheck) {
        for(const key in slots)if (!isInternalKey(key) && !(key in deletionComparisonTarget)) delete slots[key];
    }
};
function setRef(rawRef, oldRawRef, parentSuspense, vnode, isUnmount = false) {
    if ((0, _shared.isArray)(rawRef)) {
        rawRef.forEach((r, i)=>setRef(r, oldRawRef && ((0, _shared.isArray)(oldRawRef) ? oldRawRef[i] : oldRawRef), parentSuspense, vnode, isUnmount));
        return;
    }
    if (isAsyncWrapper(vnode) && !isUnmount) return;
    const refValue = vnode.shapeFlag & 4 ? getExposeProxy(vnode.component) || vnode.component.proxy : vnode.el;
    const value1 = isUnmount ? null : refValue;
    const { i: owner, r: ref } = rawRef;
    if (!owner) {
        warn(`Missing ref owner context. ref cannot be used on hoisted vnodes. A vnode with ref must be created inside the render function.`);
        return;
    }
    const oldRef = oldRawRef && oldRawRef.r;
    const refs = owner.refs === (0, _shared.EMPTY_OBJ) ? owner.refs = {} : owner.refs;
    const setupState = owner.setupState;
    if (oldRef != null && oldRef !== ref) {
        if ((0, _shared.isString)(oldRef)) {
            refs[oldRef] = null;
            if ((0, _shared.hasOwn)(setupState, oldRef)) setupState[oldRef] = null;
        } else if ((0, _reactivity.isRef)(oldRef)) oldRef.value = null;
    }
    if ((0, _shared.isFunction)(ref)) callWithErrorHandling(ref, owner, 12, [
        value1,
        refs
    ]);
    else {
        const _isString = (0, _shared.isString)(ref);
        const _isRef = (0, _reactivity.isRef)(ref);
        if (_isString || _isRef) {
            const doSet = ()=>{
                if (rawRef.f) {
                    const existing = _isString ? (0, _shared.hasOwn)(setupState, ref) ? setupState[ref] : refs[ref] : ref.value;
                    if (isUnmount) (0, _shared.isArray)(existing) && (0, _shared.remove)(existing, refValue);
                    else {
                        if (!(0, _shared.isArray)(existing)) {
                            if (_isString) {
                                refs[ref] = [
                                    refValue
                                ];
                                if ((0, _shared.hasOwn)(setupState, ref)) setupState[ref] = refs[ref];
                            } else {
                                ref.value = [
                                    refValue
                                ];
                                if (rawRef.k) refs[rawRef.k] = ref.value;
                            }
                        } else if (!existing.includes(refValue)) existing.push(refValue);
                    }
                } else if (_isString) {
                    refs[ref] = value1;
                    if ((0, _shared.hasOwn)(setupState, ref)) setupState[ref] = value1;
                } else if (_isRef) {
                    ref.value = value1;
                    if (rawRef.k) refs[rawRef.k] = value1;
                } else warn("Invalid template ref type:", ref, `(${typeof ref})`);
            };
            if (value1) {
                doSet.id = -1;
                queuePostRenderEffect(doSet, parentSuspense);
            } else doSet();
        } else warn("Invalid template ref type:", ref, `(${typeof ref})`);
    }
}
let hasMismatch = false;
const isSVGContainer = (container)=>/svg/.test(container.namespaceURI) && container.tagName !== "foreignObject";
const isComment = (node)=>node.nodeType === 8 /* COMMENT */ ;
function createHydrationFunctions(rendererInternals) {
    const { mt: mountComponent, p: patch, o: { patchProp, createText, nextSibling, parentNode, remove, insert, createComment } } = rendererInternals;
    const hydrate = (vnode, container)=>{
        if (!container.hasChildNodes()) {
            warn(`Attempting to hydrate existing markup but container is empty. Performing full mount instead.`);
            patch(null, vnode, container);
            flushPostFlushCbs();
            container._vnode = vnode;
            return;
        }
        hasMismatch = false;
        hydrateNode(container.firstChild, vnode, null, null, null);
        flushPostFlushCbs();
        container._vnode = vnode;
        if (hasMismatch && true) console.error(`Hydration completed but contains mismatches.`);
    };
    const hydrateNode = (node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized = false)=>{
        const isFragmentStart = isComment(node) && node.data === "[";
        const onMismatch = ()=>handleMismatch(node, vnode, parentComponent, parentSuspense, slotScopeIds, isFragmentStart);
        const { type, ref, shapeFlag, patchFlag } = vnode;
        let domType = node.nodeType;
        vnode.el = node;
        if (patchFlag === -2) {
            optimized = false;
            vnode.dynamicChildren = null;
        }
        let nextNode = null;
        switch(type){
            case Text:
                if (domType !== 3 /* TEXT */ ) {
                    if (vnode.children === "") {
                        insert(vnode.el = createText(""), parentNode(node), node);
                        nextNode = node;
                    } else nextNode = onMismatch();
                } else {
                    if (node.data !== vnode.children) {
                        hasMismatch = true;
                        warn(`Hydration text mismatch:
- Client: ${JSON.stringify(node.data)}
- Server: ${JSON.stringify(vnode.children)}`);
                        node.data = vnode.children;
                    }
                    nextNode = nextSibling(node);
                }
                break;
            case Comment:
                if (domType !== 8 /* COMMENT */  || isFragmentStart) nextNode = onMismatch();
                else nextNode = nextSibling(node);
                break;
            case Static:
                if (isFragmentStart) {
                    node = nextSibling(node);
                    domType = node.nodeType;
                }
                if (domType === 1 /* ELEMENT */  || domType === 3 /* TEXT */ ) {
                    nextNode = node;
                    const needToAdoptContent = !vnode.children.length;
                    for(let i = 0; i < vnode.staticCount; i++){
                        if (needToAdoptContent) vnode.children += nextNode.nodeType === 1 /* ELEMENT */  ? nextNode.outerHTML : nextNode.data;
                        if (i === vnode.staticCount - 1) vnode.anchor = nextNode;
                        nextNode = nextSibling(nextNode);
                    }
                    return isFragmentStart ? nextSibling(nextNode) : nextNode;
                } else onMismatch();
                break;
            case Fragment:
                if (!isFragmentStart) nextNode = onMismatch();
                else nextNode = hydrateFragment(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized);
                break;
            default:
                if (shapeFlag & 1) {
                    if (domType !== 1 /* ELEMENT */  || vnode.type.toLowerCase() !== node.tagName.toLowerCase()) nextNode = onMismatch();
                    else nextNode = hydrateElement(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized);
                } else if (shapeFlag & 6) {
                    vnode.slotScopeIds = slotScopeIds;
                    const container = parentNode(node);
                    mountComponent(vnode, container, null, parentComponent, parentSuspense, isSVGContainer(container), optimized);
                    nextNode = isFragmentStart ? locateClosingAsyncAnchor(node) : nextSibling(node);
                    if (nextNode && isComment(nextNode) && nextNode.data === "teleport end") nextNode = nextSibling(nextNode);
                    if (isAsyncWrapper(vnode)) {
                        let subTree;
                        if (isFragmentStart) {
                            subTree = createVNode(Fragment);
                            subTree.anchor = nextNode ? nextNode.previousSibling : container.lastChild;
                        } else subTree = node.nodeType === 3 ? createTextVNode("") : createVNode("div");
                        subTree.el = node;
                        vnode.component.subTree = subTree;
                    }
                } else if (shapeFlag & 64) {
                    if (domType !== 8 /* COMMENT */ ) nextNode = onMismatch();
                    else nextNode = vnode.type.hydrate(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, rendererInternals, hydrateChildren);
                } else if (shapeFlag & 128) nextNode = vnode.type.hydrate(node, vnode, parentComponent, parentSuspense, isSVGContainer(parentNode(node)), slotScopeIds, optimized, rendererInternals, hydrateNode);
                else warn("Invalid HostVNode type:", type, `(${typeof type})`);
        }
        if (ref != null) setRef(ref, null, parentSuspense, vnode);
        return nextNode;
    };
    const hydrateElement = (el, vnode, parentComponent, parentSuspense, slotScopeIds, optimized)=>{
        optimized = optimized || !!vnode.dynamicChildren;
        const { type, props, patchFlag, shapeFlag, dirs } = vnode;
        const forcePatchValue = type === "input" && dirs || type === "option";
        {
            if (dirs) invokeDirectiveHook(vnode, null, parentComponent, "created");
            if (props) {
                if (forcePatchValue || !optimized || patchFlag & 48) {
                    for(const key in props)if (forcePatchValue && key.endsWith("value") || (0, _shared.isOn)(key) && !(0, _shared.isReservedProp)(key)) patchProp(el, key, null, props[key], false, void 0, parentComponent);
                } else if (props.onClick) patchProp(el, "onClick", null, props.onClick, false, void 0, parentComponent);
            }
            let vnodeHooks;
            if (vnodeHooks = props && props.onVnodeBeforeMount) invokeVNodeHook(vnodeHooks, parentComponent, vnode);
            if (dirs) invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
            if ((vnodeHooks = props && props.onVnodeMounted) || dirs) queueEffectWithSuspense(()=>{
                vnodeHooks && invokeVNodeHook(vnodeHooks, parentComponent, vnode);
                dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
            }, parentSuspense);
            if (shapeFlag & 16 && // skip if element has innerHTML / textContent
            !(props && (props.innerHTML || props.textContent))) {
                let next = hydrateChildren(el.firstChild, vnode, el, parentComponent, parentSuspense, slotScopeIds, optimized);
                let hasWarned = false;
                while(next){
                    hasMismatch = true;
                    if (!hasWarned) {
                        warn(`Hydration children mismatch in <${vnode.type}>: server rendered element contains more child nodes than client vdom.`);
                        hasWarned = true;
                    }
                    const cur = next;
                    next = next.nextSibling;
                    remove(cur);
                }
            } else if (shapeFlag & 8) {
                if (el.textContent !== vnode.children) {
                    hasMismatch = true;
                    warn(`Hydration text content mismatch in <${vnode.type}>:
- Client: ${el.textContent}
- Server: ${vnode.children}`);
                    el.textContent = vnode.children;
                }
            }
        }
        return el.nextSibling;
    };
    const hydrateChildren = (node, parentVNode, container, parentComponent, parentSuspense, slotScopeIds, optimized)=>{
        optimized = optimized || !!parentVNode.dynamicChildren;
        const children = parentVNode.children;
        const l = children.length;
        let hasWarned = false;
        for(let i = 0; i < l; i++){
            const vnode = optimized ? children[i] : children[i] = normalizeVNode(children[i]);
            if (node) node = hydrateNode(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized);
            else if (vnode.type === Text && !vnode.children) continue;
            else {
                hasMismatch = true;
                if (!hasWarned) {
                    warn(`Hydration children mismatch in <${container.tagName.toLowerCase()}>: server rendered element contains fewer child nodes than client vdom.`);
                    hasWarned = true;
                }
                patch(null, vnode, container, null, parentComponent, parentSuspense, isSVGContainer(container), slotScopeIds);
            }
        }
        return node;
    };
    const hydrateFragment = (node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized)=>{
        const { slotScopeIds: fragmentSlotScopeIds } = vnode;
        if (fragmentSlotScopeIds) slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
        const container = parentNode(node);
        const next = hydrateChildren(nextSibling(node), vnode, container, parentComponent, parentSuspense, slotScopeIds, optimized);
        if (next && isComment(next) && next.data === "]") return nextSibling(vnode.anchor = next);
        else {
            hasMismatch = true;
            insert(vnode.anchor = createComment(`]`), container, next);
            return next;
        }
    };
    const handleMismatch = (node, vnode, parentComponent, parentSuspense, slotScopeIds, isFragment)=>{
        hasMismatch = true;
        warn(`Hydration node mismatch:
- Client vnode:`, vnode.type, `
- Server rendered DOM:`, node, node.nodeType === 3 /* TEXT */  ? `(text)` : isComment(node) && node.data === "[" ? `(start of fragment)` : ``);
        vnode.el = null;
        if (isFragment) {
            const end = locateClosingAsyncAnchor(node);
            while(true){
                const next2 = nextSibling(node);
                if (next2 && next2 !== end) remove(next2);
                else break;
            }
        }
        const next = nextSibling(node);
        const container = parentNode(node);
        remove(node);
        patch(null, vnode, container, next, parentComponent, parentSuspense, isSVGContainer(container), slotScopeIds);
        return next;
    };
    const locateClosingAsyncAnchor = (node)=>{
        let match = 0;
        while(node){
            node = nextSibling(node);
            if (node && isComment(node)) {
                if (node.data === "[") match++;
                if (node.data === "]") {
                    if (match === 0) return nextSibling(node);
                    else match--;
                }
            }
        }
        return node;
    };
    return [
        hydrate,
        hydrateNode
    ];
}
let supported;
let perf;
function startMeasure(instance, type) {
    if (instance.appContext.config.performance && isSupported()) perf.mark(`vue-${type}-${instance.uid}`);
    devtoolsPerfStart(instance, type, isSupported() ? perf.now() : Date.now());
}
function endMeasure(instance, type) {
    if (instance.appContext.config.performance && isSupported()) {
        const startTag = `vue-${type}-${instance.uid}`;
        const endTag = startTag + `:end`;
        perf.mark(endTag);
        perf.measure(`<${formatComponentName(instance, instance.type)}> ${type}`, startTag, endTag);
        perf.clearMarks(startTag);
        perf.clearMarks(endTag);
    }
    devtoolsPerfEnd(instance, type, isSupported() ? perf.now() : Date.now());
}
function isSupported() {
    if (supported !== void 0) return supported;
    if (typeof window !== "undefined" && window.performance) {
        supported = true;
        perf = window.performance;
    } else supported = false;
    return supported;
}
function initFeatureFlags() {
    const needWarn = [];
    if (typeof __VUE_OPTIONS_API__ !== "boolean") {
        needWarn.push(`__VUE_OPTIONS_API__`);
        (0, _shared.getGlobalThis)().__VUE_OPTIONS_API__ = true;
    }
    if (typeof __VUE_PROD_DEVTOOLS__ !== "boolean") {
        needWarn.push(`__VUE_PROD_DEVTOOLS__`);
        (0, _shared.getGlobalThis)().__VUE_PROD_DEVTOOLS__ = false;
    }
    if (0, needWarn.length) {
        const multi = needWarn.length > 1;
        console.warn(`Feature flag${multi ? `s` : ``} ${needWarn.join(", ")} ${multi ? `are` : `is`} not explicitly defined. You are running the esm-bundler build of Vue, which expects these compile-time feature flags to be globally injected via the bundler config in order to get better tree-shaking in the production bundle.

For more details, see https://link.vuejs.org/feature-flags.`);
    }
}
const queuePostRenderEffect = queueEffectWithSuspense;
function createRenderer(options) {
    return baseCreateRenderer(options);
}
function createHydrationRenderer(options) {
    return baseCreateRenderer(options, createHydrationFunctions);
}
function baseCreateRenderer(options, createHydrationFns) {
    initFeatureFlags();
    const target = (0, _shared.getGlobalThis)();
    target.__VUE__ = true;
    setDevtoolsHook(target.__VUE_DEVTOOLS_GLOBAL_HOOK__, target);
    const { insert: hostInsert, remove: hostRemove, patchProp: hostPatchProp, createElement: hostCreateElement, createText: hostCreateText, createComment: hostCreateComment, setText: hostSetText, setElementText: hostSetElementText, parentNode: hostParentNode, nextSibling: hostNextSibling, setScopeId: hostSetScopeId = (0, _shared.NOOP), insertStaticContent: hostInsertStaticContent } = options;
    const patch = (n1, n2, container, anchor = null, parentComponent = null, parentSuspense = null, isSVG = false, slotScopeIds = null, optimized = isHmrUpdating ? false : !!n2.dynamicChildren)=>{
        if (n1 === n2) return;
        if (n1 && !isSameVNodeType(n1, n2)) {
            anchor = getNextHostNode(n1);
            unmount(n1, parentComponent, parentSuspense, true);
            n1 = null;
        }
        if (n2.patchFlag === -2) {
            optimized = false;
            n2.dynamicChildren = null;
        }
        const { type, ref, shapeFlag } = n2;
        switch(type){
            case Text:
                processText(n1, n2, container, anchor);
                break;
            case Comment:
                processCommentNode(n1, n2, container, anchor);
                break;
            case Static:
                if (n1 == null) mountStaticNode(n2, container, anchor, isSVG);
                else patchStaticNode(n1, n2, container, isSVG);
                break;
            case Fragment:
                processFragment(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
                break;
            default:
                if (shapeFlag & 1) processElement(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
                else if (shapeFlag & 6) processComponent(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
                else if (shapeFlag & 64) type.process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals);
                else if (shapeFlag & 128) type.process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals);
                else warn("Invalid VNode type:", type, `(${typeof type})`);
        }
        if (ref != null && parentComponent) setRef(ref, n1 && n1.ref, parentSuspense, n2 || n1, !n2);
    };
    const processText = (n1, n2, container, anchor)=>{
        if (n1 == null) hostInsert(n2.el = hostCreateText(n2.children), container, anchor);
        else {
            const el = n2.el = n1.el;
            if (n2.children !== n1.children) hostSetText(el, n2.children);
        }
    };
    const processCommentNode = (n1, n2, container, anchor)=>{
        if (n1 == null) hostInsert(n2.el = hostCreateComment(n2.children || ""), container, anchor);
        else n2.el = n1.el;
    };
    const mountStaticNode = (n2, container, anchor, isSVG)=>{
        [n2.el, n2.anchor] = hostInsertStaticContent(n2.children, container, anchor, isSVG, n2.el, n2.anchor);
    };
    const patchStaticNode = (n1, n2, container, isSVG)=>{
        if (n2.children !== n1.children) {
            const anchor = hostNextSibling(n1.anchor);
            removeStaticNode(n1);
            [n2.el, n2.anchor] = hostInsertStaticContent(n2.children, container, anchor, isSVG);
        } else {
            n2.el = n1.el;
            n2.anchor = n1.anchor;
        }
    };
    const moveStaticNode = ({ el, anchor }, container, nextSibling)=>{
        let next;
        while(el && el !== anchor){
            next = hostNextSibling(el);
            hostInsert(el, container, nextSibling);
            el = next;
        }
        hostInsert(anchor, container, nextSibling);
    };
    const removeStaticNode = ({ el, anchor })=>{
        let next;
        while(el && el !== anchor){
            next = hostNextSibling(el);
            hostRemove(el);
            el = next;
        }
        hostRemove(anchor);
    };
    const processElement = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized)=>{
        isSVG = isSVG || n2.type === "svg";
        if (n1 == null) mountElement(n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        else patchElement(n1, n2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
    };
    const mountElement = (vnode, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized)=>{
        let el;
        let vnodeHook;
        const { type, props, shapeFlag, transition, dirs } = vnode;
        el = vnode.el = hostCreateElement(vnode.type, isSVG, props && props.is, props);
        if (shapeFlag & 8) hostSetElementText(el, vnode.children);
        else if (shapeFlag & 16) mountChildren(vnode.children, el, null, parentComponent, parentSuspense, isSVG && type !== "foreignObject", slotScopeIds, optimized);
        if (dirs) invokeDirectiveHook(vnode, null, parentComponent, "created");
        setScopeId(el, vnode, vnode.scopeId, slotScopeIds, parentComponent);
        if (props) {
            for(const key in props)if (key !== "value" && !(0, _shared.isReservedProp)(key)) hostPatchProp(el, key, null, props[key], isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);
            if ("value" in props) hostPatchProp(el, "value", null, props.value);
            if (vnodeHook = props.onVnodeBeforeMount) invokeVNodeHook(vnodeHook, parentComponent, vnode);
        }
        Object.defineProperty(el, "__vnode", {
            value: vnode,
            enumerable: false
        });
        Object.defineProperty(el, "__vueParentComponent", {
            value: parentComponent,
            enumerable: false
        });
        if (dirs) invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
        const needCallTransitionHooks = (!parentSuspense || parentSuspense && !parentSuspense.pendingBranch) && transition && !transition.persisted;
        if (needCallTransitionHooks) transition.beforeEnter(el);
        hostInsert(el, container, anchor);
        if ((vnodeHook = props && props.onVnodeMounted) || needCallTransitionHooks || dirs) queuePostRenderEffect(()=>{
            vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
            needCallTransitionHooks && transition.enter(el);
            dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
        }, parentSuspense);
    };
    const setScopeId = (el, vnode, scopeId, slotScopeIds, parentComponent)=>{
        if (scopeId) hostSetScopeId(el, scopeId);
        if (slotScopeIds) for(let i = 0; i < slotScopeIds.length; i++)hostSetScopeId(el, slotScopeIds[i]);
        if (parentComponent) {
            let subTree = parentComponent.subTree;
            if (subTree.patchFlag > 0 && subTree.patchFlag & 2048) subTree = filterSingleRoot(subTree.children) || subTree;
            if (vnode === subTree) {
                const parentVNode = parentComponent.vnode;
                setScopeId(el, parentVNode, parentVNode.scopeId, parentVNode.slotScopeIds, parentComponent.parent);
            }
        }
    };
    const mountChildren = (children, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, start = 0)=>{
        for(let i = start; i < children.length; i++){
            const child = children[i] = optimized ? cloneIfMounted(children[i]) : normalizeVNode(children[i]);
            patch(null, child, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        }
    };
    const patchElement = (n1, n2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized)=>{
        const el = n2.el = n1.el;
        let { patchFlag, dynamicChildren, dirs } = n2;
        patchFlag |= n1.patchFlag & 16;
        const oldProps = n1.props || (0, _shared.EMPTY_OBJ);
        const newProps = n2.props || (0, _shared.EMPTY_OBJ);
        let vnodeHook;
        parentComponent && toggleRecurse(parentComponent, false);
        if (vnodeHook = newProps.onVnodeBeforeUpdate) invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
        if (dirs) invokeDirectiveHook(n2, n1, parentComponent, "beforeUpdate");
        parentComponent && toggleRecurse(parentComponent, true);
        if (isHmrUpdating) {
            patchFlag = 0;
            optimized = false;
            dynamicChildren = null;
        }
        const areChildrenSVG = isSVG && n2.type !== "foreignObject";
        if (dynamicChildren) {
            patchBlockChildren(n1.dynamicChildren, dynamicChildren, el, parentComponent, parentSuspense, areChildrenSVG, slotScopeIds);
            traverseStaticChildren(n1, n2);
        } else if (!optimized) patchChildren(n1, n2, el, null, parentComponent, parentSuspense, areChildrenSVG, slotScopeIds, false);
        if (patchFlag > 0) {
            if (patchFlag & 16) patchProps(el, n2, oldProps, newProps, parentComponent, parentSuspense, isSVG);
            else {
                if (patchFlag & 2) {
                    if (oldProps.class !== newProps.class) hostPatchProp(el, "class", null, newProps.class, isSVG);
                }
                if (patchFlag & 4) hostPatchProp(el, "style", oldProps.style, newProps.style, isSVG);
                if (patchFlag & 8) {
                    const propsToUpdate = n2.dynamicProps;
                    for(let i = 0; i < propsToUpdate.length; i++){
                        const key = propsToUpdate[i];
                        const prev = oldProps[key];
                        const next = newProps[key];
                        if (next !== prev || key === "value") hostPatchProp(el, key, prev, next, isSVG, n1.children, parentComponent, parentSuspense, unmountChildren);
                    }
                }
            }
            if (patchFlag & 1) {
                if (n1.children !== n2.children) hostSetElementText(el, n2.children);
            }
        } else if (!optimized && dynamicChildren == null) patchProps(el, n2, oldProps, newProps, parentComponent, parentSuspense, isSVG);
        if ((vnodeHook = newProps.onVnodeUpdated) || dirs) queuePostRenderEffect(()=>{
            vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
            dirs && invokeDirectiveHook(n2, n1, parentComponent, "updated");
        }, parentSuspense);
    };
    const patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, isSVG, slotScopeIds)=>{
        for(let i = 0; i < newChildren.length; i++){
            const oldVNode = oldChildren[i];
            const newVNode = newChildren[i];
            const container = // oldVNode may be an errored async setup() component inside Suspense
            // which will not have a mounted element
            oldVNode.el && // - In the case of a Fragment, we need to provide the actual parent
            // of the Fragment itself so it can move its children.
            (oldVNode.type === Fragment || // - In the case of different nodes, there is going to be a replacement
            // which also requires the correct parent container
            !isSameVNodeType(oldVNode, newVNode) || // - In the case of a component, it could contain anything.
            oldVNode.shapeFlag & 70) ? hostParentNode(oldVNode.el) : // In other cases, the parent container is not actually used so we
            // just pass the block element here to avoid a DOM parentNode call.
            fallbackContainer;
            patch(oldVNode, newVNode, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, true);
        }
    };
    const patchProps = (el, vnode, oldProps, newProps, parentComponent, parentSuspense, isSVG)=>{
        if (oldProps !== newProps) {
            if (oldProps !== (0, _shared.EMPTY_OBJ)) {
                for(const key in oldProps)if (!(0, _shared.isReservedProp)(key) && !(key in newProps)) hostPatchProp(el, key, oldProps[key], null, isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);
            }
            for(const key in newProps){
                if ((0, _shared.isReservedProp)(key)) continue;
                const next = newProps[key];
                const prev = oldProps[key];
                if (next !== prev && key !== "value") hostPatchProp(el, key, prev, next, isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);
            }
            if ("value" in newProps) hostPatchProp(el, "value", oldProps.value, newProps.value);
        }
    };
    const processFragment = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized)=>{
        const fragmentStartAnchor = n2.el = n1 ? n1.el : hostCreateText("");
        const fragmentEndAnchor = n2.anchor = n1 ? n1.anchor : hostCreateText("");
        let { patchFlag, dynamicChildren, slotScopeIds: fragmentSlotScopeIds } = n2;
        if (// #5523 dev root fragment may inherit directives
        isHmrUpdating || patchFlag & 2048) {
            patchFlag = 0;
            optimized = false;
            dynamicChildren = null;
        }
        if (fragmentSlotScopeIds) slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
        if (n1 == null) {
            hostInsert(fragmentStartAnchor, container, anchor);
            hostInsert(fragmentEndAnchor, container, anchor);
            mountChildren(n2.children, container, fragmentEndAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        } else if (patchFlag > 0 && patchFlag & 64 && dynamicChildren && // #2715 the previous fragment could've been a BAILed one as a result
        // of renderSlot() with no valid children
        n1.dynamicChildren) {
            patchBlockChildren(n1.dynamicChildren, dynamicChildren, container, parentComponent, parentSuspense, isSVG, slotScopeIds);
            traverseStaticChildren(n1, n2);
        } else patchChildren(n1, n2, container, fragmentEndAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
    };
    const processComponent = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized)=>{
        n2.slotScopeIds = slotScopeIds;
        if (n1 == null) {
            if (n2.shapeFlag & 512) parentComponent.ctx.activate(n2, container, anchor, isSVG, optimized);
            else mountComponent(n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized);
        } else updateComponent(n1, n2, optimized);
    };
    const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, isSVG, optimized)=>{
        const instance = initialVNode.component = createComponentInstance(initialVNode, parentComponent, parentSuspense);
        if (0, instance.type.__hmrId) registerHMR(instance);
        pushWarningContext(initialVNode);
        startMeasure(instance, `mount`);
        if (isKeepAlive(initialVNode)) instance.ctx.renderer = internals;
        startMeasure(instance, `init`);
        setupComponent(instance);
        endMeasure(instance, `init`);
        if (instance.asyncDep) {
            parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect);
            if (!initialVNode.el) {
                const placeholder = instance.subTree = createVNode(Comment);
                processCommentNode(null, placeholder, container, anchor);
            }
            return;
        }
        setupRenderEffect(instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized);
        popWarningContext();
        endMeasure(instance, `mount`);
    };
    const updateComponent = (n1, n2, optimized)=>{
        const instance = n2.component = n1.component;
        if (shouldUpdateComponent(n1, n2, optimized)) {
            if (instance.asyncDep && !instance.asyncResolved) {
                pushWarningContext(n2);
                updateComponentPreRender(instance, n2, optimized);
                popWarningContext();
                return;
            } else {
                instance.next = n2;
                invalidateJob(instance.update);
                instance.update();
            }
        } else {
            n2.el = n1.el;
            instance.vnode = n2;
        }
    };
    const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized)=>{
        const componentUpdateFn = ()=>{
            if (!instance.isMounted) {
                let vnodeHook;
                const { el, props } = initialVNode;
                const { bm, m, parent } = instance;
                const isAsyncWrapperVNode = isAsyncWrapper(initialVNode);
                toggleRecurse(instance, false);
                if (bm) (0, _shared.invokeArrayFns)(bm);
                if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeBeforeMount)) invokeVNodeHook(vnodeHook, parent, initialVNode);
                toggleRecurse(instance, true);
                if (el && hydrateNode) {
                    const hydrateSubTree = ()=>{
                        startMeasure(instance, `render`);
                        instance.subTree = renderComponentRoot(instance);
                        endMeasure(instance, `render`);
                        startMeasure(instance, `hydrate`);
                        hydrateNode(el, instance.subTree, instance, parentSuspense, null);
                        endMeasure(instance, `hydrate`);
                    };
                    if (isAsyncWrapperVNode) initialVNode.type.__asyncLoader().then(// note: we are moving the render call into an async callback,
                    // which means it won't track dependencies - but it's ok because
                    // a server-rendered async wrapper is already in resolved state
                    // and it will never need to change.
                    ()=>!instance.isUnmounted && hydrateSubTree());
                    else hydrateSubTree();
                } else {
                    startMeasure(instance, `render`);
                    const subTree = instance.subTree = renderComponentRoot(instance);
                    endMeasure(instance, `render`);
                    startMeasure(instance, `patch`);
                    patch(null, subTree, container, anchor, instance, parentSuspense, isSVG);
                    endMeasure(instance, `patch`);
                    initialVNode.el = subTree.el;
                }
                if (m) queuePostRenderEffect(m, parentSuspense);
                if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeMounted)) {
                    const scopedInitialVNode = initialVNode;
                    queuePostRenderEffect(()=>invokeVNodeHook(vnodeHook, parent, scopedInitialVNode), parentSuspense);
                }
                if (initialVNode.shapeFlag & 256 || parent && isAsyncWrapper(parent.vnode) && parent.vnode.shapeFlag & 256) instance.a && queuePostRenderEffect(instance.a, parentSuspense);
                instance.isMounted = true;
                devtoolsComponentAdded(instance);
                initialVNode = container = anchor = null;
            } else {
                let { next, bu, u, parent, vnode } = instance;
                let originNext = next;
                let vnodeHook;
                pushWarningContext(next || instance.vnode);
                toggleRecurse(instance, false);
                if (next) {
                    next.el = vnode.el;
                    updateComponentPreRender(instance, next, optimized);
                } else next = vnode;
                if (bu) (0, _shared.invokeArrayFns)(bu);
                if (vnodeHook = next.props && next.props.onVnodeBeforeUpdate) invokeVNodeHook(vnodeHook, parent, next, vnode);
                toggleRecurse(instance, true);
                startMeasure(instance, `render`);
                const nextTree = renderComponentRoot(instance);
                endMeasure(instance, `render`);
                const prevTree = instance.subTree;
                instance.subTree = nextTree;
                startMeasure(instance, `patch`);
                patch(prevTree, nextTree, // parent may have changed if it's in a teleport
                hostParentNode(prevTree.el), // anchor may have changed if it's in a fragment
                getNextHostNode(prevTree), instance, parentSuspense, isSVG);
                endMeasure(instance, `patch`);
                next.el = nextTree.el;
                if (originNext === null) updateHOCHostEl(instance, nextTree.el);
                if (u) queuePostRenderEffect(u, parentSuspense);
                if (vnodeHook = next.props && next.props.onVnodeUpdated) queuePostRenderEffect(()=>invokeVNodeHook(vnodeHook, parent, next, vnode), parentSuspense);
                devtoolsComponentUpdated(instance);
                popWarningContext();
            }
        };
        const effect = instance.effect = new (0, _reactivity.ReactiveEffect)(componentUpdateFn, ()=>queueJob(update), instance.scope);
        const update = instance.update = ()=>effect.run();
        update.id = instance.uid;
        toggleRecurse(instance, true);
        effect.onTrack = instance.rtc ? (e)=>(0, _shared.invokeArrayFns)(instance.rtc, e) : void 0;
        effect.onTrigger = instance.rtg ? (e)=>(0, _shared.invokeArrayFns)(instance.rtg, e) : void 0;
        update.ownerInstance = instance;
        update();
    };
    const updateComponentPreRender = (instance, nextVNode, optimized)=>{
        nextVNode.component = instance;
        const prevProps = instance.vnode.props;
        instance.vnode = nextVNode;
        instance.next = null;
        updateProps(instance, nextVNode.props, prevProps, optimized);
        updateSlots(instance, nextVNode.children, optimized);
        (0, _reactivity.pauseTracking)();
        flushPreFlushCbs();
        (0, _reactivity.resetTracking)();
    };
    const patchChildren = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized = false)=>{
        const c1 = n1 && n1.children;
        const prevShapeFlag = n1 ? n1.shapeFlag : 0;
        const c2 = n2.children;
        const { patchFlag, shapeFlag } = n2;
        if (patchFlag > 0) {
            if (patchFlag & 128) {
                patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
                return;
            } else if (patchFlag & 256) {
                patchUnkeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
                return;
            }
        }
        if (shapeFlag & 8) {
            if (prevShapeFlag & 16) unmountChildren(c1, parentComponent, parentSuspense);
            if (c2 !== c1) hostSetElementText(container, c2);
        } else if (prevShapeFlag & 16) {
            if (shapeFlag & 16) patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
            else unmountChildren(c1, parentComponent, parentSuspense, true);
        } else {
            if (prevShapeFlag & 8) hostSetElementText(container, "");
            if (shapeFlag & 16) mountChildren(c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        }
    };
    const patchUnkeyedChildren = (c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized)=>{
        c1 = c1 || (0, _shared.EMPTY_ARR);
        c2 = c2 || (0, _shared.EMPTY_ARR);
        const oldLength = c1.length;
        const newLength = c2.length;
        const commonLength = Math.min(oldLength, newLength);
        let i;
        for(i = 0; i < commonLength; i++){
            const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
            patch(c1[i], nextChild, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        }
        if (oldLength > newLength) unmountChildren(c1, parentComponent, parentSuspense, true, false, commonLength);
        else mountChildren(c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, commonLength);
    };
    const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized)=>{
        let i = 0;
        const l2 = c2.length;
        let e1 = c1.length - 1;
        let e2 = l2 - 1;
        while(i <= e1 && i <= e2){
            const n1 = c1[i];
            const n2 = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
            if (isSameVNodeType(n1, n2)) patch(n1, n2, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
            else break;
            i++;
        }
        while(i <= e1 && i <= e2){
            const n1 = c1[e1];
            const n2 = c2[e2] = optimized ? cloneIfMounted(c2[e2]) : normalizeVNode(c2[e2]);
            if (isSameVNodeType(n1, n2)) patch(n1, n2, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
            else break;
            e1--;
            e2--;
        }
        if (i > e1) {
            if (i <= e2) {
                const nextPos = e2 + 1;
                const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;
                while(i <= e2){
                    patch(null, c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]), container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
                    i++;
                }
            }
        } else if (i > e2) while(i <= e1){
            unmount(c1[i], parentComponent, parentSuspense, true);
            i++;
        }
        else {
            const s1 = i;
            const s2 = i;
            const keyToNewIndexMap = /* @__PURE__ */ new Map();
            for(i = s2; i <= e2; i++){
                const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
                if (nextChild.key != null) {
                    if (keyToNewIndexMap.has(nextChild.key)) warn(`Duplicate keys found during update:`, JSON.stringify(nextChild.key), `Make sure keys are unique.`);
                    keyToNewIndexMap.set(nextChild.key, i);
                }
            }
            let j;
            let patched = 0;
            const toBePatched = e2 - s2 + 1;
            let moved = false;
            let maxNewIndexSoFar = 0;
            const newIndexToOldIndexMap = new Array(toBePatched);
            for(i = 0; i < toBePatched; i++)newIndexToOldIndexMap[i] = 0;
            for(i = s1; i <= e1; i++){
                const prevChild = c1[i];
                if (patched >= toBePatched) {
                    unmount(prevChild, parentComponent, parentSuspense, true);
                    continue;
                }
                let newIndex;
                if (prevChild.key != null) newIndex = keyToNewIndexMap.get(prevChild.key);
                else {
                    for(j = s2; j <= e2; j++)if (newIndexToOldIndexMap[j - s2] === 0 && isSameVNodeType(prevChild, c2[j])) {
                        newIndex = j;
                        break;
                    }
                }
                if (newIndex === void 0) unmount(prevChild, parentComponent, parentSuspense, true);
                else {
                    newIndexToOldIndexMap[newIndex - s2] = i + 1;
                    if (newIndex >= maxNewIndexSoFar) maxNewIndexSoFar = newIndex;
                    else moved = true;
                    patch(prevChild, c2[newIndex], container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
                    patched++;
                }
            }
            const increasingNewIndexSequence = moved ? getSequence(newIndexToOldIndexMap) : (0, _shared.EMPTY_ARR);
            j = increasingNewIndexSequence.length - 1;
            for(i = toBePatched - 1; i >= 0; i--){
                const nextIndex = s2 + i;
                const nextChild = c2[nextIndex];
                const anchor = nextIndex + 1 < l2 ? c2[nextIndex + 1].el : parentAnchor;
                if (newIndexToOldIndexMap[i] === 0) patch(null, nextChild, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
                else if (moved) {
                    if (j < 0 || i !== increasingNewIndexSequence[j]) move(nextChild, container, anchor, 2);
                    else j--;
                }
            }
        }
    };
    const move = (vnode, container, anchor, moveType, parentSuspense = null)=>{
        const { el, type, transition, children, shapeFlag } = vnode;
        if (shapeFlag & 6) {
            move(vnode.component.subTree, container, anchor, moveType);
            return;
        }
        if (shapeFlag & 128) {
            vnode.suspense.move(container, anchor, moveType);
            return;
        }
        if (shapeFlag & 64) {
            type.move(vnode, container, anchor, internals);
            return;
        }
        if (type === Fragment) {
            hostInsert(el, container, anchor);
            for(let i = 0; i < children.length; i++)move(children[i], container, anchor, moveType);
            hostInsert(vnode.anchor, container, anchor);
            return;
        }
        if (type === Static) {
            moveStaticNode(vnode, container, anchor);
            return;
        }
        const needTransition = moveType !== 2 && shapeFlag & 1 && transition;
        if (needTransition) {
            if (moveType === 0) {
                transition.beforeEnter(el);
                hostInsert(el, container, anchor);
                queuePostRenderEffect(()=>transition.enter(el), parentSuspense);
            } else {
                const { leave, delayLeave, afterLeave } = transition;
                const remove2 = ()=>hostInsert(el, container, anchor);
                const performLeave = ()=>{
                    leave(el, ()=>{
                        remove2();
                        afterLeave && afterLeave();
                    });
                };
                if (delayLeave) delayLeave(el, remove2, performLeave);
                else performLeave();
            }
        } else hostInsert(el, container, anchor);
    };
    const unmount = (vnode, parentComponent, parentSuspense, doRemove = false, optimized = false)=>{
        const { type, props, ref, children, dynamicChildren, shapeFlag, patchFlag, dirs } = vnode;
        if (ref != null) setRef(ref, null, parentSuspense, vnode, true);
        if (shapeFlag & 256) {
            parentComponent.ctx.deactivate(vnode);
            return;
        }
        const shouldInvokeDirs = shapeFlag & 1 && dirs;
        const shouldInvokeVnodeHook = !isAsyncWrapper(vnode);
        let vnodeHook;
        if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeBeforeUnmount)) invokeVNodeHook(vnodeHook, parentComponent, vnode);
        if (shapeFlag & 6) unmountComponent(vnode.component, parentSuspense, doRemove);
        else {
            if (shapeFlag & 128) {
                vnode.suspense.unmount(parentSuspense, doRemove);
                return;
            }
            if (shouldInvokeDirs) invokeDirectiveHook(vnode, null, parentComponent, "beforeUnmount");
            if (shapeFlag & 64) vnode.type.remove(vnode, parentComponent, parentSuspense, optimized, internals, doRemove);
            else if (dynamicChildren && // #1153: fast path should not be taken for non-stable (v-for) fragments
            (type !== Fragment || patchFlag > 0 && patchFlag & 64)) unmountChildren(dynamicChildren, parentComponent, parentSuspense, false, true);
            else if (type === Fragment && patchFlag & 384 || !optimized && shapeFlag & 16) unmountChildren(children, parentComponent, parentSuspense);
            if (doRemove) remove(vnode);
        }
        if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeUnmounted) || shouldInvokeDirs) queuePostRenderEffect(()=>{
            vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
            shouldInvokeDirs && invokeDirectiveHook(vnode, null, parentComponent, "unmounted");
        }, parentSuspense);
    };
    const remove = (vnode)=>{
        const { type, el, anchor, transition } = vnode;
        if (type === Fragment) {
            if (vnode.patchFlag > 0 && vnode.patchFlag & 2048 && transition && !transition.persisted) vnode.children.forEach((child)=>{
                if (child.type === Comment) hostRemove(child.el);
                else remove(child);
            });
            else removeFragment(el, anchor);
            return;
        }
        if (type === Static) {
            removeStaticNode(vnode);
            return;
        }
        const performRemove = ()=>{
            hostRemove(el);
            if (transition && !transition.persisted && transition.afterLeave) transition.afterLeave();
        };
        if (vnode.shapeFlag & 1 && transition && !transition.persisted) {
            const { leave, delayLeave } = transition;
            const performLeave = ()=>leave(el, performRemove);
            if (delayLeave) delayLeave(vnode.el, performRemove, performLeave);
            else performLeave();
        } else performRemove();
    };
    const removeFragment = (cur, end)=>{
        let next;
        while(cur !== end){
            next = hostNextSibling(cur);
            hostRemove(cur);
            cur = next;
        }
        hostRemove(end);
    };
    const unmountComponent = (instance, parentSuspense, doRemove)=>{
        if (0, instance.type.__hmrId) unregisterHMR(instance);
        const { bum, scope, update, subTree, um } = instance;
        if (bum) (0, _shared.invokeArrayFns)(bum);
        scope.stop();
        if (update) {
            update.active = false;
            unmount(subTree, instance, parentSuspense, doRemove);
        }
        if (um) queuePostRenderEffect(um, parentSuspense);
        queuePostRenderEffect(()=>{
            instance.isUnmounted = true;
        }, parentSuspense);
        if (parentSuspense && parentSuspense.pendingBranch && !parentSuspense.isUnmounted && instance.asyncDep && !instance.asyncResolved && instance.suspenseId === parentSuspense.pendingId) {
            parentSuspense.deps--;
            if (parentSuspense.deps === 0) parentSuspense.resolve();
        }
        devtoolsComponentRemoved(instance);
    };
    const unmountChildren = (children, parentComponent, parentSuspense, doRemove = false, optimized = false, start = 0)=>{
        for(let i = start; i < children.length; i++)unmount(children[i], parentComponent, parentSuspense, doRemove, optimized);
    };
    const getNextHostNode = (vnode)=>{
        if (vnode.shapeFlag & 6) return getNextHostNode(vnode.component.subTree);
        if (vnode.shapeFlag & 128) return vnode.suspense.next();
        return hostNextSibling(vnode.anchor || vnode.el);
    };
    const render = (vnode, container, isSVG)=>{
        if (vnode == null) {
            if (container._vnode) unmount(container._vnode, null, null, true);
        } else patch(container._vnode || null, vnode, container, null, null, null, isSVG);
        flushPreFlushCbs();
        flushPostFlushCbs();
        container._vnode = vnode;
    };
    const internals = {
        p: patch,
        um: unmount,
        m: move,
        r: remove,
        mt: mountComponent,
        mc: mountChildren,
        pc: patchChildren,
        pbc: patchBlockChildren,
        n: getNextHostNode,
        o: options
    };
    let hydrate;
    let hydrateNode;
    if (createHydrationFns) [hydrate, hydrateNode] = createHydrationFns(internals);
    return {
        render,
        hydrate,
        createApp: createAppAPI(render, hydrate)
    };
}
function toggleRecurse({ effect, update }, allowed) {
    effect.allowRecurse = update.allowRecurse = allowed;
}
function traverseStaticChildren(n1, n2, shallow = false) {
    const ch1 = n1.children;
    const ch2 = n2.children;
    if ((0, _shared.isArray)(ch1) && (0, _shared.isArray)(ch2)) for(let i = 0; i < ch1.length; i++){
        const c1 = ch1[i];
        let c2 = ch2[i];
        if (c2.shapeFlag & 1 && !c2.dynamicChildren) {
            if (c2.patchFlag <= 0 || c2.patchFlag === 32) {
                c2 = ch2[i] = cloneIfMounted(ch2[i]);
                c2.el = c1.el;
            }
            if (!shallow) traverseStaticChildren(c1, c2);
        }
        if (c2.type === Text) c2.el = c1.el;
        if (c2.type === Comment && !c2.el) c2.el = c1.el;
    }
}
function getSequence(arr) {
    const p = arr.slice();
    const result = [
        0
    ];
    let i, j, u, v1, c;
    const len = arr.length;
    for(i = 0; i < len; i++){
        const arrI = arr[i];
        if (arrI !== 0) {
            j = result[result.length - 1];
            if (arr[j] < arrI) {
                p[i] = j;
                result.push(i);
                continue;
            }
            u = 0;
            v1 = result.length - 1;
            while(u < v1){
                c = u + v1 >> 1;
                if (arr[result[c]] < arrI) u = c + 1;
                else v1 = c;
            }
            if (arrI < arr[result[u]]) {
                if (u > 0) p[i] = result[u - 1];
                result[u] = i;
            }
        }
    }
    u = result.length;
    v1 = result[u - 1];
    while(u-- > 0){
        result[u] = v1;
        v1 = p[v1];
    }
    return result;
}
const isTeleport = (type)=>type.__isTeleport;
const isTeleportDisabled = (props)=>props && (props.disabled || props.disabled === "");
const isTargetSVG = (target)=>typeof SVGElement !== "undefined" && target instanceof SVGElement;
const resolveTarget = (props, select)=>{
    const targetSelector = props && props.to;
    if ((0, _shared.isString)(targetSelector)) {
        if (!select) {
            warn(`Current renderer does not support string target for Teleports. (missing querySelector renderer option)`);
            return null;
        } else {
            const target = select(targetSelector);
            if (!target) warn(`Failed to locate Teleport target with selector "${targetSelector}". Note the target element must exist before the component is mounted - i.e. the target cannot be rendered by the component itself, and ideally should be outside of the entire Vue component tree.`);
            return target;
        }
    } else {
        if (!targetSelector && !isTeleportDisabled(props)) warn(`Invalid Teleport target: ${targetSelector}`);
        return targetSelector;
    }
};
const TeleportImpl = {
    __isTeleport: true,
    process (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals) {
        const { mc: mountChildren, pc: patchChildren, pbc: patchBlockChildren, o: { insert, querySelector, createText, createComment } } = internals;
        const disabled = isTeleportDisabled(n2.props);
        let { shapeFlag, children, dynamicChildren } = n2;
        if (isHmrUpdating) {
            optimized = false;
            dynamicChildren = null;
        }
        if (n1 == null) {
            const placeholder = n2.el = createComment("teleport start");
            const mainAnchor = n2.anchor = createComment("teleport end");
            insert(placeholder, container, anchor);
            insert(mainAnchor, container, anchor);
            const target = n2.target = resolveTarget(n2.props, querySelector);
            const targetAnchor = n2.targetAnchor = createText("");
            if (target) {
                insert(targetAnchor, target);
                isSVG = isSVG || isTargetSVG(target);
            } else if (!disabled) warn("Invalid Teleport target on mount:", target, `(${typeof target})`);
            const mount = (container2, anchor2)=>{
                if (shapeFlag & 16) mountChildren(children, container2, anchor2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
            };
            if (disabled) mount(container, mainAnchor);
            else if (target) mount(target, targetAnchor);
        } else {
            n2.el = n1.el;
            const mainAnchor = n2.anchor = n1.anchor;
            const target = n2.target = n1.target;
            const targetAnchor = n2.targetAnchor = n1.targetAnchor;
            const wasDisabled = isTeleportDisabled(n1.props);
            const currentContainer = wasDisabled ? container : target;
            const currentAnchor = wasDisabled ? mainAnchor : targetAnchor;
            isSVG = isSVG || isTargetSVG(target);
            if (dynamicChildren) {
                patchBlockChildren(n1.dynamicChildren, dynamicChildren, currentContainer, parentComponent, parentSuspense, isSVG, slotScopeIds);
                traverseStaticChildren(n1, n2, true);
            } else if (!optimized) patchChildren(n1, n2, currentContainer, currentAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, false);
            if (disabled) {
                if (!wasDisabled) moveTeleport(n2, container, mainAnchor, internals, 1);
            } else {
                if ((n2.props && n2.props.to) !== (n1.props && n1.props.to)) {
                    const nextTarget = n2.target = resolveTarget(n2.props, querySelector);
                    if (nextTarget) moveTeleport(n2, nextTarget, null, internals, 0);
                    else warn("Invalid Teleport target on update:", target, `(${typeof target})`);
                } else if (wasDisabled) moveTeleport(n2, target, targetAnchor, internals, 1);
            }
        }
        updateCssVars(n2);
    },
    remove (vnode, parentComponent, parentSuspense, optimized, { um: unmount, o: { remove: hostRemove } }, doRemove) {
        const { shapeFlag, children, anchor, targetAnchor, target, props } = vnode;
        if (target) hostRemove(targetAnchor);
        if (doRemove || !isTeleportDisabled(props)) {
            hostRemove(anchor);
            if (shapeFlag & 16) for(let i = 0; i < children.length; i++){
                const child = children[i];
                unmount(child, parentComponent, parentSuspense, true, !!child.dynamicChildren);
            }
        }
    },
    move: moveTeleport,
    hydrate: hydrateTeleport
};
function moveTeleport(vnode, container, parentAnchor, { o: { insert }, m: move }, moveType = 2) {
    if (moveType === 0) insert(vnode.targetAnchor, container, parentAnchor);
    const { el, anchor, shapeFlag, children, props } = vnode;
    const isReorder = moveType === 2;
    if (isReorder) insert(el, container, parentAnchor);
    if (!isReorder || isTeleportDisabled(props)) {
        if (shapeFlag & 16) for(let i = 0; i < children.length; i++)move(children[i], container, parentAnchor, 2);
    }
    if (isReorder) insert(anchor, container, parentAnchor);
}
function hydrateTeleport(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, { o: { nextSibling, parentNode, querySelector } }, hydrateChildren) {
    const target = vnode.target = resolveTarget(vnode.props, querySelector);
    if (target) {
        const targetNode = target._lpa || target.firstChild;
        if (vnode.shapeFlag & 16) {
            if (isTeleportDisabled(vnode.props)) {
                vnode.anchor = hydrateChildren(nextSibling(node), vnode, parentNode(node), parentComponent, parentSuspense, slotScopeIds, optimized);
                vnode.targetAnchor = targetNode;
            } else {
                vnode.anchor = nextSibling(node);
                let targetAnchor = targetNode;
                while(targetAnchor){
                    targetAnchor = nextSibling(targetAnchor);
                    if (targetAnchor && targetAnchor.nodeType === 8 && targetAnchor.data === "teleport anchor") {
                        vnode.targetAnchor = targetAnchor;
                        target._lpa = vnode.targetAnchor && nextSibling(vnode.targetAnchor);
                        break;
                    }
                }
                hydrateChildren(targetNode, vnode, target, parentComponent, parentSuspense, slotScopeIds, optimized);
            }
        }
        updateCssVars(vnode);
    }
    return vnode.anchor && nextSibling(vnode.anchor);
}
const Teleport = TeleportImpl;
function updateCssVars(vnode) {
    const ctx = vnode.ctx;
    if (ctx && ctx.ut) {
        let node = vnode.children[0].el;
        while(node !== vnode.targetAnchor){
            if (node.nodeType === 1) node.setAttribute("data-v-owner", ctx.uid);
            node = node.nextSibling;
        }
        ctx.ut();
    }
}
const Fragment = Symbol.for("v-fgt");
const Text = Symbol.for("v-txt");
const Comment = Symbol.for("v-cmt");
const Static = Symbol.for("v-stc");
const blockStack = [];
let currentBlock = null;
function openBlock(disableTracking = false) {
    blockStack.push(currentBlock = disableTracking ? null : []);
}
function closeBlock() {
    blockStack.pop();
    currentBlock = blockStack[blockStack.length - 1] || null;
}
let isBlockTreeEnabled = 1;
function setBlockTracking(value1) {
    isBlockTreeEnabled += value1;
}
function setupBlock(vnode) {
    vnode.dynamicChildren = isBlockTreeEnabled > 0 ? currentBlock || (0, _shared.EMPTY_ARR) : null;
    closeBlock();
    if (isBlockTreeEnabled > 0 && currentBlock) currentBlock.push(vnode);
    return vnode;
}
function createElementBlock(type, props, children, patchFlag, dynamicProps, shapeFlag) {
    return setupBlock(createBaseVNode(type, props, children, patchFlag, dynamicProps, shapeFlag, true));
}
function createBlock(type, props, children, patchFlag, dynamicProps) {
    return setupBlock(createVNode(type, props, children, patchFlag, dynamicProps, true));
}
function isVNode(value1) {
    return value1 ? value1.__v_isVNode === true : false;
}
function isSameVNodeType(n1, n2) {
    if (n2.shapeFlag & 6 && hmrDirtyComponents.has(n2.type)) {
        n1.shapeFlag &= -257;
        n2.shapeFlag &= -513;
        return false;
    }
    return n1.type === n2.type && n1.key === n2.key;
}
let vnodeArgsTransformer;
function transformVNodeArgs(transformer) {
    vnodeArgsTransformer = transformer;
}
const createVNodeWithArgsTransform = (...args)=>{
    return _createVNode(...vnodeArgsTransformer ? vnodeArgsTransformer(args, currentRenderingInstance) : args);
};
const InternalObjectKey = `__vInternal`;
const normalizeKey = ({ key })=>key != null ? key : null;
const normalizeRef = ({ ref, ref_key, ref_for })=>{
    if (typeof ref === "number") ref = "" + ref;
    return ref != null ? (0, _shared.isString)(ref) || (0, _reactivity.isRef)(ref) || (0, _shared.isFunction)(ref) ? {
        i: currentRenderingInstance,
        r: ref,
        k: ref_key,
        f: !!ref_for
    } : ref : null;
};
function createBaseVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, shapeFlag = type === Fragment ? 0 : 1, isBlockNode = false, needFullChildrenNormalization = false) {
    const vnode = {
        __v_isVNode: true,
        __v_skip: true,
        type,
        props,
        key: props && normalizeKey(props),
        ref: props && normalizeRef(props),
        scopeId: currentScopeId,
        slotScopeIds: null,
        children,
        component: null,
        suspense: null,
        ssContent: null,
        ssFallback: null,
        dirs: null,
        transition: null,
        el: null,
        anchor: null,
        target: null,
        targetAnchor: null,
        staticCount: 0,
        shapeFlag,
        patchFlag,
        dynamicProps,
        dynamicChildren: null,
        appContext: null,
        ctx: currentRenderingInstance
    };
    if (needFullChildrenNormalization) {
        normalizeChildren(vnode, children);
        if (shapeFlag & 128) type.normalize(vnode);
    } else if (children) vnode.shapeFlag |= (0, _shared.isString)(children) ? 8 : 16;
    if (vnode.key !== vnode.key) warn(`VNode created with invalid key (NaN). VNode type:`, vnode.type);
    if (isBlockTreeEnabled > 0 && // avoid a block node from tracking itself
    !isBlockNode && // has current parent block
    currentBlock && // presence of a patch flag indicates this node needs patching on updates.
    // component nodes also should always be patched, because even if the
    // component doesn't need to update, it needs to persist the instance on to
    // the next vnode so that it can be properly unmounted later.
    (vnode.patchFlag > 0 || shapeFlag & 6) && // the EVENTS flag is only for hydration and if it is the only flag, the
    // vnode should not be considered dynamic due to handler caching.
    vnode.patchFlag !== 32) currentBlock.push(vnode);
    return vnode;
}
const createVNode = createVNodeWithArgsTransform;
function _createVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {
    if (!type || type === NULL_DYNAMIC_COMPONENT) {
        if (!type) warn(`Invalid vnode type when creating vnode: ${type}.`);
        type = Comment;
    }
    if (isVNode(type)) {
        const cloned = cloneVNode(type, props, true);
        if (children) normalizeChildren(cloned, children);
        if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock) {
            if (cloned.shapeFlag & 6) currentBlock[currentBlock.indexOf(type)] = cloned;
            else currentBlock.push(cloned);
        }
        cloned.patchFlag |= -2;
        return cloned;
    }
    if (isClassComponent(type)) type = type.__vccOpts;
    if (props) {
        props = guardReactiveProps(props);
        let { class: klass, style } = props;
        if (klass && !(0, _shared.isString)(klass)) props.class = (0, _shared.normalizeClass)(klass);
        if ((0, _shared.isObject)(style)) {
            if ((0, _reactivity.isProxy)(style) && !(0, _shared.isArray)(style)) style = (0, _shared.extend)({}, style);
            props.style = (0, _shared.normalizeStyle)(style);
        }
    }
    const shapeFlag = (0, _shared.isString)(type) ? 1 : isSuspense(type) ? 128 : isTeleport(type) ? 64 : (0, _shared.isObject)(type) ? 4 : (0, _shared.isFunction)(type) ? 2 : 0;
    if (shapeFlag & 4 && (0, _reactivity.isProxy)(type)) {
        type = (0, _reactivity.toRaw)(type);
        warn(`Vue received a Component which was made a reactive object. This can lead to unnecessary performance overhead, and should be avoided by marking the component with \`markRaw\` or using \`shallowRef\` instead of \`ref\`.`, `
Component that was made reactive: `, type);
    }
    return createBaseVNode(type, props, children, patchFlag, dynamicProps, shapeFlag, isBlockNode, true);
}
function guardReactiveProps(props) {
    if (!props) return null;
    return (0, _reactivity.isProxy)(props) || InternalObjectKey in props ? (0, _shared.extend)({}, props) : props;
}
function cloneVNode(vnode, extraProps, mergeRef = false) {
    const { props, ref, patchFlag, children } = vnode;
    const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;
    const cloned = {
        __v_isVNode: true,
        __v_skip: true,
        type: vnode.type,
        props: mergedProps,
        key: mergedProps && normalizeKey(mergedProps),
        ref: extraProps && extraProps.ref ? // #2078 in the case of <component :is="vnode" ref="extra"/>
        // if the vnode itself already has a ref, cloneVNode will need to merge
        // the refs so the single vnode can be set on multiple refs
        mergeRef && ref ? (0, _shared.isArray)(ref) ? ref.concat(normalizeRef(extraProps)) : [
            ref,
            normalizeRef(extraProps)
        ] : normalizeRef(extraProps) : ref,
        scopeId: vnode.scopeId,
        slotScopeIds: vnode.slotScopeIds,
        children: patchFlag === -1 && (0, _shared.isArray)(children) ? children.map(deepCloneVNode) : children,
        target: vnode.target,
        targetAnchor: vnode.targetAnchor,
        staticCount: vnode.staticCount,
        shapeFlag: vnode.shapeFlag,
        // if the vnode is cloned with extra props, we can no longer assume its
        // existing patch flag to be reliable and need to add the FULL_PROPS flag.
        // note: preserve flag for fragments since they use the flag for children
        // fast paths only.
        patchFlag: extraProps && vnode.type !== Fragment ? patchFlag === -1 ? 16 : patchFlag | 16 : patchFlag,
        dynamicProps: vnode.dynamicProps,
        dynamicChildren: vnode.dynamicChildren,
        appContext: vnode.appContext,
        dirs: vnode.dirs,
        transition: vnode.transition,
        // These should technically only be non-null on mounted VNodes. However,
        // they *should* be copied for kept-alive vnodes. So we just always copy
        // them since them being non-null during a mount doesn't affect the logic as
        // they will simply be overwritten.
        component: vnode.component,
        suspense: vnode.suspense,
        ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),
        ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),
        el: vnode.el,
        anchor: vnode.anchor,
        ctx: vnode.ctx,
        ce: vnode.ce
    };
    return cloned;
}
function deepCloneVNode(vnode) {
    const cloned = cloneVNode(vnode);
    if ((0, _shared.isArray)(vnode.children)) cloned.children = vnode.children.map(deepCloneVNode);
    return cloned;
}
function createTextVNode(text = " ", flag = 0) {
    return createVNode(Text, null, text, flag);
}
function createStaticVNode(content, numberOfNodes) {
    const vnode = createVNode(Static, null, content);
    vnode.staticCount = numberOfNodes;
    return vnode;
}
function createCommentVNode(text = "", asBlock = false) {
    return asBlock ? (openBlock(), createBlock(Comment, null, text)) : createVNode(Comment, null, text);
}
function normalizeVNode(child) {
    if (child == null || typeof child === "boolean") return createVNode(Comment);
    else if ((0, _shared.isArray)(child)) return createVNode(Fragment, null, // #3666, avoid reference pollution when reusing vnode
    child.slice());
    else if (typeof child === "object") return cloneIfMounted(child);
    else return createVNode(Text, null, String(child));
}
function cloneIfMounted(child) {
    return child.el === null && child.patchFlag !== -1 || child.memo ? child : cloneVNode(child);
}
function normalizeChildren(vnode, children) {
    let type = 0;
    const { shapeFlag } = vnode;
    if (children == null) children = null;
    else if ((0, _shared.isArray)(children)) type = 16;
    else if (typeof children === "object") {
        if (shapeFlag & 65) {
            const slot = children.default;
            if (slot) {
                slot._c && (slot._d = false);
                normalizeChildren(vnode, slot());
                slot._c && (slot._d = true);
            }
            return;
        } else {
            type = 32;
            const slotFlag = children._;
            if (!slotFlag && !(InternalObjectKey in children)) children._ctx = currentRenderingInstance;
            else if (slotFlag === 3 && currentRenderingInstance) {
                if (currentRenderingInstance.slots._ === 1) children._ = 1;
                else {
                    children._ = 2;
                    vnode.patchFlag |= 1024;
                }
            }
        }
    } else if ((0, _shared.isFunction)(children)) {
        children = {
            default: children,
            _ctx: currentRenderingInstance
        };
        type = 32;
    } else {
        children = String(children);
        if (shapeFlag & 64) {
            type = 16;
            children = [
                createTextVNode(children)
            ];
        } else type = 8;
    }
    vnode.children = children;
    vnode.shapeFlag |= type;
}
function mergeProps(...args) {
    const ret = {};
    for(let i = 0; i < args.length; i++){
        const toMerge = args[i];
        for(const key in toMerge){
            if (key === "class") {
                if (ret.class !== toMerge.class) ret.class = (0, _shared.normalizeClass)([
                    ret.class,
                    toMerge.class
                ]);
            } else if (key === "style") ret.style = (0, _shared.normalizeStyle)([
                ret.style,
                toMerge.style
            ]);
            else if ((0, _shared.isOn)(key)) {
                const existing = ret[key];
                const incoming = toMerge[key];
                if (incoming && existing !== incoming && !((0, _shared.isArray)(existing) && existing.includes(incoming))) ret[key] = existing ? [].concat(existing, incoming) : incoming;
            } else if (key !== "") ret[key] = toMerge[key];
        }
    }
    return ret;
}
function invokeVNodeHook(hook, instance, vnode, prevVNode = null) {
    callWithAsyncErrorHandling(hook, instance, 7, [
        vnode,
        prevVNode
    ]);
}
const emptyAppContext = createAppContext();
let uid = 0;
function createComponentInstance(vnode, parent, suspense) {
    const type = vnode.type;
    const appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;
    const instance = {
        uid: uid++,
        vnode,
        type,
        parent,
        appContext,
        root: null,
        // to be immediately set
        next: null,
        subTree: null,
        // will be set synchronously right after creation
        effect: null,
        update: null,
        // will be set synchronously right after creation
        scope: new (0, _reactivity.EffectScope)(true),
        render: null,
        proxy: null,
        exposed: null,
        exposeProxy: null,
        withProxy: null,
        provides: parent ? parent.provides : Object.create(appContext.provides),
        accessCache: null,
        renderCache: [],
        // local resolved assets
        components: null,
        directives: null,
        // resolved props and emits options
        propsOptions: normalizePropsOptions(type, appContext),
        emitsOptions: normalizeEmitsOptions(type, appContext),
        // emit
        emit: null,
        // to be set immediately
        emitted: null,
        // props default value
        propsDefaults: (0, _shared.EMPTY_OBJ),
        // inheritAttrs
        inheritAttrs: type.inheritAttrs,
        // state
        ctx: (0, _shared.EMPTY_OBJ),
        data: (0, _shared.EMPTY_OBJ),
        props: (0, _shared.EMPTY_OBJ),
        attrs: (0, _shared.EMPTY_OBJ),
        slots: (0, _shared.EMPTY_OBJ),
        refs: (0, _shared.EMPTY_OBJ),
        setupState: (0, _shared.EMPTY_OBJ),
        setupContext: null,
        attrsProxy: null,
        slotsProxy: null,
        // suspense related
        suspense,
        suspenseId: suspense ? suspense.pendingId : 0,
        asyncDep: null,
        asyncResolved: false,
        // lifecycle hooks
        // not using enums here because it results in computed properties
        isMounted: false,
        isUnmounted: false,
        isDeactivated: false,
        bc: null,
        c: null,
        bm: null,
        m: null,
        bu: null,
        u: null,
        um: null,
        bum: null,
        da: null,
        a: null,
        rtg: null,
        rtc: null,
        ec: null,
        sp: null
    };
    instance.ctx = createDevRenderContext(instance);
    instance.root = parent ? parent.root : instance;
    instance.emit = emit.bind(null, instance);
    if (vnode.ce) vnode.ce(instance);
    return instance;
}
let currentInstance = null;
const getCurrentInstance = ()=>currentInstance || currentRenderingInstance;
let internalSetCurrentInstance;
let globalCurrentInstanceSetters;
let settersKey = "__VUE_INSTANCE_SETTERS__";
if (!(globalCurrentInstanceSetters = (0, _shared.getGlobalThis)()[settersKey])) globalCurrentInstanceSetters = (0, _shared.getGlobalThis)()[settersKey] = [];
globalCurrentInstanceSetters.push((i)=>currentInstance = i);
internalSetCurrentInstance = (instance)=>{
    if (globalCurrentInstanceSetters.length > 1) globalCurrentInstanceSetters.forEach((s)=>s(instance));
    else globalCurrentInstanceSetters[0](instance);
};
const setCurrentInstance = (instance)=>{
    internalSetCurrentInstance(instance);
    instance.scope.on();
};
const unsetCurrentInstance = ()=>{
    currentInstance && currentInstance.scope.off();
    internalSetCurrentInstance(null);
};
const isBuiltInTag = /* @__PURE__ */ (0, _shared.makeMap)("slot,component");
function validateComponentName(name, config) {
    const appIsNativeTag = config.isNativeTag || (0, _shared.NO);
    if (isBuiltInTag(name) || appIsNativeTag(name)) warn("Do not use built-in or reserved HTML elements as component id: " + name);
}
function isStatefulComponent(instance) {
    return instance.vnode.shapeFlag & 4;
}
let isInSSRComponentSetup = false;
function setupComponent(instance, isSSR = false) {
    isInSSRComponentSetup = isSSR;
    const { props, children } = instance.vnode;
    const isStateful = isStatefulComponent(instance);
    initProps(instance, props, isStateful, isSSR);
    initSlots(instance, children);
    const setupResult = isStateful ? setupStatefulComponent(instance, isSSR) : void 0;
    isInSSRComponentSetup = false;
    return setupResult;
}
function setupStatefulComponent(instance, isSSR) {
    var _a;
    const Component = instance.type;
    if (Component.name) validateComponentName(Component.name, instance.appContext.config);
    if (Component.components) {
        const names = Object.keys(Component.components);
        for(let i = 0; i < names.length; i++)validateComponentName(names[i], instance.appContext.config);
    }
    if (Component.directives) {
        const names = Object.keys(Component.directives);
        for(let i = 0; i < names.length; i++)validateDirectiveName(names[i]);
    }
    if (Component.compilerOptions && isRuntimeOnly()) warn(`"compilerOptions" is only supported when using a build of Vue that includes the runtime compiler. Since you are using a runtime-only build, the options should be passed via your build tool config instead.`);
    instance.accessCache = /* @__PURE__ */ Object.create(null);
    instance.proxy = (0, _reactivity.markRaw)(new Proxy(instance.ctx, PublicInstanceProxyHandlers));
    exposePropsOnRenderContext(instance);
    const { setup } = Component;
    if (setup) {
        const setupContext = instance.setupContext = setup.length > 1 ? createSetupContext(instance) : null;
        setCurrentInstance(instance);
        (0, _reactivity.pauseTracking)();
        const setupResult = callWithErrorHandling(setup, instance, 0, [
            (0, _reactivity.shallowReadonly)(instance.props),
            setupContext
        ]);
        (0, _reactivity.resetTracking)();
        unsetCurrentInstance();
        if ((0, _shared.isPromise)(setupResult)) {
            setupResult.then(unsetCurrentInstance, unsetCurrentInstance);
            if (isSSR) return setupResult.then((resolvedResult)=>{
                handleSetupResult(instance, resolvedResult, isSSR);
            }).catch((e)=>{
                handleError(e, instance, 0);
            });
            else {
                instance.asyncDep = setupResult;
                if (!instance.suspense) {
                    const name = (_a = Component.name) != null ? _a : "Anonymous";
                    warn(`Component <${name}>: setup function returned a promise, but no <Suspense> boundary was found in the parent component tree. A component with async setup() must be nested in a <Suspense> in order to be rendered.`);
                }
            }
        } else handleSetupResult(instance, setupResult, isSSR);
    } else finishComponentSetup(instance, isSSR);
}
function handleSetupResult(instance, setupResult, isSSR) {
    if ((0, _shared.isFunction)(setupResult)) {
        if (instance.type.__ssrInlineRender) instance.ssrRender = setupResult;
        else instance.render = setupResult;
    } else if ((0, _shared.isObject)(setupResult)) {
        if (isVNode(setupResult)) warn(`setup() should not return VNodes directly - return a render function instead.`);
        instance.devtoolsRawSetupState = setupResult;
        instance.setupState = (0, _reactivity.proxyRefs)(setupResult);
        exposeSetupStateOnRenderContext(instance);
    } else if (setupResult !== void 0) warn(`setup() should return an object. Received: ${setupResult === null ? "null" : typeof setupResult}`);
    finishComponentSetup(instance, isSSR);
}
let compile;
let installWithProxy;
function registerRuntimeCompiler(_compile) {
    compile = _compile;
    installWithProxy = (i)=>{
        if (i.render._rc) i.withProxy = new Proxy(i.ctx, RuntimeCompiledPublicInstanceProxyHandlers);
    };
}
const isRuntimeOnly = ()=>!compile;
function finishComponentSetup(instance, isSSR, skipOptions) {
    const Component = instance.type;
    if (!instance.render) {
        if (!isSSR && compile && !Component.render) {
            const template = Component.template || resolveMergedOptions(instance).template;
            if (template) {
                startMeasure(instance, `compile`);
                const { isCustomElement, compilerOptions } = instance.appContext.config;
                const { delimiters, compilerOptions: componentCompilerOptions } = Component;
                const finalCompilerOptions = (0, _shared.extend)((0, _shared.extend)({
                    isCustomElement,
                    delimiters
                }, compilerOptions), componentCompilerOptions);
                Component.render = compile(template, finalCompilerOptions);
                endMeasure(instance, `compile`);
            }
        }
        instance.render = Component.render || (0, _shared.NOOP);
        if (installWithProxy) installWithProxy(instance);
    }
    if (__VUE_OPTIONS_API__ && true) {
        setCurrentInstance(instance);
        (0, _reactivity.pauseTracking)();
        applyOptions(instance);
        (0, _reactivity.resetTracking)();
        unsetCurrentInstance();
    }
    if (!Component.render && instance.render === (0, _shared.NOOP) && !isSSR) {
        if (!compile && Component.template) warn(`Component provided template option but runtime compilation is not supported in this build of Vue.` + ` Configure your bundler to alias "vue" to "vue/dist/vue.esm-bundler.js".`);
        else warn(`Component is missing template or render function.`);
    }
}
function getAttrsProxy(instance) {
    return instance.attrsProxy || (instance.attrsProxy = new Proxy(instance.attrs, {
        get (target, key) {
            markAttrsAccessed();
            (0, _reactivity.track)(instance, "get", "$attrs");
            return target[key];
        },
        set () {
            warn(`setupContext.attrs is readonly.`);
            return false;
        },
        deleteProperty () {
            warn(`setupContext.attrs is readonly.`);
            return false;
        }
    }));
}
function getSlotsProxy(instance) {
    return instance.slotsProxy || (instance.slotsProxy = new Proxy(instance.slots, {
        get (target, key) {
            (0, _reactivity.track)(instance, "get", "$slots");
            return target[key];
        }
    }));
}
function createSetupContext(instance) {
    const expose = (exposed)=>{
        if (instance.exposed) warn(`expose() should be called only once per setup().`);
        if (exposed != null) {
            let exposedType = typeof exposed;
            if (exposedType === "object") {
                if ((0, _shared.isArray)(exposed)) exposedType = "array";
                else if ((0, _reactivity.isRef)(exposed)) exposedType = "ref";
            }
            if (exposedType !== "object") warn(`expose() should be passed a plain object, received ${exposedType}.`);
        }
        instance.exposed = exposed || {};
    };
    return Object.freeze({
        get attrs () {
            return getAttrsProxy(instance);
        },
        get slots () {
            return getSlotsProxy(instance);
        },
        get emit () {
            return (event, ...args)=>instance.emit(event, ...args);
        },
        expose
    });
}
function getExposeProxy(instance) {
    if (instance.exposed) return instance.exposeProxy || (instance.exposeProxy = new Proxy((0, _reactivity.proxyRefs)((0, _reactivity.markRaw)(instance.exposed)), {
        get (target, key) {
            if (key in target) return target[key];
            else if (key in publicPropertiesMap) return publicPropertiesMap[key](instance);
        },
        has (target, key) {
            return key in target || key in publicPropertiesMap;
        }
    }));
}
const classifyRE = /(?:^|[-_])(\w)/g;
const classify = (str)=>str.replace(classifyRE, (c)=>c.toUpperCase()).replace(/[-_]/g, "");
function getComponentName(Component, includeInferred = true) {
    return (0, _shared.isFunction)(Component) ? Component.displayName || Component.name : Component.name || includeInferred && Component.__name;
}
function formatComponentName(instance, Component, isRoot = false) {
    let name = getComponentName(Component);
    if (!name && Component.__file) {
        const match = Component.__file.match(/([^/\\]+)\.\w+$/);
        if (match) name = match[1];
    }
    if (!name && instance && instance.parent) {
        const inferFromRegistry = (registry)=>{
            for(const key in registry){
                if (registry[key] === Component) return key;
            }
        };
        name = inferFromRegistry(instance.components || instance.parent.type.components) || inferFromRegistry(instance.appContext.components);
    }
    return name ? classify(name) : isRoot ? `App` : `Anonymous`;
}
function isClassComponent(value1) {
    return (0, _shared.isFunction)(value1) && "__vccOpts" in value1;
}
const computed = (getterOrOptions, debugOptions)=>{
    return (0, _reactivity.computed)(getterOrOptions, debugOptions, isInSSRComponentSetup);
};
function h(type, propsOrChildren, children) {
    const l = arguments.length;
    if (l === 2) {
        if ((0, _shared.isObject)(propsOrChildren) && !(0, _shared.isArray)(propsOrChildren)) {
            if (isVNode(propsOrChildren)) return createVNode(type, null, [
                propsOrChildren
            ]);
            return createVNode(type, propsOrChildren);
        } else return createVNode(type, null, propsOrChildren);
    } else {
        if (l > 3) children = Array.prototype.slice.call(arguments, 2);
        else if (l === 3 && isVNode(children)) children = [
            children
        ];
        return createVNode(type, propsOrChildren, children);
    }
}
const ssrContextKey = Symbol.for("v-scx");
const useSSRContext = ()=>{
    {
        const ctx = inject(ssrContextKey);
        if (!ctx) warn(`Server rendering context not provided. Make sure to only call useSSRContext() conditionally in the server build.`);
        return ctx;
    }
};
function isShallow(value1) {
    return !!(value1 && value1["__v_isShallow"]);
}
function initCustomFormatter() {
    if (typeof window === "undefined") return;
    const vueStyle = {
        style: "color:#3ba776"
    };
    const numberStyle = {
        style: "color:#0b1bc9"
    };
    const stringStyle = {
        style: "color:#b62e24"
    };
    const keywordStyle = {
        style: "color:#9d288c"
    };
    const formatter = {
        header (obj) {
            if (!(0, _shared.isObject)(obj)) return null;
            if (obj.__isVue) return [
                "div",
                vueStyle,
                `VueInstance`
            ];
            else if ((0, _reactivity.isRef)(obj)) return [
                "div",
                {},
                [
                    "span",
                    vueStyle,
                    genRefFlag(obj)
                ],
                "<",
                formatValue(obj.value),
                `>`
            ];
            else if ((0, _reactivity.isReactive)(obj)) return [
                "div",
                {},
                [
                    "span",
                    vueStyle,
                    isShallow(obj) ? "ShallowReactive" : "Reactive"
                ],
                "<",
                formatValue(obj),
                `>${(0, _reactivity.isReadonly)(obj) ? ` (readonly)` : ``}`
            ];
            else if ((0, _reactivity.isReadonly)(obj)) return [
                "div",
                {},
                [
                    "span",
                    vueStyle,
                    isShallow(obj) ? "ShallowReadonly" : "Readonly"
                ],
                "<",
                formatValue(obj),
                ">"
            ];
            return null;
        },
        hasBody (obj) {
            return obj && obj.__isVue;
        },
        body (obj) {
            if (obj && obj.__isVue) return [
                "div",
                {},
                ...formatInstance(obj.$)
            ];
        }
    };
    function formatInstance(instance) {
        const blocks = [];
        if (instance.type.props && instance.props) blocks.push(createInstanceBlock("props", (0, _reactivity.toRaw)(instance.props)));
        if (instance.setupState !== (0, _shared.EMPTY_OBJ)) blocks.push(createInstanceBlock("setup", instance.setupState));
        if (instance.data !== (0, _shared.EMPTY_OBJ)) blocks.push(createInstanceBlock("data", (0, _reactivity.toRaw)(instance.data)));
        const computed = extractKeys(instance, "computed");
        if (computed) blocks.push(createInstanceBlock("computed", computed));
        const injected = extractKeys(instance, "inject");
        if (injected) blocks.push(createInstanceBlock("injected", injected));
        blocks.push([
            "div",
            {},
            [
                "span",
                {
                    style: keywordStyle.style + ";opacity:0.66"
                },
                "$ (internal): "
            ],
            [
                "object",
                {
                    object: instance
                }
            ]
        ]);
        return blocks;
    }
    function createInstanceBlock(type, target) {
        target = (0, _shared.extend)({}, target);
        if (!Object.keys(target).length) return [
            "span",
            {}
        ];
        return [
            "div",
            {
                style: "line-height:1.25em;margin-bottom:0.6em"
            },
            [
                "div",
                {
                    style: "color:#476582"
                },
                type
            ],
            [
                "div",
                {
                    style: "padding-left:1.25em"
                },
                ...Object.keys(target).map((key)=>{
                    return [
                        "div",
                        {},
                        [
                            "span",
                            keywordStyle,
                            key + ": "
                        ],
                        formatValue(target[key], false)
                    ];
                })
            ]
        ];
    }
    function formatValue(v1, asRaw = true) {
        if (typeof v1 === "number") return [
            "span",
            numberStyle,
            v1
        ];
        else if (typeof v1 === "string") return [
            "span",
            stringStyle,
            JSON.stringify(v1)
        ];
        else if (typeof v1 === "boolean") return [
            "span",
            keywordStyle,
            v1
        ];
        else if ((0, _shared.isObject)(v1)) return [
            "object",
            {
                object: asRaw ? (0, _reactivity.toRaw)(v1) : v1
            }
        ];
        else return [
            "span",
            stringStyle,
            String(v1)
        ];
    }
    function extractKeys(instance, type) {
        const Comp = instance.type;
        if ((0, _shared.isFunction)(Comp)) return;
        const extracted = {};
        for(const key in instance.ctx)if (isKeyOfType(Comp, key, type)) extracted[key] = instance.ctx[key];
        return extracted;
    }
    function isKeyOfType(Comp, key, type) {
        const opts = Comp[type];
        if ((0, _shared.isArray)(opts) && opts.includes(key) || (0, _shared.isObject)(opts) && key in opts) return true;
        if (Comp.extends && isKeyOfType(Comp.extends, key, type)) return true;
        if (Comp.mixins && Comp.mixins.some((m)=>isKeyOfType(m, key, type))) return true;
    }
    function genRefFlag(v1) {
        if (isShallow(v1)) return `ShallowRef`;
        if (v1.effect) return `ComputedRef`;
        return `Ref`;
    }
    if (window.devtoolsFormatters) window.devtoolsFormatters.push(formatter);
    else window.devtoolsFormatters = [
        formatter
    ];
}
function withMemo(memo, render, cache, index) {
    const cached = cache[index];
    if (cached && isMemoSame(cached, memo)) return cached;
    const ret = render();
    ret.memo = memo.slice();
    return cache[index] = ret;
}
function isMemoSame(cached, memo) {
    const prev = cached.memo;
    if (prev.length != memo.length) return false;
    for(let i = 0; i < prev.length; i++){
        if ((0, _shared.hasChanged)(prev[i], memo[i])) return false;
    }
    if (isBlockTreeEnabled > 0 && currentBlock) currentBlock.push(cached);
    return true;
}
const version = "3.3.4";
const _ssrUtils = {
    createComponentInstance,
    setupComponent,
    renderComponentRoot,
    setCurrentRenderingInstance,
    isVNode: isVNode,
    normalizeVNode
};
const ssrUtils = _ssrUtils;
const resolveFilter = null;
const compatUtils = null;

},{"@vue/reactivity":"fQHlL","@vue/shared":"5YL8y","@parcel/transformer-js/src/esmodule-helpers.js":"boKlo"}],"fQHlL":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "EffectScope", ()=>EffectScope);
parcelHelpers.export(exports, "ITERATE_KEY", ()=>ITERATE_KEY);
parcelHelpers.export(exports, "ReactiveEffect", ()=>ReactiveEffect);
parcelHelpers.export(exports, "computed", ()=>computed);
parcelHelpers.export(exports, "customRef", ()=>customRef);
parcelHelpers.export(exports, "deferredComputed", ()=>deferredComputed);
parcelHelpers.export(exports, "effect", ()=>effect);
parcelHelpers.export(exports, "effectScope", ()=>effectScope);
parcelHelpers.export(exports, "enableTracking", ()=>enableTracking);
parcelHelpers.export(exports, "getCurrentScope", ()=>getCurrentScope);
parcelHelpers.export(exports, "isProxy", ()=>isProxy);
parcelHelpers.export(exports, "isReactive", ()=>isReactive);
parcelHelpers.export(exports, "isReadonly", ()=>isReadonly);
parcelHelpers.export(exports, "isRef", ()=>isRef);
parcelHelpers.export(exports, "isShallow", ()=>isShallow);
parcelHelpers.export(exports, "markRaw", ()=>markRaw);
parcelHelpers.export(exports, "onScopeDispose", ()=>onScopeDispose);
parcelHelpers.export(exports, "pauseTracking", ()=>pauseTracking);
parcelHelpers.export(exports, "proxyRefs", ()=>proxyRefs);
parcelHelpers.export(exports, "reactive", ()=>reactive);
parcelHelpers.export(exports, "readonly", ()=>readonly);
parcelHelpers.export(exports, "ref", ()=>ref);
parcelHelpers.export(exports, "resetTracking", ()=>resetTracking);
parcelHelpers.export(exports, "shallowReactive", ()=>shallowReactive);
parcelHelpers.export(exports, "shallowReadonly", ()=>shallowReadonly);
parcelHelpers.export(exports, "shallowRef", ()=>shallowRef);
parcelHelpers.export(exports, "stop", ()=>stop);
parcelHelpers.export(exports, "toRaw", ()=>toRaw);
parcelHelpers.export(exports, "toRef", ()=>toRef);
parcelHelpers.export(exports, "toRefs", ()=>toRefs);
parcelHelpers.export(exports, "toValue", ()=>toValue);
parcelHelpers.export(exports, "track", ()=>track);
parcelHelpers.export(exports, "trigger", ()=>trigger);
parcelHelpers.export(exports, "triggerRef", ()=>triggerRef);
parcelHelpers.export(exports, "unref", ()=>unref);
var _shared = require("@vue/shared");
function warn(msg, ...args) {
    console.warn(`[Vue warn] ${msg}`, ...args);
}
let activeEffectScope;
class EffectScope {
    constructor(detached = false){
        this.detached = detached;
        /**
     * @internal
     */ this._active = true;
        /**
     * @internal
     */ this.effects = [];
        /**
     * @internal
     */ this.cleanups = [];
        this.parent = activeEffectScope;
        if (!detached && activeEffectScope) this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(this) - 1;
    }
    get active() {
        return this._active;
    }
    run(fn) {
        if (this._active) {
            const currentEffectScope = activeEffectScope;
            try {
                activeEffectScope = this;
                return fn();
            } finally{
                activeEffectScope = currentEffectScope;
            }
        } else warn(`cannot run an inactive effect scope.`);
    }
    /**
   * This should only be called on non-detached scopes
   * @internal
   */ on() {
        activeEffectScope = this;
    }
    /**
   * This should only be called on non-detached scopes
   * @internal
   */ off() {
        activeEffectScope = this.parent;
    }
    stop(fromParent) {
        if (this._active) {
            let i, l;
            for(i = 0, l = this.effects.length; i < l; i++)this.effects[i].stop();
            for(i = 0, l = this.cleanups.length; i < l; i++)this.cleanups[i]();
            if (this.scopes) for(i = 0, l = this.scopes.length; i < l; i++)this.scopes[i].stop(true);
            if (!this.detached && this.parent && !fromParent) {
                const last = this.parent.scopes.pop();
                if (last && last !== this) {
                    this.parent.scopes[this.index] = last;
                    last.index = this.index;
                }
            }
            this.parent = void 0;
            this._active = false;
        }
    }
}
function effectScope(detached) {
    return new EffectScope(detached);
}
function recordEffectScope(effect, scope = activeEffectScope) {
    if (scope && scope.active) scope.effects.push(effect);
}
function getCurrentScope() {
    return activeEffectScope;
}
function onScopeDispose(fn) {
    if (activeEffectScope) activeEffectScope.cleanups.push(fn);
    else warn(`onScopeDispose() is called when there is no active effect scope to be associated with.`);
}
const createDep = (effects)=>{
    const dep = new Set(effects);
    dep.w = 0;
    dep.n = 0;
    return dep;
};
const wasTracked = (dep)=>(dep.w & trackOpBit) > 0;
const newTracked = (dep)=>(dep.n & trackOpBit) > 0;
const initDepMarkers = ({ deps })=>{
    if (deps.length) for(let i = 0; i < deps.length; i++)deps[i].w |= trackOpBit;
};
const finalizeDepMarkers = (effect)=>{
    const { deps } = effect;
    if (deps.length) {
        let ptr = 0;
        for(let i = 0; i < deps.length; i++){
            const dep = deps[i];
            if (wasTracked(dep) && !newTracked(dep)) dep.delete(effect);
            else deps[ptr++] = dep;
            dep.w &= ~trackOpBit;
            dep.n &= ~trackOpBit;
        }
        deps.length = ptr;
    }
};
const targetMap = /* @__PURE__ */ new WeakMap();
let effectTrackDepth = 0;
let trackOpBit = 1;
const maxMarkerBits = 30;
let activeEffect;
const ITERATE_KEY = Symbol("iterate");
const MAP_KEY_ITERATE_KEY = Symbol("Map key iterate");
class ReactiveEffect {
    constructor(fn, scheduler = null, scope){
        this.fn = fn;
        this.scheduler = scheduler;
        this.active = true;
        this.deps = [];
        this.parent = void 0;
        recordEffectScope(this, scope);
    }
    run() {
        if (!this.active) return this.fn();
        let parent = activeEffect;
        let lastShouldTrack = shouldTrack;
        while(parent){
            if (parent === this) return;
            parent = parent.parent;
        }
        try {
            this.parent = activeEffect;
            activeEffect = this;
            shouldTrack = true;
            trackOpBit = 1 << ++effectTrackDepth;
            if (effectTrackDepth <= maxMarkerBits) initDepMarkers(this);
            else cleanupEffect(this);
            return this.fn();
        } finally{
            if (effectTrackDepth <= maxMarkerBits) finalizeDepMarkers(this);
            trackOpBit = 1 << --effectTrackDepth;
            activeEffect = this.parent;
            shouldTrack = lastShouldTrack;
            this.parent = void 0;
            if (this.deferStop) this.stop();
        }
    }
    stop() {
        if (activeEffect === this) this.deferStop = true;
        else if (this.active) {
            cleanupEffect(this);
            if (this.onStop) this.onStop();
            this.active = false;
        }
    }
}
function cleanupEffect(effect2) {
    const { deps } = effect2;
    if (deps.length) {
        for(let i = 0; i < deps.length; i++)deps[i].delete(effect2);
        deps.length = 0;
    }
}
function effect(fn, options) {
    if (fn.effect) fn = fn.effect.fn;
    const _effect = new ReactiveEffect(fn);
    if (options) {
        (0, _shared.extend)(_effect, options);
        if (options.scope) recordEffectScope(_effect, options.scope);
    }
    if (!options || !options.lazy) _effect.run();
    const runner = _effect.run.bind(_effect);
    runner.effect = _effect;
    return runner;
}
function stop(runner) {
    runner.effect.stop();
}
let shouldTrack = true;
const trackStack = [];
function pauseTracking() {
    trackStack.push(shouldTrack);
    shouldTrack = false;
}
function enableTracking() {
    trackStack.push(shouldTrack);
    shouldTrack = true;
}
function resetTracking() {
    const last = trackStack.pop();
    shouldTrack = last === void 0 ? true : last;
}
function track(target, type, key) {
    if (shouldTrack && activeEffect) {
        let depsMap = targetMap.get(target);
        if (!depsMap) targetMap.set(target, depsMap = /* @__PURE__ */ new Map());
        let dep = depsMap.get(key);
        if (!dep) depsMap.set(key, dep = createDep());
        const eventInfo = {
            effect: activeEffect,
            target,
            type,
            key
        };
        trackEffects(dep, eventInfo);
    }
}
function trackEffects(dep, debuggerEventExtraInfo) {
    let shouldTrack2 = false;
    if (effectTrackDepth <= maxMarkerBits) {
        if (!newTracked(dep)) {
            dep.n |= trackOpBit;
            shouldTrack2 = !wasTracked(dep);
        }
    } else shouldTrack2 = !dep.has(activeEffect);
    if (shouldTrack2) {
        dep.add(activeEffect);
        activeEffect.deps.push(dep);
        if (0, activeEffect.onTrack) activeEffect.onTrack((0, _shared.extend)({
            effect: activeEffect
        }, debuggerEventExtraInfo));
    }
}
function trigger(target, type, key, newValue, oldValue, oldTarget) {
    const depsMap = targetMap.get(target);
    if (!depsMap) return;
    let deps = [];
    if (type === "clear") deps = [
        ...depsMap.values()
    ];
    else if (key === "length" && (0, _shared.isArray)(target)) {
        const newLength = Number(newValue);
        depsMap.forEach((dep, key2)=>{
            if (key2 === "length" || key2 >= newLength) deps.push(dep);
        });
    } else {
        if (key !== void 0) deps.push(depsMap.get(key));
        switch(type){
            case "add":
                if (!(0, _shared.isArray)(target)) {
                    deps.push(depsMap.get(ITERATE_KEY));
                    if ((0, _shared.isMap)(target)) deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
                } else if ((0, _shared.isIntegerKey)(key)) deps.push(depsMap.get("length"));
                break;
            case "delete":
                if (!(0, _shared.isArray)(target)) {
                    deps.push(depsMap.get(ITERATE_KEY));
                    if ((0, _shared.isMap)(target)) deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
                }
                break;
            case "set":
                if ((0, _shared.isMap)(target)) deps.push(depsMap.get(ITERATE_KEY));
                break;
        }
    }
    const eventInfo = {
        target,
        type,
        key,
        newValue,
        oldValue,
        oldTarget
    };
    if (deps.length === 1) {
        if (deps[0]) triggerEffects(deps[0], eventInfo);
    } else {
        const effects = [];
        for (const dep of deps)if (dep) effects.push(...dep);
        triggerEffects(createDep(effects), eventInfo);
    }
}
function triggerEffects(dep, debuggerEventExtraInfo) {
    const effects = (0, _shared.isArray)(dep) ? dep : [
        ...dep
    ];
    for (const effect2 of effects)if (effect2.computed) triggerEffect(effect2, debuggerEventExtraInfo);
    for (const effect2 of effects)if (!effect2.computed) triggerEffect(effect2, debuggerEventExtraInfo);
}
function triggerEffect(effect2, debuggerEventExtraInfo) {
    if (effect2 !== activeEffect || effect2.allowRecurse) {
        if (0, effect2.onTrigger) effect2.onTrigger((0, _shared.extend)({
            effect: effect2
        }, debuggerEventExtraInfo));
        if (effect2.scheduler) effect2.scheduler();
        else effect2.run();
    }
}
function getDepFromReactive(object, key) {
    var _a;
    return (_a = targetMap.get(object)) == null ? void 0 : _a.get(key);
}
const isNonTrackableKeys = /* @__PURE__ */ (0, _shared.makeMap)(`__proto__,__v_isRef,__isVue`);
const builtInSymbols = new Set(/* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((key)=>key !== "arguments" && key !== "caller").map((key)=>Symbol[key]).filter((0, _shared.isSymbol)));
const get$1 = /* @__PURE__ */ createGetter();
const shallowGet = /* @__PURE__ */ createGetter(false, true);
const readonlyGet = /* @__PURE__ */ createGetter(true);
const shallowReadonlyGet = /* @__PURE__ */ createGetter(true, true);
const arrayInstrumentations = /* @__PURE__ */ createArrayInstrumentations();
function createArrayInstrumentations() {
    const instrumentations = {};
    [
        "includes",
        "indexOf",
        "lastIndexOf"
    ].forEach((key)=>{
        instrumentations[key] = function(...args) {
            const arr = toRaw(this);
            for(let i = 0, l = this.length; i < l; i++)track(arr, "get", i + "");
            const res = arr[key](...args);
            if (res === -1 || res === false) return arr[key](...args.map(toRaw));
            else return res;
        };
    });
    [
        "push",
        "pop",
        "shift",
        "unshift",
        "splice"
    ].forEach((key)=>{
        instrumentations[key] = function(...args) {
            pauseTracking();
            const res = toRaw(this)[key].apply(this, args);
            resetTracking();
            return res;
        };
    });
    return instrumentations;
}
function hasOwnProperty(key) {
    const obj = toRaw(this);
    track(obj, "has", key);
    return obj.hasOwnProperty(key);
}
function createGetter(isReadonly2 = false, shallow = false) {
    return function get2(target, key, receiver) {
        if (key === "__v_isReactive") return !isReadonly2;
        else if (key === "__v_isReadonly") return isReadonly2;
        else if (key === "__v_isShallow") return shallow;
        else if (key === "__v_raw" && receiver === (isReadonly2 ? shallow ? shallowReadonlyMap : readonlyMap : shallow ? shallowReactiveMap : reactiveMap).get(target)) return target;
        const targetIsArray = (0, _shared.isArray)(target);
        if (!isReadonly2) {
            if (targetIsArray && (0, _shared.hasOwn)(arrayInstrumentations, key)) return Reflect.get(arrayInstrumentations, key, receiver);
            if (key === "hasOwnProperty") return hasOwnProperty;
        }
        const res = Reflect.get(target, key, receiver);
        if ((0, _shared.isSymbol)(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) return res;
        if (!isReadonly2) track(target, "get", key);
        if (shallow) return res;
        if (isRef(res)) return targetIsArray && (0, _shared.isIntegerKey)(key) ? res : res.value;
        if ((0, _shared.isObject)(res)) return isReadonly2 ? readonly(res) : reactive(res);
        return res;
    };
}
const set$1 = /* @__PURE__ */ createSetter();
const shallowSet = /* @__PURE__ */ createSetter(true);
function createSetter(shallow = false) {
    return function set2(target, key, value, receiver) {
        let oldValue = target[key];
        if (isReadonly(oldValue) && isRef(oldValue) && !isRef(value)) return false;
        if (!shallow) {
            if (!isShallow(value) && !isReadonly(value)) {
                oldValue = toRaw(oldValue);
                value = toRaw(value);
            }
            if (!(0, _shared.isArray)(target) && isRef(oldValue) && !isRef(value)) {
                oldValue.value = value;
                return true;
            }
        }
        const hadKey = (0, _shared.isArray)(target) && (0, _shared.isIntegerKey)(key) ? Number(key) < target.length : (0, _shared.hasOwn)(target, key);
        const result = Reflect.set(target, key, value, receiver);
        if (target === toRaw(receiver)) {
            if (!hadKey) trigger(target, "add", key, value);
            else if ((0, _shared.hasChanged)(value, oldValue)) trigger(target, "set", key, value, oldValue);
        }
        return result;
    };
}
function deleteProperty(target, key) {
    const hadKey = (0, _shared.hasOwn)(target, key);
    const oldValue = target[key];
    const result = Reflect.deleteProperty(target, key);
    if (result && hadKey) trigger(target, "delete", key, void 0, oldValue);
    return result;
}
function has$1(target, key) {
    const result = Reflect.has(target, key);
    if (!(0, _shared.isSymbol)(key) || !builtInSymbols.has(key)) track(target, "has", key);
    return result;
}
function ownKeys(target) {
    track(target, "iterate", (0, _shared.isArray)(target) ? "length" : ITERATE_KEY);
    return Reflect.ownKeys(target);
}
const mutableHandlers = {
    get: get$1,
    set: set$1,
    deleteProperty,
    has: has$1,
    ownKeys
};
const readonlyHandlers = {
    get: readonlyGet,
    set (target, key) {
        warn(`Set operation on key "${String(key)}" failed: target is readonly.`, target);
        return true;
    },
    deleteProperty (target, key) {
        warn(`Delete operation on key "${String(key)}" failed: target is readonly.`, target);
        return true;
    }
};
const shallowReactiveHandlers = /* @__PURE__ */ (0, _shared.extend)({}, mutableHandlers, {
    get: shallowGet,
    set: shallowSet
});
const shallowReadonlyHandlers = /* @__PURE__ */ (0, _shared.extend)({}, readonlyHandlers, {
    get: shallowReadonlyGet
});
const toShallow = (value)=>value;
const getProto = (v)=>Reflect.getPrototypeOf(v);
function get(target, key, isReadonly = false, isShallow = false) {
    target = target["__v_raw"];
    const rawTarget = toRaw(target);
    const rawKey = toRaw(key);
    if (!isReadonly) {
        if (key !== rawKey) track(rawTarget, "get", key);
        track(rawTarget, "get", rawKey);
    }
    const { has: has2 } = getProto(rawTarget);
    const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;
    if (has2.call(rawTarget, key)) return wrap(target.get(key));
    else if (has2.call(rawTarget, rawKey)) return wrap(target.get(rawKey));
    else if (target !== rawTarget) target.get(key);
}
function has(key, isReadonly = false) {
    const target = this["__v_raw"];
    const rawTarget = toRaw(target);
    const rawKey = toRaw(key);
    if (!isReadonly) {
        if (key !== rawKey) track(rawTarget, "has", key);
        track(rawTarget, "has", rawKey);
    }
    return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);
}
function size(target, isReadonly = false) {
    target = target["__v_raw"];
    !isReadonly && track(toRaw(target), "iterate", ITERATE_KEY);
    return Reflect.get(target, "size", target);
}
function add(value) {
    value = toRaw(value);
    const target = toRaw(this);
    const proto = getProto(target);
    const hadKey = proto.has.call(target, value);
    if (!hadKey) {
        target.add(value);
        trigger(target, "add", value, value);
    }
    return this;
}
function set(key, value) {
    value = toRaw(value);
    const target = toRaw(this);
    const { has: has2, get: get2 } = getProto(target);
    let hadKey = has2.call(target, key);
    if (!hadKey) {
        key = toRaw(key);
        hadKey = has2.call(target, key);
    } else checkIdentityKeys(target, has2, key);
    const oldValue = get2.call(target, key);
    target.set(key, value);
    if (!hadKey) trigger(target, "add", key, value);
    else if ((0, _shared.hasChanged)(value, oldValue)) trigger(target, "set", key, value, oldValue);
    return this;
}
function deleteEntry(key) {
    const target = toRaw(this);
    const { has: has2, get: get2 } = getProto(target);
    let hadKey = has2.call(target, key);
    if (!hadKey) {
        key = toRaw(key);
        hadKey = has2.call(target, key);
    } else checkIdentityKeys(target, has2, key);
    const oldValue = get2 ? get2.call(target, key) : void 0;
    const result = target.delete(key);
    if (hadKey) trigger(target, "delete", key, void 0, oldValue);
    return result;
}
function clear() {
    const target = toRaw(this);
    const hadItems = target.size !== 0;
    const oldTarget = (0, _shared.isMap)(target) ? new Map(target) : new Set(target);
    const result = target.clear();
    if (hadItems) trigger(target, "clear", void 0, void 0, oldTarget);
    return result;
}
function createForEach(isReadonly, isShallow) {
    return function forEach(callback, thisArg) {
        const observed = this;
        const target = observed["__v_raw"];
        const rawTarget = toRaw(target);
        const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;
        !isReadonly && track(rawTarget, "iterate", ITERATE_KEY);
        return target.forEach((value, key)=>{
            return callback.call(thisArg, wrap(value), wrap(key), observed);
        });
    };
}
function createIterableMethod(method, isReadonly, isShallow) {
    return function(...args) {
        const target = this["__v_raw"];
        const rawTarget = toRaw(target);
        const targetIsMap = (0, _shared.isMap)(rawTarget);
        const isPair = method === "entries" || method === Symbol.iterator && targetIsMap;
        const isKeyOnly = method === "keys" && targetIsMap;
        const innerIterator = target[method](...args);
        const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;
        !isReadonly && track(rawTarget, "iterate", isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY);
        return {
            // iterator protocol
            next () {
                const { value, done } = innerIterator.next();
                return done ? {
                    value,
                    done
                } : {
                    value: isPair ? [
                        wrap(value[0]),
                        wrap(value[1])
                    ] : wrap(value),
                    done
                };
            },
            // iterable protocol
            [Symbol.iterator] () {
                return this;
            }
        };
    };
}
function createReadonlyMethod(type) {
    return function(...args) {
        {
            const key = args[0] ? `on key "${args[0]}" ` : ``;
            console.warn(`${(0, _shared.capitalize)(type)} operation ${key}failed: target is readonly.`, toRaw(this));
        }
        return type === "delete" ? false : this;
    };
}
function createInstrumentations() {
    const mutableInstrumentations2 = {
        get (key) {
            return get(this, key);
        },
        get size () {
            return size(this);
        },
        has,
        add,
        set,
        delete: deleteEntry,
        clear,
        forEach: createForEach(false, false)
    };
    const shallowInstrumentations2 = {
        get (key) {
            return get(this, key, false, true);
        },
        get size () {
            return size(this);
        },
        has,
        add,
        set,
        delete: deleteEntry,
        clear,
        forEach: createForEach(false, true)
    };
    const readonlyInstrumentations2 = {
        get (key) {
            return get(this, key, true);
        },
        get size () {
            return size(this, true);
        },
        has (key) {
            return has.call(this, key, true);
        },
        add: createReadonlyMethod("add"),
        set: createReadonlyMethod("set"),
        delete: createReadonlyMethod("delete"),
        clear: createReadonlyMethod("clear"),
        forEach: createForEach(true, false)
    };
    const shallowReadonlyInstrumentations2 = {
        get (key) {
            return get(this, key, true, true);
        },
        get size () {
            return size(this, true);
        },
        has (key) {
            return has.call(this, key, true);
        },
        add: createReadonlyMethod("add"),
        set: createReadonlyMethod("set"),
        delete: createReadonlyMethod("delete"),
        clear: createReadonlyMethod("clear"),
        forEach: createForEach(true, true)
    };
    const iteratorMethods = [
        "keys",
        "values",
        "entries",
        Symbol.iterator
    ];
    iteratorMethods.forEach((method)=>{
        mutableInstrumentations2[method] = createIterableMethod(method, false, false);
        readonlyInstrumentations2[method] = createIterableMethod(method, true, false);
        shallowInstrumentations2[method] = createIterableMethod(method, false, true);
        shallowReadonlyInstrumentations2[method] = createIterableMethod(method, true, true);
    });
    return [
        mutableInstrumentations2,
        readonlyInstrumentations2,
        shallowInstrumentations2,
        shallowReadonlyInstrumentations2
    ];
}
const [mutableInstrumentations, readonlyInstrumentations, shallowInstrumentations, shallowReadonlyInstrumentations] = /* @__PURE__ */ createInstrumentations();
function createInstrumentationGetter(isReadonly, shallow) {
    const instrumentations = shallow ? isReadonly ? shallowReadonlyInstrumentations : shallowInstrumentations : isReadonly ? readonlyInstrumentations : mutableInstrumentations;
    return (target, key, receiver)=>{
        if (key === "__v_isReactive") return !isReadonly;
        else if (key === "__v_isReadonly") return isReadonly;
        else if (key === "__v_raw") return target;
        return Reflect.get((0, _shared.hasOwn)(instrumentations, key) && key in target ? instrumentations : target, key, receiver);
    };
}
const mutableCollectionHandlers = {
    get: /* @__PURE__ */ createInstrumentationGetter(false, false)
};
const shallowCollectionHandlers = {
    get: /* @__PURE__ */ createInstrumentationGetter(false, true)
};
const readonlyCollectionHandlers = {
    get: /* @__PURE__ */ createInstrumentationGetter(true, false)
};
const shallowReadonlyCollectionHandlers = {
    get: /* @__PURE__ */ createInstrumentationGetter(true, true)
};
function checkIdentityKeys(target, has2, key) {
    const rawKey = toRaw(key);
    if (rawKey !== key && has2.call(target, rawKey)) {
        const type = (0, _shared.toRawType)(target);
        console.warn(`Reactive ${type} contains both the raw and reactive versions of the same object${type === `Map` ? ` as keys` : ``}, which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.`);
    }
}
const reactiveMap = /* @__PURE__ */ new WeakMap();
const shallowReactiveMap = /* @__PURE__ */ new WeakMap();
const readonlyMap = /* @__PURE__ */ new WeakMap();
const shallowReadonlyMap = /* @__PURE__ */ new WeakMap();
function targetTypeMap(rawType) {
    switch(rawType){
        case "Object":
        case "Array":
            return 1 /* COMMON */ ;
        case "Map":
        case "Set":
        case "WeakMap":
        case "WeakSet":
            return 2 /* COLLECTION */ ;
        default:
            return 0 /* INVALID */ ;
    }
}
function getTargetType(value) {
    return value["__v_skip"] || !Object.isExtensible(value) ? 0 /* INVALID */  : targetTypeMap((0, _shared.toRawType)(value));
}
function reactive(target) {
    if (isReadonly(target)) return target;
    return createReactiveObject(target, false, mutableHandlers, mutableCollectionHandlers, reactiveMap);
}
function shallowReactive(target) {
    return createReactiveObject(target, false, shallowReactiveHandlers, shallowCollectionHandlers, shallowReactiveMap);
}
function readonly(target) {
    return createReactiveObject(target, true, readonlyHandlers, readonlyCollectionHandlers, readonlyMap);
}
function shallowReadonly(target) {
    return createReactiveObject(target, true, shallowReadonlyHandlers, shallowReadonlyCollectionHandlers, shallowReadonlyMap);
}
function createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {
    if (!(0, _shared.isObject)(target)) {
        console.warn(`value cannot be made reactive: ${String(target)}`);
        return target;
    }
    if (target["__v_raw"] && !(isReadonly2 && target["__v_isReactive"])) return target;
    const existingProxy = proxyMap.get(target);
    if (existingProxy) return existingProxy;
    const targetType = getTargetType(target);
    if (targetType === 0 /* INVALID */ ) return target;
    const proxy = new Proxy(target, targetType === 2 /* COLLECTION */  ? collectionHandlers : baseHandlers);
    proxyMap.set(target, proxy);
    return proxy;
}
function isReactive(value) {
    if (isReadonly(value)) return isReactive(value["__v_raw"]);
    return !!(value && value["__v_isReactive"]);
}
function isReadonly(value) {
    return !!(value && value["__v_isReadonly"]);
}
function isShallow(value) {
    return !!(value && value["__v_isShallow"]);
}
function isProxy(value) {
    return isReactive(value) || isReadonly(value);
}
function toRaw(observed) {
    const raw = observed && observed["__v_raw"];
    return raw ? toRaw(raw) : observed;
}
function markRaw(value) {
    (0, _shared.def)(value, "__v_skip", true);
    return value;
}
const toReactive = (value)=>(0, _shared.isObject)(value) ? reactive(value) : value;
const toReadonly = (value)=>(0, _shared.isObject)(value) ? readonly(value) : value;
function trackRefValue(ref2) {
    if (shouldTrack && activeEffect) {
        ref2 = toRaw(ref2);
        trackEffects(ref2.dep || (ref2.dep = createDep()), {
            target: ref2,
            type: "get",
            key: "value"
        });
    }
}
function triggerRefValue(ref2, newVal) {
    ref2 = toRaw(ref2);
    const dep = ref2.dep;
    if (dep) triggerEffects(dep, {
        target: ref2,
        type: "set",
        key: "value",
        newValue: newVal
    });
}
function isRef(r) {
    return !!(r && r.__v_isRef === true);
}
function ref(value) {
    return createRef(value, false);
}
function shallowRef(value) {
    return createRef(value, true);
}
function createRef(rawValue, shallow) {
    if (isRef(rawValue)) return rawValue;
    return new RefImpl(rawValue, shallow);
}
class RefImpl {
    constructor(value, __v_isShallow){
        this.__v_isShallow = __v_isShallow;
        this.dep = void 0;
        this.__v_isRef = true;
        this._rawValue = __v_isShallow ? value : toRaw(value);
        this._value = __v_isShallow ? value : toReactive(value);
    }
    get value() {
        trackRefValue(this);
        return this._value;
    }
    set value(newVal) {
        const useDirectValue = this.__v_isShallow || isShallow(newVal) || isReadonly(newVal);
        newVal = useDirectValue ? newVal : toRaw(newVal);
        if ((0, _shared.hasChanged)(newVal, this._rawValue)) {
            this._rawValue = newVal;
            this._value = useDirectValue ? newVal : toReactive(newVal);
            triggerRefValue(this, newVal);
        }
    }
}
function triggerRef(ref2) {
    triggerRefValue(ref2, (0, ref2.value));
}
function unref(ref2) {
    return isRef(ref2) ? ref2.value : ref2;
}
function toValue(source) {
    return (0, _shared.isFunction)(source) ? source() : unref(source);
}
const shallowUnwrapHandlers = {
    get: (target, key, receiver)=>unref(Reflect.get(target, key, receiver)),
    set: (target, key, value, receiver)=>{
        const oldValue = target[key];
        if (isRef(oldValue) && !isRef(value)) {
            oldValue.value = value;
            return true;
        } else return Reflect.set(target, key, value, receiver);
    }
};
function proxyRefs(objectWithRefs) {
    return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);
}
class CustomRefImpl {
    constructor(factory){
        this.dep = void 0;
        this.__v_isRef = true;
        const { get, set } = factory(()=>trackRefValue(this), ()=>triggerRefValue(this));
        this._get = get;
        this._set = set;
    }
    get value() {
        return this._get();
    }
    set value(newVal) {
        this._set(newVal);
    }
}
function customRef(factory) {
    return new CustomRefImpl(factory);
}
function toRefs(object) {
    if (!isProxy(object)) console.warn(`toRefs() expects a reactive object but received a plain one.`);
    const ret = (0, _shared.isArray)(object) ? new Array(object.length) : {};
    for(const key in object)ret[key] = propertyToRef(object, key);
    return ret;
}
class ObjectRefImpl {
    constructor(_object, _key, _defaultValue){
        this._object = _object;
        this._key = _key;
        this._defaultValue = _defaultValue;
        this.__v_isRef = true;
    }
    get value() {
        const val = this._object[this._key];
        return val === void 0 ? this._defaultValue : val;
    }
    set value(newVal) {
        this._object[this._key] = newVal;
    }
    get dep() {
        return getDepFromReactive(toRaw(this._object), this._key);
    }
}
class GetterRefImpl {
    constructor(_getter){
        this._getter = _getter;
        this.__v_isRef = true;
        this.__v_isReadonly = true;
    }
    get value() {
        return this._getter();
    }
}
function toRef(source, key, defaultValue) {
    if (isRef(source)) return source;
    else if ((0, _shared.isFunction)(source)) return new GetterRefImpl(source);
    else if ((0, _shared.isObject)(source) && arguments.length > 1) return propertyToRef(source, key, defaultValue);
    else return ref(source);
}
function propertyToRef(source, key, defaultValue) {
    const val = source[key];
    return isRef(val) ? val : new ObjectRefImpl(source, key, defaultValue);
}
class ComputedRefImpl {
    constructor(getter, _setter, isReadonly, isSSR){
        this._setter = _setter;
        this.dep = void 0;
        this.__v_isRef = true;
        this["__v_isReadonly"] = false;
        this._dirty = true;
        this.effect = new ReactiveEffect(getter, ()=>{
            if (!this._dirty) {
                this._dirty = true;
                triggerRefValue(this);
            }
        });
        this.effect.computed = this;
        this.effect.active = this._cacheable = !isSSR;
        this["__v_isReadonly"] = isReadonly;
    }
    get value() {
        const self = toRaw(this);
        trackRefValue(self);
        if (self._dirty || !self._cacheable) {
            self._dirty = false;
            self._value = self.effect.run();
        }
        return self._value;
    }
    set value(newValue) {
        this._setter(newValue);
    }
}
function computed(getterOrOptions, debugOptions, isSSR = false) {
    let getter;
    let setter;
    const onlyGetter = (0, _shared.isFunction)(getterOrOptions);
    if (onlyGetter) {
        getter = getterOrOptions;
        setter = ()=>{
            console.warn("Write operation failed: computed value is readonly");
        };
    } else {
        getter = getterOrOptions.get;
        setter = getterOrOptions.set;
    }
    const cRef = new ComputedRefImpl(getter, setter, onlyGetter || !setter, isSSR);
    if (debugOptions && !isSSR) {
        cRef.effect.onTrack = debugOptions.onTrack;
        cRef.effect.onTrigger = debugOptions.onTrigger;
    }
    return cRef;
}
const tick = /* @__PURE__ */ Promise.resolve();
const queue = [];
let queued = false;
const scheduler = (fn)=>{
    queue.push(fn);
    if (!queued) {
        queued = true;
        tick.then(flush);
    }
};
const flush = ()=>{
    for(let i = 0; i < queue.length; i++)queue[i]();
    queue.length = 0;
    queued = false;
};
class DeferredComputedRefImpl {
    constructor(getter){
        this.dep = void 0;
        this._dirty = true;
        this.__v_isRef = true;
        this["__v_isReadonly"] = true;
        let compareTarget;
        let hasCompareTarget = false;
        let scheduled = false;
        this.effect = new ReactiveEffect(getter, (computedTrigger)=>{
            if (this.dep) {
                if (computedTrigger) {
                    compareTarget = this._value;
                    hasCompareTarget = true;
                } else if (!scheduled) {
                    const valueToCompare = hasCompareTarget ? compareTarget : this._value;
                    scheduled = true;
                    hasCompareTarget = false;
                    scheduler(()=>{
                        if (this.effect.active && this._get() !== valueToCompare) triggerRefValue(this);
                        scheduled = false;
                    });
                }
                for (const e of this.dep)if (e.computed instanceof DeferredComputedRefImpl) e.scheduler(true);
            }
            this._dirty = true;
        });
        this.effect.computed = this;
    }
    _get() {
        if (this._dirty) {
            this._dirty = false;
            return this._value = this.effect.run();
        }
        return this._value;
    }
    get value() {
        trackRefValue(this);
        return toRaw(this)._get();
    }
}
function deferredComputed(getter) {
    return new DeferredComputedRefImpl(getter);
}

},{"@vue/shared":"5YL8y","@parcel/transformer-js/src/esmodule-helpers.js":"boKlo"}],"5YL8y":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "EMPTY_ARR", ()=>EMPTY_ARR);
parcelHelpers.export(exports, "EMPTY_OBJ", ()=>EMPTY_OBJ);
parcelHelpers.export(exports, "NO", ()=>NO);
parcelHelpers.export(exports, "NOOP", ()=>NOOP);
parcelHelpers.export(exports, "PatchFlagNames", ()=>PatchFlagNames);
parcelHelpers.export(exports, "camelize", ()=>camelize);
parcelHelpers.export(exports, "capitalize", ()=>capitalize);
parcelHelpers.export(exports, "def", ()=>def);
parcelHelpers.export(exports, "escapeHtml", ()=>escapeHtml);
parcelHelpers.export(exports, "escapeHtmlComment", ()=>escapeHtmlComment);
parcelHelpers.export(exports, "extend", ()=>extend);
parcelHelpers.export(exports, "genPropsAccessExp", ()=>genPropsAccessExp);
parcelHelpers.export(exports, "generateCodeFrame", ()=>generateCodeFrame);
parcelHelpers.export(exports, "getGlobalThis", ()=>getGlobalThis);
parcelHelpers.export(exports, "hasChanged", ()=>hasChanged);
parcelHelpers.export(exports, "hasOwn", ()=>hasOwn);
parcelHelpers.export(exports, "hyphenate", ()=>hyphenate);
parcelHelpers.export(exports, "includeBooleanAttr", ()=>includeBooleanAttr);
parcelHelpers.export(exports, "invokeArrayFns", ()=>invokeArrayFns);
parcelHelpers.export(exports, "isArray", ()=>isArray);
parcelHelpers.export(exports, "isBooleanAttr", ()=>isBooleanAttr);
parcelHelpers.export(exports, "isBuiltInDirective", ()=>isBuiltInDirective);
parcelHelpers.export(exports, "isDate", ()=>isDate);
parcelHelpers.export(exports, "isFunction", ()=>isFunction);
parcelHelpers.export(exports, "isGloballyWhitelisted", ()=>isGloballyWhitelisted);
parcelHelpers.export(exports, "isHTMLTag", ()=>isHTMLTag);
parcelHelpers.export(exports, "isIntegerKey", ()=>isIntegerKey);
parcelHelpers.export(exports, "isKnownHtmlAttr", ()=>isKnownHtmlAttr);
parcelHelpers.export(exports, "isKnownSvgAttr", ()=>isKnownSvgAttr);
parcelHelpers.export(exports, "isMap", ()=>isMap);
parcelHelpers.export(exports, "isModelListener", ()=>isModelListener);
parcelHelpers.export(exports, "isObject", ()=>isObject);
parcelHelpers.export(exports, "isOn", ()=>isOn);
parcelHelpers.export(exports, "isPlainObject", ()=>isPlainObject);
parcelHelpers.export(exports, "isPromise", ()=>isPromise);
parcelHelpers.export(exports, "isRegExp", ()=>isRegExp);
parcelHelpers.export(exports, "isReservedProp", ()=>isReservedProp);
parcelHelpers.export(exports, "isSSRSafeAttrName", ()=>isSSRSafeAttrName);
parcelHelpers.export(exports, "isSVGTag", ()=>isSVGTag);
parcelHelpers.export(exports, "isSet", ()=>isSet);
parcelHelpers.export(exports, "isSpecialBooleanAttr", ()=>isSpecialBooleanAttr);
parcelHelpers.export(exports, "isString", ()=>isString);
parcelHelpers.export(exports, "isSymbol", ()=>isSymbol);
parcelHelpers.export(exports, "isVoidTag", ()=>isVoidTag);
parcelHelpers.export(exports, "looseEqual", ()=>looseEqual);
parcelHelpers.export(exports, "looseIndexOf", ()=>looseIndexOf);
parcelHelpers.export(exports, "looseToNumber", ()=>looseToNumber);
parcelHelpers.export(exports, "makeMap", ()=>makeMap);
parcelHelpers.export(exports, "normalizeClass", ()=>normalizeClass);
parcelHelpers.export(exports, "normalizeProps", ()=>normalizeProps);
parcelHelpers.export(exports, "normalizeStyle", ()=>normalizeStyle);
parcelHelpers.export(exports, "objectToString", ()=>objectToString);
parcelHelpers.export(exports, "parseStringStyle", ()=>parseStringStyle);
parcelHelpers.export(exports, "propsToAttrMap", ()=>propsToAttrMap);
parcelHelpers.export(exports, "remove", ()=>remove);
parcelHelpers.export(exports, "slotFlagsText", ()=>slotFlagsText);
parcelHelpers.export(exports, "stringifyStyle", ()=>stringifyStyle);
parcelHelpers.export(exports, "toDisplayString", ()=>toDisplayString);
parcelHelpers.export(exports, "toHandlerKey", ()=>toHandlerKey);
parcelHelpers.export(exports, "toNumber", ()=>toNumber);
parcelHelpers.export(exports, "toRawType", ()=>toRawType);
parcelHelpers.export(exports, "toTypeString", ()=>toTypeString);
var global = arguments[3];
function makeMap(str, expectsLowerCase) {
    const map = /* @__PURE__ */ Object.create(null);
    const list = str.split(",");
    for(let i = 0; i < list.length; i++)map[list[i]] = true;
    return expectsLowerCase ? (val)=>!!map[val.toLowerCase()] : (val)=>!!map[val];
}
const EMPTY_OBJ = Object.freeze({});
const EMPTY_ARR = Object.freeze([]);
const NOOP = ()=>{};
const NO = ()=>false;
const onRE = /^on[^a-z]/;
const isOn = (key)=>onRE.test(key);
const isModelListener = (key)=>key.startsWith("onUpdate:");
const extend = Object.assign;
const remove = (arr, el)=>{
    const i = arr.indexOf(el);
    if (i > -1) arr.splice(i, 1);
};
const hasOwnProperty = Object.prototype.hasOwnProperty;
const hasOwn = (val, key)=>hasOwnProperty.call(val, key);
const isArray = Array.isArray;
const isMap = (val)=>toTypeString(val) === "[object Map]";
const isSet = (val)=>toTypeString(val) === "[object Set]";
const isDate = (val)=>toTypeString(val) === "[object Date]";
const isRegExp = (val)=>toTypeString(val) === "[object RegExp]";
const isFunction = (val)=>typeof val === "function";
const isString = (val)=>typeof val === "string";
const isSymbol = (val)=>typeof val === "symbol";
const isObject = (val)=>val !== null && typeof val === "object";
const isPromise = (val)=>{
    return isObject(val) && isFunction(val.then) && isFunction(val.catch);
};
const objectToString = Object.prototype.toString;
const toTypeString = (value)=>objectToString.call(value);
const toRawType = (value)=>{
    return toTypeString(value).slice(8, -1);
};
const isPlainObject = (val)=>toTypeString(val) === "[object Object]";
const isIntegerKey = (key)=>isString(key) && key !== "NaN" && key[0] !== "-" && "" + parseInt(key, 10) === key;
const isReservedProp = /* @__PURE__ */ makeMap(// the leading comma is intentional so empty string "" is also included
",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted");
const isBuiltInDirective = /* @__PURE__ */ makeMap("bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo");
const cacheStringFunction = (fn)=>{
    const cache = /* @__PURE__ */ Object.create(null);
    return (str)=>{
        const hit = cache[str];
        return hit || (cache[str] = fn(str));
    };
};
const camelizeRE = /-(\w)/g;
const camelize = cacheStringFunction((str)=>{
    return str.replace(camelizeRE, (_, c)=>c ? c.toUpperCase() : "");
});
const hyphenateRE = /\B([A-Z])/g;
const hyphenate = cacheStringFunction((str)=>str.replace(hyphenateRE, "-$1").toLowerCase());
const capitalize = cacheStringFunction((str)=>str.charAt(0).toUpperCase() + str.slice(1));
const toHandlerKey = cacheStringFunction((str)=>str ? `on${capitalize(str)}` : ``);
const hasChanged = (value, oldValue)=>!Object.is(value, oldValue);
const invokeArrayFns = (fns, arg)=>{
    for(let i = 0; i < fns.length; i++)fns[i](arg);
};
const def = (obj, key, value)=>{
    Object.defineProperty(obj, key, {
        configurable: true,
        enumerable: false,
        value
    });
};
const looseToNumber = (val)=>{
    const n = parseFloat(val);
    return isNaN(n) ? val : n;
};
const toNumber = (val)=>{
    const n = isString(val) ? Number(val) : NaN;
    return isNaN(n) ? val : n;
};
let _globalThis;
const getGlobalThis = ()=>{
    return _globalThis || (_globalThis = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
};
const identRE = /^[_$a-zA-Z\xA0-\uFFFF][_$a-zA-Z0-9\xA0-\uFFFF]*$/;
function genPropsAccessExp(name) {
    return identRE.test(name) ? `__props.${name}` : `__props[${JSON.stringify(name)}]`;
}
const PatchFlagNames = {
    [1]: `TEXT`,
    [2]: `CLASS`,
    [4]: `STYLE`,
    [8]: `PROPS`,
    [16]: `FULL_PROPS`,
    [32]: `HYDRATE_EVENTS`,
    [64]: `STABLE_FRAGMENT`,
    [128]: `KEYED_FRAGMENT`,
    [256]: `UNKEYED_FRAGMENT`,
    [512]: `NEED_PATCH`,
    [1024]: `DYNAMIC_SLOTS`,
    [2048]: `DEV_ROOT_FRAGMENT`,
    [-1]: `HOISTED`,
    [-2]: `BAIL`
};
const slotFlagsText = {
    [1]: "STABLE",
    [2]: "DYNAMIC",
    [3]: "FORWARDED"
};
const GLOBALS_WHITE_LISTED = "Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt,console";
const isGloballyWhitelisted = /* @__PURE__ */ makeMap(GLOBALS_WHITE_LISTED);
const range = 2;
function generateCodeFrame(source, start = 0, end = source.length) {
    let lines = source.split(/(\r?\n)/);
    const newlineSequences = lines.filter((_, idx)=>idx % 2 === 1);
    lines = lines.filter((_, idx)=>idx % 2 === 0);
    let count = 0;
    const res = [];
    for(let i = 0; i < lines.length; i++){
        count += lines[i].length + (newlineSequences[i] && newlineSequences[i].length || 0);
        if (count >= start) {
            for(let j = i - range; j <= i + range || end > count; j++){
                if (j < 0 || j >= lines.length) continue;
                const line = j + 1;
                res.push(`${line}${" ".repeat(Math.max(3 - String(line).length, 0))}|  ${lines[j]}`);
                const lineLength = lines[j].length;
                const newLineSeqLength = newlineSequences[j] && newlineSequences[j].length || 0;
                if (j === i) {
                    const pad = start - (count - (lineLength + newLineSeqLength));
                    const length = Math.max(1, end > count ? lineLength - pad : end - start);
                    res.push(`   |  ` + " ".repeat(pad) + "^".repeat(length));
                } else if (j > i) {
                    if (end > count) {
                        const length = Math.max(Math.min(end - count, lineLength), 1);
                        res.push(`   |  ` + "^".repeat(length));
                    }
                    count += lineLength + newLineSeqLength;
                }
            }
            break;
        }
    }
    return res.join("\n");
}
function normalizeStyle(value) {
    if (isArray(value)) {
        const res = {};
        for(let i = 0; i < value.length; i++){
            const item = value[i];
            const normalized = isString(item) ? parseStringStyle(item) : normalizeStyle(item);
            if (normalized) for(const key in normalized)res[key] = normalized[key];
        }
        return res;
    } else if (isString(value)) return value;
    else if (isObject(value)) return value;
}
const listDelimiterRE = /;(?![^(]*\))/g;
const propertyDelimiterRE = /:([^]+)/;
const styleCommentRE = /\/\*[^]*?\*\//g;
function parseStringStyle(cssText) {
    const ret = {};
    cssText.replace(styleCommentRE, "").split(listDelimiterRE).forEach((item)=>{
        if (item) {
            const tmp = item.split(propertyDelimiterRE);
            tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
        }
    });
    return ret;
}
function stringifyStyle(styles) {
    let ret = "";
    if (!styles || isString(styles)) return ret;
    for(const key in styles){
        const value = styles[key];
        const normalizedKey = key.startsWith(`--`) ? key : hyphenate(key);
        if (isString(value) || typeof value === "number") ret += `${normalizedKey}:${value};`;
    }
    return ret;
}
function normalizeClass(value) {
    let res = "";
    if (isString(value)) res = value;
    else if (isArray(value)) for(let i = 0; i < value.length; i++){
        const normalized = normalizeClass(value[i]);
        if (normalized) res += normalized + " ";
    }
    else if (isObject(value)) {
        for(const name in value)if (value[name]) res += name + " ";
    }
    return res.trim();
}
function normalizeProps(props) {
    if (!props) return null;
    let { class: klass, style } = props;
    if (klass && !isString(klass)) props.class = normalizeClass(klass);
    if (style) props.style = normalizeStyle(style);
    return props;
}
const HTML_TAGS = "html,body,base,head,link,meta,style,title,address,article,aside,footer,header,hgroup,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot";
const SVG_TAGS = "svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistantLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,text,textPath,title,tspan,unknown,use,view";
const VOID_TAGS = "area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr";
const isHTMLTag = /* @__PURE__ */ makeMap(HTML_TAGS);
const isSVGTag = /* @__PURE__ */ makeMap(SVG_TAGS);
const isVoidTag = /* @__PURE__ */ makeMap(VOID_TAGS);
const specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
const isSpecialBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs);
const isBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs + `,async,autofocus,autoplay,controls,default,defer,disabled,hidden,inert,loop,open,required,reversed,scoped,seamless,checked,muted,multiple,selected`);
function includeBooleanAttr(value) {
    return !!value || value === "";
}
const unsafeAttrCharRE = /[>/="'\u0009\u000a\u000c\u0020]/;
const attrValidationCache = {};
function isSSRSafeAttrName(name) {
    if (attrValidationCache.hasOwnProperty(name)) return attrValidationCache[name];
    const isUnsafe = unsafeAttrCharRE.test(name);
    if (isUnsafe) console.error(`unsafe attribute name: ${name}`);
    return attrValidationCache[name] = !isUnsafe;
}
const propsToAttrMap = {
    acceptCharset: "accept-charset",
    className: "class",
    htmlFor: "for",
    httpEquiv: "http-equiv"
};
const isKnownHtmlAttr = /* @__PURE__ */ makeMap(`accept,accept-charset,accesskey,action,align,allow,alt,async,autocapitalize,autocomplete,autofocus,autoplay,background,bgcolor,border,buffered,capture,challenge,charset,checked,cite,class,code,codebase,color,cols,colspan,content,contenteditable,contextmenu,controls,coords,crossorigin,csp,data,datetime,decoding,default,defer,dir,dirname,disabled,download,draggable,dropzone,enctype,enterkeyhint,for,form,formaction,formenctype,formmethod,formnovalidate,formtarget,headers,height,hidden,high,href,hreflang,http-equiv,icon,id,importance,inert,integrity,ismap,itemprop,keytype,kind,label,lang,language,loading,list,loop,low,manifest,max,maxlength,minlength,media,min,multiple,muted,name,novalidate,open,optimum,pattern,ping,placeholder,poster,preload,radiogroup,readonly,referrerpolicy,rel,required,reversed,rows,rowspan,sandbox,scope,scoped,selected,shape,size,sizes,slot,span,spellcheck,src,srcdoc,srclang,srcset,start,step,style,summary,tabindex,target,title,translate,type,usemap,value,width,wrap`);
const isKnownSvgAttr = /* @__PURE__ */ makeMap(`xmlns,accent-height,accumulate,additive,alignment-baseline,alphabetic,amplitude,arabic-form,ascent,attributeName,attributeType,azimuth,baseFrequency,baseline-shift,baseProfile,bbox,begin,bias,by,calcMode,cap-height,class,clip,clipPathUnits,clip-path,clip-rule,color,color-interpolation,color-interpolation-filters,color-profile,color-rendering,contentScriptType,contentStyleType,crossorigin,cursor,cx,cy,d,decelerate,descent,diffuseConstant,direction,display,divisor,dominant-baseline,dur,dx,dy,edgeMode,elevation,enable-background,end,exponent,fill,fill-opacity,fill-rule,filter,filterRes,filterUnits,flood-color,flood-opacity,font-family,font-size,font-size-adjust,font-stretch,font-style,font-variant,font-weight,format,from,fr,fx,fy,g1,g2,glyph-name,glyph-orientation-horizontal,glyph-orientation-vertical,glyphRef,gradientTransform,gradientUnits,hanging,height,href,hreflang,horiz-adv-x,horiz-origin-x,id,ideographic,image-rendering,in,in2,intercept,k,k1,k2,k3,k4,kernelMatrix,kernelUnitLength,kerning,keyPoints,keySplines,keyTimes,lang,lengthAdjust,letter-spacing,lighting-color,limitingConeAngle,local,marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,mask,maskContentUnits,maskUnits,mathematical,max,media,method,min,mode,name,numOctaves,offset,opacity,operator,order,orient,orientation,origin,overflow,overline-position,overline-thickness,panose-1,paint-order,path,pathLength,patternContentUnits,patternTransform,patternUnits,ping,pointer-events,points,pointsAtX,pointsAtY,pointsAtZ,preserveAlpha,preserveAspectRatio,primitiveUnits,r,radius,referrerPolicy,refX,refY,rel,rendering-intent,repeatCount,repeatDur,requiredExtensions,requiredFeatures,restart,result,rotate,rx,ry,scale,seed,shape-rendering,slope,spacing,specularConstant,specularExponent,speed,spreadMethod,startOffset,stdDeviation,stemh,stemv,stitchTiles,stop-color,stop-opacity,strikethrough-position,strikethrough-thickness,string,stroke,stroke-dasharray,stroke-dashoffset,stroke-linecap,stroke-linejoin,stroke-miterlimit,stroke-opacity,stroke-width,style,surfaceScale,systemLanguage,tabindex,tableValues,target,targetX,targetY,text-anchor,text-decoration,text-rendering,textLength,to,transform,transform-origin,type,u1,u2,underline-position,underline-thickness,unicode,unicode-bidi,unicode-range,units-per-em,v-alphabetic,v-hanging,v-ideographic,v-mathematical,values,vector-effect,version,vert-adv-y,vert-origin-x,vert-origin-y,viewBox,viewTarget,visibility,width,widths,word-spacing,writing-mode,x,x-height,x1,x2,xChannelSelector,xlink:actuate,xlink:arcrole,xlink:href,xlink:role,xlink:show,xlink:title,xlink:type,xml:base,xml:lang,xml:space,y,y1,y2,yChannelSelector,z,zoomAndPan`);
const escapeRE = /["'&<>]/;
function escapeHtml(string) {
    const str = "" + string;
    const match = escapeRE.exec(str);
    if (!match) return str;
    let html = "";
    let escaped;
    let index;
    let lastIndex = 0;
    for(index = match.index; index < str.length; index++){
        switch(str.charCodeAt(index)){
            case 34:
                escaped = "&quot;";
                break;
            case 38:
                escaped = "&amp;";
                break;
            case 39:
                escaped = "&#39;";
                break;
            case 60:
                escaped = "&lt;";
                break;
            case 62:
                escaped = "&gt;";
                break;
            default:
                continue;
        }
        if (lastIndex !== index) html += str.slice(lastIndex, index);
        lastIndex = index + 1;
        html += escaped;
    }
    return lastIndex !== index ? html + str.slice(lastIndex, index) : html;
}
const commentStripRE = /^-?>|<!--|-->|--!>|<!-$/g;
function escapeHtmlComment(src) {
    return src.replace(commentStripRE, "");
}
function looseCompareArrays(a, b) {
    if (a.length !== b.length) return false;
    let equal = true;
    for(let i = 0; equal && i < a.length; i++)equal = looseEqual(a[i], b[i]);
    return equal;
}
function looseEqual(a, b) {
    if (a === b) return true;
    let aValidType = isDate(a);
    let bValidType = isDate(b);
    if (aValidType || bValidType) return aValidType && bValidType ? a.getTime() === b.getTime() : false;
    aValidType = isSymbol(a);
    bValidType = isSymbol(b);
    if (aValidType || bValidType) return a === b;
    aValidType = isArray(a);
    bValidType = isArray(b);
    if (aValidType || bValidType) return aValidType && bValidType ? looseCompareArrays(a, b) : false;
    aValidType = isObject(a);
    bValidType = isObject(b);
    if (aValidType || bValidType) {
        if (!aValidType || !bValidType) return false;
        const aKeysCount = Object.keys(a).length;
        const bKeysCount = Object.keys(b).length;
        if (aKeysCount !== bKeysCount) return false;
        for(const key in a){
            const aHasKey = a.hasOwnProperty(key);
            const bHasKey = b.hasOwnProperty(key);
            if (aHasKey && !bHasKey || !aHasKey && bHasKey || !looseEqual(a[key], b[key])) return false;
        }
    }
    return String(a) === String(b);
}
function looseIndexOf(arr, val) {
    return arr.findIndex((item)=>looseEqual(item, val));
}
const toDisplayString = (val)=>{
    return isString(val) ? val : val == null ? "" : isArray(val) || isObject(val) && (val.toString === objectToString || !isFunction(val.toString)) ? JSON.stringify(val, replacer, 2) : String(val);
};
const replacer = (_key, val)=>{
    if (val && val.__v_isRef) return replacer(_key, val.value);
    else if (isMap(val)) return {
        [`Map(${val.size})`]: [
            ...val.entries()
        ].reduce((entries, [key, val2])=>{
            entries[`${key} =>`] = val2;
            return entries;
        }, {})
    };
    else if (isSet(val)) return {
        [`Set(${val.size})`]: [
            ...val.values()
        ]
    };
    else if (isObject(val) && !isArray(val) && !isPlainObject(val)) return String(val);
    return val;
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"boKlo"}],"boKlo":[function(require,module,exports) {
exports.interopDefault = function(a) {
    return a && a.__esModule ? a : {
        default: a
    };
};
exports.defineInteropFlag = function(a) {
    Object.defineProperty(a, "__esModule", {
        value: true
    });
};
exports.exportAll = function(source, dest) {
    Object.keys(source).forEach(function(key) {
        if (key === "default" || key === "__esModule" || dest.hasOwnProperty(key)) return;
        Object.defineProperty(dest, key, {
            enumerable: true,
            get: function() {
                return source[key];
            }
        });
    });
    return dest;
};
exports.export = function(dest, destName, get) {
    Object.defineProperty(dest, destName, {
        enumerable: true,
        get: get
    });
};

},{}],"43z63":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
let script;
let initialize = ()=>{
    script = require("7d7a5419a72d0ec2");
    if (script.__esModule) script = script.default;
    script.render = require("85790bfb39e84d55").render;
    script.__cssModules = require("ded6c04294cb6814").default;
    require("6db9042b7ea1c2b5").default(script);
    script.__scopeId = "data-v-710b65";
    script.__file = "/Users/davidzimberknopf/Documents/Apps/vue-plasmo-text/src/popup.vue";
};
initialize();
if (module.hot) {
    script.__hmrId = "710b65-hmr";
    module.hot.accept(()=>{
        setTimeout(()=>{
            initialize();
            if (!__VUE_HMR_RUNTIME__.createRecord("710b65-hmr", script)) __VUE_HMR_RUNTIME__.reload("710b65-hmr", script);
        }, 0);
    });
}
exports.default = script;

},{"7d7a5419a72d0ec2":"g7714","85790bfb39e84d55":"38JGT","6db9042b7ea1c2b5":"2saEx","@parcel/transformer-js/src/esmodule-helpers.js":"boKlo","ded6c04294cb6814":"95MeF"}],"g7714":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _vue = require("vue");
var _appVue = require("./App.vue");
var _appVueDefault = parcelHelpers.interopDefault(_appVue);
exports.default = /*#__PURE__*/ (0, _vue.defineComponent)({
    __name: "popup",
    setup (__props, { expose: __expose }) {
        __expose();
        const __returned__ = {
            AppWidget: (0, _appVueDefault.default)
        };
        Object.defineProperty(__returned__, "__isScriptSetup", {
            enumerable: false,
            value: true
        });
        return __returned__;
    }
});

},{"vue":"dmrjI","@parcel/transformer-js/src/esmodule-helpers.js":"boKlo","./App.vue":"6QgOV"}],"6QgOV":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
let script;
let initialize = ()=>{
    script = require("29158dae54139136");
    if (script.__esModule) script = script.default;
    script.render = require("8a4954974a3e2a08").render;
    script.__cssModules = require("f5f81ab60053088e").default;
    require("7e9898e9b122e745").default(script);
    script.__scopeId = "data-v-041961";
    script.__file = "/Users/davidzimberknopf/Documents/Apps/vue-plasmo-text/src/App.vue";
};
initialize();
if (module.hot) {
    script.__hmrId = "041961-hmr";
    module.hot.accept(()=>{
        setTimeout(()=>{
            initialize();
            if (!__VUE_HMR_RUNTIME__.createRecord("041961-hmr", script)) __VUE_HMR_RUNTIME__.reload("041961-hmr", script);
        }, 0);
    });
}
exports.default = script;

},{"29158dae54139136":"80M9n","8a4954974a3e2a08":"9oijb","f5f81ab60053088e":"8CTwa","7e9898e9b122e745":"9hwKF","@parcel/transformer-js/src/esmodule-helpers.js":"boKlo"}],"80M9n":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _vue = require("vue");
var _helloWorldVue = require("./components/HelloWorld.vue");
var _helloWorldVueDefault = parcelHelpers.interopDefault(_helloWorldVue);
exports.default = /*#__PURE__*/ (0, _vue.defineComponent)({
    __name: "App",
    setup (__props, { expose: __expose }) {
        __expose();
        const __returned__ = {
            HelloWorld: (0, _helloWorldVueDefault.default)
        };
        Object.defineProperty(__returned__, "__isScriptSetup", {
            enumerable: false,
            value: true
        });
        return __returned__;
    }
});

},{"vue":"dmrjI","./components/HelloWorld.vue":"gH8Yv","@parcel/transformer-js/src/esmodule-helpers.js":"boKlo"}],"gH8Yv":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
let script;
let initialize = ()=>{
    script = require("92f333d20e158605");
    if (script.__esModule) script = script.default;
    script.render = require("cb47be8f05cd37f6").render;
    script.__cssModules = require("9da11a393ef97a55").default;
    require("868c11f6879346b4").default(script);
    script.__scopeId = "data-v-838f69";
    script.__file = "/Users/davidzimberknopf/Documents/Apps/vue-plasmo-text/src/components/HelloWorld.vue";
};
initialize();
if (module.hot) {
    script.__hmrId = "838f69-hmr";
    module.hot.accept(()=>{
        setTimeout(()=>{
            initialize();
            if (!__VUE_HMR_RUNTIME__.createRecord("838f69-hmr", script)) __VUE_HMR_RUNTIME__.reload("838f69-hmr", script);
        }, 0);
    });
}
exports.default = script;

},{"92f333d20e158605":"hOOxl","cb47be8f05cd37f6":"isfIG","9da11a393ef97a55":"lj2Ye","868c11f6879346b4":"7GQV6","@parcel/transformer-js/src/esmodule-helpers.js":"boKlo"}],"hOOxl":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _vue = require("vue");
exports.default = /*#__PURE__*/ (0, _vue.defineComponent)({
    __name: "HelloWorld",
    props: {
        msg: {
            type: String,
            required: true
        }
    },
    setup (__props, { expose: __expose }) {
        __expose();
        const count = (0, _vue.ref)(0);
        const __returned__ = {
            count
        };
        Object.defineProperty(__returned__, "__isScriptSetup", {
            enumerable: false,
            value: true
        });
        return __returned__;
    }
});

},{"vue":"dmrjI","@parcel/transformer-js/src/esmodule-helpers.js":"boKlo"}],"isfIG":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "render", ()=>render);
var _vue = require("vue");
const _withScopeId = (n)=>((0, _vue.pushScopeId)("data-v-838f69"), n = n(), (0, _vue.popScopeId)(), n);
const _hoisted_1 = {
    class: "card"
};
const _hoisted_2 = /*#__PURE__*/ _withScopeId(()=>/*#__PURE__*/ (0, _vue.createElementVNode)("p", null, [
        /*#__PURE__*/ (0, _vue.createTextVNode)(" Edit "),
        /*#__PURE__*/ (0, _vue.createElementVNode)("code", null, "components/HelloWorld.vue"),
        /*#__PURE__*/ (0, _vue.createTextVNode)(" to test HMR ")
    ], -1 /* HOISTED */ ));
const _hoisted_3 = /*#__PURE__*/ _withScopeId(()=>/*#__PURE__*/ (0, _vue.createElementVNode)("p", null, [
        /*#__PURE__*/ (0, _vue.createTextVNode)(" Check out "),
        /*#__PURE__*/ (0, _vue.createElementVNode)("a", {
            href: "https://vuejs.org/guide/quick-start.html#local",
            target: "_blank"
        }, "create-vue"),
        /*#__PURE__*/ (0, _vue.createTextVNode)(", the official Vue + Vite starter ")
    ], -1 /* HOISTED */ ));
const _hoisted_4 = /*#__PURE__*/ _withScopeId(()=>/*#__PURE__*/ (0, _vue.createElementVNode)("p", null, [
        /*#__PURE__*/ (0, _vue.createTextVNode)(" Install "),
        /*#__PURE__*/ (0, _vue.createElementVNode)("a", {
            href: "https://github.com/vuejs/language-tools",
            target: "_blank"
        }, "Volar"),
        /*#__PURE__*/ (0, _vue.createTextVNode)(" in your IDE for a better DX ")
    ], -1 /* HOISTED */ ));
const _hoisted_5 = /*#__PURE__*/ _withScopeId(()=>/*#__PURE__*/ (0, _vue.createElementVNode)("p", {
        class: "read-the-docs"
    }, "Click on the Vite and Vue logos to learn more", -1 /* HOISTED */ ));
function render(_ctx, _cache, $props, $setup, $data, $options) {
    return (0, _vue.openBlock)(), (0, _vue.createElementBlock)((0, _vue.Fragment), null, [
        (0, _vue.createElementVNode)("h1", null, (0, _vue.toDisplayString)($props.msg), 1 /* TEXT */ ),
        (0, _vue.createElementVNode)("div", _hoisted_1, [
            (0, _vue.createElementVNode)("button", {
                type: "button",
                onClick: _cache[0] || (_cache[0] = ($event)=>$setup.count++)
            }, "count is " + (0, _vue.toDisplayString)($setup.count), 1 /* TEXT */ ),
            _hoisted_2
        ]),
        _hoisted_3,
        _hoisted_4,
        _hoisted_5
    ], 64 /* STABLE_FRAGMENT */ );
}
if (module.hot) module.hot.accept(()=>{
    __VUE_HMR_RUNTIME__.rerender("838f69-hmr", render);
});

},{"vue":"dmrjI","@parcel/transformer-js/src/esmodule-helpers.js":"boKlo"}],"lj2Ye":[function() {},{}],"7GQV6":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
let NOOP = ()=>{};
exports.default = (script)=>{};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"boKlo"}],"9oijb":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "render", ()=>render);
var _vue = require("vue");
var _vueSvg = require("./assets/vue.svg");
var _vueSvgDefault = parcelHelpers.interopDefault(_vueSvg);
const _withScopeId = (n)=>((0, _vue.pushScopeId)("data-v-041961"), n = n(), (0, _vue.popScopeId)(), n);
const _hoisted_1 = /*#__PURE__*/ (0, _vue.createStaticVNode)('<div class="body" data-v-041961><a href="https://vitejs.dev" target="_blank" data-v-041961><img src="/vite.svg" class="logo" alt="Vite logo" data-v-041961></a><a href="https://vuejs.org/" target="_blank" data-v-041961><img src="' + (0, _vueSvgDefault.default) + '" class="logo vue" alt="Vue logo" data-v-041961></a></div>', 1);
function render(_ctx, _cache, $props, $setup, $data, $options) {
    return (0, _vue.openBlock)(), (0, _vue.createElementBlock)((0, _vue.Fragment), null, [
        _hoisted_1,
        (0, _vue.createVNode)($setup["HelloWorld"], {
            msg: "Vite + Vue"
        })
    ], 64 /* STABLE_FRAGMENT */ );
}
if (module.hot) module.hot.accept(()=>{
    __VUE_HMR_RUNTIME__.rerender("041961-hmr", render);
});

},{"vue":"dmrjI","./assets/vue.svg":"iFMZH","@parcel/transformer-js/src/esmodule-helpers.js":"boKlo"}],"iFMZH":[function(require,module,exports) {
module.exports = require("d66b18f3ab833fab").getBundleURL("ceSdd") + "vue.a3ce0b68.svg" + "?" + Date.now();

},{"d66b18f3ab833fab":"eCfaW"}],"eCfaW":[function(require,module,exports) {
"use strict";
var bundleURL = {};
function getBundleURLCached(id) {
    var value = bundleURL[id];
    if (!value) {
        value = getBundleURL();
        bundleURL[id] = value;
    }
    return value;
}
function getBundleURL() {
    try {
        throw new Error();
    } catch (err) {
        var matches = ("" + err.stack).match(/(https?|file|ftp|(chrome|moz|safari-web)-extension):\/\/[^)\n]+/g);
        if (matches) // The first two stack frames will be this function and getBundleURLCached.
        // Use the 3rd one, which will be a runtime in the original bundle.
        return getBaseURL(matches[2]);
    }
    return "/";
}
function getBaseURL(url) {
    return ("" + url).replace(/^((?:https?|file|ftp|(chrome|moz|safari-web)-extension):\/\/.+)\/[^/]+$/, "$1") + "/";
}
// TODO: Replace uses with `new URL(url).origin` when ie11 is no longer supported.
function getOrigin(url) {
    var matches = ("" + url).match(/(https?|file|ftp|(chrome|moz|safari-web)-extension):\/\/[^/]+/);
    if (!matches) throw new Error("Origin not found");
    return matches[0];
}
exports.getBundleURL = getBundleURLCached;
exports.getBaseURL = getBaseURL;
exports.getOrigin = getOrigin;

},{}],"8CTwa":[function() {},{}],"9hwKF":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
let NOOP = ()=>{};
exports.default = (script)=>{};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"boKlo"}],"38JGT":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "render", ()=>render);
var _vue = require("vue");
function render(_ctx, _cache, $props, $setup, $data, $options) {
    return (0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", null, [
        (0, _vue.createVNode)($setup["AppWidget"])
    ]);
}
if (module.hot) module.hot.accept(()=>{
    __VUE_HMR_RUNTIME__.rerender("710b65-hmr", render);
});

},{"vue":"dmrjI","@parcel/transformer-js/src/esmodule-helpers.js":"boKlo"}],"2saEx":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
let NOOP = ()=>{};
exports.default = (script)=>{};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"boKlo"}],"95MeF":[function() {},{}],"4j7Mh":[function(require,module,exports) {
globalThis.__VUE_OPTIONS_API__ = true;
globalThis.__VUE_PROD_DEVTOOLS__ = true;

},{}]},["9oFvy","4z694"], "4z694", "parcelRequire05f1")

//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUMsRUFBRSxFQUFDLEFBQUMsQ0FBQSxNQUFJLEtBQUcsTUFBTSxRQUFRLE1BQUksQ0FBQyxDQUFDLEVBQUUsU0FBTyxFQUFFLEtBQUcsQ0FBQSxLQUFJLEVBQUUsS0FBSztRQUFDO1FBQUU7S0FBRTtJQUFFLE9BQU8sRUFBRSxVQUFTLENBQUEsSUFBRSxFQUFFLE9BQU8sRUFBRSxFQUFFLFFBQU8sR0FBRSxHQUFHO0FBQUM7QUFBQyxTQUFTLEVBQUUsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDO0lBQUUsSUFBRyxFQUFFLEdBQUUsR0FBRSxJQUFHLE9BQU0sQ0FBQztJQUFFLElBQUksSUFBRSxFQUFFLE9BQU8sT0FBTyxNQUFLLElBQUcsSUFBRSxDQUFDO0lBQUUsTUFBSyxFQUFFLFNBQU8sR0FBRztRQUFDLElBQUcsQ0FBQyxHQUFFLEVBQUUsR0FBQyxFQUFFO1FBQVEsSUFBRyxFQUFFLEdBQUUsR0FBRSxPQUFNLElBQUUsQ0FBQzthQUFNO1lBQUMsSUFBSSxJQUFFLEVBQUUsT0FBTyxPQUFPLE1BQUs7WUFBRyxJQUFHLEVBQUUsV0FBUyxHQUFFO2dCQUFDLElBQUUsQ0FBQztnQkFBRTtZQUFLO1lBQUMsRUFBRSxRQUFRO1FBQUU7SUFBQztJQUFDLE9BQU87QUFBQztBQUFDLFNBQVMsRUFBRSxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUM7SUFBRSxJQUFHLEVBQUMsU0FBUSxDQUFDLEVBQUMsR0FBQztJQUFFLElBQUcsQ0FBQyxHQUFFLE9BQU0sQ0FBQztJQUFFLElBQUcsS0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLGNBQWMsRUFBQyxPQUFPLEVBQUUsU0FBTyxFQUFFLEVBQUUsUUFBTyxHQUFFLEtBQUcsQ0FBQztJQUFFLElBQUcsRUFBRSxhQUFhLENBQUMsRUFBRSxFQUFDLE9BQU0sQ0FBQztJQUFFLEVBQUUsYUFBYSxDQUFDLEVBQUUsR0FBQyxDQUFDO0lBQUUsSUFBSSxJQUFFLEVBQUUsS0FBSyxDQUFDLEVBQUU7SUFBQyxPQUFPLEVBQUUsZ0JBQWdCLEtBQUs7UUFBQztRQUFFO0tBQUUsR0FB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QUNQLElBQUk7UUFDRixNQUFNLElBQUk7SUFDWixFQUFFLE9BQU8sS0FBSztRQUNaLElBQUksVUFBVSxBQUFDLENBQUEsS0FBSyxJQUFJLEtBQUksRUFBRyxNQUFNO1FBQ3JDLElBQUksU0FDRiwyRUFBMkU7UUFDM0UsbUVBQW1FO1FBQ25FLE9BQU8sV0FBVyxPQUFPLENBQUMsRUFBRTtJQUVoQztJQUNBLE9BQU87QUFDVDtBQUNBLFNBQVMsV0FBVyxHQUFHO0lBQ3JCLE9BQU8sQUFBQyxDQUFBLEtBQUssR0FBRSxFQUFHLFFBQVEsMkVBQTJFLFFBQVE7QUFDL0c7QUFFQSxrRkFBa0Y7QUFDbEYsU0FBUyxVQUFVLEdBQUc7SUFDcEIsSUFBSSxVQUFVLEFBQUMsQ0FBQSxLQUFLLEdBQUUsRUFBRyxNQUFNO0lBQy9CLElBQUksQ0FBQyxTQUNILE1BQU0sSUFBSSxNQUFNO0lBRWxCLE9BQU8sT0FBTyxDQUFDLEVBQUU7QUFDbkI7QUFDQSxRQUFRLGVBQWU7QUFDdkIsUUFBUSxhQUFhO0FBQ3JCLFFBQVEsWUFBWTs7Ozs7QUhyQ25CLElBQUksT0FBTyxLQUFPO2tCQUVILENBQUEsVUFFZjs7Ozs7QSw0QztBO0EsUyxPLEksRSxNLEUsTSxFLE0sRSxLLEUsUTtJREpDLE9BQUEsQ0FBQSxHQUFBLGNBQUEsS0FBQSxDQUFBLEdBQUEsdUJBQUEsRUFFTSxPQUZOLE1BQUE7UUFDRSxDQUFBLEdBQUEsZ0JBQUEsRUFBdUIsTUFBdkIsQ0FBQSxZQUFBO0s7QTtBLEksTyxLLE8sSSxPO0ksb0IsUyxjO0E7Ozs7O0FBREgsSUFBSSxPQUFPLEtBQU87a0JBRUgsQ0FBQSxVQUVmOzs7QUtMRCxXQUFXLHNCQUFzQjtBQUNqQyxXQUFXLHdCQUF3QiIsInNvdXJjZXMiOlsibm9kZV9tb2R1bGVzL0BwbGFzbW9ocS9wYXJjZWwtcnVudGltZS9kaXN0L3J1bnRpbWUtYjE4OGIyYzlmY2MxZmEzYy5qcyIsIm5vZGVfbW9kdWxlcy9AcGxhc21vaHEvcGFyY2VsLXJlc29sdmVyL2Rpc3QvcG9seWZpbGxzL3JlYWN0LXJlZnJlc2gvcnVudGltZS5qcyIsIi5wbGFzbW8vc3RhdGljL3BvcHVwLnRzIiwibm9kZV9tb2R1bGVzL3Z1ZS9kaXN0L3Z1ZS5ydW50aW1lLmVzbS1idW5kbGVyLmpzIiwibm9kZV9tb2R1bGVzL0B2dWUvcnVudGltZS1kb20vZGlzdC9ydW50aW1lLWRvbS5lc20tYnVuZGxlci5qcyIsIm5vZGVfbW9kdWxlcy9AdnVlL3J1bnRpbWUtY29yZS9kaXN0L3J1bnRpbWUtY29yZS5lc20tYnVuZGxlci5qcyIsIm5vZGVfbW9kdWxlcy9AdnVlL3JlYWN0aXZpdHkvZGlzdC9yZWFjdGl2aXR5LmVzbS1idW5kbGVyLmpzIiwibm9kZV9tb2R1bGVzL0B2dWUvc2hhcmVkL2Rpc3Qvc2hhcmVkLmVzbS1idW5kbGVyLmpzIiwibm9kZV9tb2R1bGVzL0BwYXJjZWwvdHJhbnNmb3JtZXItanMvc3JjL2VzbW9kdWxlLWhlbHBlcnMuanMiLCJzcmMvcG9wdXAudnVlIiwic3JjL0FwcC52dWUiLCJzcmMvY29tcG9uZW50cy9IZWxsb1dvcmxkLnZ1ZSIsIm5vZGVfbW9kdWxlcy9AcGFyY2VsL3J1bnRpbWUtanMvbGliL3J1bnRpbWUtYmQwZTg2NTExOTE5NTExYS5qcyIsIm5vZGVfbW9kdWxlcy9AcGFyY2VsL3J1bnRpbWUtanMvbGliL2hlbHBlcnMvYnVuZGxlLXVybC5qcyIsIi5wbGFzbW8vc3RhdGljL2NvbW1vbi92dWUudHMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIFc9T2JqZWN0LmNyZWF0ZTt2YXIgRD1PYmplY3QuZGVmaW5lUHJvcGVydHk7dmFyIFY9T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjt2YXIgRz1PYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lczt2YXIgWD1PYmplY3QuZ2V0UHJvdG90eXBlT2YsSj1PYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O3ZhciBxPShlLHQsbyxyKT0+e2lmKHQmJnR5cGVvZiB0PT1cIm9iamVjdFwifHx0eXBlb2YgdD09XCJmdW5jdGlvblwiKWZvcihsZXQgcyBvZiBHKHQpKSFKLmNhbGwoZSxzKSYmcyE9PW8mJkQoZSxzLHtnZXQ6KCk9PnRbc10sZW51bWVyYWJsZTohKHI9Vih0LHMpKXx8ci5lbnVtZXJhYmxlfSk7cmV0dXJuIGV9O3ZhciB6PShlLHQsbyk9PihvPWUhPW51bGw/VyhYKGUpKTp7fSxxKHR8fCFlfHwhZS5fX2VzTW9kdWxlP0QobyxcImRlZmF1bHRcIix7dmFsdWU6ZSxlbnVtZXJhYmxlOiEwfSk6byxlKSk7dmFyIF89dHlwZW9mIGdsb2JhbFRoaXMucHJvY2VzczxcInVcIj9nbG9iYWxUaGlzLnByb2Nlc3MuYXJndjpbXTt2YXIgVD0oKT0+dHlwZW9mIGdsb2JhbFRoaXMucHJvY2VzczxcInVcIj9nbG9iYWxUaGlzLnByb2Nlc3MuZW52Ont9O3ZhciBLPW5ldyBTZXQoXyksdz1lPT5LLmhhcyhlKSx1ZT1fLmZpbHRlcihlPT5lLnN0YXJ0c1dpdGgoXCItLVwiKSYmZS5pbmNsdWRlcyhcIj1cIikpLm1hcChlPT5lLnNwbGl0KFwiPVwiKSkucmVkdWNlKChlLFt0LG9dKT0+KGVbdF09byxlKSx7fSk7dmFyIGRlPXcoXCItLWRyeS1ydW5cIiksQT0oKT0+dyhcIi0tdmVyYm9zZVwiKXx8VCgpLlZFUkJPU0U9PT1cInRydWVcIixmZT1BKCk7dmFyIHg9KGU9XCJcIiwuLi50KT0+Y29uc29sZS5sb2coZS5wYWRFbmQoOSksXCJ8XCIsLi4udCk7dmFyIEw9KC4uLmUpPT5jb25zb2xlLmVycm9yKFwiXFx1ezFGNTM0fSBFUlJPUlwiLnBhZEVuZCg5KSxcInxcIiwuLi5lKSxrPSguLi5lKT0+eChcIlxcdXsxRjUzNX0gSU5GT1wiLC4uLmUpLFI9KC4uLmUpPT54KFwiXFx1ezFGN0UwfSBXQVJOXCIsLi4uZSksUT0wLHA9KC4uLmUpPT5BKCkmJngoYFxcdXsxRjdFMX0gJHtRKyt9YCwuLi5lKTt2YXIgYz17XCJpc0NvbnRlbnRTY3JpcHRcIjpmYWxzZSxcImlzQmFja2dyb3VuZFwiOmZhbHNlLFwiaXNSZWFjdFwiOmZhbHNlLFwicnVudGltZXNcIjpbXCJwYWdlLXJ1bnRpbWVcIl0sXCJob3N0XCI6XCJsb2NhbGhvc3RcIixcInBvcnRcIjoxODE1LFwiZW50cnlGaWxlUGF0aFwiOlwiL1VzZXJzL2RhdmlkemltYmVya25vcGYvRG9jdW1lbnRzL0FwcHMvdnVlLXBsYXNtby10ZXh0Ly5wbGFzbW8vc3RhdGljL3BvcHVwLnRzXCIsXCJidW5kbGVJZFwiOlwiOGU5MGQ4Mzk3ZTM5NGM4YlwiLFwiZW52SGFzaFwiOlwiZTc5MmZiYmRhYTc4ZWU4NFwiLFwidmVyYm9zZVwiOlwiZmFsc2VcIixcInNlY3VyZVwiOmZhbHNlLFwic2VydmVyUG9ydFwiOjUyNzEyfTttb2R1bGUuYnVuZGxlLkhNUl9CVU5ETEVfSUQ9Yy5idW5kbGVJZDtnbG9iYWxUaGlzLnByb2Nlc3M9e2FyZ3Y6W10sZW52OntWRVJCT1NFOmMudmVyYm9zZX19O3ZhciBZPW1vZHVsZS5idW5kbGUuTW9kdWxlO2Z1bmN0aW9uIFooZSl7WS5jYWxsKHRoaXMsZSksdGhpcy5ob3Q9e2RhdGE6bW9kdWxlLmJ1bmRsZS5ob3REYXRhW2VdLF9hY2NlcHRDYWxsYmFja3M6W10sX2Rpc3Bvc2VDYWxsYmFja3M6W10sYWNjZXB0OmZ1bmN0aW9uKHQpe3RoaXMuX2FjY2VwdENhbGxiYWNrcy5wdXNoKHR8fGZ1bmN0aW9uKCl7fSl9LGRpc3Bvc2U6ZnVuY3Rpb24odCl7dGhpcy5fZGlzcG9zZUNhbGxiYWNrcy5wdXNoKHQpfX0sbW9kdWxlLmJ1bmRsZS5ob3REYXRhW2VdPXZvaWQgMH1tb2R1bGUuYnVuZGxlLk1vZHVsZT1aO21vZHVsZS5idW5kbGUuaG90RGF0YT17fTt2YXIgZD1nbG9iYWxUaGlzLmJyb3dzZXJ8fGdsb2JhbFRoaXMuY2hyb21lfHxudWxsO2FzeW5jIGZ1bmN0aW9uIG0oZT0hMSl7ZT8ocChcIlRyaWdnZXJpbmcgZnVsbCByZWxvYWRcIiksZC5ydW50aW1lLnNlbmRNZXNzYWdlKHtfX3BsYXNtb19mdWxsX3JlbG9hZF9fOiEwfSkpOmdsb2JhbFRoaXMubG9jYXRpb24/LnJlbG9hZD8uKCl9ZnVuY3Rpb24gaCgpe3JldHVybiFjLmhvc3R8fGMuaG9zdD09PVwiMC4wLjAuMFwiP2xvY2F0aW9uLnByb3RvY29sLmluZGV4T2YoXCJodHRwXCIpPT09MD9sb2NhdGlvbi5ob3N0bmFtZTpcImxvY2FsaG9zdFwiOmMuaG9zdH1mdW5jdGlvbiBmKCl7cmV0dXJuIGMucG9ydHx8bG9jYXRpb24ucG9ydH12YXIgUz1cIl9fcGxhc21vX3J1bnRpbWVfcGFnZV9cIjt2YXIgaT17Y2hlY2tlZEFzc2V0czp7fSxhc3NldHNUb0Rpc3Bvc2U6W10sYXNzZXRzVG9BY2NlcHQ6W119LEI9KCk9PntpLmNoZWNrZWRBc3NldHM9e30saS5hc3NldHNUb0Rpc3Bvc2U9W10saS5hc3NldHNUb0FjY2VwdD1bXX07ZnVuY3Rpb24gdShlLHQpe2xldHttb2R1bGVzOm99PWU7aWYoIW8pcmV0dXJuW107bGV0IHI9W10scyxuLGE7Zm9yKHMgaW4gbylmb3IobiBpbiBvW3NdWzFdKWE9b1tzXVsxXVtuXSwoYT09PXR8fEFycmF5LmlzQXJyYXkoYSkmJmFbYS5sZW5ndGgtMV09PT10KSYmci5wdXNoKFtlLHNdKTtyZXR1cm4gZS5wYXJlbnQmJihyPXIuY29uY2F0KHUoZS5wYXJlbnQsdCkpKSxyfWZ1bmN0aW9uIEUoZSx0LG8pe2lmKEMoZSx0LG8pKXJldHVybiEwO2xldCByPXUobW9kdWxlLmJ1bmRsZS5yb290LHQpLHM9ITE7Zm9yKDtyLmxlbmd0aD4wOyl7bGV0W24sYV09ci5zaGlmdCgpO2lmKEMobixhLG51bGwpKXM9ITA7ZWxzZXtsZXQgeT11KG1vZHVsZS5idW5kbGUucm9vdCxhKTtpZih5Lmxlbmd0aD09PTApe3M9ITE7YnJlYWt9ci5wdXNoKC4uLnkpfX1yZXR1cm4gc31mdW5jdGlvbiBDKGUsdCxvKXtsZXR7bW9kdWxlczpyfT1lO2lmKCFyKXJldHVybiExO2lmKG8mJiFvW2UuSE1SX0JVTkRMRV9JRF0pcmV0dXJuIGUucGFyZW50P0UoZS5wYXJlbnQsdCxvKTohMDtpZihpLmNoZWNrZWRBc3NldHNbdF0pcmV0dXJuITA7aS5jaGVja2VkQXNzZXRzW3RdPSEwO2xldCBzPWUuY2FjaGVbdF07cmV0dXJuIGkuYXNzZXRzVG9EaXNwb3NlLnB1c2goW2UsdF0pLCFzfHxzLmhvdCYmcy5ob3QuX2FjY2VwdENhbGxiYWNrcy5sZW5ndGg/KGkuYXNzZXRzVG9BY2NlcHQucHVzaChbZSx0XSksITApOiExfWZ1bmN0aW9uIE0oZSx0KXtsZXR7bW9kdWxlczpvfT1lO3JldHVybiBvPyEhb1t0XTohMX1mdW5jdGlvbiBlZShlKXtpZihlLnR5cGU9PT1cImpzXCImJnR5cGVvZiBkb2N1bWVudDxcInVcIilyZXR1cm4gbmV3IFByb21pc2UoKHQsbyk9PntsZXQgcj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpO3Iuc3JjPWAke2UudXJsfT90PSR7RGF0ZS5ub3coKX1gLGUub3V0cHV0Rm9ybWF0PT09XCJlc21vZHVsZVwiJiYoci50eXBlPVwibW9kdWxlXCIpLHIuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwoKT0+dChyKSksci5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwoKT0+byhuZXcgRXJyb3IoYEZhaWxlZCB0byBkb3dubG9hZCBhc3NldDogJHtlLmlkfWApKSksZG9jdW1lbnQuaGVhZD8uYXBwZW5kQ2hpbGQocil9KX12YXIgUD0hMTt0cnl7KDAsZXZhbCkoJ3Rocm93IG5ldyBFcnJvcihcInRlc3RcIik7IC8vIyBzb3VyY2VVUkw9dGVzdC5qcycpfWNhdGNoKGUpe1A9ZS5zdGFjay5pbmNsdWRlcyhcInRlc3QuanNcIil9YXN5bmMgZnVuY3Rpb24gTyhlKXtnbG9iYWwucGFyY2VsSG90VXBkYXRlPU9iamVjdC5jcmVhdGUobnVsbCksZS5mb3JFYWNoKG89PntvLnVybD1kLnJ1bnRpbWUuZ2V0VVJMKFwiL19fcGxhc21vX2htcl9wcm94eV9fP3VybD1cIitlbmNvZGVVUklDb21wb25lbnQoYCR7by51cmx9P3Q9JHtEYXRlLm5vdygpfWApKX0pO2xldCB0PWF3YWl0IFByb21pc2UuYWxsKFA/W106ZS5tYXAoZWUpKTt0cnl7ZS5mb3JFYWNoKGZ1bmN0aW9uKG8peyQobW9kdWxlLmJ1bmRsZS5yb290LG8pfSl9ZmluYWxseXtkZWxldGUgZ2xvYmFsLnBhcmNlbEhvdFVwZGF0ZSx0JiZ0LmZvckVhY2gobz0+e28mJmRvY3VtZW50LmhlYWQ/LnJlbW92ZUNoaWxkKG8pfSl9fWZ1bmN0aW9uIHRlKGUpe2xldCB0PWUuY2xvbmVOb2RlKCk7dC5vbmxvYWQ9ZnVuY3Rpb24oKXtlLnBhcmVudE5vZGUhPT1udWxsJiZlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZSl9LHQuc2V0QXR0cmlidXRlKFwiaHJlZlwiLGUuZ2V0QXR0cmlidXRlKFwiaHJlZlwiKS5zcGxpdChcIj9cIilbMF0rXCI/XCIrRGF0ZS5ub3coKSksZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0LGUubmV4dFNpYmxpbmcpfXZhciBiPW51bGw7ZnVuY3Rpb24gb2UoKXtifHwoYj1zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7bGV0IGU9ZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnbGlua1tyZWw9XCJzdHlsZXNoZWV0XCJdJyk7Zm9yKHZhciB0PTA7dDxlLmxlbmd0aDt0Kyspe2xldCBvPWVbdF0uZ2V0QXR0cmlidXRlKFwiaHJlZlwiKSxyPWgoKSxzPXI9PT1cImxvY2FsaG9zdFwiP25ldyBSZWdFeHAoXCJeKGh0dHBzPzpcXFxcL1xcXFwvKDAuMC4wLjB8MTI3LjAuMC4xKXxsb2NhbGhvc3QpOlwiK2YoKSkudGVzdChvKTpvLmluZGV4T2YocitcIjpcIitmKCkpOy9eaHR0cHM/OlxcL1xcLy9pLnRlc3QobykmJm8uaW5kZXhPZihsb2NhdGlvbi5vcmlnaW4pIT09MCYmIXN8fHRlKGVbdF0pfWI9bnVsbH0sNDcpKX1mdW5jdGlvbiAkKGUsdCl7bGV0e21vZHVsZXM6b309ZTtpZihvKXtpZih0LnR5cGU9PT1cImNzc1wiKW9lKCk7ZWxzZSBpZih0LnR5cGU9PT1cImpzXCIpe2xldCByPXQuZGVwc0J5QnVuZGxlW2UuSE1SX0JVTkRMRV9JRF07aWYocil7aWYob1t0LmlkXSl7bGV0IG49b1t0LmlkXVsxXTtmb3IobGV0IGEgaW4gbilpZighclthXXx8clthXSE9PW5bYV0pe2xldCBsPW5bYV07dShtb2R1bGUuYnVuZGxlLnJvb3QsbCkubGVuZ3RoPT09MSYmdihtb2R1bGUuYnVuZGxlLnJvb3QsbCl9fVAmJigwLGV2YWwpKHQub3V0cHV0KTtsZXQgcz1nbG9iYWwucGFyY2VsSG90VXBkYXRlW3QuaWRdO29bdC5pZF09W3Mscl19ZWxzZSBlLnBhcmVudCYmJChlLnBhcmVudCx0KX19fWZ1bmN0aW9uIHYoZSx0KXtsZXQgbz1lLm1vZHVsZXM7aWYobylpZihvW3RdKXtsZXQgcj1vW3RdWzFdLHM9W107Zm9yKGxldCBuIGluIHIpdShtb2R1bGUuYnVuZGxlLnJvb3QscltuXSkubGVuZ3RoPT09MSYmcy5wdXNoKHJbbl0pO2RlbGV0ZSBvW3RdLGRlbGV0ZSBlLmNhY2hlW3RdLHMuZm9yRWFjaChuPT57dihtb2R1bGUuYnVuZGxlLnJvb3Qsbil9KX1lbHNlIGUucGFyZW50JiZ2KGUucGFyZW50LHQpfWZ1bmN0aW9uIEgoZSx0KXtsZXQgbz1lLmNhY2hlW3RdO2UuaG90RGF0YVt0XT17fSxvJiZvLmhvdCYmKG8uaG90LmRhdGE9ZS5ob3REYXRhW3RdKSxvJiZvLmhvdCYmby5ob3QuX2Rpc3Bvc2VDYWxsYmFja3MubGVuZ3RoJiZvLmhvdC5fZGlzcG9zZUNhbGxiYWNrcy5mb3JFYWNoKGZ1bmN0aW9uKHIpe3IoZS5ob3REYXRhW3RdKX0pLGRlbGV0ZSBlLmNhY2hlW3RdfWZ1bmN0aW9uIGooZSx0KXtlKHQpO2xldCBvPWUuY2FjaGVbdF07aWYobyYmby5ob3QmJm8uaG90Ll9hY2NlcHRDYWxsYmFja3MubGVuZ3RoKXtsZXQgcj11KG1vZHVsZS5idW5kbGUucm9vdCx0KTtvLmhvdC5fYWNjZXB0Q2FsbGJhY2tzLmZvckVhY2goZnVuY3Rpb24ocyl7bGV0IG49cygoKT0+cik7biYmbi5sZW5ndGgmJihuLmZvckVhY2goKFthLGxdKT0+e0goYSxsKX0pLGkuYXNzZXRzVG9BY2NlcHQucHVzaC5hcHBseShpLmFzc2V0c1RvQWNjZXB0LG4pKX0pfX1mdW5jdGlvbiByZShlPWYoKSl7bGV0IHQ9aCgpO3JldHVybmAke2Muc2VjdXJlfHxsb2NhdGlvbi5wcm90b2NvbD09PVwiaHR0cHM6XCImJiEvbG9jYWxob3N0fDEyNy4wLjAuMXwwLjAuMC4wLy50ZXN0KHQpP1wid3NzXCI6XCJ3c1wifTovLyR7dH06JHtlfS9gfWZ1bmN0aW9uIHNlKGUpe3R5cGVvZiBlLm1lc3NhZ2U9PVwic3RyaW5nXCImJkwoXCJbcGxhc21vL3BhcmNlbC1ydW50aW1lXTogXCIrZS5tZXNzYWdlKX1mdW5jdGlvbiBJKGUpe2lmKHR5cGVvZiBnbG9iYWxUaGlzLldlYlNvY2tldD5cInVcIilyZXR1cm47bGV0IHQ9bmV3IFdlYlNvY2tldChyZSgpKTtyZXR1cm4gdC5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLGFzeW5jIGZ1bmN0aW9uKG8pe2xldCByPUpTT04ucGFyc2Uoby5kYXRhKTtpZihyLnR5cGU9PT1cInVwZGF0ZVwiJiZhd2FpdCBlKHIuYXNzZXRzKSxyLnR5cGU9PT1cImVycm9yXCIpZm9yKGxldCBzIG9mIHIuZGlhZ25vc3RpY3MuYW5zaSl7bGV0IG49cy5jb2RlZnJhbWV8fHMuc3RhY2s7UihcIltwbGFzbW8vcGFyY2VsLXJ1bnRpbWVdOiBcIitzLm1lc3NhZ2UrYFxuYCtuK2BcblxuYCtzLmhpbnRzLmpvaW4oYFxuYCkpfX0pLHQuYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsc2UpLHQuYWRkRXZlbnRMaXN0ZW5lcihcIm9wZW5cIiwoKT0+e2soYFtwbGFzbW8vcGFyY2VsLXJ1bnRpbWVdOiBDb25uZWN0ZWQgdG8gSE1SIHNlcnZlciBmb3IgJHtjLmVudHJ5RmlsZVBhdGh9YCl9KSx0LmFkZEV2ZW50TGlzdGVuZXIoXCJjbG9zZVwiLCgpPT57UihgW3BsYXNtby9wYXJjZWwtcnVudGltZV06IENvbm5lY3Rpb24gdG8gdGhlIEhNUiBzZXJ2ZXIgaXMgY2xvc2VkIGZvciAke2MuZW50cnlGaWxlUGF0aH1gKX0pLHR9dmFyIE49eihyZXF1aXJlKFwicmVhY3QtcmVmcmVzaC9ydW50aW1lXCIpKTthc3luYyBmdW5jdGlvbiBVKCl7Ti5kZWZhdWx0LmluamVjdEludG9HbG9iYWxIb29rKHdpbmRvdyksd2luZG93LiRSZWZyZXNoUmVnJD1mdW5jdGlvbigpe30sd2luZG93LiRSZWZyZXNoU2lnJD1mdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbihlKXtyZXR1cm4gZX19fXZhciBuZT1gJHtTfSR7bW9kdWxlLmlkfV9fYCxnLEY9bW9kdWxlLmJ1bmRsZS5wYXJlbnQ7aWYoIUZ8fCFGLmlzUGFyY2VsUmVxdWlyZSl7dHJ5e2c9ZD8ucnVudGltZS5jb25uZWN0KHtuYW1lOm5lfSksZy5vbkRpc2Nvbm5lY3QuYWRkTGlzdGVuZXIoKCk9PnttKCl9KSxjLmlzUmVhY3R8fGcub25NZXNzYWdlLmFkZExpc3RlbmVyKCgpPT57bSgpfSl9Y2F0Y2goZSl7cChlKX1JKGFzeW5jIGU9PntpZihwKFwiUGFnZSBydW50aW1lIC0gT24gSE1SIFVwZGF0ZVwiKSxjLmlzUmVhY3Qpe0IoKTtsZXQgdD1lLmZpbHRlcihyPT5yLmVudkhhc2g9PT1jLmVudkhhc2gpO2lmKHQuc29tZShyPT5yLnR5cGU9PT1cImNzc1wifHxyLnR5cGU9PT1cImpzXCImJkUobW9kdWxlLmJ1bmRsZS5yb290LHIuaWQsci5kZXBzQnlCdW5kbGUpKSl0cnl7YXdhaXQgTyh0KTtsZXQgcj17fTtmb3IobGV0W24sYV1vZiBpLmFzc2V0c1RvRGlzcG9zZSlyW2FdfHwoSChuLGEpLHJbYV09ITApO2xldCBzPXt9O2ZvcihsZXQgbj0wO248aS5hc3NldHNUb0FjY2VwdC5sZW5ndGg7bisrKXtsZXRbYSxsXT1pLmFzc2V0c1RvQWNjZXB0W25dO3NbbF18fChqKGEsbCksc1tsXT0hMCl9fWNhdGNoKHIpe2MudmVyYm9zZT09PVwidHJ1ZVwiJiYoY29uc29sZS50cmFjZShyKSxhbGVydChKU09OLnN0cmluZ2lmeShyKSkpLGF3YWl0IG0oITApfX1lbHNle2xldCB0PWUuZmlsdGVyKG89Pm8uZW52SGFzaD09PWMuZW52SGFzaCkuc29tZShvPT5NKG1vZHVsZS5idW5kbGUsby5pZCkpO3AoXCJQYWdlIHJ1bnRpbWUgLVwiLHtzb3VyY2VDaGFuZ2VkOnR9KSx0JiZnLnBvc3RNZXNzYWdlKHtfX3BsYXNtb19wYWdlX2NoYW5nZWRfXzohMH0pfX0pfWMuaXNSZWFjdCYmKHAoXCJJbmplY3RpbmcgcmVhY3QgcmVmcmVzaFwiKSxVKCkpO1xuIiwidmFyIG9lPU9iamVjdC5jcmVhdGU7dmFyIEg9T2JqZWN0LmRlZmluZVByb3BlcnR5O3ZhciBhZT1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO3ZhciB1ZT1PYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lczt2YXIgc2U9T2JqZWN0LmdldFByb3RvdHlwZU9mLGxlPU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7dmFyIHo9KG8sZik9PigpPT4oZnx8bygoZj17ZXhwb3J0czp7fX0pLmV4cG9ydHMsZiksZi5leHBvcnRzKSxjZT0obyxmKT0+e2Zvcih2YXIgcyBpbiBmKUgobyxzLHtnZXQ6ZltzXSxlbnVtZXJhYmxlOiEwfSl9LEQ9KG8sZixzLHkpPT57aWYoZiYmdHlwZW9mIGY9PVwib2JqZWN0XCJ8fHR5cGVvZiBmPT1cImZ1bmN0aW9uXCIpZm9yKGxldCBtIG9mIHVlKGYpKSFsZS5jYWxsKG8sbSkmJm0hPT1zJiZIKG8sbSx7Z2V0OigpPT5mW21dLGVudW1lcmFibGU6ISh5PWFlKGYsbSkpfHx5LmVudW1lcmFibGV9KTtyZXR1cm4gb30sUz0obyxmLHMpPT4oRChvLGYsXCJkZWZhdWx0XCIpLHMmJkQocyxmLFwiZGVmYXVsdFwiKSksRz0obyxmLHMpPT4ocz1vIT1udWxsP29lKHNlKG8pKTp7fSxEKGZ8fCFvfHwhby5fX2VzTW9kdWxlP0gocyxcImRlZmF1bHRcIix7dmFsdWU6byxlbnVtZXJhYmxlOiEwfSk6cyxvKSksZGU9bz0+RChIKHt9LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLG8pO3ZhciBOPXooaD0+e1widXNlIHN0cmljdFwiOyhmdW5jdGlvbigpe1widXNlIHN0cmljdFwiO3ZhciBvPVN5bWJvbC5mb3IoXCJyZWFjdC5mb3J3YXJkX3JlZlwiKSxmPVN5bWJvbC5mb3IoXCJyZWFjdC5tZW1vXCIpLHM9dHlwZW9mIFdlYWtNYXA9PVwiZnVuY3Rpb25cIj9XZWFrTWFwOk1hcCx5PW5ldyBNYXAsbT1uZXcgcyxiPW5ldyBzLGo9bmV3IHMsRT1bXSxDPW5ldyBNYXAsTz1uZXcgTWFwLHA9bmV3IFNldCxfPW5ldyBTZXQsRj10eXBlb2YgV2Vha01hcD09XCJmdW5jdGlvblwiP25ldyBXZWFrTWFwOm51bGwsVD0hMTtmdW5jdGlvbiBCKGUpe2lmKGUuZnVsbEtleSE9PW51bGwpcmV0dXJuIGUuZnVsbEtleTt2YXIgcj1lLm93bktleSxuO3RyeXtuPWUuZ2V0Q3VzdG9tSG9va3MoKX1jYXRjaChpKXtyZXR1cm4gZS5mb3JjZVJlc2V0PSEwLGUuZnVsbEtleT1yLHJ9Zm9yKHZhciB0PTA7dDxuLmxlbmd0aDt0Kyspe3ZhciBsPW5bdF07aWYodHlwZW9mIGwhPVwiZnVuY3Rpb25cIilyZXR1cm4gZS5mb3JjZVJlc2V0PSEwLGUuZnVsbEtleT1yLHI7dmFyIGQ9Yi5nZXQobCk7aWYoZCE9PXZvaWQgMCl7dmFyIGE9QihkKTtkLmZvcmNlUmVzZXQmJihlLmZvcmNlUmVzZXQ9ITApLHIrPWBcbi0tLVxuYCthfX1yZXR1cm4gZS5mdWxsS2V5PXIscn1mdW5jdGlvbiBxKGUscil7dmFyIG49Yi5nZXQoZSksdD1iLmdldChyKTtyZXR1cm4gbj09PXZvaWQgMCYmdD09PXZvaWQgMD8hMDohKG49PT12b2lkIDB8fHQ9PT12b2lkIDB8fEIobikhPT1CKHQpfHx0LmZvcmNlUmVzZXQpfWZ1bmN0aW9uICQoZSl7cmV0dXJuIGUucHJvdG90eXBlJiZlLnByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50fWZ1bmN0aW9uIGsoZSxyKXtyZXR1cm4gJChlKXx8JChyKT8hMTohIXEoZSxyKX1mdW5jdGlvbiBZKGUpe3JldHVybiBqLmdldChlKX1mdW5jdGlvbiBaKGUpe3ZhciByPW5ldyBNYXA7cmV0dXJuIGUuZm9yRWFjaChmdW5jdGlvbihuLHQpe3Iuc2V0KHQsbil9KSxyfWZ1bmN0aW9uIFcoZSl7dmFyIHI9bmV3IFNldDtyZXR1cm4gZS5mb3JFYWNoKGZ1bmN0aW9uKG4pe3IuYWRkKG4pfSkscn1mdW5jdGlvbiBNKGUscil7dHJ5e3JldHVybiBlW3JdfWNhdGNoKG4pe3JldHVybn19ZnVuY3Rpb24gSigpe2lmKEUubGVuZ3RoPT09MHx8VClyZXR1cm4gbnVsbDtUPSEwO3RyeXt2YXIgZT1uZXcgU2V0LHI9bmV3IFNldCxuPUU7RT1bXSxuLmZvckVhY2goZnVuY3Rpb24odSl7dmFyIGM9dVswXSx2PXVbMV0sUj1jLmN1cnJlbnQ7ai5zZXQoUixjKSxqLnNldCh2LGMpLGMuY3VycmVudD12LGsoUix2KT9yLmFkZChjKTplLmFkZChjKX0pO3ZhciB0PXt1cGRhdGVkRmFtaWxpZXM6cixzdGFsZUZhbWlsaWVzOmV9O0MuZm9yRWFjaChmdW5jdGlvbih1KXt1LnNldFJlZnJlc2hIYW5kbGVyKFkpfSk7dmFyIGw9ITEsZD1udWxsLGE9VyhfKSxpPVcocCksZz1aKE8pO2lmKGEuZm9yRWFjaChmdW5jdGlvbih1KXt2YXIgYz1nLmdldCh1KTtpZihjPT09dm9pZCAwKXRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBmaW5kIGhlbHBlcnMgZm9yIGEgcm9vdC4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdCBSZWZyZXNoLlwiKTtpZihfLmhhcyh1KSxGIT09bnVsbCYmRi5oYXModSkpe3ZhciB2PUYuZ2V0KHUpO3RyeXtjLnNjaGVkdWxlUm9vdCh1LHYpfWNhdGNoKFIpe2x8fChsPSEwLGQ9Uil9fX0pLGkuZm9yRWFjaChmdW5jdGlvbih1KXt2YXIgYz1nLmdldCh1KTtpZihjPT09dm9pZCAwKXRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBmaW5kIGhlbHBlcnMgZm9yIGEgcm9vdC4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdCBSZWZyZXNoLlwiKTtwLmhhcyh1KTt0cnl7Yy5zY2hlZHVsZVJlZnJlc2godSx0KX1jYXRjaCh2KXtsfHwobD0hMCxkPXYpfX0pLGwpdGhyb3cgZDtyZXR1cm4gdH1maW5hbGx5e1Q9ITF9fWZ1bmN0aW9uIFAoZSxyKXt7aWYoZT09PW51bGx8fHR5cGVvZiBlIT1cImZ1bmN0aW9uXCImJnR5cGVvZiBlIT1cIm9iamVjdFwifHxtLmhhcyhlKSlyZXR1cm47dmFyIG49eS5nZXQocik7aWYobj09PXZvaWQgMD8obj17Y3VycmVudDplfSx5LnNldChyLG4pKTpFLnB1c2goW24sZV0pLG0uc2V0KGUsbiksdHlwZW9mIGU9PVwib2JqZWN0XCImJmUhPT1udWxsKXN3aXRjaChNKGUsXCIkJHR5cGVvZlwiKSl7Y2FzZSBvOlAoZS5yZW5kZXIscitcIiRyZW5kZXJcIik7YnJlYWs7Y2FzZSBmOlAoZS50eXBlLHIrXCIkdHlwZVwiKTticmVha319fWZ1bmN0aW9uIEsoZSxyKXt2YXIgbj1hcmd1bWVudHMubGVuZ3RoPjImJmFyZ3VtZW50c1syXSE9PXZvaWQgMD9hcmd1bWVudHNbMl06ITEsdD1hcmd1bWVudHMubGVuZ3RoPjM/YXJndW1lbnRzWzNdOnZvaWQgMDtpZihiLmhhcyhlKXx8Yi5zZXQoZSx7Zm9yY2VSZXNldDpuLG93bktleTpyLGZ1bGxLZXk6bnVsbCxnZXRDdXN0b21Ib29rczp0fHxmdW5jdGlvbigpe3JldHVybltdfX0pLHR5cGVvZiBlPT1cIm9iamVjdFwiJiZlIT09bnVsbClzd2l0Y2goTShlLFwiJCR0eXBlb2ZcIikpe2Nhc2UgbzpLKGUucmVuZGVyLHIsbix0KTticmVhaztjYXNlIGY6SyhlLnR5cGUscixuLHQpO2JyZWFrfX1mdW5jdGlvbiB4KGUpe3t2YXIgcj1iLmdldChlKTtyIT09dm9pZCAwJiZCKHIpfX1mdW5jdGlvbiBRKGUpe3JldHVybiB5LmdldChlKX1mdW5jdGlvbiBYKGUpe3JldHVybiBtLmdldChlKX1mdW5jdGlvbiBlZShlKXt7dmFyIHI9bmV3IFNldDtyZXR1cm4gcC5mb3JFYWNoKGZ1bmN0aW9uKG4pe3ZhciB0PU8uZ2V0KG4pO2lmKHQ9PT12b2lkIDApdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IGZpbmQgaGVscGVycyBmb3IgYSByb290LiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0IFJlZnJlc2guXCIpO3ZhciBsPXQuZmluZEhvc3RJbnN0YW5jZXNGb3JSZWZyZXNoKG4sZSk7bC5mb3JFYWNoKGZ1bmN0aW9uKGQpe3IuYWRkKGQpfSl9KSxyfX1mdW5jdGlvbiByZShlKXt7dmFyIHI9ZS5fX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX187aWYocj09PXZvaWQgMCl7dmFyIG49MDtlLl9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXz1yPXtyZW5kZXJlcnM6bmV3IE1hcCxzdXBwb3J0c0ZpYmVyOiEwLGluamVjdDpmdW5jdGlvbihhKXtyZXR1cm4gbisrfSxvblNjaGVkdWxlRmliZXJSb290OmZ1bmN0aW9uKGEsaSxnKXt9LG9uQ29tbWl0RmliZXJSb290OmZ1bmN0aW9uKGEsaSxnLHUpe30sb25Db21taXRGaWJlclVubW91bnQ6ZnVuY3Rpb24oKXt9fX1pZihyLmlzRGlzYWJsZWQpe2NvbnNvbGUud2FybihcIlNvbWV0aGluZyBoYXMgc2hpbW1lZCB0aGUgUmVhY3QgRGV2VG9vbHMgZ2xvYmFsIGhvb2sgKF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXykuIEZhc3QgUmVmcmVzaCBpcyBub3QgY29tcGF0aWJsZSB3aXRoIHRoaXMgc2hpbSBhbmQgd2lsbCBiZSBkaXNhYmxlZC5cIik7cmV0dXJufXZhciB0PXIuaW5qZWN0O3IuaW5qZWN0PWZ1bmN0aW9uKGEpe3ZhciBpPXQuYXBwbHkodGhpcyxhcmd1bWVudHMpO3JldHVybiB0eXBlb2YgYS5zY2hlZHVsZVJlZnJlc2g9PVwiZnVuY3Rpb25cIiYmdHlwZW9mIGEuc2V0UmVmcmVzaEhhbmRsZXI9PVwiZnVuY3Rpb25cIiYmQy5zZXQoaSxhKSxpfSxyLnJlbmRlcmVycy5mb3JFYWNoKGZ1bmN0aW9uKGEsaSl7dHlwZW9mIGEuc2NoZWR1bGVSZWZyZXNoPT1cImZ1bmN0aW9uXCImJnR5cGVvZiBhLnNldFJlZnJlc2hIYW5kbGVyPT1cImZ1bmN0aW9uXCImJkMuc2V0KGksYSl9KTt2YXIgbD1yLm9uQ29tbWl0RmliZXJSb290LGQ9ci5vblNjaGVkdWxlRmliZXJSb290fHxmdW5jdGlvbigpe307ci5vblNjaGVkdWxlRmliZXJSb290PWZ1bmN0aW9uKGEsaSxnKXtyZXR1cm4gVHx8KF8uZGVsZXRlKGkpLEYhPT1udWxsJiZGLnNldChpLGcpKSxkLmFwcGx5KHRoaXMsYXJndW1lbnRzKX0sci5vbkNvbW1pdEZpYmVyUm9vdD1mdW5jdGlvbihhLGksZyx1KXt2YXIgYz1DLmdldChhKTtpZihjIT09dm9pZCAwKXtPLnNldChpLGMpO3ZhciB2PWkuY3VycmVudCxSPXYuYWx0ZXJuYXRlO2lmKFIhPT1udWxsKXt2YXIgTD1SLm1lbW9pemVkU3RhdGUhPW51bGwmJlIubWVtb2l6ZWRTdGF0ZS5lbGVtZW50IT1udWxsJiZwLmhhcyhpKSxBPXYubWVtb2l6ZWRTdGF0ZSE9bnVsbCYmdi5tZW1vaXplZFN0YXRlLmVsZW1lbnQhPW51bGw7IUwmJkE/KHAuYWRkKGkpLF8uZGVsZXRlKGkpKTpMJiZBfHwoTCYmIUE/KHAuZGVsZXRlKGkpLHU/Xy5hZGQoaSk6Ty5kZWxldGUoaSkpOiFMJiYhQSYmdSYmXy5hZGQoaSkpfWVsc2UgcC5hZGQoaSl9cmV0dXJuIGwuYXBwbHkodGhpcyxhcmd1bWVudHMpfX19ZnVuY3Rpb24gbmUoKXtyZXR1cm4hMX1mdW5jdGlvbiB0ZSgpe3JldHVybiBwLnNpemV9ZnVuY3Rpb24gZmUoKXt7dmFyIGUscixuPSExO3JldHVybiBmdW5jdGlvbih0LGwsZCxhKXtpZih0eXBlb2YgbD09XCJzdHJpbmdcIilyZXR1cm4gZXx8KGU9dCxyPXR5cGVvZiBhPT1cImZ1bmN0aW9uXCIpLHQhPW51bGwmJih0eXBlb2YgdD09XCJmdW5jdGlvblwifHx0eXBlb2YgdD09XCJvYmplY3RcIikmJksodCxsLGQsYSksdDshbiYmciYmKG49ITAseChlKSl9fX1mdW5jdGlvbiBpZShlKXtzd2l0Y2godHlwZW9mIGUpe2Nhc2VcImZ1bmN0aW9uXCI6e2lmKGUucHJvdG90eXBlIT1udWxsKXtpZihlLnByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50KXJldHVybiEwO3ZhciByPU9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGUucHJvdG90eXBlKTtpZihyLmxlbmd0aD4xfHxyWzBdIT09XCJjb25zdHJ1Y3RvclwifHxlLnByb3RvdHlwZS5fX3Byb3RvX18hPT1PYmplY3QucHJvdG90eXBlKXJldHVybiExfXZhciBuPWUubmFtZXx8ZS5kaXNwbGF5TmFtZTtyZXR1cm4gdHlwZW9mIG49PVwic3RyaW5nXCImJi9eW0EtWl0vLnRlc3Qobil9Y2FzZVwib2JqZWN0XCI6e2lmKGUhPW51bGwpc3dpdGNoKE0oZSxcIiQkdHlwZW9mXCIpKXtjYXNlIG86Y2FzZSBmOnJldHVybiEwO2RlZmF1bHQ6cmV0dXJuITF9cmV0dXJuITF9ZGVmYXVsdDpyZXR1cm4hMX19aC5fZ2V0TW91bnRlZFJvb3RDb3VudD10ZSxoLmNvbGxlY3RDdXN0b21Ib29rc0ZvclNpZ25hdHVyZT14LGguY3JlYXRlU2lnbmF0dXJlRnVuY3Rpb25Gb3JUcmFuc2Zvcm09ZmUsaC5maW5kQWZmZWN0ZWRIb3N0SW5zdGFuY2VzPWVlLGguZ2V0RmFtaWx5QnlJRD1RLGguZ2V0RmFtaWx5QnlUeXBlPVgsaC5oYXNVbnJlY292ZXJhYmxlRXJyb3JzPW5lLGguaW5qZWN0SW50b0dsb2JhbEhvb2s9cmUsaC5pc0xpa2VseUNvbXBvbmVudFR5cGU9aWUsaC5wZXJmb3JtUmVhY3RSZWZyZXNoPUosaC5yZWdpc3Rlcj1QLGguc2V0U2lnbmF0dXJlPUt9KSgpfSk7dmFyIEk9eigocGUsVik9PntcInVzZSBzdHJpY3RcIjtWLmV4cG9ydHM9TigpfSk7dmFyIHc9e307Y2Uodyx7ZGVmYXVsdDooKT0+aGV9KTttb2R1bGUuZXhwb3J0cz1kZSh3KTt2YXIgVT1HKEkoKSk7Uyh3LEcoSSgpKSxtb2R1bGUuZXhwb3J0cyk7dmFyIGhlPVUuZGVmYXVsdDtcbi8qISBCdW5kbGVkIGxpY2Vuc2UgaW5mb3JtYXRpb246XG5cbnJlYWN0LXJlZnJlc2gvY2pzL3JlYWN0LXJlZnJlc2gtcnVudGltZS5kZXZlbG9wbWVudC5qczpcbiAgKCoqXG4gICAqIEBsaWNlbnNlIFJlYWN0XG4gICAqIHJlYWN0LXJlZnJlc2gtcnVudGltZS5kZXZlbG9wbWVudC5qc1xuICAgKlxuICAgKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAgICpcbiAgICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gICAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAgICopXG4qL1xuIiwiaW1wb3J0IHsgY3JlYXRlQXBwIH0gZnJvbSBcInZ1ZVwiXG5cbi8vIEB0cy1pZ25vcmVcbmltcG9ydCAqIGFzIENvbXBvbmVudCBmcm9tIFwiLi4vLi4vc3JjL3BvcHVwLnZ1ZVwiXG5cbmltcG9ydCBcIkBwbGFzbW8tc3RhdGljLWNvbW1vbi92dWVcIlxuXG5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiRE9NQ29udGVudExvYWRlZFwiLCAoKSA9PiB7XG4gIGNvbnN0IGFwcCA9IGNyZWF0ZUFwcChDb21wb25lbnQuZGVmYXVsdClcbiAgQ29tcG9uZW50LmRlZmF1bHQucHJlcGFyZT8uKGFwcClcbiAgYXBwLm1vdW50KFwiI19fcGxhc21vXCIpXG59KVxuIiwiaW1wb3J0IHsgaW5pdEN1c3RvbUZvcm1hdHRlciwgd2FybiB9IGZyb20gJ0B2dWUvcnVudGltZS1kb20nO1xuZXhwb3J0ICogZnJvbSAnQHZ1ZS9ydW50aW1lLWRvbSc7XG5cbmZ1bmN0aW9uIGluaXREZXYoKSB7XG4gIHtcbiAgICBpbml0Q3VzdG9tRm9ybWF0dGVyKCk7XG4gIH1cbn1cblxuaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgaW5pdERldigpO1xufVxuY29uc3QgY29tcGlsZSA9ICgpID0+IHtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICB3YXJuKFxuICAgICAgYFJ1bnRpbWUgY29tcGlsYXRpb24gaXMgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJ1aWxkIG9mIFZ1ZS5gICsgKGAgQ29uZmlndXJlIHlvdXIgYnVuZGxlciB0byBhbGlhcyBcInZ1ZVwiIHRvIFwidnVlL2Rpc3QvdnVlLmVzbS1idW5kbGVyLmpzXCIuYCApXG4gICAgICAvKiBzaG91bGQgbm90IGhhcHBlbiAqL1xuICAgICk7XG4gIH1cbn07XG5cbmV4cG9ydCB7IGNvbXBpbGUgfTtcbiIsImltcG9ydCB7IHdhcm4sIGNhbWVsaXplLCBjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZywgZGVmaW5lQ29tcG9uZW50LCBuZXh0VGljaywgY3JlYXRlVk5vZGUsIGdldEN1cnJlbnRJbnN0YW5jZSwgd2F0Y2hQb3N0RWZmZWN0LCBvbk1vdW50ZWQsIG9uVW5tb3VudGVkLCBGcmFnbWVudCwgU3RhdGljLCBoLCBCYXNlVHJhbnNpdGlvbiwgQmFzZVRyYW5zaXRpb25Qcm9wc1ZhbGlkYXRvcnMsIGFzc2VydE51bWJlciwgdXNlVHJhbnNpdGlvblN0YXRlLCBvblVwZGF0ZWQsIHRvUmF3LCBnZXRUcmFuc2l0aW9uUmF3Q2hpbGRyZW4sIHNldFRyYW5zaXRpb25Ib29rcywgcmVzb2x2ZVRyYW5zaXRpb25Ib29rcywgaXNSdW50aW1lT25seSwgY3JlYXRlUmVuZGVyZXIsIGNyZWF0ZUh5ZHJhdGlvblJlbmRlcmVyIH0gZnJvbSAnQHZ1ZS9ydW50aW1lLWNvcmUnO1xuZXhwb3J0ICogZnJvbSAnQHZ1ZS9ydW50aW1lLWNvcmUnO1xuaW1wb3J0IHsgaXNTdHJpbmcsIGlzQXJyYXksIGh5cGhlbmF0ZSwgY2FwaXRhbGl6ZSwgaXNTcGVjaWFsQm9vbGVhbkF0dHIsIGluY2x1ZGVCb29sZWFuQXR0ciwgaXNPbiwgaXNNb2RlbExpc3RlbmVyLCBpc0Z1bmN0aW9uLCBjYW1lbGl6ZSBhcyBjYW1lbGl6ZSQxLCB0b051bWJlciwgZXh0ZW5kLCBFTVBUWV9PQkosIGlzT2JqZWN0LCBsb29zZVRvTnVtYmVyLCBsb29zZUluZGV4T2YsIGlzU2V0LCBsb29zZUVxdWFsLCBpbnZva2VBcnJheUZucywgaXNIVE1MVGFnLCBpc1NWR1RhZyB9IGZyb20gJ0B2dWUvc2hhcmVkJztcblxuY29uc3Qgc3ZnTlMgPSBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCI7XG5jb25zdCBkb2MgPSB0eXBlb2YgZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCIgPyBkb2N1bWVudCA6IG51bGw7XG5jb25zdCB0ZW1wbGF0ZUNvbnRhaW5lciA9IGRvYyAmJiAvKiBAX19QVVJFX18gKi8gZG9jLmNyZWF0ZUVsZW1lbnQoXCJ0ZW1wbGF0ZVwiKTtcbmNvbnN0IG5vZGVPcHMgPSB7XG4gIGluc2VydDogKGNoaWxkLCBwYXJlbnQsIGFuY2hvcikgPT4ge1xuICAgIHBhcmVudC5pbnNlcnRCZWZvcmUoY2hpbGQsIGFuY2hvciB8fCBudWxsKTtcbiAgfSxcbiAgcmVtb3ZlOiAoY2hpbGQpID0+IHtcbiAgICBjb25zdCBwYXJlbnQgPSBjaGlsZC5wYXJlbnROb2RlO1xuICAgIGlmIChwYXJlbnQpIHtcbiAgICAgIHBhcmVudC5yZW1vdmVDaGlsZChjaGlsZCk7XG4gICAgfVxuICB9LFxuICBjcmVhdGVFbGVtZW50OiAodGFnLCBpc1NWRywgaXMsIHByb3BzKSA9PiB7XG4gICAgY29uc3QgZWwgPSBpc1NWRyA/IGRvYy5jcmVhdGVFbGVtZW50TlMoc3ZnTlMsIHRhZykgOiBkb2MuY3JlYXRlRWxlbWVudCh0YWcsIGlzID8geyBpcyB9IDogdm9pZCAwKTtcbiAgICBpZiAodGFnID09PSBcInNlbGVjdFwiICYmIHByb3BzICYmIHByb3BzLm11bHRpcGxlICE9IG51bGwpIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZShcIm11bHRpcGxlXCIsIHByb3BzLm11bHRpcGxlKTtcbiAgICB9XG4gICAgcmV0dXJuIGVsO1xuICB9LFxuICBjcmVhdGVUZXh0OiAodGV4dCkgPT4gZG9jLmNyZWF0ZVRleHROb2RlKHRleHQpLFxuICBjcmVhdGVDb21tZW50OiAodGV4dCkgPT4gZG9jLmNyZWF0ZUNvbW1lbnQodGV4dCksXG4gIHNldFRleHQ6IChub2RlLCB0ZXh0KSA9PiB7XG4gICAgbm9kZS5ub2RlVmFsdWUgPSB0ZXh0O1xuICB9LFxuICBzZXRFbGVtZW50VGV4dDogKGVsLCB0ZXh0KSA9PiB7XG4gICAgZWwudGV4dENvbnRlbnQgPSB0ZXh0O1xuICB9LFxuICBwYXJlbnROb2RlOiAobm9kZSkgPT4gbm9kZS5wYXJlbnROb2RlLFxuICBuZXh0U2libGluZzogKG5vZGUpID0+IG5vZGUubmV4dFNpYmxpbmcsXG4gIHF1ZXJ5U2VsZWN0b3I6IChzZWxlY3RvcikgPT4gZG9jLnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpLFxuICBzZXRTY29wZUlkKGVsLCBpZCkge1xuICAgIGVsLnNldEF0dHJpYnV0ZShpZCwgXCJcIik7XG4gIH0sXG4gIC8vIF9fVU5TQUZFX19cbiAgLy8gUmVhc29uOiBpbm5lckhUTUwuXG4gIC8vIFN0YXRpYyBjb250ZW50IGhlcmUgY2FuIG9ubHkgY29tZSBmcm9tIGNvbXBpbGVkIHRlbXBsYXRlcy5cbiAgLy8gQXMgbG9uZyBhcyB0aGUgdXNlciBvbmx5IHVzZXMgdHJ1c3RlZCB0ZW1wbGF0ZXMsIHRoaXMgaXMgc2FmZS5cbiAgaW5zZXJ0U3RhdGljQ29udGVudChjb250ZW50LCBwYXJlbnQsIGFuY2hvciwgaXNTVkcsIHN0YXJ0LCBlbmQpIHtcbiAgICBjb25zdCBiZWZvcmUgPSBhbmNob3IgPyBhbmNob3IucHJldmlvdXNTaWJsaW5nIDogcGFyZW50Lmxhc3RDaGlsZDtcbiAgICBpZiAoc3RhcnQgJiYgKHN0YXJ0ID09PSBlbmQgfHwgc3RhcnQubmV4dFNpYmxpbmcpKSB7XG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKHN0YXJ0LmNsb25lTm9kZSh0cnVlKSwgYW5jaG9yKTtcbiAgICAgICAgaWYgKHN0YXJ0ID09PSBlbmQgfHwgIShzdGFydCA9IHN0YXJ0Lm5leHRTaWJsaW5nKSlcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGVtcGxhdGVDb250YWluZXIuaW5uZXJIVE1MID0gaXNTVkcgPyBgPHN2Zz4ke2NvbnRlbnR9PC9zdmc+YCA6IGNvbnRlbnQ7XG4gICAgICBjb25zdCB0ZW1wbGF0ZSA9IHRlbXBsYXRlQ29udGFpbmVyLmNvbnRlbnQ7XG4gICAgICBpZiAoaXNTVkcpIHtcbiAgICAgICAgY29uc3Qgd3JhcHBlciA9IHRlbXBsYXRlLmZpcnN0Q2hpbGQ7XG4gICAgICAgIHdoaWxlICh3cmFwcGVyLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICB0ZW1wbGF0ZS5hcHBlbmRDaGlsZCh3cmFwcGVyLmZpcnN0Q2hpbGQpO1xuICAgICAgICB9XG4gICAgICAgIHRlbXBsYXRlLnJlbW92ZUNoaWxkKHdyYXBwZXIpO1xuICAgICAgfVxuICAgICAgcGFyZW50Lmluc2VydEJlZm9yZSh0ZW1wbGF0ZSwgYW5jaG9yKTtcbiAgICB9XG4gICAgcmV0dXJuIFtcbiAgICAgIC8vIGZpcnN0XG4gICAgICBiZWZvcmUgPyBiZWZvcmUubmV4dFNpYmxpbmcgOiBwYXJlbnQuZmlyc3RDaGlsZCxcbiAgICAgIC8vIGxhc3RcbiAgICAgIGFuY2hvciA/IGFuY2hvci5wcmV2aW91c1NpYmxpbmcgOiBwYXJlbnQubGFzdENoaWxkXG4gICAgXTtcbiAgfVxufTtcblxuZnVuY3Rpb24gcGF0Y2hDbGFzcyhlbCwgdmFsdWUsIGlzU1ZHKSB7XG4gIGNvbnN0IHRyYW5zaXRpb25DbGFzc2VzID0gZWwuX3Z0YztcbiAgaWYgKHRyYW5zaXRpb25DbGFzc2VzKSB7XG4gICAgdmFsdWUgPSAodmFsdWUgPyBbdmFsdWUsIC4uLnRyYW5zaXRpb25DbGFzc2VzXSA6IFsuLi50cmFuc2l0aW9uQ2xhc3Nlc10pLmpvaW4oXCIgXCIpO1xuICB9XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgZWwucmVtb3ZlQXR0cmlidXRlKFwiY2xhc3NcIik7XG4gIH0gZWxzZSBpZiAoaXNTVkcpIHtcbiAgICBlbC5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCB2YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgZWwuY2xhc3NOYW1lID0gdmFsdWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gcGF0Y2hTdHlsZShlbCwgcHJldiwgbmV4dCkge1xuICBjb25zdCBzdHlsZSA9IGVsLnN0eWxlO1xuICBjb25zdCBpc0Nzc1N0cmluZyA9IGlzU3RyaW5nKG5leHQpO1xuICBpZiAobmV4dCAmJiAhaXNDc3NTdHJpbmcpIHtcbiAgICBpZiAocHJldiAmJiAhaXNTdHJpbmcocHJldikpIHtcbiAgICAgIGZvciAoY29uc3Qga2V5IGluIHByZXYpIHtcbiAgICAgICAgaWYgKG5leHRba2V5XSA9PSBudWxsKSB7XG4gICAgICAgICAgc2V0U3R5bGUoc3R5bGUsIGtleSwgXCJcIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChjb25zdCBrZXkgaW4gbmV4dCkge1xuICAgICAgc2V0U3R5bGUoc3R5bGUsIGtleSwgbmV4dFtrZXldKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgY3VycmVudERpc3BsYXkgPSBzdHlsZS5kaXNwbGF5O1xuICAgIGlmIChpc0Nzc1N0cmluZykge1xuICAgICAgaWYgKHByZXYgIT09IG5leHQpIHtcbiAgICAgICAgc3R5bGUuY3NzVGV4dCA9IG5leHQ7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwcmV2KSB7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoXCJzdHlsZVwiKTtcbiAgICB9XG4gICAgaWYgKFwiX3ZvZFwiIGluIGVsKSB7XG4gICAgICBzdHlsZS5kaXNwbGF5ID0gY3VycmVudERpc3BsYXk7XG4gICAgfVxuICB9XG59XG5jb25zdCBzZW1pY29sb25SRSA9IC9bXlxcXFxdO1xccyokLztcbmNvbnN0IGltcG9ydGFudFJFID0gL1xccyohaW1wb3J0YW50JC87XG5mdW5jdGlvbiBzZXRTdHlsZShzdHlsZSwgbmFtZSwgdmFsKSB7XG4gIGlmIChpc0FycmF5KHZhbCkpIHtcbiAgICB2YWwuZm9yRWFjaCgodikgPT4gc2V0U3R5bGUoc3R5bGUsIG5hbWUsIHYpKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAodmFsID09IG51bGwpXG4gICAgICB2YWwgPSBcIlwiO1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICBpZiAoc2VtaWNvbG9uUkUudGVzdCh2YWwpKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgYFVuZXhwZWN0ZWQgc2VtaWNvbG9uIGF0IHRoZSBlbmQgb2YgJyR7bmFtZX0nIHN0eWxlIHZhbHVlOiAnJHt2YWx9J2BcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG5hbWUuc3RhcnRzV2l0aChcIi0tXCIpKSB7XG4gICAgICBzdHlsZS5zZXRQcm9wZXJ0eShuYW1lLCB2YWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBwcmVmaXhlZCA9IGF1dG9QcmVmaXgoc3R5bGUsIG5hbWUpO1xuICAgICAgaWYgKGltcG9ydGFudFJFLnRlc3QodmFsKSkge1xuICAgICAgICBzdHlsZS5zZXRQcm9wZXJ0eShcbiAgICAgICAgICBoeXBoZW5hdGUocHJlZml4ZWQpLFxuICAgICAgICAgIHZhbC5yZXBsYWNlKGltcG9ydGFudFJFLCBcIlwiKSxcbiAgICAgICAgICBcImltcG9ydGFudFwiXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHlsZVtwcmVmaXhlZF0gPSB2YWw7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5jb25zdCBwcmVmaXhlcyA9IFtcIldlYmtpdFwiLCBcIk1velwiLCBcIm1zXCJdO1xuY29uc3QgcHJlZml4Q2FjaGUgPSB7fTtcbmZ1bmN0aW9uIGF1dG9QcmVmaXgoc3R5bGUsIHJhd05hbWUpIHtcbiAgY29uc3QgY2FjaGVkID0gcHJlZml4Q2FjaGVbcmF3TmFtZV07XG4gIGlmIChjYWNoZWQpIHtcbiAgICByZXR1cm4gY2FjaGVkO1xuICB9XG4gIGxldCBuYW1lID0gY2FtZWxpemUocmF3TmFtZSk7XG4gIGlmIChuYW1lICE9PSBcImZpbHRlclwiICYmIG5hbWUgaW4gc3R5bGUpIHtcbiAgICByZXR1cm4gcHJlZml4Q2FjaGVbcmF3TmFtZV0gPSBuYW1lO1xuICB9XG4gIG5hbWUgPSBjYXBpdGFsaXplKG5hbWUpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHByZWZpeGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgcHJlZml4ZWQgPSBwcmVmaXhlc1tpXSArIG5hbWU7XG4gICAgaWYgKHByZWZpeGVkIGluIHN0eWxlKSB7XG4gICAgICByZXR1cm4gcHJlZml4Q2FjaGVbcmF3TmFtZV0gPSBwcmVmaXhlZDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJhd05hbWU7XG59XG5cbmNvbnN0IHhsaW5rTlMgPSBcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcIjtcbmZ1bmN0aW9uIHBhdGNoQXR0cihlbCwga2V5LCB2YWx1ZSwgaXNTVkcsIGluc3RhbmNlKSB7XG4gIGlmIChpc1NWRyAmJiBrZXkuc3RhcnRzV2l0aChcInhsaW5rOlwiKSkge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGVOUyh4bGlua05TLCBrZXkuc2xpY2UoNiwga2V5Lmxlbmd0aCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGVOUyh4bGlua05TLCBrZXksIHZhbHVlKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgaXNCb29sZWFuID0gaXNTcGVjaWFsQm9vbGVhbkF0dHIoa2V5KTtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCB8fCBpc0Jvb2xlYW4gJiYgIWluY2x1ZGVCb29sZWFuQXR0cih2YWx1ZSkpIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoa2V5LCBpc0Jvb2xlYW4gPyBcIlwiIDogdmFsdWUpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwYXRjaERPTVByb3AoZWwsIGtleSwgdmFsdWUsIHByZXZDaGlsZHJlbiwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgdW5tb3VudENoaWxkcmVuKSB7XG4gIGlmIChrZXkgPT09IFwiaW5uZXJIVE1MXCIgfHwga2V5ID09PSBcInRleHRDb250ZW50XCIpIHtcbiAgICBpZiAocHJldkNoaWxkcmVuKSB7XG4gICAgICB1bm1vdW50Q2hpbGRyZW4ocHJldkNoaWxkcmVuLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlKTtcbiAgICB9XG4gICAgZWxba2V5XSA9IHZhbHVlID09IG51bGwgPyBcIlwiIDogdmFsdWU7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHRhZyA9IGVsLnRhZ05hbWU7XG4gIGlmIChrZXkgPT09IFwidmFsdWVcIiAmJiB0YWcgIT09IFwiUFJPR1JFU1NcIiAmJiAvLyBjdXN0b20gZWxlbWVudHMgbWF5IHVzZSBfdmFsdWUgaW50ZXJuYWxseVxuICAhdGFnLmluY2x1ZGVzKFwiLVwiKSkge1xuICAgIGVsLl92YWx1ZSA9IHZhbHVlO1xuICAgIGNvbnN0IG9sZFZhbHVlID0gdGFnID09PSBcIk9QVElPTlwiID8gZWwuZ2V0QXR0cmlidXRlKFwidmFsdWVcIikgOiBlbC52YWx1ZTtcbiAgICBjb25zdCBuZXdWYWx1ZSA9IHZhbHVlID09IG51bGwgPyBcIlwiIDogdmFsdWU7XG4gICAgaWYgKG9sZFZhbHVlICE9PSBuZXdWYWx1ZSkge1xuICAgICAgZWwudmFsdWUgPSBuZXdWYWx1ZTtcbiAgICB9XG4gICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cbiAgbGV0IG5lZWRSZW1vdmUgPSBmYWxzZTtcbiAgaWYgKHZhbHVlID09PSBcIlwiIHx8IHZhbHVlID09IG51bGwpIHtcbiAgICBjb25zdCB0eXBlID0gdHlwZW9mIGVsW2tleV07XG4gICAgaWYgKHR5cGUgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICB2YWx1ZSA9IGluY2x1ZGVCb29sZWFuQXR0cih2YWx1ZSk7XG4gICAgfSBlbHNlIGlmICh2YWx1ZSA9PSBudWxsICYmIHR5cGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHZhbHVlID0gXCJcIjtcbiAgICAgIG5lZWRSZW1vdmUgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgdmFsdWUgPSAwO1xuICAgICAgbmVlZFJlbW92ZSA9IHRydWU7XG4gICAgfVxuICB9XG4gIHRyeSB7XG4gICAgZWxba2V5XSA9IHZhbHVlO1xuICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgIW5lZWRSZW1vdmUpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIGBGYWlsZWQgc2V0dGluZyBwcm9wIFwiJHtrZXl9XCIgb24gPCR7dGFnLnRvTG93ZXJDYXNlKCl9PjogdmFsdWUgJHt2YWx1ZX0gaXMgaW52YWxpZC5gLFxuICAgICAgICBlXG4gICAgICApO1xuICAgIH1cbiAgfVxuICBuZWVkUmVtb3ZlICYmIGVsLnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xufVxuXG5mdW5jdGlvbiBhZGRFdmVudExpc3RlbmVyKGVsLCBldmVudCwgaGFuZGxlciwgb3B0aW9ucykge1xuICBlbC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyLCBvcHRpb25zKTtcbn1cbmZ1bmN0aW9uIHJlbW92ZUV2ZW50TGlzdGVuZXIoZWwsIGV2ZW50LCBoYW5kbGVyLCBvcHRpb25zKSB7XG4gIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXIsIG9wdGlvbnMpO1xufVxuZnVuY3Rpb24gcGF0Y2hFdmVudChlbCwgcmF3TmFtZSwgcHJldlZhbHVlLCBuZXh0VmFsdWUsIGluc3RhbmNlID0gbnVsbCkge1xuICBjb25zdCBpbnZva2VycyA9IGVsLl92ZWkgfHwgKGVsLl92ZWkgPSB7fSk7XG4gIGNvbnN0IGV4aXN0aW5nSW52b2tlciA9IGludm9rZXJzW3Jhd05hbWVdO1xuICBpZiAobmV4dFZhbHVlICYmIGV4aXN0aW5nSW52b2tlcikge1xuICAgIGV4aXN0aW5nSW52b2tlci52YWx1ZSA9IG5leHRWYWx1ZTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBbbmFtZSwgb3B0aW9uc10gPSBwYXJzZU5hbWUocmF3TmFtZSk7XG4gICAgaWYgKG5leHRWYWx1ZSkge1xuICAgICAgY29uc3QgaW52b2tlciA9IGludm9rZXJzW3Jhd05hbWVdID0gY3JlYXRlSW52b2tlcihuZXh0VmFsdWUsIGluc3RhbmNlKTtcbiAgICAgIGFkZEV2ZW50TGlzdGVuZXIoZWwsIG5hbWUsIGludm9rZXIsIG9wdGlvbnMpO1xuICAgIH0gZWxzZSBpZiAoZXhpc3RpbmdJbnZva2VyKSB7XG4gICAgICByZW1vdmVFdmVudExpc3RlbmVyKGVsLCBuYW1lLCBleGlzdGluZ0ludm9rZXIsIG9wdGlvbnMpO1xuICAgICAgaW52b2tlcnNbcmF3TmFtZV0gPSB2b2lkIDA7XG4gICAgfVxuICB9XG59XG5jb25zdCBvcHRpb25zTW9kaWZpZXJSRSA9IC8oPzpPbmNlfFBhc3NpdmV8Q2FwdHVyZSkkLztcbmZ1bmN0aW9uIHBhcnNlTmFtZShuYW1lKSB7XG4gIGxldCBvcHRpb25zO1xuICBpZiAob3B0aW9uc01vZGlmaWVyUkUudGVzdChuYW1lKSkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgICBsZXQgbTtcbiAgICB3aGlsZSAobSA9IG5hbWUubWF0Y2gob3B0aW9uc01vZGlmaWVyUkUpKSB7XG4gICAgICBuYW1lID0gbmFtZS5zbGljZSgwLCBuYW1lLmxlbmd0aCAtIG1bMF0ubGVuZ3RoKTtcbiAgICAgIG9wdGlvbnNbbVswXS50b0xvd2VyQ2FzZSgpXSA9IHRydWU7XG4gICAgfVxuICB9XG4gIGNvbnN0IGV2ZW50ID0gbmFtZVsyXSA9PT0gXCI6XCIgPyBuYW1lLnNsaWNlKDMpIDogaHlwaGVuYXRlKG5hbWUuc2xpY2UoMikpO1xuICByZXR1cm4gW2V2ZW50LCBvcHRpb25zXTtcbn1cbmxldCBjYWNoZWROb3cgPSAwO1xuY29uc3QgcCA9IC8qIEBfX1BVUkVfXyAqLyBQcm9taXNlLnJlc29sdmUoKTtcbmNvbnN0IGdldE5vdyA9ICgpID0+IGNhY2hlZE5vdyB8fCAocC50aGVuKCgpID0+IGNhY2hlZE5vdyA9IDApLCBjYWNoZWROb3cgPSBEYXRlLm5vdygpKTtcbmZ1bmN0aW9uIGNyZWF0ZUludm9rZXIoaW5pdGlhbFZhbHVlLCBpbnN0YW5jZSkge1xuICBjb25zdCBpbnZva2VyID0gKGUpID0+IHtcbiAgICBpZiAoIWUuX3Z0cykge1xuICAgICAgZS5fdnRzID0gRGF0ZS5ub3coKTtcbiAgICB9IGVsc2UgaWYgKGUuX3Z0cyA8PSBpbnZva2VyLmF0dGFjaGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNhbGxXaXRoQXN5bmNFcnJvckhhbmRsaW5nKFxuICAgICAgcGF0Y2hTdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oZSwgaW52b2tlci52YWx1ZSksXG4gICAgICBpbnN0YW5jZSxcbiAgICAgIDUsXG4gICAgICBbZV1cbiAgICApO1xuICB9O1xuICBpbnZva2VyLnZhbHVlID0gaW5pdGlhbFZhbHVlO1xuICBpbnZva2VyLmF0dGFjaGVkID0gZ2V0Tm93KCk7XG4gIHJldHVybiBpbnZva2VyO1xufVxuZnVuY3Rpb24gcGF0Y2hTdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oZSwgdmFsdWUpIHtcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgY29uc3Qgb3JpZ2luYWxTdG9wID0gZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb247XG4gICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24gPSAoKSA9PiB7XG4gICAgICBvcmlnaW5hbFN0b3AuY2FsbChlKTtcbiAgICAgIGUuX3N0b3BwZWQgPSB0cnVlO1xuICAgIH07XG4gICAgcmV0dXJuIHZhbHVlLm1hcCgoZm4pID0+IChlMikgPT4gIWUyLl9zdG9wcGVkICYmIGZuICYmIGZuKGUyKSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG59XG5cbmNvbnN0IG5hdGl2ZU9uUkUgPSAvXm9uW2Etel0vO1xuY29uc3QgcGF0Y2hQcm9wID0gKGVsLCBrZXksIHByZXZWYWx1ZSwgbmV4dFZhbHVlLCBpc1NWRyA9IGZhbHNlLCBwcmV2Q2hpbGRyZW4sIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHVubW91bnRDaGlsZHJlbikgPT4ge1xuICBpZiAoa2V5ID09PSBcImNsYXNzXCIpIHtcbiAgICBwYXRjaENsYXNzKGVsLCBuZXh0VmFsdWUsIGlzU1ZHKTtcbiAgfSBlbHNlIGlmIChrZXkgPT09IFwic3R5bGVcIikge1xuICAgIHBhdGNoU3R5bGUoZWwsIHByZXZWYWx1ZSwgbmV4dFZhbHVlKTtcbiAgfSBlbHNlIGlmIChpc09uKGtleSkpIHtcbiAgICBpZiAoIWlzTW9kZWxMaXN0ZW5lcihrZXkpKSB7XG4gICAgICBwYXRjaEV2ZW50KGVsLCBrZXksIHByZXZWYWx1ZSwgbmV4dFZhbHVlLCBwYXJlbnRDb21wb25lbnQpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChrZXlbMF0gPT09IFwiLlwiID8gKGtleSA9IGtleS5zbGljZSgxKSwgdHJ1ZSkgOiBrZXlbMF0gPT09IFwiXlwiID8gKGtleSA9IGtleS5zbGljZSgxKSwgZmFsc2UpIDogc2hvdWxkU2V0QXNQcm9wKGVsLCBrZXksIG5leHRWYWx1ZSwgaXNTVkcpKSB7XG4gICAgcGF0Y2hET01Qcm9wKFxuICAgICAgZWwsXG4gICAgICBrZXksXG4gICAgICBuZXh0VmFsdWUsXG4gICAgICBwcmV2Q2hpbGRyZW4sXG4gICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgIHVubW91bnRDaGlsZHJlblxuICAgICk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKGtleSA9PT0gXCJ0cnVlLXZhbHVlXCIpIHtcbiAgICAgIGVsLl90cnVlVmFsdWUgPSBuZXh0VmFsdWU7XG4gICAgfSBlbHNlIGlmIChrZXkgPT09IFwiZmFsc2UtdmFsdWVcIikge1xuICAgICAgZWwuX2ZhbHNlVmFsdWUgPSBuZXh0VmFsdWU7XG4gICAgfVxuICAgIHBhdGNoQXR0cihlbCwga2V5LCBuZXh0VmFsdWUsIGlzU1ZHKTtcbiAgfVxufTtcbmZ1bmN0aW9uIHNob3VsZFNldEFzUHJvcChlbCwga2V5LCB2YWx1ZSwgaXNTVkcpIHtcbiAgaWYgKGlzU1ZHKSB7XG4gICAgaWYgKGtleSA9PT0gXCJpbm5lckhUTUxcIiB8fCBrZXkgPT09IFwidGV4dENvbnRlbnRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChrZXkgaW4gZWwgJiYgbmF0aXZlT25SRS50ZXN0KGtleSkgJiYgaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGtleSA9PT0gXCJzcGVsbGNoZWNrXCIgfHwga2V5ID09PSBcImRyYWdnYWJsZVwiIHx8IGtleSA9PT0gXCJ0cmFuc2xhdGVcIikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoa2V5ID09PSBcImZvcm1cIikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoa2V5ID09PSBcImxpc3RcIiAmJiBlbC50YWdOYW1lID09PSBcIklOUFVUXCIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGtleSA9PT0gXCJ0eXBlXCIgJiYgZWwudGFnTmFtZSA9PT0gXCJURVhUQVJFQVwiKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChuYXRpdmVPblJFLnRlc3Qoa2V5KSAmJiBpc1N0cmluZyh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGtleSBpbiBlbDtcbn1cblxuZnVuY3Rpb24gZGVmaW5lQ3VzdG9tRWxlbWVudChvcHRpb25zLCBoeWRyYXRlMikge1xuICBjb25zdCBDb21wID0gZGVmaW5lQ29tcG9uZW50KG9wdGlvbnMpO1xuICBjbGFzcyBWdWVDdXN0b21FbGVtZW50IGV4dGVuZHMgVnVlRWxlbWVudCB7XG4gICAgY29uc3RydWN0b3IoaW5pdGlhbFByb3BzKSB7XG4gICAgICBzdXBlcihDb21wLCBpbml0aWFsUHJvcHMsIGh5ZHJhdGUyKTtcbiAgICB9XG4gIH1cbiAgVnVlQ3VzdG9tRWxlbWVudC5kZWYgPSBDb21wO1xuICByZXR1cm4gVnVlQ3VzdG9tRWxlbWVudDtcbn1cbmNvbnN0IGRlZmluZVNTUkN1c3RvbUVsZW1lbnQgPSAob3B0aW9ucykgPT4ge1xuICByZXR1cm4gZGVmaW5lQ3VzdG9tRWxlbWVudChvcHRpb25zLCBoeWRyYXRlKTtcbn07XG5jb25zdCBCYXNlQ2xhc3MgPSB0eXBlb2YgSFRNTEVsZW1lbnQgIT09IFwidW5kZWZpbmVkXCIgPyBIVE1MRWxlbWVudCA6IGNsYXNzIHtcbn07XG5jbGFzcyBWdWVFbGVtZW50IGV4dGVuZHMgQmFzZUNsYXNzIHtcbiAgY29uc3RydWN0b3IoX2RlZiwgX3Byb3BzID0ge30sIGh5ZHJhdGUyKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLl9kZWYgPSBfZGVmO1xuICAgIHRoaXMuX3Byb3BzID0gX3Byb3BzO1xuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHRoaXMuX2luc3RhbmNlID0gbnVsbDtcbiAgICB0aGlzLl9jb25uZWN0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9yZXNvbHZlZCA9IGZhbHNlO1xuICAgIHRoaXMuX251bWJlclByb3BzID0gbnVsbDtcbiAgICBpZiAodGhpcy5zaGFkb3dSb290ICYmIGh5ZHJhdGUyKSB7XG4gICAgICBoeWRyYXRlMih0aGlzLl9jcmVhdGVWTm9kZSgpLCB0aGlzLnNoYWRvd1Jvb3QpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiB0aGlzLnNoYWRvd1Jvb3QpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBgQ3VzdG9tIGVsZW1lbnQgaGFzIHByZS1yZW5kZXJlZCBkZWNsYXJhdGl2ZSBzaGFkb3cgcm9vdCBidXQgaXMgbm90IGRlZmluZWQgYXMgaHlkcmF0YWJsZS4gVXNlIFxcYGRlZmluZVNTUkN1c3RvbUVsZW1lbnRcXGAuYFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgdGhpcy5hdHRhY2hTaGFkb3coeyBtb2RlOiBcIm9wZW5cIiB9KTtcbiAgICAgIGlmICghdGhpcy5fZGVmLl9fYXN5bmNMb2FkZXIpIHtcbiAgICAgICAgdGhpcy5fcmVzb2x2ZVByb3BzKHRoaXMuX2RlZik7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIHRoaXMuX2Nvbm5lY3RlZCA9IHRydWU7XG4gICAgaWYgKCF0aGlzLl9pbnN0YW5jZSkge1xuICAgICAgaWYgKHRoaXMuX3Jlc29sdmVkKSB7XG4gICAgICAgIHRoaXMuX3VwZGF0ZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fcmVzb2x2ZURlZigpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICB0aGlzLl9jb25uZWN0ZWQgPSBmYWxzZTtcbiAgICBuZXh0VGljaygoKSA9PiB7XG4gICAgICBpZiAoIXRoaXMuX2Nvbm5lY3RlZCkge1xuICAgICAgICByZW5kZXIobnVsbCwgdGhpcy5zaGFkb3dSb290KTtcbiAgICAgICAgdGhpcy5faW5zdGFuY2UgPSBudWxsO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiByZXNvbHZlIGlubmVyIGNvbXBvbmVudCBkZWZpbml0aW9uIChoYW5kbGUgcG9zc2libGUgYXN5bmMgY29tcG9uZW50KVxuICAgKi9cbiAgX3Jlc29sdmVEZWYoKSB7XG4gICAgdGhpcy5fcmVzb2x2ZWQgPSB0cnVlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5hdHRyaWJ1dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLl9zZXRBdHRyKHRoaXMuYXR0cmlidXRlc1tpXS5uYW1lKTtcbiAgICB9XG4gICAgbmV3IE11dGF0aW9uT2JzZXJ2ZXIoKG11dGF0aW9ucykgPT4ge1xuICAgICAgZm9yIChjb25zdCBtIG9mIG11dGF0aW9ucykge1xuICAgICAgICB0aGlzLl9zZXRBdHRyKG0uYXR0cmlidXRlTmFtZSk7XG4gICAgICB9XG4gICAgfSkub2JzZXJ2ZSh0aGlzLCB7IGF0dHJpYnV0ZXM6IHRydWUgfSk7XG4gICAgY29uc3QgcmVzb2x2ZSA9IChkZWYsIGlzQXN5bmMgPSBmYWxzZSkgPT4ge1xuICAgICAgY29uc3QgeyBwcm9wcywgc3R5bGVzIH0gPSBkZWY7XG4gICAgICBsZXQgbnVtYmVyUHJvcHM7XG4gICAgICBpZiAocHJvcHMgJiYgIWlzQXJyYXkocHJvcHMpKSB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHByb3BzKSB7XG4gICAgICAgICAgY29uc3Qgb3B0ID0gcHJvcHNba2V5XTtcbiAgICAgICAgICBpZiAob3B0ID09PSBOdW1iZXIgfHwgb3B0ICYmIG9wdC50eXBlID09PSBOdW1iZXIpIHtcbiAgICAgICAgICAgIGlmIChrZXkgaW4gdGhpcy5fcHJvcHMpIHtcbiAgICAgICAgICAgICAgdGhpcy5fcHJvcHNba2V5XSA9IHRvTnVtYmVyKHRoaXMuX3Byb3BzW2tleV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKG51bWJlclByb3BzIHx8IChudW1iZXJQcm9wcyA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpKSlbY2FtZWxpemUkMShrZXkpXSA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLl9udW1iZXJQcm9wcyA9IG51bWJlclByb3BzO1xuICAgICAgaWYgKGlzQXN5bmMpIHtcbiAgICAgICAgdGhpcy5fcmVzb2x2ZVByb3BzKGRlZik7XG4gICAgICB9XG4gICAgICB0aGlzLl9hcHBseVN0eWxlcyhzdHlsZXMpO1xuICAgICAgdGhpcy5fdXBkYXRlKCk7XG4gICAgfTtcbiAgICBjb25zdCBhc3luY0RlZiA9IHRoaXMuX2RlZi5fX2FzeW5jTG9hZGVyO1xuICAgIGlmIChhc3luY0RlZikge1xuICAgICAgYXN5bmNEZWYoKS50aGVuKChkZWYpID0+IHJlc29sdmUoZGVmLCB0cnVlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc29sdmUodGhpcy5fZGVmKTtcbiAgICB9XG4gIH1cbiAgX3Jlc29sdmVQcm9wcyhkZWYpIHtcbiAgICBjb25zdCB7IHByb3BzIH0gPSBkZWY7XG4gICAgY29uc3QgZGVjbGFyZWRQcm9wS2V5cyA9IGlzQXJyYXkocHJvcHMpID8gcHJvcHMgOiBPYmplY3Qua2V5cyhwcm9wcyB8fCB7fSk7XG4gICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXModGhpcykpIHtcbiAgICAgIGlmIChrZXlbMF0gIT09IFwiX1wiICYmIGRlY2xhcmVkUHJvcEtleXMuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICB0aGlzLl9zZXRQcm9wKGtleSwgdGhpc1trZXldLCB0cnVlLCBmYWxzZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAoY29uc3Qga2V5IG9mIGRlY2xhcmVkUHJvcEtleXMubWFwKGNhbWVsaXplJDEpKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywga2V5LCB7XG4gICAgICAgIGdldCgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0UHJvcChrZXkpO1xuICAgICAgICB9LFxuICAgICAgICBzZXQodmFsKSB7XG4gICAgICAgICAgdGhpcy5fc2V0UHJvcChrZXksIHZhbCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBfc2V0QXR0cihrZXkpIHtcbiAgICBsZXQgdmFsdWUgPSB0aGlzLmdldEF0dHJpYnV0ZShrZXkpO1xuICAgIGNvbnN0IGNhbWVsS2V5ID0gY2FtZWxpemUkMShrZXkpO1xuICAgIGlmICh0aGlzLl9udW1iZXJQcm9wcyAmJiB0aGlzLl9udW1iZXJQcm9wc1tjYW1lbEtleV0pIHtcbiAgICAgIHZhbHVlID0gdG9OdW1iZXIodmFsdWUpO1xuICAgIH1cbiAgICB0aGlzLl9zZXRQcm9wKGNhbWVsS2V5LCB2YWx1ZSwgZmFsc2UpO1xuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF9nZXRQcm9wKGtleSkge1xuICAgIHJldHVybiB0aGlzLl9wcm9wc1trZXldO1xuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF9zZXRQcm9wKGtleSwgdmFsLCBzaG91bGRSZWZsZWN0ID0gdHJ1ZSwgc2hvdWxkVXBkYXRlID0gdHJ1ZSkge1xuICAgIGlmICh2YWwgIT09IHRoaXMuX3Byb3BzW2tleV0pIHtcbiAgICAgIHRoaXMuX3Byb3BzW2tleV0gPSB2YWw7XG4gICAgICBpZiAoc2hvdWxkVXBkYXRlICYmIHRoaXMuX2luc3RhbmNlKSB7XG4gICAgICAgIHRoaXMuX3VwZGF0ZSgpO1xuICAgICAgfVxuICAgICAgaWYgKHNob3VsZFJlZmxlY3QpIHtcbiAgICAgICAgaWYgKHZhbCA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKGh5cGhlbmF0ZShrZXkpLCBcIlwiKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSBcInN0cmluZ1wiIHx8IHR5cGVvZiB2YWwgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZShoeXBoZW5hdGUoa2V5KSwgdmFsICsgXCJcIik7XG4gICAgICAgIH0gZWxzZSBpZiAoIXZhbCkge1xuICAgICAgICAgIHRoaXMucmVtb3ZlQXR0cmlidXRlKGh5cGhlbmF0ZShrZXkpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBfdXBkYXRlKCkge1xuICAgIHJlbmRlcih0aGlzLl9jcmVhdGVWTm9kZSgpLCB0aGlzLnNoYWRvd1Jvb3QpO1xuICB9XG4gIF9jcmVhdGVWTm9kZSgpIHtcbiAgICBjb25zdCB2bm9kZSA9IGNyZWF0ZVZOb2RlKHRoaXMuX2RlZiwgZXh0ZW5kKHt9LCB0aGlzLl9wcm9wcykpO1xuICAgIGlmICghdGhpcy5faW5zdGFuY2UpIHtcbiAgICAgIHZub2RlLmNlID0gKGluc3RhbmNlKSA9PiB7XG4gICAgICAgIHRoaXMuX2luc3RhbmNlID0gaW5zdGFuY2U7XG4gICAgICAgIGluc3RhbmNlLmlzQ0UgPSB0cnVlO1xuICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgIGluc3RhbmNlLmNlUmVsb2FkID0gKG5ld1N0eWxlcykgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3N0eWxlcykge1xuICAgICAgICAgICAgICB0aGlzLl9zdHlsZXMuZm9yRWFjaCgocykgPT4gdGhpcy5zaGFkb3dSb290LnJlbW92ZUNoaWxkKHMpKTtcbiAgICAgICAgICAgICAgdGhpcy5fc3R5bGVzLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9hcHBseVN0eWxlcyhuZXdTdHlsZXMpO1xuICAgICAgICAgICAgdGhpcy5faW5zdGFuY2UgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlKCk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkaXNwYXRjaCA9IChldmVudCwgYXJncykgPT4ge1xuICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChcbiAgICAgICAgICAgIG5ldyBDdXN0b21FdmVudChldmVudCwge1xuICAgICAgICAgICAgICBkZXRhaWw6IGFyZ3NcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKTtcbiAgICAgICAgfTtcbiAgICAgICAgaW5zdGFuY2UuZW1pdCA9IChldmVudCwgLi4uYXJncykgPT4ge1xuICAgICAgICAgIGRpc3BhdGNoKGV2ZW50LCBhcmdzKTtcbiAgICAgICAgICBpZiAoaHlwaGVuYXRlKGV2ZW50KSAhPT0gZXZlbnQpIHtcbiAgICAgICAgICAgIGRpc3BhdGNoKGh5cGhlbmF0ZShldmVudCksIGFyZ3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgbGV0IHBhcmVudCA9IHRoaXM7XG4gICAgICAgIHdoaWxlIChwYXJlbnQgPSBwYXJlbnQgJiYgKHBhcmVudC5wYXJlbnROb2RlIHx8IHBhcmVudC5ob3N0KSkge1xuICAgICAgICAgIGlmIChwYXJlbnQgaW5zdGFuY2VvZiBWdWVFbGVtZW50KSB7XG4gICAgICAgICAgICBpbnN0YW5jZS5wYXJlbnQgPSBwYXJlbnQuX2luc3RhbmNlO1xuICAgICAgICAgICAgaW5zdGFuY2UucHJvdmlkZXMgPSBwYXJlbnQuX2luc3RhbmNlLnByb3ZpZGVzO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gdm5vZGU7XG4gIH1cbiAgX2FwcGx5U3R5bGVzKHN0eWxlcykge1xuICAgIGlmIChzdHlsZXMpIHtcbiAgICAgIHN0eWxlcy5mb3JFYWNoKChjc3MpID0+IHtcbiAgICAgICAgY29uc3QgcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtcbiAgICAgICAgcy50ZXh0Q29udGVudCA9IGNzcztcbiAgICAgICAgdGhpcy5zaGFkb3dSb290LmFwcGVuZENoaWxkKHMpO1xuICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgICh0aGlzLl9zdHlsZXMgfHwgKHRoaXMuX3N0eWxlcyA9IFtdKSkucHVzaChzKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHVzZUNzc01vZHVsZShuYW1lID0gXCIkc3R5bGVcIikge1xuICB7XG4gICAgY29uc3QgaW5zdGFuY2UgPSBnZXRDdXJyZW50SW5zdGFuY2UoKTtcbiAgICBpZiAoIWluc3RhbmNlKSB7XG4gICAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHdhcm4oYHVzZUNzc01vZHVsZSBtdXN0IGJlIGNhbGxlZCBpbnNpZGUgc2V0dXAoKWApO1xuICAgICAgcmV0dXJuIEVNUFRZX09CSjtcbiAgICB9XG4gICAgY29uc3QgbW9kdWxlcyA9IGluc3RhbmNlLnR5cGUuX19jc3NNb2R1bGVzO1xuICAgIGlmICghbW9kdWxlcykge1xuICAgICAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiB3YXJuKGBDdXJyZW50IGluc3RhbmNlIGRvZXMgbm90IGhhdmUgQ1NTIG1vZHVsZXMgaW5qZWN0ZWQuYCk7XG4gICAgICByZXR1cm4gRU1QVFlfT0JKO1xuICAgIH1cbiAgICBjb25zdCBtb2QgPSBtb2R1bGVzW25hbWVdO1xuICAgIGlmICghbW9kKSB7XG4gICAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHdhcm4oYEN1cnJlbnQgaW5zdGFuY2UgZG9lcyBub3QgaGF2ZSBDU1MgbW9kdWxlIG5hbWVkIFwiJHtuYW1lfVwiLmApO1xuICAgICAgcmV0dXJuIEVNUFRZX09CSjtcbiAgICB9XG4gICAgcmV0dXJuIG1vZDtcbiAgfVxufVxuXG5mdW5jdGlvbiB1c2VDc3NWYXJzKGdldHRlcikge1xuICBjb25zdCBpbnN0YW5jZSA9IGdldEN1cnJlbnRJbnN0YW5jZSgpO1xuICBpZiAoIWluc3RhbmNlKSB7XG4gICAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiB3YXJuKGB1c2VDc3NWYXJzIGlzIGNhbGxlZCB3aXRob3V0IGN1cnJlbnQgYWN0aXZlIGNvbXBvbmVudCBpbnN0YW5jZS5gKTtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgdXBkYXRlVGVsZXBvcnRzID0gaW5zdGFuY2UudXQgPSAodmFycyA9IGdldHRlcihpbnN0YW5jZS5wcm94eSkpID0+IHtcbiAgICBBcnJheS5mcm9tKFxuICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChgW2RhdGEtdi1vd25lcj1cIiR7aW5zdGFuY2UudWlkfVwiXWApXG4gICAgKS5mb3JFYWNoKChub2RlKSA9PiBzZXRWYXJzT25Ob2RlKG5vZGUsIHZhcnMpKTtcbiAgfTtcbiAgY29uc3Qgc2V0VmFycyA9ICgpID0+IHtcbiAgICBjb25zdCB2YXJzID0gZ2V0dGVyKGluc3RhbmNlLnByb3h5KTtcbiAgICBzZXRWYXJzT25WTm9kZShpbnN0YW5jZS5zdWJUcmVlLCB2YXJzKTtcbiAgICB1cGRhdGVUZWxlcG9ydHModmFycyk7XG4gIH07XG4gIHdhdGNoUG9zdEVmZmVjdChzZXRWYXJzKTtcbiAgb25Nb3VudGVkKCgpID0+IHtcbiAgICBjb25zdCBvYiA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKHNldFZhcnMpO1xuICAgIG9iLm9ic2VydmUoaW5zdGFuY2Uuc3ViVHJlZS5lbC5wYXJlbnROb2RlLCB7IGNoaWxkTGlzdDogdHJ1ZSB9KTtcbiAgICBvblVubW91bnRlZCgoKSA9PiBvYi5kaXNjb25uZWN0KCkpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIHNldFZhcnNPblZOb2RlKHZub2RlLCB2YXJzKSB7XG4gIGlmICh2bm9kZS5zaGFwZUZsYWcgJiAxMjgpIHtcbiAgICBjb25zdCBzdXNwZW5zZSA9IHZub2RlLnN1c3BlbnNlO1xuICAgIHZub2RlID0gc3VzcGVuc2UuYWN0aXZlQnJhbmNoO1xuICAgIGlmIChzdXNwZW5zZS5wZW5kaW5nQnJhbmNoICYmICFzdXNwZW5zZS5pc0h5ZHJhdGluZykge1xuICAgICAgc3VzcGVuc2UuZWZmZWN0cy5wdXNoKCgpID0+IHtcbiAgICAgICAgc2V0VmFyc09uVk5vZGUoc3VzcGVuc2UuYWN0aXZlQnJhbmNoLCB2YXJzKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICB3aGlsZSAodm5vZGUuY29tcG9uZW50KSB7XG4gICAgdm5vZGUgPSB2bm9kZS5jb21wb25lbnQuc3ViVHJlZTtcbiAgfVxuICBpZiAodm5vZGUuc2hhcGVGbGFnICYgMSAmJiB2bm9kZS5lbCkge1xuICAgIHNldFZhcnNPbk5vZGUodm5vZGUuZWwsIHZhcnMpO1xuICB9IGVsc2UgaWYgKHZub2RlLnR5cGUgPT09IEZyYWdtZW50KSB7XG4gICAgdm5vZGUuY2hpbGRyZW4uZm9yRWFjaCgoYykgPT4gc2V0VmFyc09uVk5vZGUoYywgdmFycykpO1xuICB9IGVsc2UgaWYgKHZub2RlLnR5cGUgPT09IFN0YXRpYykge1xuICAgIGxldCB7IGVsLCBhbmNob3IgfSA9IHZub2RlO1xuICAgIHdoaWxlIChlbCkge1xuICAgICAgc2V0VmFyc09uTm9kZShlbCwgdmFycyk7XG4gICAgICBpZiAoZWwgPT09IGFuY2hvcilcbiAgICAgICAgYnJlYWs7XG4gICAgICBlbCA9IGVsLm5leHRTaWJsaW5nO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gc2V0VmFyc09uTm9kZShlbCwgdmFycykge1xuICBpZiAoZWwubm9kZVR5cGUgPT09IDEpIHtcbiAgICBjb25zdCBzdHlsZSA9IGVsLnN0eWxlO1xuICAgIGZvciAoY29uc3Qga2V5IGluIHZhcnMpIHtcbiAgICAgIHN0eWxlLnNldFByb3BlcnR5KGAtLSR7a2V5fWAsIHZhcnNba2V5XSk7XG4gICAgfVxuICB9XG59XG5cbmNvbnN0IFRSQU5TSVRJT04gPSBcInRyYW5zaXRpb25cIjtcbmNvbnN0IEFOSU1BVElPTiA9IFwiYW5pbWF0aW9uXCI7XG5jb25zdCBUcmFuc2l0aW9uID0gKHByb3BzLCB7IHNsb3RzIH0pID0+IGgoQmFzZVRyYW5zaXRpb24sIHJlc29sdmVUcmFuc2l0aW9uUHJvcHMocHJvcHMpLCBzbG90cyk7XG5UcmFuc2l0aW9uLmRpc3BsYXlOYW1lID0gXCJUcmFuc2l0aW9uXCI7XG5jb25zdCBET01UcmFuc2l0aW9uUHJvcHNWYWxpZGF0b3JzID0ge1xuICBuYW1lOiBTdHJpbmcsXG4gIHR5cGU6IFN0cmluZyxcbiAgY3NzOiB7XG4gICAgdHlwZTogQm9vbGVhbixcbiAgICBkZWZhdWx0OiB0cnVlXG4gIH0sXG4gIGR1cmF0aW9uOiBbU3RyaW5nLCBOdW1iZXIsIE9iamVjdF0sXG4gIGVudGVyRnJvbUNsYXNzOiBTdHJpbmcsXG4gIGVudGVyQWN0aXZlQ2xhc3M6IFN0cmluZyxcbiAgZW50ZXJUb0NsYXNzOiBTdHJpbmcsXG4gIGFwcGVhckZyb21DbGFzczogU3RyaW5nLFxuICBhcHBlYXJBY3RpdmVDbGFzczogU3RyaW5nLFxuICBhcHBlYXJUb0NsYXNzOiBTdHJpbmcsXG4gIGxlYXZlRnJvbUNsYXNzOiBTdHJpbmcsXG4gIGxlYXZlQWN0aXZlQ2xhc3M6IFN0cmluZyxcbiAgbGVhdmVUb0NsYXNzOiBTdHJpbmdcbn07XG5jb25zdCBUcmFuc2l0aW9uUHJvcHNWYWxpZGF0b3JzID0gVHJhbnNpdGlvbi5wcm9wcyA9IC8qIEBfX1BVUkVfXyAqLyBleHRlbmQoXG4gIHt9LFxuICBCYXNlVHJhbnNpdGlvblByb3BzVmFsaWRhdG9ycyxcbiAgRE9NVHJhbnNpdGlvblByb3BzVmFsaWRhdG9yc1xuKTtcbmNvbnN0IGNhbGxIb29rID0gKGhvb2ssIGFyZ3MgPSBbXSkgPT4ge1xuICBpZiAoaXNBcnJheShob29rKSkge1xuICAgIGhvb2suZm9yRWFjaCgoaDIpID0+IGgyKC4uLmFyZ3MpKTtcbiAgfSBlbHNlIGlmIChob29rKSB7XG4gICAgaG9vayguLi5hcmdzKTtcbiAgfVxufTtcbmNvbnN0IGhhc0V4cGxpY2l0Q2FsbGJhY2sgPSAoaG9vaykgPT4ge1xuICByZXR1cm4gaG9vayA/IGlzQXJyYXkoaG9vaykgPyBob29rLnNvbWUoKGgyKSA9PiBoMi5sZW5ndGggPiAxKSA6IGhvb2subGVuZ3RoID4gMSA6IGZhbHNlO1xufTtcbmZ1bmN0aW9uIHJlc29sdmVUcmFuc2l0aW9uUHJvcHMocmF3UHJvcHMpIHtcbiAgY29uc3QgYmFzZVByb3BzID0ge307XG4gIGZvciAoY29uc3Qga2V5IGluIHJhd1Byb3BzKSB7XG4gICAgaWYgKCEoa2V5IGluIERPTVRyYW5zaXRpb25Qcm9wc1ZhbGlkYXRvcnMpKSB7XG4gICAgICBiYXNlUHJvcHNba2V5XSA9IHJhd1Byb3BzW2tleV07XG4gICAgfVxuICB9XG4gIGlmIChyYXdQcm9wcy5jc3MgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIGJhc2VQcm9wcztcbiAgfVxuICBjb25zdCB7XG4gICAgbmFtZSA9IFwidlwiLFxuICAgIHR5cGUsXG4gICAgZHVyYXRpb24sXG4gICAgZW50ZXJGcm9tQ2xhc3MgPSBgJHtuYW1lfS1lbnRlci1mcm9tYCxcbiAgICBlbnRlckFjdGl2ZUNsYXNzID0gYCR7bmFtZX0tZW50ZXItYWN0aXZlYCxcbiAgICBlbnRlclRvQ2xhc3MgPSBgJHtuYW1lfS1lbnRlci10b2AsXG4gICAgYXBwZWFyRnJvbUNsYXNzID0gZW50ZXJGcm9tQ2xhc3MsXG4gICAgYXBwZWFyQWN0aXZlQ2xhc3MgPSBlbnRlckFjdGl2ZUNsYXNzLFxuICAgIGFwcGVhclRvQ2xhc3MgPSBlbnRlclRvQ2xhc3MsXG4gICAgbGVhdmVGcm9tQ2xhc3MgPSBgJHtuYW1lfS1sZWF2ZS1mcm9tYCxcbiAgICBsZWF2ZUFjdGl2ZUNsYXNzID0gYCR7bmFtZX0tbGVhdmUtYWN0aXZlYCxcbiAgICBsZWF2ZVRvQ2xhc3MgPSBgJHtuYW1lfS1sZWF2ZS10b2BcbiAgfSA9IHJhd1Byb3BzO1xuICBjb25zdCBkdXJhdGlvbnMgPSBub3JtYWxpemVEdXJhdGlvbihkdXJhdGlvbik7XG4gIGNvbnN0IGVudGVyRHVyYXRpb24gPSBkdXJhdGlvbnMgJiYgZHVyYXRpb25zWzBdO1xuICBjb25zdCBsZWF2ZUR1cmF0aW9uID0gZHVyYXRpb25zICYmIGR1cmF0aW9uc1sxXTtcbiAgY29uc3Qge1xuICAgIG9uQmVmb3JlRW50ZXIsXG4gICAgb25FbnRlcixcbiAgICBvbkVudGVyQ2FuY2VsbGVkLFxuICAgIG9uTGVhdmUsXG4gICAgb25MZWF2ZUNhbmNlbGxlZCxcbiAgICBvbkJlZm9yZUFwcGVhciA9IG9uQmVmb3JlRW50ZXIsXG4gICAgb25BcHBlYXIgPSBvbkVudGVyLFxuICAgIG9uQXBwZWFyQ2FuY2VsbGVkID0gb25FbnRlckNhbmNlbGxlZFxuICB9ID0gYmFzZVByb3BzO1xuICBjb25zdCBmaW5pc2hFbnRlciA9IChlbCwgaXNBcHBlYXIsIGRvbmUpID0+IHtcbiAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGlzQXBwZWFyID8gYXBwZWFyVG9DbGFzcyA6IGVudGVyVG9DbGFzcyk7XG4gICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBpc0FwcGVhciA/IGFwcGVhckFjdGl2ZUNsYXNzIDogZW50ZXJBY3RpdmVDbGFzcyk7XG4gICAgZG9uZSAmJiBkb25lKCk7XG4gIH07XG4gIGNvbnN0IGZpbmlzaExlYXZlID0gKGVsLCBkb25lKSA9PiB7XG4gICAgZWwuX2lzTGVhdmluZyA9IGZhbHNlO1xuICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVGcm9tQ2xhc3MpO1xuICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVUb0NsYXNzKTtcbiAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQWN0aXZlQ2xhc3MpO1xuICAgIGRvbmUgJiYgZG9uZSgpO1xuICB9O1xuICBjb25zdCBtYWtlRW50ZXJIb29rID0gKGlzQXBwZWFyKSA9PiB7XG4gICAgcmV0dXJuIChlbCwgZG9uZSkgPT4ge1xuICAgICAgY29uc3QgaG9vayA9IGlzQXBwZWFyID8gb25BcHBlYXIgOiBvbkVudGVyO1xuICAgICAgY29uc3QgcmVzb2x2ZSA9ICgpID0+IGZpbmlzaEVudGVyKGVsLCBpc0FwcGVhciwgZG9uZSk7XG4gICAgICBjYWxsSG9vayhob29rLCBbZWwsIHJlc29sdmVdKTtcbiAgICAgIG5leHRGcmFtZSgoKSA9PiB7XG4gICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgaXNBcHBlYXIgPyBhcHBlYXJGcm9tQ2xhc3MgOiBlbnRlckZyb21DbGFzcyk7XG4gICAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgaXNBcHBlYXIgPyBhcHBlYXJUb0NsYXNzIDogZW50ZXJUb0NsYXNzKTtcbiAgICAgICAgaWYgKCFoYXNFeHBsaWNpdENhbGxiYWNrKGhvb2spKSB7XG4gICAgICAgICAgd2hlblRyYW5zaXRpb25FbmRzKGVsLCB0eXBlLCBlbnRlckR1cmF0aW9uLCByZXNvbHZlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcbiAgfTtcbiAgcmV0dXJuIGV4dGVuZChiYXNlUHJvcHMsIHtcbiAgICBvbkJlZm9yZUVudGVyKGVsKSB7XG4gICAgICBjYWxsSG9vayhvbkJlZm9yZUVudGVyLCBbZWxdKTtcbiAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgZW50ZXJGcm9tQ2xhc3MpO1xuICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBlbnRlckFjdGl2ZUNsYXNzKTtcbiAgICB9LFxuICAgIG9uQmVmb3JlQXBwZWFyKGVsKSB7XG4gICAgICBjYWxsSG9vayhvbkJlZm9yZUFwcGVhciwgW2VsXSk7XG4gICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGFwcGVhckZyb21DbGFzcyk7XG4gICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGFwcGVhckFjdGl2ZUNsYXNzKTtcbiAgICB9LFxuICAgIG9uRW50ZXI6IG1ha2VFbnRlckhvb2soZmFsc2UpLFxuICAgIG9uQXBwZWFyOiBtYWtlRW50ZXJIb29rKHRydWUpLFxuICAgIG9uTGVhdmUoZWwsIGRvbmUpIHtcbiAgICAgIGVsLl9pc0xlYXZpbmcgPSB0cnVlO1xuICAgICAgY29uc3QgcmVzb2x2ZSA9ICgpID0+IGZpbmlzaExlYXZlKGVsLCBkb25lKTtcbiAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVGcm9tQ2xhc3MpO1xuICAgICAgZm9yY2VSZWZsb3coKTtcbiAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVBY3RpdmVDbGFzcyk7XG4gICAgICBuZXh0RnJhbWUoKCkgPT4ge1xuICAgICAgICBpZiAoIWVsLl9pc0xlYXZpbmcpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUZyb21DbGFzcyk7XG4gICAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVUb0NsYXNzKTtcbiAgICAgICAgaWYgKCFoYXNFeHBsaWNpdENhbGxiYWNrKG9uTGVhdmUpKSB7XG4gICAgICAgICAgd2hlblRyYW5zaXRpb25FbmRzKGVsLCB0eXBlLCBsZWF2ZUR1cmF0aW9uLCByZXNvbHZlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBjYWxsSG9vayhvbkxlYXZlLCBbZWwsIHJlc29sdmVdKTtcbiAgICB9LFxuICAgIG9uRW50ZXJDYW5jZWxsZWQoZWwpIHtcbiAgICAgIGZpbmlzaEVudGVyKGVsLCBmYWxzZSk7XG4gICAgICBjYWxsSG9vayhvbkVudGVyQ2FuY2VsbGVkLCBbZWxdKTtcbiAgICB9LFxuICAgIG9uQXBwZWFyQ2FuY2VsbGVkKGVsKSB7XG4gICAgICBmaW5pc2hFbnRlcihlbCwgdHJ1ZSk7XG4gICAgICBjYWxsSG9vayhvbkFwcGVhckNhbmNlbGxlZCwgW2VsXSk7XG4gICAgfSxcbiAgICBvbkxlYXZlQ2FuY2VsbGVkKGVsKSB7XG4gICAgICBmaW5pc2hMZWF2ZShlbCk7XG4gICAgICBjYWxsSG9vayhvbkxlYXZlQ2FuY2VsbGVkLCBbZWxdKTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplRHVyYXRpb24oZHVyYXRpb24pIHtcbiAgaWYgKGR1cmF0aW9uID09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfSBlbHNlIGlmIChpc09iamVjdChkdXJhdGlvbikpIHtcbiAgICByZXR1cm4gW051bWJlck9mKGR1cmF0aW9uLmVudGVyKSwgTnVtYmVyT2YoZHVyYXRpb24ubGVhdmUpXTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBuID0gTnVtYmVyT2YoZHVyYXRpb24pO1xuICAgIHJldHVybiBbbiwgbl07XG4gIH1cbn1cbmZ1bmN0aW9uIE51bWJlck9mKHZhbCkge1xuICBjb25zdCByZXMgPSB0b051bWJlcih2YWwpO1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIGFzc2VydE51bWJlcihyZXMsIFwiPHRyYW5zaXRpb24+IGV4cGxpY2l0IGR1cmF0aW9uXCIpO1xuICB9XG4gIHJldHVybiByZXM7XG59XG5mdW5jdGlvbiBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGNscykge1xuICBjbHMuc3BsaXQoL1xccysvKS5mb3JFYWNoKChjKSA9PiBjICYmIGVsLmNsYXNzTGlzdC5hZGQoYykpO1xuICAoZWwuX3Z0YyB8fCAoZWwuX3Z0YyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCkpKS5hZGQoY2xzKTtcbn1cbmZ1bmN0aW9uIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgY2xzKSB7XG4gIGNscy5zcGxpdCgvXFxzKy8pLmZvckVhY2goKGMpID0+IGMgJiYgZWwuY2xhc3NMaXN0LnJlbW92ZShjKSk7XG4gIGNvbnN0IHsgX3Z0YyB9ID0gZWw7XG4gIGlmIChfdnRjKSB7XG4gICAgX3Z0Yy5kZWxldGUoY2xzKTtcbiAgICBpZiAoIV92dGMuc2l6ZSkge1xuICAgICAgZWwuX3Z0YyA9IHZvaWQgMDtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIG5leHRGcmFtZShjYikge1xuICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShjYik7XG4gIH0pO1xufVxubGV0IGVuZElkID0gMDtcbmZ1bmN0aW9uIHdoZW5UcmFuc2l0aW9uRW5kcyhlbCwgZXhwZWN0ZWRUeXBlLCBleHBsaWNpdFRpbWVvdXQsIHJlc29sdmUpIHtcbiAgY29uc3QgaWQgPSBlbC5fZW5kSWQgPSArK2VuZElkO1xuICBjb25zdCByZXNvbHZlSWZOb3RTdGFsZSA9ICgpID0+IHtcbiAgICBpZiAoaWQgPT09IGVsLl9lbmRJZCkge1xuICAgICAgcmVzb2x2ZSgpO1xuICAgIH1cbiAgfTtcbiAgaWYgKGV4cGxpY2l0VGltZW91dCkge1xuICAgIHJldHVybiBzZXRUaW1lb3V0KHJlc29sdmVJZk5vdFN0YWxlLCBleHBsaWNpdFRpbWVvdXQpO1xuICB9XG4gIGNvbnN0IHsgdHlwZSwgdGltZW91dCwgcHJvcENvdW50IH0gPSBnZXRUcmFuc2l0aW9uSW5mbyhlbCwgZXhwZWN0ZWRUeXBlKTtcbiAgaWYgKCF0eXBlKSB7XG4gICAgcmV0dXJuIHJlc29sdmUoKTtcbiAgfVxuICBjb25zdCBlbmRFdmVudCA9IHR5cGUgKyBcImVuZFwiO1xuICBsZXQgZW5kZWQgPSAwO1xuICBjb25zdCBlbmQgPSAoKSA9PiB7XG4gICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihlbmRFdmVudCwgb25FbmQpO1xuICAgIHJlc29sdmVJZk5vdFN0YWxlKCk7XG4gIH07XG4gIGNvbnN0IG9uRW5kID0gKGUpID0+IHtcbiAgICBpZiAoZS50YXJnZXQgPT09IGVsICYmICsrZW5kZWQgPj0gcHJvcENvdW50KSB7XG4gICAgICBlbmQoKTtcbiAgICB9XG4gIH07XG4gIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgIGlmIChlbmRlZCA8IHByb3BDb3VudCkge1xuICAgICAgZW5kKCk7XG4gICAgfVxuICB9LCB0aW1lb3V0ICsgMSk7XG4gIGVsLmFkZEV2ZW50TGlzdGVuZXIoZW5kRXZlbnQsIG9uRW5kKTtcbn1cbmZ1bmN0aW9uIGdldFRyYW5zaXRpb25JbmZvKGVsLCBleHBlY3RlZFR5cGUpIHtcbiAgY29uc3Qgc3R5bGVzID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwpO1xuICBjb25zdCBnZXRTdHlsZVByb3BlcnRpZXMgPSAoa2V5KSA9PiAoc3R5bGVzW2tleV0gfHwgXCJcIikuc3BsaXQoXCIsIFwiKTtcbiAgY29uc3QgdHJhbnNpdGlvbkRlbGF5cyA9IGdldFN0eWxlUHJvcGVydGllcyhgJHtUUkFOU0lUSU9OfURlbGF5YCk7XG4gIGNvbnN0IHRyYW5zaXRpb25EdXJhdGlvbnMgPSBnZXRTdHlsZVByb3BlcnRpZXMoYCR7VFJBTlNJVElPTn1EdXJhdGlvbmApO1xuICBjb25zdCB0cmFuc2l0aW9uVGltZW91dCA9IGdldFRpbWVvdXQodHJhbnNpdGlvbkRlbGF5cywgdHJhbnNpdGlvbkR1cmF0aW9ucyk7XG4gIGNvbnN0IGFuaW1hdGlvbkRlbGF5cyA9IGdldFN0eWxlUHJvcGVydGllcyhgJHtBTklNQVRJT059RGVsYXlgKTtcbiAgY29uc3QgYW5pbWF0aW9uRHVyYXRpb25zID0gZ2V0U3R5bGVQcm9wZXJ0aWVzKGAke0FOSU1BVElPTn1EdXJhdGlvbmApO1xuICBjb25zdCBhbmltYXRpb25UaW1lb3V0ID0gZ2V0VGltZW91dChhbmltYXRpb25EZWxheXMsIGFuaW1hdGlvbkR1cmF0aW9ucyk7XG4gIGxldCB0eXBlID0gbnVsbDtcbiAgbGV0IHRpbWVvdXQgPSAwO1xuICBsZXQgcHJvcENvdW50ID0gMDtcbiAgaWYgKGV4cGVjdGVkVHlwZSA9PT0gVFJBTlNJVElPTikge1xuICAgIGlmICh0cmFuc2l0aW9uVGltZW91dCA+IDApIHtcbiAgICAgIHR5cGUgPSBUUkFOU0lUSU9OO1xuICAgICAgdGltZW91dCA9IHRyYW5zaXRpb25UaW1lb3V0O1xuICAgICAgcHJvcENvdW50ID0gdHJhbnNpdGlvbkR1cmF0aW9ucy5sZW5ndGg7XG4gICAgfVxuICB9IGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gQU5JTUFUSU9OKSB7XG4gICAgaWYgKGFuaW1hdGlvblRpbWVvdXQgPiAwKSB7XG4gICAgICB0eXBlID0gQU5JTUFUSU9OO1xuICAgICAgdGltZW91dCA9IGFuaW1hdGlvblRpbWVvdXQ7XG4gICAgICBwcm9wQ291bnQgPSBhbmltYXRpb25EdXJhdGlvbnMubGVuZ3RoO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aW1lb3V0ID0gTWF0aC5tYXgodHJhbnNpdGlvblRpbWVvdXQsIGFuaW1hdGlvblRpbWVvdXQpO1xuICAgIHR5cGUgPSB0aW1lb3V0ID4gMCA/IHRyYW5zaXRpb25UaW1lb3V0ID4gYW5pbWF0aW9uVGltZW91dCA/IFRSQU5TSVRJT04gOiBBTklNQVRJT04gOiBudWxsO1xuICAgIHByb3BDb3VudCA9IHR5cGUgPyB0eXBlID09PSBUUkFOU0lUSU9OID8gdHJhbnNpdGlvbkR1cmF0aW9ucy5sZW5ndGggOiBhbmltYXRpb25EdXJhdGlvbnMubGVuZ3RoIDogMDtcbiAgfVxuICBjb25zdCBoYXNUcmFuc2Zvcm0gPSB0eXBlID09PSBUUkFOU0lUSU9OICYmIC9cXGIodHJhbnNmb3JtfGFsbCkoLHwkKS8udGVzdChcbiAgICBnZXRTdHlsZVByb3BlcnRpZXMoYCR7VFJBTlNJVElPTn1Qcm9wZXJ0eWApLnRvU3RyaW5nKClcbiAgKTtcbiAgcmV0dXJuIHtcbiAgICB0eXBlLFxuICAgIHRpbWVvdXQsXG4gICAgcHJvcENvdW50LFxuICAgIGhhc1RyYW5zZm9ybVxuICB9O1xufVxuZnVuY3Rpb24gZ2V0VGltZW91dChkZWxheXMsIGR1cmF0aW9ucykge1xuICB3aGlsZSAoZGVsYXlzLmxlbmd0aCA8IGR1cmF0aW9ucy5sZW5ndGgpIHtcbiAgICBkZWxheXMgPSBkZWxheXMuY29uY2F0KGRlbGF5cyk7XG4gIH1cbiAgcmV0dXJuIE1hdGgubWF4KC4uLmR1cmF0aW9ucy5tYXAoKGQsIGkpID0+IHRvTXMoZCkgKyB0b01zKGRlbGF5c1tpXSkpKTtcbn1cbmZ1bmN0aW9uIHRvTXMocykge1xuICByZXR1cm4gTnVtYmVyKHMuc2xpY2UoMCwgLTEpLnJlcGxhY2UoXCIsXCIsIFwiLlwiKSkgKiAxZTM7XG59XG5mdW5jdGlvbiBmb3JjZVJlZmxvdygpIHtcbiAgcmV0dXJuIGRvY3VtZW50LmJvZHkub2Zmc2V0SGVpZ2h0O1xufVxuXG5jb25zdCBwb3NpdGlvbk1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuY29uc3QgbmV3UG9zaXRpb25NYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbmNvbnN0IFRyYW5zaXRpb25Hcm91cEltcGwgPSB7XG4gIG5hbWU6IFwiVHJhbnNpdGlvbkdyb3VwXCIsXG4gIHByb3BzOiAvKiBAX19QVVJFX18gKi8gZXh0ZW5kKHt9LCBUcmFuc2l0aW9uUHJvcHNWYWxpZGF0b3JzLCB7XG4gICAgdGFnOiBTdHJpbmcsXG4gICAgbW92ZUNsYXNzOiBTdHJpbmdcbiAgfSksXG4gIHNldHVwKHByb3BzLCB7IHNsb3RzIH0pIHtcbiAgICBjb25zdCBpbnN0YW5jZSA9IGdldEN1cnJlbnRJbnN0YW5jZSgpO1xuICAgIGNvbnN0IHN0YXRlID0gdXNlVHJhbnNpdGlvblN0YXRlKCk7XG4gICAgbGV0IHByZXZDaGlsZHJlbjtcbiAgICBsZXQgY2hpbGRyZW47XG4gICAgb25VcGRhdGVkKCgpID0+IHtcbiAgICAgIGlmICghcHJldkNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBtb3ZlQ2xhc3MgPSBwcm9wcy5tb3ZlQ2xhc3MgfHwgYCR7cHJvcHMubmFtZSB8fCBcInZcIn0tbW92ZWA7XG4gICAgICBpZiAoIWhhc0NTU1RyYW5zZm9ybShcbiAgICAgICAgcHJldkNoaWxkcmVuWzBdLmVsLFxuICAgICAgICBpbnN0YW5jZS52bm9kZS5lbCxcbiAgICAgICAgbW92ZUNsYXNzXG4gICAgICApKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHByZXZDaGlsZHJlbi5mb3JFYWNoKGNhbGxQZW5kaW5nQ2JzKTtcbiAgICAgIHByZXZDaGlsZHJlbi5mb3JFYWNoKHJlY29yZFBvc2l0aW9uKTtcbiAgICAgIGNvbnN0IG1vdmVkQ2hpbGRyZW4gPSBwcmV2Q2hpbGRyZW4uZmlsdGVyKGFwcGx5VHJhbnNsYXRpb24pO1xuICAgICAgZm9yY2VSZWZsb3coKTtcbiAgICAgIG1vdmVkQ2hpbGRyZW4uZm9yRWFjaCgoYykgPT4ge1xuICAgICAgICBjb25zdCBlbCA9IGMuZWw7XG4gICAgICAgIGNvbnN0IHN0eWxlID0gZWwuc3R5bGU7XG4gICAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbW92ZUNsYXNzKTtcbiAgICAgICAgc3R5bGUudHJhbnNmb3JtID0gc3R5bGUud2Via2l0VHJhbnNmb3JtID0gc3R5bGUudHJhbnNpdGlvbkR1cmF0aW9uID0gXCJcIjtcbiAgICAgICAgY29uc3QgY2IgPSBlbC5fbW92ZUNiID0gKGUpID0+IHtcbiAgICAgICAgICBpZiAoZSAmJiBlLnRhcmdldCAhPT0gZWwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFlIHx8IC90cmFuc2Zvcm0kLy50ZXN0KGUucHJvcGVydHlOYW1lKSkge1xuICAgICAgICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRyYW5zaXRpb25lbmRcIiwgY2IpO1xuICAgICAgICAgICAgZWwuX21vdmVDYiA9IG51bGw7XG4gICAgICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIG1vdmVDbGFzcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKFwidHJhbnNpdGlvbmVuZFwiLCBjYik7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgY29uc3QgcmF3UHJvcHMgPSB0b1Jhdyhwcm9wcyk7XG4gICAgICBjb25zdCBjc3NUcmFuc2l0aW9uUHJvcHMgPSByZXNvbHZlVHJhbnNpdGlvblByb3BzKHJhd1Byb3BzKTtcbiAgICAgIGxldCB0YWcgPSByYXdQcm9wcy50YWcgfHwgRnJhZ21lbnQ7XG4gICAgICBwcmV2Q2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgICAgIGNoaWxkcmVuID0gc2xvdHMuZGVmYXVsdCA/IGdldFRyYW5zaXRpb25SYXdDaGlsZHJlbihzbG90cy5kZWZhdWx0KCkpIDogW107XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICAgIGlmIChjaGlsZC5rZXkgIT0gbnVsbCkge1xuICAgICAgICAgIHNldFRyYW5zaXRpb25Ib29rcyhcbiAgICAgICAgICAgIGNoaWxkLFxuICAgICAgICAgICAgcmVzb2x2ZVRyYW5zaXRpb25Ib29rcyhjaGlsZCwgY3NzVHJhbnNpdGlvblByb3BzLCBzdGF0ZSwgaW5zdGFuY2UpXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgd2FybihgPFRyYW5zaXRpb25Hcm91cD4gY2hpbGRyZW4gbXVzdCBiZSBrZXllZC5gKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHByZXZDaGlsZHJlbikge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByZXZDaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvbnN0IGNoaWxkID0gcHJldkNoaWxkcmVuW2ldO1xuICAgICAgICAgIHNldFRyYW5zaXRpb25Ib29rcyhcbiAgICAgICAgICAgIGNoaWxkLFxuICAgICAgICAgICAgcmVzb2x2ZVRyYW5zaXRpb25Ib29rcyhjaGlsZCwgY3NzVHJhbnNpdGlvblByb3BzLCBzdGF0ZSwgaW5zdGFuY2UpXG4gICAgICAgICAgKTtcbiAgICAgICAgICBwb3NpdGlvbk1hcC5zZXQoY2hpbGQsIGNoaWxkLmVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGNyZWF0ZVZOb2RlKHRhZywgbnVsbCwgY2hpbGRyZW4pO1xuICAgIH07XG4gIH1cbn07XG5jb25zdCByZW1vdmVNb2RlID0gKHByb3BzKSA9PiBkZWxldGUgcHJvcHMubW9kZTtcbi8qIEBfX1BVUkVfXyAqLyByZW1vdmVNb2RlKFRyYW5zaXRpb25Hcm91cEltcGwucHJvcHMpO1xuY29uc3QgVHJhbnNpdGlvbkdyb3VwID0gVHJhbnNpdGlvbkdyb3VwSW1wbDtcbmZ1bmN0aW9uIGNhbGxQZW5kaW5nQ2JzKGMpIHtcbiAgY29uc3QgZWwgPSBjLmVsO1xuICBpZiAoZWwuX21vdmVDYikge1xuICAgIGVsLl9tb3ZlQ2IoKTtcbiAgfVxuICBpZiAoZWwuX2VudGVyQ2IpIHtcbiAgICBlbC5fZW50ZXJDYigpO1xuICB9XG59XG5mdW5jdGlvbiByZWNvcmRQb3NpdGlvbihjKSB7XG4gIG5ld1Bvc2l0aW9uTWFwLnNldChjLCBjLmVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpKTtcbn1cbmZ1bmN0aW9uIGFwcGx5VHJhbnNsYXRpb24oYykge1xuICBjb25zdCBvbGRQb3MgPSBwb3NpdGlvbk1hcC5nZXQoYyk7XG4gIGNvbnN0IG5ld1BvcyA9IG5ld1Bvc2l0aW9uTWFwLmdldChjKTtcbiAgY29uc3QgZHggPSBvbGRQb3MubGVmdCAtIG5ld1Bvcy5sZWZ0O1xuICBjb25zdCBkeSA9IG9sZFBvcy50b3AgLSBuZXdQb3MudG9wO1xuICBpZiAoZHggfHwgZHkpIHtcbiAgICBjb25zdCBzID0gYy5lbC5zdHlsZTtcbiAgICBzLnRyYW5zZm9ybSA9IHMud2Via2l0VHJhbnNmb3JtID0gYHRyYW5zbGF0ZSgke2R4fXB4LCR7ZHl9cHgpYDtcbiAgICBzLnRyYW5zaXRpb25EdXJhdGlvbiA9IFwiMHNcIjtcbiAgICByZXR1cm4gYztcbiAgfVxufVxuZnVuY3Rpb24gaGFzQ1NTVHJhbnNmb3JtKGVsLCByb290LCBtb3ZlQ2xhc3MpIHtcbiAgY29uc3QgY2xvbmUgPSBlbC5jbG9uZU5vZGUoKTtcbiAgaWYgKGVsLl92dGMpIHtcbiAgICBlbC5fdnRjLmZvckVhY2goKGNscykgPT4ge1xuICAgICAgY2xzLnNwbGl0KC9cXHMrLykuZm9yRWFjaCgoYykgPT4gYyAmJiBjbG9uZS5jbGFzc0xpc3QucmVtb3ZlKGMpKTtcbiAgICB9KTtcbiAgfVxuICBtb3ZlQ2xhc3Muc3BsaXQoL1xccysvKS5mb3JFYWNoKChjKSA9PiBjICYmIGNsb25lLmNsYXNzTGlzdC5hZGQoYykpO1xuICBjbG9uZS5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gIGNvbnN0IGNvbnRhaW5lciA9IHJvb3Qubm9kZVR5cGUgPT09IDEgPyByb290IDogcm9vdC5wYXJlbnROb2RlO1xuICBjb250YWluZXIuYXBwZW5kQ2hpbGQoY2xvbmUpO1xuICBjb25zdCB7IGhhc1RyYW5zZm9ybSB9ID0gZ2V0VHJhbnNpdGlvbkluZm8oY2xvbmUpO1xuICBjb250YWluZXIucmVtb3ZlQ2hpbGQoY2xvbmUpO1xuICByZXR1cm4gaGFzVHJhbnNmb3JtO1xufVxuXG5jb25zdCBnZXRNb2RlbEFzc2lnbmVyID0gKHZub2RlKSA9PiB7XG4gIGNvbnN0IGZuID0gdm5vZGUucHJvcHNbXCJvblVwZGF0ZTptb2RlbFZhbHVlXCJdIHx8IGZhbHNlO1xuICByZXR1cm4gaXNBcnJheShmbikgPyAodmFsdWUpID0+IGludm9rZUFycmF5Rm5zKGZuLCB2YWx1ZSkgOiBmbjtcbn07XG5mdW5jdGlvbiBvbkNvbXBvc2l0aW9uU3RhcnQoZSkge1xuICBlLnRhcmdldC5jb21wb3NpbmcgPSB0cnVlO1xufVxuZnVuY3Rpb24gb25Db21wb3NpdGlvbkVuZChlKSB7XG4gIGNvbnN0IHRhcmdldCA9IGUudGFyZ2V0O1xuICBpZiAodGFyZ2V0LmNvbXBvc2luZykge1xuICAgIHRhcmdldC5jb21wb3NpbmcgPSBmYWxzZTtcbiAgICB0YXJnZXQuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoXCJpbnB1dFwiKSk7XG4gIH1cbn1cbmNvbnN0IHZNb2RlbFRleHQgPSB7XG4gIGNyZWF0ZWQoZWwsIHsgbW9kaWZpZXJzOiB7IGxhenksIHRyaW0sIG51bWJlciB9IH0sIHZub2RlKSB7XG4gICAgZWwuX2Fzc2lnbiA9IGdldE1vZGVsQXNzaWduZXIodm5vZGUpO1xuICAgIGNvbnN0IGNhc3RUb051bWJlciA9IG51bWJlciB8fCB2bm9kZS5wcm9wcyAmJiB2bm9kZS5wcm9wcy50eXBlID09PSBcIm51bWJlclwiO1xuICAgIGFkZEV2ZW50TGlzdGVuZXIoZWwsIGxhenkgPyBcImNoYW5nZVwiIDogXCJpbnB1dFwiLCAoZSkgPT4ge1xuICAgICAgaWYgKGUudGFyZ2V0LmNvbXBvc2luZylcbiAgICAgICAgcmV0dXJuO1xuICAgICAgbGV0IGRvbVZhbHVlID0gZWwudmFsdWU7XG4gICAgICBpZiAodHJpbSkge1xuICAgICAgICBkb21WYWx1ZSA9IGRvbVZhbHVlLnRyaW0oKTtcbiAgICAgIH1cbiAgICAgIGlmIChjYXN0VG9OdW1iZXIpIHtcbiAgICAgICAgZG9tVmFsdWUgPSBsb29zZVRvTnVtYmVyKGRvbVZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGVsLl9hc3NpZ24oZG9tVmFsdWUpO1xuICAgIH0pO1xuICAgIGlmICh0cmltKSB7XG4gICAgICBhZGRFdmVudExpc3RlbmVyKGVsLCBcImNoYW5nZVwiLCAoKSA9PiB7XG4gICAgICAgIGVsLnZhbHVlID0gZWwudmFsdWUudHJpbSgpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGlmICghbGF6eSkge1xuICAgICAgYWRkRXZlbnRMaXN0ZW5lcihlbCwgXCJjb21wb3NpdGlvbnN0YXJ0XCIsIG9uQ29tcG9zaXRpb25TdGFydCk7XG4gICAgICBhZGRFdmVudExpc3RlbmVyKGVsLCBcImNvbXBvc2l0aW9uZW5kXCIsIG9uQ29tcG9zaXRpb25FbmQpO1xuICAgICAgYWRkRXZlbnRMaXN0ZW5lcihlbCwgXCJjaGFuZ2VcIiwgb25Db21wb3NpdGlvbkVuZCk7XG4gICAgfVxuICB9LFxuICAvLyBzZXQgdmFsdWUgb24gbW91bnRlZCBzbyBpdCdzIGFmdGVyIG1pbi9tYXggZm9yIHR5cGU9XCJyYW5nZVwiXG4gIG1vdW50ZWQoZWwsIHsgdmFsdWUgfSkge1xuICAgIGVsLnZhbHVlID0gdmFsdWUgPT0gbnVsbCA/IFwiXCIgOiB2YWx1ZTtcbiAgfSxcbiAgYmVmb3JlVXBkYXRlKGVsLCB7IHZhbHVlLCBtb2RpZmllcnM6IHsgbGF6eSwgdHJpbSwgbnVtYmVyIH0gfSwgdm5vZGUpIHtcbiAgICBlbC5fYXNzaWduID0gZ2V0TW9kZWxBc3NpZ25lcih2bm9kZSk7XG4gICAgaWYgKGVsLmNvbXBvc2luZylcbiAgICAgIHJldHVybjtcbiAgICBpZiAoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA9PT0gZWwgJiYgZWwudHlwZSAhPT0gXCJyYW5nZVwiKSB7XG4gICAgICBpZiAobGF6eSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodHJpbSAmJiBlbC52YWx1ZS50cmltKCkgPT09IHZhbHVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICgobnVtYmVyIHx8IGVsLnR5cGUgPT09IFwibnVtYmVyXCIpICYmIGxvb3NlVG9OdW1iZXIoZWwudmFsdWUpID09PSB2YWx1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IG5ld1ZhbHVlID0gdmFsdWUgPT0gbnVsbCA/IFwiXCIgOiB2YWx1ZTtcbiAgICBpZiAoZWwudmFsdWUgIT09IG5ld1ZhbHVlKSB7XG4gICAgICBlbC52YWx1ZSA9IG5ld1ZhbHVlO1xuICAgIH1cbiAgfVxufTtcbmNvbnN0IHZNb2RlbENoZWNrYm94ID0ge1xuICAvLyAjNDA5NiBhcnJheSBjaGVja2JveGVzIG5lZWQgdG8gYmUgZGVlcCB0cmF2ZXJzZWRcbiAgZGVlcDogdHJ1ZSxcbiAgY3JlYXRlZChlbCwgXywgdm5vZGUpIHtcbiAgICBlbC5fYXNzaWduID0gZ2V0TW9kZWxBc3NpZ25lcih2bm9kZSk7XG4gICAgYWRkRXZlbnRMaXN0ZW5lcihlbCwgXCJjaGFuZ2VcIiwgKCkgPT4ge1xuICAgICAgY29uc3QgbW9kZWxWYWx1ZSA9IGVsLl9tb2RlbFZhbHVlO1xuICAgICAgY29uc3QgZWxlbWVudFZhbHVlID0gZ2V0VmFsdWUoZWwpO1xuICAgICAgY29uc3QgY2hlY2tlZCA9IGVsLmNoZWNrZWQ7XG4gICAgICBjb25zdCBhc3NpZ24gPSBlbC5fYXNzaWduO1xuICAgICAgaWYgKGlzQXJyYXkobW9kZWxWYWx1ZSkpIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSBsb29zZUluZGV4T2YobW9kZWxWYWx1ZSwgZWxlbWVudFZhbHVlKTtcbiAgICAgICAgY29uc3QgZm91bmQgPSBpbmRleCAhPT0gLTE7XG4gICAgICAgIGlmIChjaGVja2VkICYmICFmb3VuZCkge1xuICAgICAgICAgIGFzc2lnbihtb2RlbFZhbHVlLmNvbmNhdChlbGVtZW50VmFsdWUpKTtcbiAgICAgICAgfSBlbHNlIGlmICghY2hlY2tlZCAmJiBmb3VuZCkge1xuICAgICAgICAgIGNvbnN0IGZpbHRlcmVkID0gWy4uLm1vZGVsVmFsdWVdO1xuICAgICAgICAgIGZpbHRlcmVkLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgYXNzaWduKGZpbHRlcmVkKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChpc1NldChtb2RlbFZhbHVlKSkge1xuICAgICAgICBjb25zdCBjbG9uZWQgPSBuZXcgU2V0KG1vZGVsVmFsdWUpO1xuICAgICAgICBpZiAoY2hlY2tlZCkge1xuICAgICAgICAgIGNsb25lZC5hZGQoZWxlbWVudFZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjbG9uZWQuZGVsZXRlKGVsZW1lbnRWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgYXNzaWduKGNsb25lZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhc3NpZ24oZ2V0Q2hlY2tib3hWYWx1ZShlbCwgY2hlY2tlZCkpO1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxuICAvLyBzZXQgaW5pdGlhbCBjaGVja2VkIG9uIG1vdW50IHRvIHdhaXQgZm9yIHRydWUtdmFsdWUvZmFsc2UtdmFsdWVcbiAgbW91bnRlZDogc2V0Q2hlY2tlZCxcbiAgYmVmb3JlVXBkYXRlKGVsLCBiaW5kaW5nLCB2bm9kZSkge1xuICAgIGVsLl9hc3NpZ24gPSBnZXRNb2RlbEFzc2lnbmVyKHZub2RlKTtcbiAgICBzZXRDaGVja2VkKGVsLCBiaW5kaW5nLCB2bm9kZSk7XG4gIH1cbn07XG5mdW5jdGlvbiBzZXRDaGVja2VkKGVsLCB7IHZhbHVlLCBvbGRWYWx1ZSB9LCB2bm9kZSkge1xuICBlbC5fbW9kZWxWYWx1ZSA9IHZhbHVlO1xuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICBlbC5jaGVja2VkID0gbG9vc2VJbmRleE9mKHZhbHVlLCB2bm9kZS5wcm9wcy52YWx1ZSkgPiAtMTtcbiAgfSBlbHNlIGlmIChpc1NldCh2YWx1ZSkpIHtcbiAgICBlbC5jaGVja2VkID0gdmFsdWUuaGFzKHZub2RlLnByb3BzLnZhbHVlKTtcbiAgfSBlbHNlIGlmICh2YWx1ZSAhPT0gb2xkVmFsdWUpIHtcbiAgICBlbC5jaGVja2VkID0gbG9vc2VFcXVhbCh2YWx1ZSwgZ2V0Q2hlY2tib3hWYWx1ZShlbCwgdHJ1ZSkpO1xuICB9XG59XG5jb25zdCB2TW9kZWxSYWRpbyA9IHtcbiAgY3JlYXRlZChlbCwgeyB2YWx1ZSB9LCB2bm9kZSkge1xuICAgIGVsLmNoZWNrZWQgPSBsb29zZUVxdWFsKHZhbHVlLCB2bm9kZS5wcm9wcy52YWx1ZSk7XG4gICAgZWwuX2Fzc2lnbiA9IGdldE1vZGVsQXNzaWduZXIodm5vZGUpO1xuICAgIGFkZEV2ZW50TGlzdGVuZXIoZWwsIFwiY2hhbmdlXCIsICgpID0+IHtcbiAgICAgIGVsLl9hc3NpZ24oZ2V0VmFsdWUoZWwpKTtcbiAgICB9KTtcbiAgfSxcbiAgYmVmb3JlVXBkYXRlKGVsLCB7IHZhbHVlLCBvbGRWYWx1ZSB9LCB2bm9kZSkge1xuICAgIGVsLl9hc3NpZ24gPSBnZXRNb2RlbEFzc2lnbmVyKHZub2RlKTtcbiAgICBpZiAodmFsdWUgIT09IG9sZFZhbHVlKSB7XG4gICAgICBlbC5jaGVja2VkID0gbG9vc2VFcXVhbCh2YWx1ZSwgdm5vZGUucHJvcHMudmFsdWUpO1xuICAgIH1cbiAgfVxufTtcbmNvbnN0IHZNb2RlbFNlbGVjdCA9IHtcbiAgLy8gPHNlbGVjdCBtdWx0aXBsZT4gdmFsdWUgbmVlZCB0byBiZSBkZWVwIHRyYXZlcnNlZFxuICBkZWVwOiB0cnVlLFxuICBjcmVhdGVkKGVsLCB7IHZhbHVlLCBtb2RpZmllcnM6IHsgbnVtYmVyIH0gfSwgdm5vZGUpIHtcbiAgICBjb25zdCBpc1NldE1vZGVsID0gaXNTZXQodmFsdWUpO1xuICAgIGFkZEV2ZW50TGlzdGVuZXIoZWwsIFwiY2hhbmdlXCIsICgpID0+IHtcbiAgICAgIGNvbnN0IHNlbGVjdGVkVmFsID0gQXJyYXkucHJvdG90eXBlLmZpbHRlci5jYWxsKGVsLm9wdGlvbnMsIChvKSA9PiBvLnNlbGVjdGVkKS5tYXAoXG4gICAgICAgIChvKSA9PiBudW1iZXIgPyBsb29zZVRvTnVtYmVyKGdldFZhbHVlKG8pKSA6IGdldFZhbHVlKG8pXG4gICAgICApO1xuICAgICAgZWwuX2Fzc2lnbihcbiAgICAgICAgZWwubXVsdGlwbGUgPyBpc1NldE1vZGVsID8gbmV3IFNldChzZWxlY3RlZFZhbCkgOiBzZWxlY3RlZFZhbCA6IHNlbGVjdGVkVmFsWzBdXG4gICAgICApO1xuICAgIH0pO1xuICAgIGVsLl9hc3NpZ24gPSBnZXRNb2RlbEFzc2lnbmVyKHZub2RlKTtcbiAgfSxcbiAgLy8gc2V0IHZhbHVlIGluIG1vdW50ZWQgJiB1cGRhdGVkIGJlY2F1c2UgPHNlbGVjdD4gcmVsaWVzIG9uIGl0cyBjaGlsZHJlblxuICAvLyA8b3B0aW9uPnMuXG4gIG1vdW50ZWQoZWwsIHsgdmFsdWUgfSkge1xuICAgIHNldFNlbGVjdGVkKGVsLCB2YWx1ZSk7XG4gIH0sXG4gIGJlZm9yZVVwZGF0ZShlbCwgX2JpbmRpbmcsIHZub2RlKSB7XG4gICAgZWwuX2Fzc2lnbiA9IGdldE1vZGVsQXNzaWduZXIodm5vZGUpO1xuICB9LFxuICB1cGRhdGVkKGVsLCB7IHZhbHVlIH0pIHtcbiAgICBzZXRTZWxlY3RlZChlbCwgdmFsdWUpO1xuICB9XG59O1xuZnVuY3Rpb24gc2V0U2VsZWN0ZWQoZWwsIHZhbHVlKSB7XG4gIGNvbnN0IGlzTXVsdGlwbGUgPSBlbC5tdWx0aXBsZTtcbiAgaWYgKGlzTXVsdGlwbGUgJiYgIWlzQXJyYXkodmFsdWUpICYmICFpc1NldCh2YWx1ZSkpIHtcbiAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHdhcm4oXG4gICAgICBgPHNlbGVjdCBtdWx0aXBsZSB2LW1vZGVsPiBleHBlY3RzIGFuIEFycmF5IG9yIFNldCB2YWx1ZSBmb3IgaXRzIGJpbmRpbmcsIGJ1dCBnb3QgJHtPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLnNsaWNlKDgsIC0xKX0uYFxuICAgICk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGZvciAobGV0IGkgPSAwLCBsID0gZWwub3B0aW9ucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBjb25zdCBvcHRpb24gPSBlbC5vcHRpb25zW2ldO1xuICAgIGNvbnN0IG9wdGlvblZhbHVlID0gZ2V0VmFsdWUob3B0aW9uKTtcbiAgICBpZiAoaXNNdWx0aXBsZSkge1xuICAgICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIG9wdGlvbi5zZWxlY3RlZCA9IGxvb3NlSW5kZXhPZih2YWx1ZSwgb3B0aW9uVmFsdWUpID4gLTE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvcHRpb24uc2VsZWN0ZWQgPSB2YWx1ZS5oYXMob3B0aW9uVmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAobG9vc2VFcXVhbChnZXRWYWx1ZShvcHRpb24pLCB2YWx1ZSkpIHtcbiAgICAgICAgaWYgKGVsLnNlbGVjdGVkSW5kZXggIT09IGkpXG4gICAgICAgICAgZWwuc2VsZWN0ZWRJbmRleCA9IGk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKCFpc011bHRpcGxlICYmIGVsLnNlbGVjdGVkSW5kZXggIT09IC0xKSB7XG4gICAgZWwuc2VsZWN0ZWRJbmRleCA9IC0xO1xuICB9XG59XG5mdW5jdGlvbiBnZXRWYWx1ZShlbCkge1xuICByZXR1cm4gXCJfdmFsdWVcIiBpbiBlbCA/IGVsLl92YWx1ZSA6IGVsLnZhbHVlO1xufVxuZnVuY3Rpb24gZ2V0Q2hlY2tib3hWYWx1ZShlbCwgY2hlY2tlZCkge1xuICBjb25zdCBrZXkgPSBjaGVja2VkID8gXCJfdHJ1ZVZhbHVlXCIgOiBcIl9mYWxzZVZhbHVlXCI7XG4gIHJldHVybiBrZXkgaW4gZWwgPyBlbFtrZXldIDogY2hlY2tlZDtcbn1cbmNvbnN0IHZNb2RlbER5bmFtaWMgPSB7XG4gIGNyZWF0ZWQoZWwsIGJpbmRpbmcsIHZub2RlKSB7XG4gICAgY2FsbE1vZGVsSG9vayhlbCwgYmluZGluZywgdm5vZGUsIG51bGwsIFwiY3JlYXRlZFwiKTtcbiAgfSxcbiAgbW91bnRlZChlbCwgYmluZGluZywgdm5vZGUpIHtcbiAgICBjYWxsTW9kZWxIb29rKGVsLCBiaW5kaW5nLCB2bm9kZSwgbnVsbCwgXCJtb3VudGVkXCIpO1xuICB9LFxuICBiZWZvcmVVcGRhdGUoZWwsIGJpbmRpbmcsIHZub2RlLCBwcmV2Vk5vZGUpIHtcbiAgICBjYWxsTW9kZWxIb29rKGVsLCBiaW5kaW5nLCB2bm9kZSwgcHJldlZOb2RlLCBcImJlZm9yZVVwZGF0ZVwiKTtcbiAgfSxcbiAgdXBkYXRlZChlbCwgYmluZGluZywgdm5vZGUsIHByZXZWTm9kZSkge1xuICAgIGNhbGxNb2RlbEhvb2soZWwsIGJpbmRpbmcsIHZub2RlLCBwcmV2Vk5vZGUsIFwidXBkYXRlZFwiKTtcbiAgfVxufTtcbmZ1bmN0aW9uIHJlc29sdmVEeW5hbWljTW9kZWwodGFnTmFtZSwgdHlwZSkge1xuICBzd2l0Y2ggKHRhZ05hbWUpIHtcbiAgICBjYXNlIFwiU0VMRUNUXCI6XG4gICAgICByZXR1cm4gdk1vZGVsU2VsZWN0O1xuICAgIGNhc2UgXCJURVhUQVJFQVwiOlxuICAgICAgcmV0dXJuIHZNb2RlbFRleHQ7XG4gICAgZGVmYXVsdDpcbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIFwiY2hlY2tib3hcIjpcbiAgICAgICAgICByZXR1cm4gdk1vZGVsQ2hlY2tib3g7XG4gICAgICAgIGNhc2UgXCJyYWRpb1wiOlxuICAgICAgICAgIHJldHVybiB2TW9kZWxSYWRpbztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gdk1vZGVsVGV4dDtcbiAgICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gY2FsbE1vZGVsSG9vayhlbCwgYmluZGluZywgdm5vZGUsIHByZXZWTm9kZSwgaG9vaykge1xuICBjb25zdCBtb2RlbFRvVXNlID0gcmVzb2x2ZUR5bmFtaWNNb2RlbChcbiAgICBlbC50YWdOYW1lLFxuICAgIHZub2RlLnByb3BzICYmIHZub2RlLnByb3BzLnR5cGVcbiAgKTtcbiAgY29uc3QgZm4gPSBtb2RlbFRvVXNlW2hvb2tdO1xuICBmbiAmJiBmbihlbCwgYmluZGluZywgdm5vZGUsIHByZXZWTm9kZSk7XG59XG5mdW5jdGlvbiBpbml0Vk1vZGVsRm9yU1NSKCkge1xuICB2TW9kZWxUZXh0LmdldFNTUlByb3BzID0gKHsgdmFsdWUgfSkgPT4gKHsgdmFsdWUgfSk7XG4gIHZNb2RlbFJhZGlvLmdldFNTUlByb3BzID0gKHsgdmFsdWUgfSwgdm5vZGUpID0+IHtcbiAgICBpZiAodm5vZGUucHJvcHMgJiYgbG9vc2VFcXVhbCh2bm9kZS5wcm9wcy52YWx1ZSwgdmFsdWUpKSB7XG4gICAgICByZXR1cm4geyBjaGVja2VkOiB0cnVlIH07XG4gICAgfVxuICB9O1xuICB2TW9kZWxDaGVja2JveC5nZXRTU1JQcm9wcyA9ICh7IHZhbHVlIH0sIHZub2RlKSA9PiB7XG4gICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICBpZiAodm5vZGUucHJvcHMgJiYgbG9vc2VJbmRleE9mKHZhbHVlLCB2bm9kZS5wcm9wcy52YWx1ZSkgPiAtMSkge1xuICAgICAgICByZXR1cm4geyBjaGVja2VkOiB0cnVlIH07XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc1NldCh2YWx1ZSkpIHtcbiAgICAgIGlmICh2bm9kZS5wcm9wcyAmJiB2YWx1ZS5oYXModm5vZGUucHJvcHMudmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB7IGNoZWNrZWQ6IHRydWUgfTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHZhbHVlKSB7XG4gICAgICByZXR1cm4geyBjaGVja2VkOiB0cnVlIH07XG4gICAgfVxuICB9O1xuICB2TW9kZWxEeW5hbWljLmdldFNTUlByb3BzID0gKGJpbmRpbmcsIHZub2RlKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB2bm9kZS50eXBlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG1vZGVsVG9Vc2UgPSByZXNvbHZlRHluYW1pY01vZGVsKFxuICAgICAgLy8gcmVzb2x2ZUR5bmFtaWNNb2RlbCBleHBlY3RzIGFuIHVwcGVyY2FzZSB0YWcgbmFtZSwgYnV0IHZub2RlLnR5cGUgaXMgbG93ZXJjYXNlXG4gICAgICB2bm9kZS50eXBlLnRvVXBwZXJDYXNlKCksXG4gICAgICB2bm9kZS5wcm9wcyAmJiB2bm9kZS5wcm9wcy50eXBlXG4gICAgKTtcbiAgICBpZiAobW9kZWxUb1VzZS5nZXRTU1JQcm9wcykge1xuICAgICAgcmV0dXJuIG1vZGVsVG9Vc2UuZ2V0U1NSUHJvcHMoYmluZGluZywgdm5vZGUpO1xuICAgIH1cbiAgfTtcbn1cblxuY29uc3Qgc3lzdGVtTW9kaWZpZXJzID0gW1wiY3RybFwiLCBcInNoaWZ0XCIsIFwiYWx0XCIsIFwibWV0YVwiXTtcbmNvbnN0IG1vZGlmaWVyR3VhcmRzID0ge1xuICBzdG9wOiAoZSkgPT4gZS5zdG9wUHJvcGFnYXRpb24oKSxcbiAgcHJldmVudDogKGUpID0+IGUucHJldmVudERlZmF1bHQoKSxcbiAgc2VsZjogKGUpID0+IGUudGFyZ2V0ICE9PSBlLmN1cnJlbnRUYXJnZXQsXG4gIGN0cmw6IChlKSA9PiAhZS5jdHJsS2V5LFxuICBzaGlmdDogKGUpID0+ICFlLnNoaWZ0S2V5LFxuICBhbHQ6IChlKSA9PiAhZS5hbHRLZXksXG4gIG1ldGE6IChlKSA9PiAhZS5tZXRhS2V5LFxuICBsZWZ0OiAoZSkgPT4gXCJidXR0b25cIiBpbiBlICYmIGUuYnV0dG9uICE9PSAwLFxuICBtaWRkbGU6IChlKSA9PiBcImJ1dHRvblwiIGluIGUgJiYgZS5idXR0b24gIT09IDEsXG4gIHJpZ2h0OiAoZSkgPT4gXCJidXR0b25cIiBpbiBlICYmIGUuYnV0dG9uICE9PSAyLFxuICBleGFjdDogKGUsIG1vZGlmaWVycykgPT4gc3lzdGVtTW9kaWZpZXJzLnNvbWUoKG0pID0+IGVbYCR7bX1LZXlgXSAmJiAhbW9kaWZpZXJzLmluY2x1ZGVzKG0pKVxufTtcbmNvbnN0IHdpdGhNb2RpZmllcnMgPSAoZm4sIG1vZGlmaWVycykgPT4ge1xuICByZXR1cm4gKGV2ZW50LCAuLi5hcmdzKSA9PiB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtb2RpZmllcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGd1YXJkID0gbW9kaWZpZXJHdWFyZHNbbW9kaWZpZXJzW2ldXTtcbiAgICAgIGlmIChndWFyZCAmJiBndWFyZChldmVudCwgbW9kaWZpZXJzKSlcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXR1cm4gZm4oZXZlbnQsIC4uLmFyZ3MpO1xuICB9O1xufTtcbmNvbnN0IGtleU5hbWVzID0ge1xuICBlc2M6IFwiZXNjYXBlXCIsXG4gIHNwYWNlOiBcIiBcIixcbiAgdXA6IFwiYXJyb3ctdXBcIixcbiAgbGVmdDogXCJhcnJvdy1sZWZ0XCIsXG4gIHJpZ2h0OiBcImFycm93LXJpZ2h0XCIsXG4gIGRvd246IFwiYXJyb3ctZG93blwiLFxuICBkZWxldGU6IFwiYmFja3NwYWNlXCJcbn07XG5jb25zdCB3aXRoS2V5cyA9IChmbiwgbW9kaWZpZXJzKSA9PiB7XG4gIHJldHVybiAoZXZlbnQpID0+IHtcbiAgICBpZiAoIShcImtleVwiIGluIGV2ZW50KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBldmVudEtleSA9IGh5cGhlbmF0ZShldmVudC5rZXkpO1xuICAgIGlmIChtb2RpZmllcnMuc29tZSgoaykgPT4gayA9PT0gZXZlbnRLZXkgfHwga2V5TmFtZXNba10gPT09IGV2ZW50S2V5KSkge1xuICAgICAgcmV0dXJuIGZuKGV2ZW50KTtcbiAgICB9XG4gIH07XG59O1xuXG5jb25zdCB2U2hvdyA9IHtcbiAgYmVmb3JlTW91bnQoZWwsIHsgdmFsdWUgfSwgeyB0cmFuc2l0aW9uIH0pIHtcbiAgICBlbC5fdm9kID0gZWwuc3R5bGUuZGlzcGxheSA9PT0gXCJub25lXCIgPyBcIlwiIDogZWwuc3R5bGUuZGlzcGxheTtcbiAgICBpZiAodHJhbnNpdGlvbiAmJiB2YWx1ZSkge1xuICAgICAgdHJhbnNpdGlvbi5iZWZvcmVFbnRlcihlbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNldERpc3BsYXkoZWwsIHZhbHVlKTtcbiAgICB9XG4gIH0sXG4gIG1vdW50ZWQoZWwsIHsgdmFsdWUgfSwgeyB0cmFuc2l0aW9uIH0pIHtcbiAgICBpZiAodHJhbnNpdGlvbiAmJiB2YWx1ZSkge1xuICAgICAgdHJhbnNpdGlvbi5lbnRlcihlbCk7XG4gICAgfVxuICB9LFxuICB1cGRhdGVkKGVsLCB7IHZhbHVlLCBvbGRWYWx1ZSB9LCB7IHRyYW5zaXRpb24gfSkge1xuICAgIGlmICghdmFsdWUgPT09ICFvbGRWYWx1ZSlcbiAgICAgIHJldHVybjtcbiAgICBpZiAodHJhbnNpdGlvbikge1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIHRyYW5zaXRpb24uYmVmb3JlRW50ZXIoZWwpO1xuICAgICAgICBzZXREaXNwbGF5KGVsLCB0cnVlKTtcbiAgICAgICAgdHJhbnNpdGlvbi5lbnRlcihlbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0cmFuc2l0aW9uLmxlYXZlKGVsLCAoKSA9PiB7XG4gICAgICAgICAgc2V0RGlzcGxheShlbCwgZmFsc2UpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc2V0RGlzcGxheShlbCwgdmFsdWUpO1xuICAgIH1cbiAgfSxcbiAgYmVmb3JlVW5tb3VudChlbCwgeyB2YWx1ZSB9KSB7XG4gICAgc2V0RGlzcGxheShlbCwgdmFsdWUpO1xuICB9XG59O1xuZnVuY3Rpb24gc2V0RGlzcGxheShlbCwgdmFsdWUpIHtcbiAgZWwuc3R5bGUuZGlzcGxheSA9IHZhbHVlID8gZWwuX3ZvZCA6IFwibm9uZVwiO1xufVxuZnVuY3Rpb24gaW5pdFZTaG93Rm9yU1NSKCkge1xuICB2U2hvdy5nZXRTU1JQcm9wcyA9ICh7IHZhbHVlIH0pID0+IHtcbiAgICBpZiAoIXZhbHVlKSB7XG4gICAgICByZXR1cm4geyBzdHlsZTogeyBkaXNwbGF5OiBcIm5vbmVcIiB9IH07XG4gICAgfVxuICB9O1xufVxuXG5jb25zdCByZW5kZXJlck9wdGlvbnMgPSAvKiBAX19QVVJFX18gKi8gZXh0ZW5kKHsgcGF0Y2hQcm9wIH0sIG5vZGVPcHMpO1xubGV0IHJlbmRlcmVyO1xubGV0IGVuYWJsZWRIeWRyYXRpb24gPSBmYWxzZTtcbmZ1bmN0aW9uIGVuc3VyZVJlbmRlcmVyKCkge1xuICByZXR1cm4gcmVuZGVyZXIgfHwgKHJlbmRlcmVyID0gY3JlYXRlUmVuZGVyZXIocmVuZGVyZXJPcHRpb25zKSk7XG59XG5mdW5jdGlvbiBlbnN1cmVIeWRyYXRpb25SZW5kZXJlcigpIHtcbiAgcmVuZGVyZXIgPSBlbmFibGVkSHlkcmF0aW9uID8gcmVuZGVyZXIgOiBjcmVhdGVIeWRyYXRpb25SZW5kZXJlcihyZW5kZXJlck9wdGlvbnMpO1xuICBlbmFibGVkSHlkcmF0aW9uID0gdHJ1ZTtcbiAgcmV0dXJuIHJlbmRlcmVyO1xufVxuY29uc3QgcmVuZGVyID0gKC4uLmFyZ3MpID0+IHtcbiAgZW5zdXJlUmVuZGVyZXIoKS5yZW5kZXIoLi4uYXJncyk7XG59O1xuY29uc3QgaHlkcmF0ZSA9ICguLi5hcmdzKSA9PiB7XG4gIGVuc3VyZUh5ZHJhdGlvblJlbmRlcmVyKCkuaHlkcmF0ZSguLi5hcmdzKTtcbn07XG5jb25zdCBjcmVhdGVBcHAgPSAoLi4uYXJncykgPT4ge1xuICBjb25zdCBhcHAgPSBlbnN1cmVSZW5kZXJlcigpLmNyZWF0ZUFwcCguLi5hcmdzKTtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICBpbmplY3ROYXRpdmVUYWdDaGVjayhhcHApO1xuICAgIGluamVjdENvbXBpbGVyT3B0aW9uc0NoZWNrKGFwcCk7XG4gIH1cbiAgY29uc3QgeyBtb3VudCB9ID0gYXBwO1xuICBhcHAubW91bnQgPSAoY29udGFpbmVyT3JTZWxlY3RvcikgPT4ge1xuICAgIGNvbnN0IGNvbnRhaW5lciA9IG5vcm1hbGl6ZUNvbnRhaW5lcihjb250YWluZXJPclNlbGVjdG9yKTtcbiAgICBpZiAoIWNvbnRhaW5lcilcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBjb21wb25lbnQgPSBhcHAuX2NvbXBvbmVudDtcbiAgICBpZiAoIWlzRnVuY3Rpb24oY29tcG9uZW50KSAmJiAhY29tcG9uZW50LnJlbmRlciAmJiAhY29tcG9uZW50LnRlbXBsYXRlKSB7XG4gICAgICBjb21wb25lbnQudGVtcGxhdGUgPSBjb250YWluZXIuaW5uZXJIVE1MO1xuICAgIH1cbiAgICBjb250YWluZXIuaW5uZXJIVE1MID0gXCJcIjtcbiAgICBjb25zdCBwcm94eSA9IG1vdW50KGNvbnRhaW5lciwgZmFsc2UsIGNvbnRhaW5lciBpbnN0YW5jZW9mIFNWR0VsZW1lbnQpO1xuICAgIGlmIChjb250YWluZXIgaW5zdGFuY2VvZiBFbGVtZW50KSB7XG4gICAgICBjb250YWluZXIucmVtb3ZlQXR0cmlidXRlKFwidi1jbG9ha1wiKTtcbiAgICAgIGNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoXCJkYXRhLXYtYXBwXCIsIFwiXCIpO1xuICAgIH1cbiAgICByZXR1cm4gcHJveHk7XG4gIH07XG4gIHJldHVybiBhcHA7XG59O1xuY29uc3QgY3JlYXRlU1NSQXBwID0gKC4uLmFyZ3MpID0+IHtcbiAgY29uc3QgYXBwID0gZW5zdXJlSHlkcmF0aW9uUmVuZGVyZXIoKS5jcmVhdGVBcHAoLi4uYXJncyk7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgaW5qZWN0TmF0aXZlVGFnQ2hlY2soYXBwKTtcbiAgICBpbmplY3RDb21waWxlck9wdGlvbnNDaGVjayhhcHApO1xuICB9XG4gIGNvbnN0IHsgbW91bnQgfSA9IGFwcDtcbiAgYXBwLm1vdW50ID0gKGNvbnRhaW5lck9yU2VsZWN0b3IpID0+IHtcbiAgICBjb25zdCBjb250YWluZXIgPSBub3JtYWxpemVDb250YWluZXIoY29udGFpbmVyT3JTZWxlY3Rvcik7XG4gICAgaWYgKGNvbnRhaW5lcikge1xuICAgICAgcmV0dXJuIG1vdW50KGNvbnRhaW5lciwgdHJ1ZSwgY29udGFpbmVyIGluc3RhbmNlb2YgU1ZHRWxlbWVudCk7XG4gICAgfVxuICB9O1xuICByZXR1cm4gYXBwO1xufTtcbmZ1bmN0aW9uIGluamVjdE5hdGl2ZVRhZ0NoZWNrKGFwcCkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYXBwLmNvbmZpZywgXCJpc05hdGl2ZVRhZ1wiLCB7XG4gICAgdmFsdWU6ICh0YWcpID0+IGlzSFRNTFRhZyh0YWcpIHx8IGlzU1ZHVGFnKHRhZyksXG4gICAgd3JpdGFibGU6IGZhbHNlXG4gIH0pO1xufVxuZnVuY3Rpb24gaW5qZWN0Q29tcGlsZXJPcHRpb25zQ2hlY2soYXBwKSB7XG4gIGlmIChpc1J1bnRpbWVPbmx5KCkpIHtcbiAgICBjb25zdCBpc0N1c3RvbUVsZW1lbnQgPSBhcHAuY29uZmlnLmlzQ3VzdG9tRWxlbWVudDtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYXBwLmNvbmZpZywgXCJpc0N1c3RvbUVsZW1lbnRcIiwge1xuICAgICAgZ2V0KCkge1xuICAgICAgICByZXR1cm4gaXNDdXN0b21FbGVtZW50O1xuICAgICAgfSxcbiAgICAgIHNldCgpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBgVGhlIFxcYGlzQ3VzdG9tRWxlbWVudFxcYCBjb25maWcgb3B0aW9uIGlzIGRlcHJlY2F0ZWQuIFVzZSBcXGBjb21waWxlck9wdGlvbnMuaXNDdXN0b21FbGVtZW50XFxgIGluc3RlYWQuYFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IGNvbXBpbGVyT3B0aW9ucyA9IGFwcC5jb25maWcuY29tcGlsZXJPcHRpb25zO1xuICAgIGNvbnN0IG1zZyA9IGBUaGUgXFxgY29tcGlsZXJPcHRpb25zXFxgIGNvbmZpZyBvcHRpb24gaXMgb25seSByZXNwZWN0ZWQgd2hlbiB1c2luZyBhIGJ1aWxkIG9mIFZ1ZS5qcyB0aGF0IGluY2x1ZGVzIHRoZSBydW50aW1lIGNvbXBpbGVyIChha2EgXCJmdWxsIGJ1aWxkXCIpLiBTaW5jZSB5b3UgYXJlIHVzaW5nIHRoZSBydW50aW1lLW9ubHkgYnVpbGQsIFxcYGNvbXBpbGVyT3B0aW9uc1xcYCBtdXN0IGJlIHBhc3NlZCB0byBcXGBAdnVlL2NvbXBpbGVyLWRvbVxcYCBpbiB0aGUgYnVpbGQgc2V0dXAgaW5zdGVhZC5cbi0gRm9yIHZ1ZS1sb2FkZXI6IHBhc3MgaXQgdmlhIHZ1ZS1sb2FkZXIncyBcXGBjb21waWxlck9wdGlvbnNcXGAgbG9hZGVyIG9wdGlvbi5cbi0gRm9yIHZ1ZS1jbGk6IHNlZSBodHRwczovL2NsaS52dWVqcy5vcmcvZ3VpZGUvd2VicGFjay5odG1sI21vZGlmeWluZy1vcHRpb25zLW9mLWEtbG9hZGVyXG4tIEZvciB2aXRlOiBwYXNzIGl0IHZpYSBAdml0ZWpzL3BsdWdpbi12dWUgb3B0aW9ucy4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS92aXRlanMvdml0ZS1wbHVnaW4tdnVlL3RyZWUvbWFpbi9wYWNrYWdlcy9wbHVnaW4tdnVlI2V4YW1wbGUtZm9yLXBhc3Npbmctb3B0aW9ucy10by12dWVjb21waWxlci1zZmNgO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhcHAuY29uZmlnLCBcImNvbXBpbGVyT3B0aW9uc1wiLCB7XG4gICAgICBnZXQoKSB7XG4gICAgICAgIHdhcm4obXNnKTtcbiAgICAgICAgcmV0dXJuIGNvbXBpbGVyT3B0aW9ucztcbiAgICAgIH0sXG4gICAgICBzZXQoKSB7XG4gICAgICAgIHdhcm4obXNnKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gbm9ybWFsaXplQ29udGFpbmVyKGNvbnRhaW5lcikge1xuICBpZiAoaXNTdHJpbmcoY29udGFpbmVyKSkge1xuICAgIGNvbnN0IHJlcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoY29udGFpbmVyKTtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhcmVzKSB7XG4gICAgICB3YXJuKFxuICAgICAgICBgRmFpbGVkIHRvIG1vdW50IGFwcDogbW91bnQgdGFyZ2V0IHNlbGVjdG9yIFwiJHtjb250YWluZXJ9XCIgcmV0dXJuZWQgbnVsbC5gXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xuICB9XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHdpbmRvdy5TaGFkb3dSb290ICYmIGNvbnRhaW5lciBpbnN0YW5jZW9mIHdpbmRvdy5TaGFkb3dSb290ICYmIGNvbnRhaW5lci5tb2RlID09PSBcImNsb3NlZFwiKSB7XG4gICAgd2FybihcbiAgICAgIGBtb3VudGluZyBvbiBhIFNoYWRvd1Jvb3Qgd2l0aCBcXGB7bW9kZTogXCJjbG9zZWRcIn1cXGAgbWF5IGxlYWQgdG8gdW5wcmVkaWN0YWJsZSBidWdzYFxuICAgICk7XG4gIH1cbiAgcmV0dXJuIGNvbnRhaW5lcjtcbn1cbmxldCBzc3JEaXJlY3RpdmVJbml0aWFsaXplZCA9IGZhbHNlO1xuY29uc3QgaW5pdERpcmVjdGl2ZXNGb3JTU1IgPSAoKSA9PiB7XG4gIGlmICghc3NyRGlyZWN0aXZlSW5pdGlhbGl6ZWQpIHtcbiAgICBzc3JEaXJlY3RpdmVJbml0aWFsaXplZCA9IHRydWU7XG4gICAgaW5pdFZNb2RlbEZvclNTUigpO1xuICAgIGluaXRWU2hvd0ZvclNTUigpO1xuICB9XG59IDtcblxuZXhwb3J0IHsgVHJhbnNpdGlvbiwgVHJhbnNpdGlvbkdyb3VwLCBWdWVFbGVtZW50LCBjcmVhdGVBcHAsIGNyZWF0ZVNTUkFwcCwgZGVmaW5lQ3VzdG9tRWxlbWVudCwgZGVmaW5lU1NSQ3VzdG9tRWxlbWVudCwgaHlkcmF0ZSwgaW5pdERpcmVjdGl2ZXNGb3JTU1IsIHJlbmRlciwgdXNlQ3NzTW9kdWxlLCB1c2VDc3NWYXJzLCB2TW9kZWxDaGVja2JveCwgdk1vZGVsRHluYW1pYywgdk1vZGVsUmFkaW8sIHZNb2RlbFNlbGVjdCwgdk1vZGVsVGV4dCwgdlNob3csIHdpdGhLZXlzLCB3aXRoTW9kaWZpZXJzIH07XG4iLCJpbXBvcnQgeyBwYXVzZVRyYWNraW5nLCByZXNldFRyYWNraW5nLCBpc1JlZiwgdG9SYXcsIGdldEN1cnJlbnRTY29wZSwgaXNTaGFsbG93IGFzIGlzU2hhbGxvdyQxLCBpc1JlYWN0aXZlLCBSZWFjdGl2ZUVmZmVjdCwgcmVmLCBzaGFsbG93UmVhZG9ubHksIHRyYWNrLCByZWFjdGl2ZSwgc2hhbGxvd1JlYWN0aXZlLCB0cmlnZ2VyLCBpc1Byb3h5LCBwcm94eVJlZnMsIG1hcmtSYXcsIEVmZmVjdFNjb3BlLCBjb21wdXRlZCBhcyBjb21wdXRlZCQxLCBpc1JlYWRvbmx5IH0gZnJvbSAnQHZ1ZS9yZWFjdGl2aXR5JztcbmV4cG9ydCB7IEVmZmVjdFNjb3BlLCBSZWFjdGl2ZUVmZmVjdCwgY3VzdG9tUmVmLCBlZmZlY3QsIGVmZmVjdFNjb3BlLCBnZXRDdXJyZW50U2NvcGUsIGlzUHJveHksIGlzUmVhY3RpdmUsIGlzUmVhZG9ubHksIGlzUmVmLCBpc1NoYWxsb3csIG1hcmtSYXcsIG9uU2NvcGVEaXNwb3NlLCBwcm94eVJlZnMsIHJlYWN0aXZlLCByZWFkb25seSwgcmVmLCBzaGFsbG93UmVhY3RpdmUsIHNoYWxsb3dSZWFkb25seSwgc2hhbGxvd1JlZiwgc3RvcCwgdG9SYXcsIHRvUmVmLCB0b1JlZnMsIHRvVmFsdWUsIHRyaWdnZXJSZWYsIHVucmVmIH0gZnJvbSAnQHZ1ZS9yZWFjdGl2aXR5JztcbmltcG9ydCB7IGlzU3RyaW5nLCBpc0Z1bmN0aW9uLCBpc1Byb21pc2UsIGlzQXJyYXksIE5PT1AsIGdldEdsb2JhbFRoaXMsIGV4dGVuZCwgRU1QVFlfT0JKLCB0b0hhbmRsZXJLZXksIGxvb3NlVG9OdW1iZXIsIGh5cGhlbmF0ZSwgY2FtZWxpemUsIGlzT2JqZWN0LCBpc09uLCBoYXNPd24sIGlzTW9kZWxMaXN0ZW5lciwgdG9OdW1iZXIsIGhhc0NoYW5nZWQsIHJlbW92ZSwgaXNTZXQsIGlzTWFwLCBpc1BsYWluT2JqZWN0LCBpc0J1aWx0SW5EaXJlY3RpdmUsIGludm9rZUFycmF5Rm5zLCBpc1JlZ0V4cCwgY2FwaXRhbGl6ZSwgaXNHbG9iYWxseVdoaXRlbGlzdGVkLCBOTywgZGVmLCBpc1Jlc2VydmVkUHJvcCwgRU1QVFlfQVJSLCB0b1Jhd1R5cGUsIG1ha2VNYXAsIG5vcm1hbGl6ZUNsYXNzLCBub3JtYWxpemVTdHlsZSB9IGZyb20gJ0B2dWUvc2hhcmVkJztcbmV4cG9ydCB7IGNhbWVsaXplLCBjYXBpdGFsaXplLCBub3JtYWxpemVDbGFzcywgbm9ybWFsaXplUHJvcHMsIG5vcm1hbGl6ZVN0eWxlLCB0b0Rpc3BsYXlTdHJpbmcsIHRvSGFuZGxlcktleSB9IGZyb20gJ0B2dWUvc2hhcmVkJztcblxuY29uc3Qgc3RhY2sgPSBbXTtcbmZ1bmN0aW9uIHB1c2hXYXJuaW5nQ29udGV4dCh2bm9kZSkge1xuICBzdGFjay5wdXNoKHZub2RlKTtcbn1cbmZ1bmN0aW9uIHBvcFdhcm5pbmdDb250ZXh0KCkge1xuICBzdGFjay5wb3AoKTtcbn1cbmZ1bmN0aW9uIHdhcm4obXNnLCAuLi5hcmdzKSB7XG4gIGlmICghISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSlcbiAgICByZXR1cm47XG4gIHBhdXNlVHJhY2tpbmcoKTtcbiAgY29uc3QgaW5zdGFuY2UgPSBzdGFjay5sZW5ndGggPyBzdGFja1tzdGFjay5sZW5ndGggLSAxXS5jb21wb25lbnQgOiBudWxsO1xuICBjb25zdCBhcHBXYXJuSGFuZGxlciA9IGluc3RhbmNlICYmIGluc3RhbmNlLmFwcENvbnRleHQuY29uZmlnLndhcm5IYW5kbGVyO1xuICBjb25zdCB0cmFjZSA9IGdldENvbXBvbmVudFRyYWNlKCk7XG4gIGlmIChhcHBXYXJuSGFuZGxlcikge1xuICAgIGNhbGxXaXRoRXJyb3JIYW5kbGluZyhcbiAgICAgIGFwcFdhcm5IYW5kbGVyLFxuICAgICAgaW5zdGFuY2UsXG4gICAgICAxMSxcbiAgICAgIFtcbiAgICAgICAgbXNnICsgYXJncy5qb2luKFwiXCIpLFxuICAgICAgICBpbnN0YW5jZSAmJiBpbnN0YW5jZS5wcm94eSxcbiAgICAgICAgdHJhY2UubWFwKFxuICAgICAgICAgICh7IHZub2RlIH0pID0+IGBhdCA8JHtmb3JtYXRDb21wb25lbnROYW1lKGluc3RhbmNlLCB2bm9kZS50eXBlKX0+YFxuICAgICAgICApLmpvaW4oXCJcXG5cIiksXG4gICAgICAgIHRyYWNlXG4gICAgICBdXG4gICAgKTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCB3YXJuQXJncyA9IFtgW1Z1ZSB3YXJuXTogJHttc2d9YCwgLi4uYXJnc107XG4gICAgaWYgKHRyYWNlLmxlbmd0aCAmJiAvLyBhdm9pZCBzcGFtbWluZyBjb25zb2xlIGR1cmluZyB0ZXN0c1xuICAgIHRydWUpIHtcbiAgICAgIHdhcm5BcmdzLnB1c2goYFxuYCwgLi4uZm9ybWF0VHJhY2UodHJhY2UpKTtcbiAgICB9XG4gICAgY29uc29sZS53YXJuKC4uLndhcm5BcmdzKTtcbiAgfVxuICByZXNldFRyYWNraW5nKCk7XG59XG5mdW5jdGlvbiBnZXRDb21wb25lbnRUcmFjZSgpIHtcbiAgbGV0IGN1cnJlbnRWTm9kZSA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdO1xuICBpZiAoIWN1cnJlbnRWTm9kZSkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBjb25zdCBub3JtYWxpemVkU3RhY2sgPSBbXTtcbiAgd2hpbGUgKGN1cnJlbnRWTm9kZSkge1xuICAgIGNvbnN0IGxhc3QgPSBub3JtYWxpemVkU3RhY2tbMF07XG4gICAgaWYgKGxhc3QgJiYgbGFzdC52bm9kZSA9PT0gY3VycmVudFZOb2RlKSB7XG4gICAgICBsYXN0LnJlY3Vyc2VDb3VudCsrO1xuICAgIH0gZWxzZSB7XG4gICAgICBub3JtYWxpemVkU3RhY2sucHVzaCh7XG4gICAgICAgIHZub2RlOiBjdXJyZW50Vk5vZGUsXG4gICAgICAgIHJlY3Vyc2VDb3VudDogMFxuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IHBhcmVudEluc3RhbmNlID0gY3VycmVudFZOb2RlLmNvbXBvbmVudCAmJiBjdXJyZW50Vk5vZGUuY29tcG9uZW50LnBhcmVudDtcbiAgICBjdXJyZW50Vk5vZGUgPSBwYXJlbnRJbnN0YW5jZSAmJiBwYXJlbnRJbnN0YW5jZS52bm9kZTtcbiAgfVxuICByZXR1cm4gbm9ybWFsaXplZFN0YWNrO1xufVxuZnVuY3Rpb24gZm9ybWF0VHJhY2UodHJhY2UpIHtcbiAgY29uc3QgbG9ncyA9IFtdO1xuICB0cmFjZS5mb3JFYWNoKChlbnRyeSwgaSkgPT4ge1xuICAgIGxvZ3MucHVzaCguLi5pID09PSAwID8gW10gOiBbYFxuYF0sIC4uLmZvcm1hdFRyYWNlRW50cnkoZW50cnkpKTtcbiAgfSk7XG4gIHJldHVybiBsb2dzO1xufVxuZnVuY3Rpb24gZm9ybWF0VHJhY2VFbnRyeSh7IHZub2RlLCByZWN1cnNlQ291bnQgfSkge1xuICBjb25zdCBwb3N0Zml4ID0gcmVjdXJzZUNvdW50ID4gMCA/IGAuLi4gKCR7cmVjdXJzZUNvdW50fSByZWN1cnNpdmUgY2FsbHMpYCA6IGBgO1xuICBjb25zdCBpc1Jvb3QgPSB2bm9kZS5jb21wb25lbnQgPyB2bm9kZS5jb21wb25lbnQucGFyZW50ID09IG51bGwgOiBmYWxzZTtcbiAgY29uc3Qgb3BlbiA9IGAgYXQgPCR7Zm9ybWF0Q29tcG9uZW50TmFtZShcbiAgICB2bm9kZS5jb21wb25lbnQsXG4gICAgdm5vZGUudHlwZSxcbiAgICBpc1Jvb3RcbiAgKX1gO1xuICBjb25zdCBjbG9zZSA9IGA+YCArIHBvc3RmaXg7XG4gIHJldHVybiB2bm9kZS5wcm9wcyA/IFtvcGVuLCAuLi5mb3JtYXRQcm9wcyh2bm9kZS5wcm9wcyksIGNsb3NlXSA6IFtvcGVuICsgY2xvc2VdO1xufVxuZnVuY3Rpb24gZm9ybWF0UHJvcHMocHJvcHMpIHtcbiAgY29uc3QgcmVzID0gW107XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhwcm9wcyk7XG4gIGtleXMuc2xpY2UoMCwgMykuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgcmVzLnB1c2goLi4uZm9ybWF0UHJvcChrZXksIHByb3BzW2tleV0pKTtcbiAgfSk7XG4gIGlmIChrZXlzLmxlbmd0aCA+IDMpIHtcbiAgICByZXMucHVzaChgIC4uLmApO1xuICB9XG4gIHJldHVybiByZXM7XG59XG5mdW5jdGlvbiBmb3JtYXRQcm9wKGtleSwgdmFsdWUsIHJhdykge1xuICBpZiAoaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgdmFsdWUgPSBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG4gICAgcmV0dXJuIHJhdyA/IHZhbHVlIDogW2Ake2tleX09JHt2YWx1ZX1gXTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIgfHwgdHlwZW9mIHZhbHVlID09PSBcImJvb2xlYW5cIiB8fCB2YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHJhdyA/IHZhbHVlIDogW2Ake2tleX09JHt2YWx1ZX1gXTtcbiAgfSBlbHNlIGlmIChpc1JlZih2YWx1ZSkpIHtcbiAgICB2YWx1ZSA9IGZvcm1hdFByb3Aoa2V5LCB0b1Jhdyh2YWx1ZS52YWx1ZSksIHRydWUpO1xuICAgIHJldHVybiByYXcgPyB2YWx1ZSA6IFtgJHtrZXl9PVJlZjxgLCB2YWx1ZSwgYD5gXTtcbiAgfSBlbHNlIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgIHJldHVybiBbYCR7a2V5fT1mbiR7dmFsdWUubmFtZSA/IGA8JHt2YWx1ZS5uYW1lfT5gIDogYGB9YF07XG4gIH0gZWxzZSB7XG4gICAgdmFsdWUgPSB0b1Jhdyh2YWx1ZSk7XG4gICAgcmV0dXJuIHJhdyA/IHZhbHVlIDogW2Ake2tleX09YCwgdmFsdWVdO1xuICB9XG59XG5mdW5jdGlvbiBhc3NlcnROdW1iZXIodmFsLCB0eXBlKSB7XG4gIGlmICghISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSlcbiAgICByZXR1cm47XG4gIGlmICh2YWwgPT09IHZvaWQgMCkge1xuICAgIHJldHVybjtcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsICE9PSBcIm51bWJlclwiKSB7XG4gICAgd2FybihgJHt0eXBlfSBpcyBub3QgYSB2YWxpZCBudW1iZXIgLSBnb3QgJHtKU09OLnN0cmluZ2lmeSh2YWwpfS5gKTtcbiAgfSBlbHNlIGlmIChpc05hTih2YWwpKSB7XG4gICAgd2FybihgJHt0eXBlfSBpcyBOYU4gLSB0aGUgZHVyYXRpb24gZXhwcmVzc2lvbiBtaWdodCBiZSBpbmNvcnJlY3QuYCk7XG4gIH1cbn1cblxuY29uc3QgRXJyb3JUeXBlU3RyaW5ncyA9IHtcbiAgW1wic3BcIl06IFwic2VydmVyUHJlZmV0Y2ggaG9va1wiLFxuICBbXCJiY1wiXTogXCJiZWZvcmVDcmVhdGUgaG9va1wiLFxuICBbXCJjXCJdOiBcImNyZWF0ZWQgaG9va1wiLFxuICBbXCJibVwiXTogXCJiZWZvcmVNb3VudCBob29rXCIsXG4gIFtcIm1cIl06IFwibW91bnRlZCBob29rXCIsXG4gIFtcImJ1XCJdOiBcImJlZm9yZVVwZGF0ZSBob29rXCIsXG4gIFtcInVcIl06IFwidXBkYXRlZFwiLFxuICBbXCJidW1cIl06IFwiYmVmb3JlVW5tb3VudCBob29rXCIsXG4gIFtcInVtXCJdOiBcInVubW91bnRlZCBob29rXCIsXG4gIFtcImFcIl06IFwiYWN0aXZhdGVkIGhvb2tcIixcbiAgW1wiZGFcIl06IFwiZGVhY3RpdmF0ZWQgaG9va1wiLFxuICBbXCJlY1wiXTogXCJlcnJvckNhcHR1cmVkIGhvb2tcIixcbiAgW1wicnRjXCJdOiBcInJlbmRlclRyYWNrZWQgaG9va1wiLFxuICBbXCJydGdcIl06IFwicmVuZGVyVHJpZ2dlcmVkIGhvb2tcIixcbiAgWzBdOiBcInNldHVwIGZ1bmN0aW9uXCIsXG4gIFsxXTogXCJyZW5kZXIgZnVuY3Rpb25cIixcbiAgWzJdOiBcIndhdGNoZXIgZ2V0dGVyXCIsXG4gIFszXTogXCJ3YXRjaGVyIGNhbGxiYWNrXCIsXG4gIFs0XTogXCJ3YXRjaGVyIGNsZWFudXAgZnVuY3Rpb25cIixcbiAgWzVdOiBcIm5hdGl2ZSBldmVudCBoYW5kbGVyXCIsXG4gIFs2XTogXCJjb21wb25lbnQgZXZlbnQgaGFuZGxlclwiLFxuICBbN106IFwidm5vZGUgaG9va1wiLFxuICBbOF06IFwiZGlyZWN0aXZlIGhvb2tcIixcbiAgWzldOiBcInRyYW5zaXRpb24gaG9va1wiLFxuICBbMTBdOiBcImFwcCBlcnJvckhhbmRsZXJcIixcbiAgWzExXTogXCJhcHAgd2FybkhhbmRsZXJcIixcbiAgWzEyXTogXCJyZWYgZnVuY3Rpb25cIixcbiAgWzEzXTogXCJhc3luYyBjb21wb25lbnQgbG9hZGVyXCIsXG4gIFsxNF06IFwic2NoZWR1bGVyIGZsdXNoLiBUaGlzIGlzIGxpa2VseSBhIFZ1ZSBpbnRlcm5hbHMgYnVnLiBQbGVhc2Ugb3BlbiBhbiBpc3N1ZSBhdCBodHRwczovL25ldy1pc3N1ZS52dWVqcy5vcmcvP3JlcG89dnVlanMvY29yZVwiXG59O1xuZnVuY3Rpb24gY2FsbFdpdGhFcnJvckhhbmRsaW5nKGZuLCBpbnN0YW5jZSwgdHlwZSwgYXJncykge1xuICBsZXQgcmVzO1xuICB0cnkge1xuICAgIHJlcyA9IGFyZ3MgPyBmbiguLi5hcmdzKSA6IGZuKCk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGhhbmRsZUVycm9yKGVyciwgaW5zdGFuY2UsIHR5cGUpO1xuICB9XG4gIHJldHVybiByZXM7XG59XG5mdW5jdGlvbiBjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZyhmbiwgaW5zdGFuY2UsIHR5cGUsIGFyZ3MpIHtcbiAgaWYgKGlzRnVuY3Rpb24oZm4pKSB7XG4gICAgY29uc3QgcmVzID0gY2FsbFdpdGhFcnJvckhhbmRsaW5nKGZuLCBpbnN0YW5jZSwgdHlwZSwgYXJncyk7XG4gICAgaWYgKHJlcyAmJiBpc1Byb21pc2UocmVzKSkge1xuICAgICAgcmVzLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgaGFuZGxlRXJyb3IoZXJyLCBpbnN0YW5jZSwgdHlwZSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbiAgfVxuICBjb25zdCB2YWx1ZXMgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBmbi5sZW5ndGg7IGkrKykge1xuICAgIHZhbHVlcy5wdXNoKGNhbGxXaXRoQXN5bmNFcnJvckhhbmRsaW5nKGZuW2ldLCBpbnN0YW5jZSwgdHlwZSwgYXJncykpO1xuICB9XG4gIHJldHVybiB2YWx1ZXM7XG59XG5mdW5jdGlvbiBoYW5kbGVFcnJvcihlcnIsIGluc3RhbmNlLCB0eXBlLCB0aHJvd0luRGV2ID0gdHJ1ZSkge1xuICBjb25zdCBjb250ZXh0Vk5vZGUgPSBpbnN0YW5jZSA/IGluc3RhbmNlLnZub2RlIDogbnVsbDtcbiAgaWYgKGluc3RhbmNlKSB7XG4gICAgbGV0IGN1ciA9IGluc3RhbmNlLnBhcmVudDtcbiAgICBjb25zdCBleHBvc2VkSW5zdGFuY2UgPSBpbnN0YW5jZS5wcm94eTtcbiAgICBjb25zdCBlcnJvckluZm8gPSAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gRXJyb3JUeXBlU3RyaW5nc1t0eXBlXSA6IHR5cGU7XG4gICAgd2hpbGUgKGN1cikge1xuICAgICAgY29uc3QgZXJyb3JDYXB0dXJlZEhvb2tzID0gY3VyLmVjO1xuICAgICAgaWYgKGVycm9yQ2FwdHVyZWRIb29rcykge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVycm9yQ2FwdHVyZWRIb29rcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChlcnJvckNhcHR1cmVkSG9va3NbaV0oZXJyLCBleHBvc2VkSW5zdGFuY2UsIGVycm9ySW5mbykgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjdXIgPSBjdXIucGFyZW50O1xuICAgIH1cbiAgICBjb25zdCBhcHBFcnJvckhhbmRsZXIgPSBpbnN0YW5jZS5hcHBDb250ZXh0LmNvbmZpZy5lcnJvckhhbmRsZXI7XG4gICAgaWYgKGFwcEVycm9ySGFuZGxlcikge1xuICAgICAgY2FsbFdpdGhFcnJvckhhbmRsaW5nKFxuICAgICAgICBhcHBFcnJvckhhbmRsZXIsXG4gICAgICAgIG51bGwsXG4gICAgICAgIDEwLFxuICAgICAgICBbZXJyLCBleHBvc2VkSW5zdGFuY2UsIGVycm9ySW5mb11cbiAgICAgICk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG4gIGxvZ0Vycm9yKGVyciwgdHlwZSwgY29udGV4dFZOb2RlLCB0aHJvd0luRGV2KTtcbn1cbmZ1bmN0aW9uIGxvZ0Vycm9yKGVyciwgdHlwZSwgY29udGV4dFZOb2RlLCB0aHJvd0luRGV2ID0gdHJ1ZSkge1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIGNvbnN0IGluZm8gPSBFcnJvclR5cGVTdHJpbmdzW3R5cGVdO1xuICAgIGlmIChjb250ZXh0Vk5vZGUpIHtcbiAgICAgIHB1c2hXYXJuaW5nQ29udGV4dChjb250ZXh0Vk5vZGUpO1xuICAgIH1cbiAgICB3YXJuKGBVbmhhbmRsZWQgZXJyb3Ike2luZm8gPyBgIGR1cmluZyBleGVjdXRpb24gb2YgJHtpbmZvfWAgOiBgYH1gKTtcbiAgICBpZiAoY29udGV4dFZOb2RlKSB7XG4gICAgICBwb3BXYXJuaW5nQ29udGV4dCgpO1xuICAgIH1cbiAgICBpZiAodGhyb3dJbkRldikge1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgfVxufVxuXG5sZXQgaXNGbHVzaGluZyA9IGZhbHNlO1xubGV0IGlzRmx1c2hQZW5kaW5nID0gZmFsc2U7XG5jb25zdCBxdWV1ZSA9IFtdO1xubGV0IGZsdXNoSW5kZXggPSAwO1xuY29uc3QgcGVuZGluZ1Bvc3RGbHVzaENicyA9IFtdO1xubGV0IGFjdGl2ZVBvc3RGbHVzaENicyA9IG51bGw7XG5sZXQgcG9zdEZsdXNoSW5kZXggPSAwO1xuY29uc3QgcmVzb2x2ZWRQcm9taXNlID0gLyogQF9fUFVSRV9fICovIFByb21pc2UucmVzb2x2ZSgpO1xubGV0IGN1cnJlbnRGbHVzaFByb21pc2UgPSBudWxsO1xuY29uc3QgUkVDVVJTSU9OX0xJTUlUID0gMTAwO1xuZnVuY3Rpb24gbmV4dFRpY2soZm4pIHtcbiAgY29uc3QgcCA9IGN1cnJlbnRGbHVzaFByb21pc2UgfHwgcmVzb2x2ZWRQcm9taXNlO1xuICByZXR1cm4gZm4gPyBwLnRoZW4odGhpcyA/IGZuLmJpbmQodGhpcykgOiBmbikgOiBwO1xufVxuZnVuY3Rpb24gZmluZEluc2VydGlvbkluZGV4KGlkKSB7XG4gIGxldCBzdGFydCA9IGZsdXNoSW5kZXggKyAxO1xuICBsZXQgZW5kID0gcXVldWUubGVuZ3RoO1xuICB3aGlsZSAoc3RhcnQgPCBlbmQpIHtcbiAgICBjb25zdCBtaWRkbGUgPSBzdGFydCArIGVuZCA+Pj4gMTtcbiAgICBjb25zdCBtaWRkbGVKb2JJZCA9IGdldElkKHF1ZXVlW21pZGRsZV0pO1xuICAgIG1pZGRsZUpvYklkIDwgaWQgPyBzdGFydCA9IG1pZGRsZSArIDEgOiBlbmQgPSBtaWRkbGU7XG4gIH1cbiAgcmV0dXJuIHN0YXJ0O1xufVxuZnVuY3Rpb24gcXVldWVKb2Ioam9iKSB7XG4gIGlmICghcXVldWUubGVuZ3RoIHx8ICFxdWV1ZS5pbmNsdWRlcyhcbiAgICBqb2IsXG4gICAgaXNGbHVzaGluZyAmJiBqb2IuYWxsb3dSZWN1cnNlID8gZmx1c2hJbmRleCArIDEgOiBmbHVzaEluZGV4XG4gICkpIHtcbiAgICBpZiAoam9iLmlkID09IG51bGwpIHtcbiAgICAgIHF1ZXVlLnB1c2goam9iKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcXVldWUuc3BsaWNlKGZpbmRJbnNlcnRpb25JbmRleChqb2IuaWQpLCAwLCBqb2IpO1xuICAgIH1cbiAgICBxdWV1ZUZsdXNoKCk7XG4gIH1cbn1cbmZ1bmN0aW9uIHF1ZXVlRmx1c2goKSB7XG4gIGlmICghaXNGbHVzaGluZyAmJiAhaXNGbHVzaFBlbmRpbmcpIHtcbiAgICBpc0ZsdXNoUGVuZGluZyA9IHRydWU7XG4gICAgY3VycmVudEZsdXNoUHJvbWlzZSA9IHJlc29sdmVkUHJvbWlzZS50aGVuKGZsdXNoSm9icyk7XG4gIH1cbn1cbmZ1bmN0aW9uIGludmFsaWRhdGVKb2Ioam9iKSB7XG4gIGNvbnN0IGkgPSBxdWV1ZS5pbmRleE9mKGpvYik7XG4gIGlmIChpID4gZmx1c2hJbmRleCkge1xuICAgIHF1ZXVlLnNwbGljZShpLCAxKTtcbiAgfVxufVxuZnVuY3Rpb24gcXVldWVQb3N0Rmx1c2hDYihjYikge1xuICBpZiAoIWlzQXJyYXkoY2IpKSB7XG4gICAgaWYgKCFhY3RpdmVQb3N0Rmx1c2hDYnMgfHwgIWFjdGl2ZVBvc3RGbHVzaENicy5pbmNsdWRlcyhcbiAgICAgIGNiLFxuICAgICAgY2IuYWxsb3dSZWN1cnNlID8gcG9zdEZsdXNoSW5kZXggKyAxIDogcG9zdEZsdXNoSW5kZXhcbiAgICApKSB7XG4gICAgICBwZW5kaW5nUG9zdEZsdXNoQ2JzLnB1c2goY2IpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBwZW5kaW5nUG9zdEZsdXNoQ2JzLnB1c2goLi4uY2IpO1xuICB9XG4gIHF1ZXVlRmx1c2goKTtcbn1cbmZ1bmN0aW9uIGZsdXNoUHJlRmx1c2hDYnMoc2VlbiwgaSA9IGlzRmx1c2hpbmcgPyBmbHVzaEluZGV4ICsgMSA6IDApIHtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICBzZWVuID0gc2VlbiB8fCAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICB9XG4gIGZvciAoOyBpIDwgcXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBjYiA9IHF1ZXVlW2ldO1xuICAgIGlmIChjYiAmJiBjYi5wcmUpIHtcbiAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGNoZWNrUmVjdXJzaXZlVXBkYXRlcyhzZWVuLCBjYikpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBxdWV1ZS5zcGxpY2UoaSwgMSk7XG4gICAgICBpLS07XG4gICAgICBjYigpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZmx1c2hQb3N0Rmx1c2hDYnMoc2Vlbikge1xuICBpZiAocGVuZGluZ1Bvc3RGbHVzaENicy5sZW5ndGgpIHtcbiAgICBjb25zdCBkZWR1cGVkID0gWy4uLm5ldyBTZXQocGVuZGluZ1Bvc3RGbHVzaENicyldO1xuICAgIHBlbmRpbmdQb3N0Rmx1c2hDYnMubGVuZ3RoID0gMDtcbiAgICBpZiAoYWN0aXZlUG9zdEZsdXNoQ2JzKSB7XG4gICAgICBhY3RpdmVQb3N0Rmx1c2hDYnMucHVzaCguLi5kZWR1cGVkKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgYWN0aXZlUG9zdEZsdXNoQ2JzID0gZGVkdXBlZDtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgc2VlbiA9IHNlZW4gfHwgLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB9XG4gICAgYWN0aXZlUG9zdEZsdXNoQ2JzLnNvcnQoKGEsIGIpID0+IGdldElkKGEpIC0gZ2V0SWQoYikpO1xuICAgIGZvciAocG9zdEZsdXNoSW5kZXggPSAwOyBwb3N0Rmx1c2hJbmRleCA8IGFjdGl2ZVBvc3RGbHVzaENicy5sZW5ndGg7IHBvc3RGbHVzaEluZGV4KyspIHtcbiAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGNoZWNrUmVjdXJzaXZlVXBkYXRlcyhzZWVuLCBhY3RpdmVQb3N0Rmx1c2hDYnNbcG9zdEZsdXNoSW5kZXhdKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGFjdGl2ZVBvc3RGbHVzaENic1twb3N0Rmx1c2hJbmRleF0oKTtcbiAgICB9XG4gICAgYWN0aXZlUG9zdEZsdXNoQ2JzID0gbnVsbDtcbiAgICBwb3N0Rmx1c2hJbmRleCA9IDA7XG4gIH1cbn1cbmNvbnN0IGdldElkID0gKGpvYikgPT4gam9iLmlkID09IG51bGwgPyBJbmZpbml0eSA6IGpvYi5pZDtcbmNvbnN0IGNvbXBhcmF0b3IgPSAoYSwgYikgPT4ge1xuICBjb25zdCBkaWZmID0gZ2V0SWQoYSkgLSBnZXRJZChiKTtcbiAgaWYgKGRpZmYgPT09IDApIHtcbiAgICBpZiAoYS5wcmUgJiYgIWIucHJlKVxuICAgICAgcmV0dXJuIC0xO1xuICAgIGlmIChiLnByZSAmJiAhYS5wcmUpXG4gICAgICByZXR1cm4gMTtcbiAgfVxuICByZXR1cm4gZGlmZjtcbn07XG5mdW5jdGlvbiBmbHVzaEpvYnMoc2Vlbikge1xuICBpc0ZsdXNoUGVuZGluZyA9IGZhbHNlO1xuICBpc0ZsdXNoaW5nID0gdHJ1ZTtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICBzZWVuID0gc2VlbiB8fCAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICB9XG4gIHF1ZXVlLnNvcnQoY29tcGFyYXRvcik7XG4gIGNvbnN0IGNoZWNrID0gISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IChqb2IpID0+IGNoZWNrUmVjdXJzaXZlVXBkYXRlcyhzZWVuLCBqb2IpIDogTk9PUDtcbiAgdHJ5IHtcbiAgICBmb3IgKGZsdXNoSW5kZXggPSAwOyBmbHVzaEluZGV4IDwgcXVldWUubGVuZ3RoOyBmbHVzaEluZGV4KyspIHtcbiAgICAgIGNvbnN0IGpvYiA9IHF1ZXVlW2ZsdXNoSW5kZXhdO1xuICAgICAgaWYgKGpvYiAmJiBqb2IuYWN0aXZlICE9PSBmYWxzZSkge1xuICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBjaGVjayhqb2IpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY2FsbFdpdGhFcnJvckhhbmRsaW5nKGpvYiwgbnVsbCwgMTQpO1xuICAgICAgfVxuICAgIH1cbiAgfSBmaW5hbGx5IHtcbiAgICBmbHVzaEluZGV4ID0gMDtcbiAgICBxdWV1ZS5sZW5ndGggPSAwO1xuICAgIGZsdXNoUG9zdEZsdXNoQ2JzKHNlZW4pO1xuICAgIGlzRmx1c2hpbmcgPSBmYWxzZTtcbiAgICBjdXJyZW50Rmx1c2hQcm9taXNlID0gbnVsbDtcbiAgICBpZiAocXVldWUubGVuZ3RoIHx8IHBlbmRpbmdQb3N0Rmx1c2hDYnMubGVuZ3RoKSB7XG4gICAgICBmbHVzaEpvYnMoc2Vlbik7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBjaGVja1JlY3Vyc2l2ZVVwZGF0ZXMoc2VlbiwgZm4pIHtcbiAgaWYgKCFzZWVuLmhhcyhmbikpIHtcbiAgICBzZWVuLnNldChmbiwgMSk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgY291bnQgPSBzZWVuLmdldChmbik7XG4gICAgaWYgKGNvdW50ID4gUkVDVVJTSU9OX0xJTUlUKSB7XG4gICAgICBjb25zdCBpbnN0YW5jZSA9IGZuLm93bmVySW5zdGFuY2U7XG4gICAgICBjb25zdCBjb21wb25lbnROYW1lID0gaW5zdGFuY2UgJiYgZ2V0Q29tcG9uZW50TmFtZShpbnN0YW5jZS50eXBlKTtcbiAgICAgIHdhcm4oXG4gICAgICAgIGBNYXhpbXVtIHJlY3Vyc2l2ZSB1cGRhdGVzIGV4Y2VlZGVkJHtjb21wb25lbnROYW1lID8gYCBpbiBjb21wb25lbnQgPCR7Y29tcG9uZW50TmFtZX0+YCA6IGBgfS4gVGhpcyBtZWFucyB5b3UgaGF2ZSBhIHJlYWN0aXZlIGVmZmVjdCB0aGF0IGlzIG11dGF0aW5nIGl0cyBvd24gZGVwZW5kZW5jaWVzIGFuZCB0aHVzIHJlY3Vyc2l2ZWx5IHRyaWdnZXJpbmcgaXRzZWxmLiBQb3NzaWJsZSBzb3VyY2VzIGluY2x1ZGUgY29tcG9uZW50IHRlbXBsYXRlLCByZW5kZXIgZnVuY3Rpb24sIHVwZGF0ZWQgaG9vayBvciB3YXRjaGVyIHNvdXJjZSBmdW5jdGlvbi5gXG4gICAgICApO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNlZW4uc2V0KGZuLCBjb3VudCArIDEpO1xuICAgIH1cbiAgfVxufVxuXG5sZXQgaXNIbXJVcGRhdGluZyA9IGZhbHNlO1xuY29uc3QgaG1yRGlydHlDb21wb25lbnRzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbmlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gIGdldEdsb2JhbFRoaXMoKS5fX1ZVRV9ITVJfUlVOVElNRV9fID0ge1xuICAgIGNyZWF0ZVJlY29yZDogdHJ5V3JhcChjcmVhdGVSZWNvcmQpLFxuICAgIHJlcmVuZGVyOiB0cnlXcmFwKHJlcmVuZGVyKSxcbiAgICByZWxvYWQ6IHRyeVdyYXAocmVsb2FkKVxuICB9O1xufVxuY29uc3QgbWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbmZ1bmN0aW9uIHJlZ2lzdGVySE1SKGluc3RhbmNlKSB7XG4gIGNvbnN0IGlkID0gaW5zdGFuY2UudHlwZS5fX2htcklkO1xuICBsZXQgcmVjb3JkID0gbWFwLmdldChpZCk7XG4gIGlmICghcmVjb3JkKSB7XG4gICAgY3JlYXRlUmVjb3JkKGlkLCBpbnN0YW5jZS50eXBlKTtcbiAgICByZWNvcmQgPSBtYXAuZ2V0KGlkKTtcbiAgfVxuICByZWNvcmQuaW5zdGFuY2VzLmFkZChpbnN0YW5jZSk7XG59XG5mdW5jdGlvbiB1bnJlZ2lzdGVySE1SKGluc3RhbmNlKSB7XG4gIG1hcC5nZXQoaW5zdGFuY2UudHlwZS5fX2htcklkKS5pbnN0YW5jZXMuZGVsZXRlKGluc3RhbmNlKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVJlY29yZChpZCwgaW5pdGlhbERlZikge1xuICBpZiAobWFwLmhhcyhpZCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgbWFwLnNldChpZCwge1xuICAgIGluaXRpYWxEZWY6IG5vcm1hbGl6ZUNsYXNzQ29tcG9uZW50KGluaXRpYWxEZWYpLFxuICAgIGluc3RhbmNlczogLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKVxuICB9KTtcbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBub3JtYWxpemVDbGFzc0NvbXBvbmVudChjb21wb25lbnQpIHtcbiAgcmV0dXJuIGlzQ2xhc3NDb21wb25lbnQoY29tcG9uZW50KSA/IGNvbXBvbmVudC5fX3ZjY09wdHMgOiBjb21wb25lbnQ7XG59XG5mdW5jdGlvbiByZXJlbmRlcihpZCwgbmV3UmVuZGVyKSB7XG4gIGNvbnN0IHJlY29yZCA9IG1hcC5nZXQoaWQpO1xuICBpZiAoIXJlY29yZCkge1xuICAgIHJldHVybjtcbiAgfVxuICByZWNvcmQuaW5pdGlhbERlZi5yZW5kZXIgPSBuZXdSZW5kZXI7XG4gIFsuLi5yZWNvcmQuaW5zdGFuY2VzXS5mb3JFYWNoKChpbnN0YW5jZSkgPT4ge1xuICAgIGlmIChuZXdSZW5kZXIpIHtcbiAgICAgIGluc3RhbmNlLnJlbmRlciA9IG5ld1JlbmRlcjtcbiAgICAgIG5vcm1hbGl6ZUNsYXNzQ29tcG9uZW50KGluc3RhbmNlLnR5cGUpLnJlbmRlciA9IG5ld1JlbmRlcjtcbiAgICB9XG4gICAgaW5zdGFuY2UucmVuZGVyQ2FjaGUgPSBbXTtcbiAgICBpc0htclVwZGF0aW5nID0gdHJ1ZTtcbiAgICBpbnN0YW5jZS51cGRhdGUoKTtcbiAgICBpc0htclVwZGF0aW5nID0gZmFsc2U7XG4gIH0pO1xufVxuZnVuY3Rpb24gcmVsb2FkKGlkLCBuZXdDb21wKSB7XG4gIGNvbnN0IHJlY29yZCA9IG1hcC5nZXQoaWQpO1xuICBpZiAoIXJlY29yZClcbiAgICByZXR1cm47XG4gIG5ld0NvbXAgPSBub3JtYWxpemVDbGFzc0NvbXBvbmVudChuZXdDb21wKTtcbiAgdXBkYXRlQ29tcG9uZW50RGVmKHJlY29yZC5pbml0aWFsRGVmLCBuZXdDb21wKTtcbiAgY29uc3QgaW5zdGFuY2VzID0gWy4uLnJlY29yZC5pbnN0YW5jZXNdO1xuICBmb3IgKGNvbnN0IGluc3RhbmNlIG9mIGluc3RhbmNlcykge1xuICAgIGNvbnN0IG9sZENvbXAgPSBub3JtYWxpemVDbGFzc0NvbXBvbmVudChpbnN0YW5jZS50eXBlKTtcbiAgICBpZiAoIWhtckRpcnR5Q29tcG9uZW50cy5oYXMob2xkQ29tcCkpIHtcbiAgICAgIGlmIChvbGRDb21wICE9PSByZWNvcmQuaW5pdGlhbERlZikge1xuICAgICAgICB1cGRhdGVDb21wb25lbnREZWYob2xkQ29tcCwgbmV3Q29tcCk7XG4gICAgICB9XG4gICAgICBobXJEaXJ0eUNvbXBvbmVudHMuYWRkKG9sZENvbXApO1xuICAgIH1cbiAgICBpbnN0YW5jZS5hcHBDb250ZXh0LnByb3BzQ2FjaGUuZGVsZXRlKGluc3RhbmNlLnR5cGUpO1xuICAgIGluc3RhbmNlLmFwcENvbnRleHQuZW1pdHNDYWNoZS5kZWxldGUoaW5zdGFuY2UudHlwZSk7XG4gICAgaW5zdGFuY2UuYXBwQ29udGV4dC5vcHRpb25zQ2FjaGUuZGVsZXRlKGluc3RhbmNlLnR5cGUpO1xuICAgIGlmIChpbnN0YW5jZS5jZVJlbG9hZCkge1xuICAgICAgaG1yRGlydHlDb21wb25lbnRzLmFkZChvbGRDb21wKTtcbiAgICAgIGluc3RhbmNlLmNlUmVsb2FkKG5ld0NvbXAuc3R5bGVzKTtcbiAgICAgIGhtckRpcnR5Q29tcG9uZW50cy5kZWxldGUob2xkQ29tcCk7XG4gICAgfSBlbHNlIGlmIChpbnN0YW5jZS5wYXJlbnQpIHtcbiAgICAgIHF1ZXVlSm9iKGluc3RhbmNlLnBhcmVudC51cGRhdGUpO1xuICAgIH0gZWxzZSBpZiAoaW5zdGFuY2UuYXBwQ29udGV4dC5yZWxvYWQpIHtcbiAgICAgIGluc3RhbmNlLmFwcENvbnRleHQucmVsb2FkKCk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICB3aW5kb3cubG9jYXRpb24ucmVsb2FkKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgXCJbSE1SXSBSb290IG9yIG1hbnVhbGx5IG1vdW50ZWQgaW5zdGFuY2UgbW9kaWZpZWQuIEZ1bGwgcmVsb2FkIHJlcXVpcmVkLlwiXG4gICAgICApO1xuICAgIH1cbiAgfVxuICBxdWV1ZVBvc3RGbHVzaENiKCgpID0+IHtcbiAgICBmb3IgKGNvbnN0IGluc3RhbmNlIG9mIGluc3RhbmNlcykge1xuICAgICAgaG1yRGlydHlDb21wb25lbnRzLmRlbGV0ZShcbiAgICAgICAgbm9ybWFsaXplQ2xhc3NDb21wb25lbnQoaW5zdGFuY2UudHlwZSlcbiAgICAgICk7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZUNvbXBvbmVudERlZihvbGRDb21wLCBuZXdDb21wKSB7XG4gIGV4dGVuZChvbGRDb21wLCBuZXdDb21wKTtcbiAgZm9yIChjb25zdCBrZXkgaW4gb2xkQ29tcCkge1xuICAgIGlmIChrZXkgIT09IFwiX19maWxlXCIgJiYgIShrZXkgaW4gbmV3Q29tcCkpIHtcbiAgICAgIGRlbGV0ZSBvbGRDb21wW2tleV07XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiB0cnlXcmFwKGZuKSB7XG4gIHJldHVybiAoaWQsIGFyZykgPT4ge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZm4oaWQsIGFyZyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29uc29sZS5lcnJvcihlKTtcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgYFtITVJdIFNvbWV0aGluZyB3ZW50IHdyb25nIGR1cmluZyBWdWUgY29tcG9uZW50IGhvdC1yZWxvYWQuIEZ1bGwgcmVsb2FkIHJlcXVpcmVkLmBcbiAgICAgICk7XG4gICAgfVxuICB9O1xufVxuXG5sZXQgZGV2dG9vbHM7XG5sZXQgYnVmZmVyID0gW107XG5sZXQgZGV2dG9vbHNOb3RJbnN0YWxsZWQgPSBmYWxzZTtcbmZ1bmN0aW9uIGVtaXQkMShldmVudCwgLi4uYXJncykge1xuICBpZiAoZGV2dG9vbHMpIHtcbiAgICBkZXZ0b29scy5lbWl0KGV2ZW50LCAuLi5hcmdzKTtcbiAgfSBlbHNlIGlmICghZGV2dG9vbHNOb3RJbnN0YWxsZWQpIHtcbiAgICBidWZmZXIucHVzaCh7IGV2ZW50LCBhcmdzIH0pO1xuICB9XG59XG5mdW5jdGlvbiBzZXREZXZ0b29sc0hvb2soaG9vaywgdGFyZ2V0KSB7XG4gIHZhciBfYSwgX2I7XG4gIGRldnRvb2xzID0gaG9vaztcbiAgaWYgKGRldnRvb2xzKSB7XG4gICAgZGV2dG9vbHMuZW5hYmxlZCA9IHRydWU7XG4gICAgYnVmZmVyLmZvckVhY2goKHsgZXZlbnQsIGFyZ3MgfSkgPT4gZGV2dG9vbHMuZW1pdChldmVudCwgLi4uYXJncykpO1xuICAgIGJ1ZmZlciA9IFtdO1xuICB9IGVsc2UgaWYgKFxuICAgIC8vIGhhbmRsZSBsYXRlIGRldnRvb2xzIGluamVjdGlvbiAtIG9ubHkgZG8gdGhpcyBpZiB3ZSBhcmUgaW4gYW4gYWN0dWFsXG4gICAgLy8gYnJvd3NlciBlbnZpcm9ubWVudCB0byBhdm9pZCB0aGUgdGltZXIgaGFuZGxlIHN0YWxsaW5nIHRlc3QgcnVubmVyIGV4aXRcbiAgICAvLyAoIzQ4MTUpXG4gICAgdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiAvLyBzb21lIGVudnMgbW9jayB3aW5kb3cgYnV0IG5vdCBmdWxseVxuICAgIHdpbmRvdy5IVE1MRWxlbWVudCAmJiAvLyBhbHNvIGV4Y2x1ZGUganNkb21cbiAgICAhKChfYiA9IChfYSA9IHdpbmRvdy5uYXZpZ2F0b3IpID09IG51bGwgPyB2b2lkIDAgOiBfYS51c2VyQWdlbnQpID09IG51bGwgPyB2b2lkIDAgOiBfYi5pbmNsdWRlcyhcImpzZG9tXCIpKVxuICApIHtcbiAgICBjb25zdCByZXBsYXkgPSB0YXJnZXQuX19WVUVfREVWVE9PTFNfSE9PS19SRVBMQVlfXyA9IHRhcmdldC5fX1ZVRV9ERVZUT09MU19IT09LX1JFUExBWV9fIHx8IFtdO1xuICAgIHJlcGxheS5wdXNoKChuZXdIb29rKSA9PiB7XG4gICAgICBzZXREZXZ0b29sc0hvb2sobmV3SG9vaywgdGFyZ2V0KTtcbiAgICB9KTtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGlmICghZGV2dG9vbHMpIHtcbiAgICAgICAgdGFyZ2V0Ll9fVlVFX0RFVlRPT0xTX0hPT0tfUkVQTEFZX18gPSBudWxsO1xuICAgICAgICBkZXZ0b29sc05vdEluc3RhbGxlZCA9IHRydWU7XG4gICAgICAgIGJ1ZmZlciA9IFtdO1xuICAgICAgfVxuICAgIH0sIDNlMyk7XG4gIH0gZWxzZSB7XG4gICAgZGV2dG9vbHNOb3RJbnN0YWxsZWQgPSB0cnVlO1xuICAgIGJ1ZmZlciA9IFtdO1xuICB9XG59XG5mdW5jdGlvbiBkZXZ0b29sc0luaXRBcHAoYXBwLCB2ZXJzaW9uKSB7XG4gIGVtaXQkMShcImFwcDppbml0XCIgLyogQVBQX0lOSVQgKi8sIGFwcCwgdmVyc2lvbiwge1xuICAgIEZyYWdtZW50LFxuICAgIFRleHQsXG4gICAgQ29tbWVudCxcbiAgICBTdGF0aWNcbiAgfSk7XG59XG5mdW5jdGlvbiBkZXZ0b29sc1VubW91bnRBcHAoYXBwKSB7XG4gIGVtaXQkMShcImFwcDp1bm1vdW50XCIgLyogQVBQX1VOTU9VTlQgKi8sIGFwcCk7XG59XG5jb25zdCBkZXZ0b29sc0NvbXBvbmVudEFkZGVkID0gLyogQF9fUFVSRV9fICovIGNyZWF0ZURldnRvb2xzQ29tcG9uZW50SG9vayhcbiAgXCJjb21wb25lbnQ6YWRkZWRcIiAvKiBDT01QT05FTlRfQURERUQgKi9cbik7XG5jb25zdCBkZXZ0b29sc0NvbXBvbmVudFVwZGF0ZWQgPSAvKiBAX19QVVJFX18gKi8gY3JlYXRlRGV2dG9vbHNDb21wb25lbnRIb29rKFwiY29tcG9uZW50OnVwZGF0ZWRcIiAvKiBDT01QT05FTlRfVVBEQVRFRCAqLyk7XG5jb25zdCBfZGV2dG9vbHNDb21wb25lbnRSZW1vdmVkID0gLyogQF9fUFVSRV9fICovIGNyZWF0ZURldnRvb2xzQ29tcG9uZW50SG9vayhcbiAgXCJjb21wb25lbnQ6cmVtb3ZlZFwiIC8qIENPTVBPTkVOVF9SRU1PVkVEICovXG4pO1xuY29uc3QgZGV2dG9vbHNDb21wb25lbnRSZW1vdmVkID0gKGNvbXBvbmVudCkgPT4ge1xuICBpZiAoZGV2dG9vbHMgJiYgdHlwZW9mIGRldnRvb2xzLmNsZWFudXBCdWZmZXIgPT09IFwiZnVuY3Rpb25cIiAmJiAvLyByZW1vdmUgdGhlIGNvbXBvbmVudCBpZiBpdCB3YXNuJ3QgYnVmZmVyZWRcbiAgIWRldnRvb2xzLmNsZWFudXBCdWZmZXIoY29tcG9uZW50KSkge1xuICAgIF9kZXZ0b29sc0NvbXBvbmVudFJlbW92ZWQoY29tcG9uZW50KTtcbiAgfVxufTtcbmZ1bmN0aW9uIGNyZWF0ZURldnRvb2xzQ29tcG9uZW50SG9vayhob29rKSB7XG4gIHJldHVybiAoY29tcG9uZW50KSA9PiB7XG4gICAgZW1pdCQxKFxuICAgICAgaG9vayxcbiAgICAgIGNvbXBvbmVudC5hcHBDb250ZXh0LmFwcCxcbiAgICAgIGNvbXBvbmVudC51aWQsXG4gICAgICBjb21wb25lbnQucGFyZW50ID8gY29tcG9uZW50LnBhcmVudC51aWQgOiB2b2lkIDAsXG4gICAgICBjb21wb25lbnRcbiAgICApO1xuICB9O1xufVxuY29uc3QgZGV2dG9vbHNQZXJmU3RhcnQgPSAvKiBAX19QVVJFX18gKi8gY3JlYXRlRGV2dG9vbHNQZXJmb3JtYW5jZUhvb2soXG4gIFwicGVyZjpzdGFydFwiIC8qIFBFUkZPUk1BTkNFX1NUQVJUICovXG4pO1xuY29uc3QgZGV2dG9vbHNQZXJmRW5kID0gLyogQF9fUFVSRV9fICovIGNyZWF0ZURldnRvb2xzUGVyZm9ybWFuY2VIb29rKFxuICBcInBlcmY6ZW5kXCIgLyogUEVSRk9STUFOQ0VfRU5EICovXG4pO1xuZnVuY3Rpb24gY3JlYXRlRGV2dG9vbHNQZXJmb3JtYW5jZUhvb2soaG9vaykge1xuICByZXR1cm4gKGNvbXBvbmVudCwgdHlwZSwgdGltZSkgPT4ge1xuICAgIGVtaXQkMShob29rLCBjb21wb25lbnQuYXBwQ29udGV4dC5hcHAsIGNvbXBvbmVudC51aWQsIGNvbXBvbmVudCwgdHlwZSwgdGltZSk7XG4gIH07XG59XG5mdW5jdGlvbiBkZXZ0b29sc0NvbXBvbmVudEVtaXQoY29tcG9uZW50LCBldmVudCwgcGFyYW1zKSB7XG4gIGVtaXQkMShcbiAgICBcImNvbXBvbmVudDplbWl0XCIgLyogQ09NUE9ORU5UX0VNSVQgKi8sXG4gICAgY29tcG9uZW50LmFwcENvbnRleHQuYXBwLFxuICAgIGNvbXBvbmVudCxcbiAgICBldmVudCxcbiAgICBwYXJhbXNcbiAgKTtcbn1cblxuZnVuY3Rpb24gZW1pdChpbnN0YW5jZSwgZXZlbnQsIC4uLnJhd0FyZ3MpIHtcbiAgaWYgKGluc3RhbmNlLmlzVW5tb3VudGVkKVxuICAgIHJldHVybjtcbiAgY29uc3QgcHJvcHMgPSBpbnN0YW5jZS52bm9kZS5wcm9wcyB8fCBFTVBUWV9PQko7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgY29uc3Qge1xuICAgICAgZW1pdHNPcHRpb25zLFxuICAgICAgcHJvcHNPcHRpb25zOiBbcHJvcHNPcHRpb25zXVxuICAgIH0gPSBpbnN0YW5jZTtcbiAgICBpZiAoZW1pdHNPcHRpb25zKSB7XG4gICAgICBpZiAoIShldmVudCBpbiBlbWl0c09wdGlvbnMpICYmIHRydWUpIHtcbiAgICAgICAgaWYgKCFwcm9wc09wdGlvbnMgfHwgISh0b0hhbmRsZXJLZXkoZXZlbnQpIGluIHByb3BzT3B0aW9ucykpIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgYENvbXBvbmVudCBlbWl0dGVkIGV2ZW50IFwiJHtldmVudH1cIiBidXQgaXQgaXMgbmVpdGhlciBkZWNsYXJlZCBpbiB0aGUgZW1pdHMgb3B0aW9uIG5vciBhcyBhbiBcIiR7dG9IYW5kbGVyS2V5KGV2ZW50KX1cIiBwcm9wLmBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCB2YWxpZGF0b3IgPSBlbWl0c09wdGlvbnNbZXZlbnRdO1xuICAgICAgICBpZiAoaXNGdW5jdGlvbih2YWxpZGF0b3IpKSB7XG4gICAgICAgICAgY29uc3QgaXNWYWxpZCA9IHZhbGlkYXRvciguLi5yYXdBcmdzKTtcbiAgICAgICAgICBpZiAoIWlzVmFsaWQpIHtcbiAgICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAgIGBJbnZhbGlkIGV2ZW50IGFyZ3VtZW50czogZXZlbnQgdmFsaWRhdGlvbiBmYWlsZWQgZm9yIGV2ZW50IFwiJHtldmVudH1cIi5gXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBsZXQgYXJncyA9IHJhd0FyZ3M7XG4gIGNvbnN0IGlzTW9kZWxMaXN0ZW5lciA9IGV2ZW50LnN0YXJ0c1dpdGgoXCJ1cGRhdGU6XCIpO1xuICBjb25zdCBtb2RlbEFyZyA9IGlzTW9kZWxMaXN0ZW5lciAmJiBldmVudC5zbGljZSg3KTtcbiAgaWYgKG1vZGVsQXJnICYmIG1vZGVsQXJnIGluIHByb3BzKSB7XG4gICAgY29uc3QgbW9kaWZpZXJzS2V5ID0gYCR7bW9kZWxBcmcgPT09IFwibW9kZWxWYWx1ZVwiID8gXCJtb2RlbFwiIDogbW9kZWxBcmd9TW9kaWZpZXJzYDtcbiAgICBjb25zdCB7IG51bWJlciwgdHJpbSB9ID0gcHJvcHNbbW9kaWZpZXJzS2V5XSB8fCBFTVBUWV9PQko7XG4gICAgaWYgKHRyaW0pIHtcbiAgICAgIGFyZ3MgPSByYXdBcmdzLm1hcCgoYSkgPT4gaXNTdHJpbmcoYSkgPyBhLnRyaW0oKSA6IGEpO1xuICAgIH1cbiAgICBpZiAobnVtYmVyKSB7XG4gICAgICBhcmdzID0gcmF3QXJncy5tYXAobG9vc2VUb051bWJlcik7XG4gICAgfVxuICB9XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykge1xuICAgIGRldnRvb2xzQ29tcG9uZW50RW1pdChpbnN0YW5jZSwgZXZlbnQsIGFyZ3MpO1xuICB9XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgY29uc3QgbG93ZXJDYXNlRXZlbnQgPSBldmVudC50b0xvd2VyQ2FzZSgpO1xuICAgIGlmIChsb3dlckNhc2VFdmVudCAhPT0gZXZlbnQgJiYgcHJvcHNbdG9IYW5kbGVyS2V5KGxvd2VyQ2FzZUV2ZW50KV0pIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIGBFdmVudCBcIiR7bG93ZXJDYXNlRXZlbnR9XCIgaXMgZW1pdHRlZCBpbiBjb21wb25lbnQgJHtmb3JtYXRDb21wb25lbnROYW1lKFxuICAgICAgICAgIGluc3RhbmNlLFxuICAgICAgICAgIGluc3RhbmNlLnR5cGVcbiAgICAgICAgKX0gYnV0IHRoZSBoYW5kbGVyIGlzIHJlZ2lzdGVyZWQgZm9yIFwiJHtldmVudH1cIi4gTm90ZSB0aGF0IEhUTUwgYXR0cmlidXRlcyBhcmUgY2FzZS1pbnNlbnNpdGl2ZSBhbmQgeW91IGNhbm5vdCB1c2Ugdi1vbiB0byBsaXN0ZW4gdG8gY2FtZWxDYXNlIGV2ZW50cyB3aGVuIHVzaW5nIGluLURPTSB0ZW1wbGF0ZXMuIFlvdSBzaG91bGQgcHJvYmFibHkgdXNlIFwiJHtoeXBoZW5hdGUoZXZlbnQpfVwiIGluc3RlYWQgb2YgXCIke2V2ZW50fVwiLmBcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIGxldCBoYW5kbGVyTmFtZTtcbiAgbGV0IGhhbmRsZXIgPSBwcm9wc1toYW5kbGVyTmFtZSA9IHRvSGFuZGxlcktleShldmVudCldIHx8IC8vIGFsc28gdHJ5IGNhbWVsQ2FzZSBldmVudCBoYW5kbGVyICgjMjI0OSlcbiAgcHJvcHNbaGFuZGxlck5hbWUgPSB0b0hhbmRsZXJLZXkoY2FtZWxpemUoZXZlbnQpKV07XG4gIGlmICghaGFuZGxlciAmJiBpc01vZGVsTGlzdGVuZXIpIHtcbiAgICBoYW5kbGVyID0gcHJvcHNbaGFuZGxlck5hbWUgPSB0b0hhbmRsZXJLZXkoaHlwaGVuYXRlKGV2ZW50KSldO1xuICB9XG4gIGlmIChoYW5kbGVyKSB7XG4gICAgY2FsbFdpdGhBc3luY0Vycm9ySGFuZGxpbmcoXG4gICAgICBoYW5kbGVyLFxuICAgICAgaW5zdGFuY2UsXG4gICAgICA2LFxuICAgICAgYXJnc1xuICAgICk7XG4gIH1cbiAgY29uc3Qgb25jZUhhbmRsZXIgPSBwcm9wc1toYW5kbGVyTmFtZSArIGBPbmNlYF07XG4gIGlmIChvbmNlSGFuZGxlcikge1xuICAgIGlmICghaW5zdGFuY2UuZW1pdHRlZCkge1xuICAgICAgaW5zdGFuY2UuZW1pdHRlZCA9IHt9O1xuICAgIH0gZWxzZSBpZiAoaW5zdGFuY2UuZW1pdHRlZFtoYW5kbGVyTmFtZV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaW5zdGFuY2UuZW1pdHRlZFtoYW5kbGVyTmFtZV0gPSB0cnVlO1xuICAgIGNhbGxXaXRoQXN5bmNFcnJvckhhbmRsaW5nKFxuICAgICAgb25jZUhhbmRsZXIsXG4gICAgICBpbnN0YW5jZSxcbiAgICAgIDYsXG4gICAgICBhcmdzXG4gICAgKTtcbiAgfVxufVxuZnVuY3Rpb24gbm9ybWFsaXplRW1pdHNPcHRpb25zKGNvbXAsIGFwcENvbnRleHQsIGFzTWl4aW4gPSBmYWxzZSkge1xuICBjb25zdCBjYWNoZSA9IGFwcENvbnRleHQuZW1pdHNDYWNoZTtcbiAgY29uc3QgY2FjaGVkID0gY2FjaGUuZ2V0KGNvbXApO1xuICBpZiAoY2FjaGVkICE9PSB2b2lkIDApIHtcbiAgICByZXR1cm4gY2FjaGVkO1xuICB9XG4gIGNvbnN0IHJhdyA9IGNvbXAuZW1pdHM7XG4gIGxldCBub3JtYWxpemVkID0ge307XG4gIGxldCBoYXNFeHRlbmRzID0gZmFsc2U7XG4gIGlmIChfX1ZVRV9PUFRJT05TX0FQSV9fICYmICFpc0Z1bmN0aW9uKGNvbXApKSB7XG4gICAgY29uc3QgZXh0ZW5kRW1pdHMgPSAocmF3MikgPT4ge1xuICAgICAgY29uc3Qgbm9ybWFsaXplZEZyb21FeHRlbmQgPSBub3JtYWxpemVFbWl0c09wdGlvbnMocmF3MiwgYXBwQ29udGV4dCwgdHJ1ZSk7XG4gICAgICBpZiAobm9ybWFsaXplZEZyb21FeHRlbmQpIHtcbiAgICAgICAgaGFzRXh0ZW5kcyA9IHRydWU7XG4gICAgICAgIGV4dGVuZChub3JtYWxpemVkLCBub3JtYWxpemVkRnJvbUV4dGVuZCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBpZiAoIWFzTWl4aW4gJiYgYXBwQ29udGV4dC5taXhpbnMubGVuZ3RoKSB7XG4gICAgICBhcHBDb250ZXh0Lm1peGlucy5mb3JFYWNoKGV4dGVuZEVtaXRzKTtcbiAgICB9XG4gICAgaWYgKGNvbXAuZXh0ZW5kcykge1xuICAgICAgZXh0ZW5kRW1pdHMoY29tcC5leHRlbmRzKTtcbiAgICB9XG4gICAgaWYgKGNvbXAubWl4aW5zKSB7XG4gICAgICBjb21wLm1peGlucy5mb3JFYWNoKGV4dGVuZEVtaXRzKTtcbiAgICB9XG4gIH1cbiAgaWYgKCFyYXcgJiYgIWhhc0V4dGVuZHMpIHtcbiAgICBpZiAoaXNPYmplY3QoY29tcCkpIHtcbiAgICAgIGNhY2hlLnNldChjb21wLCBudWxsKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKGlzQXJyYXkocmF3KSkge1xuICAgIHJhdy5mb3JFYWNoKChrZXkpID0+IG5vcm1hbGl6ZWRba2V5XSA9IG51bGwpO1xuICB9IGVsc2Uge1xuICAgIGV4dGVuZChub3JtYWxpemVkLCByYXcpO1xuICB9XG4gIGlmIChpc09iamVjdChjb21wKSkge1xuICAgIGNhY2hlLnNldChjb21wLCBub3JtYWxpemVkKTtcbiAgfVxuICByZXR1cm4gbm9ybWFsaXplZDtcbn1cbmZ1bmN0aW9uIGlzRW1pdExpc3RlbmVyKG9wdGlvbnMsIGtleSkge1xuICBpZiAoIW9wdGlvbnMgfHwgIWlzT24oa2V5KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBrZXkgPSBrZXkuc2xpY2UoMikucmVwbGFjZSgvT25jZSQvLCBcIlwiKTtcbiAgcmV0dXJuIGhhc093bihvcHRpb25zLCBrZXlbMF0udG9Mb3dlckNhc2UoKSArIGtleS5zbGljZSgxKSkgfHwgaGFzT3duKG9wdGlvbnMsIGh5cGhlbmF0ZShrZXkpKSB8fCBoYXNPd24ob3B0aW9ucywga2V5KTtcbn1cblxubGV0IGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSA9IG51bGw7XG5sZXQgY3VycmVudFNjb3BlSWQgPSBudWxsO1xuZnVuY3Rpb24gc2V0Q3VycmVudFJlbmRlcmluZ0luc3RhbmNlKGluc3RhbmNlKSB7XG4gIGNvbnN0IHByZXYgPSBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2U7XG4gIGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSA9IGluc3RhbmNlO1xuICBjdXJyZW50U2NvcGVJZCA9IGluc3RhbmNlICYmIGluc3RhbmNlLnR5cGUuX19zY29wZUlkIHx8IG51bGw7XG4gIHJldHVybiBwcmV2O1xufVxuZnVuY3Rpb24gcHVzaFNjb3BlSWQoaWQpIHtcbiAgY3VycmVudFNjb3BlSWQgPSBpZDtcbn1cbmZ1bmN0aW9uIHBvcFNjb3BlSWQoKSB7XG4gIGN1cnJlbnRTY29wZUlkID0gbnVsbDtcbn1cbmNvbnN0IHdpdGhTY29wZUlkID0gKF9pZCkgPT4gd2l0aEN0eDtcbmZ1bmN0aW9uIHdpdGhDdHgoZm4sIGN0eCA9IGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSwgaXNOb25TY29wZWRTbG90KSB7XG4gIGlmICghY3R4KVxuICAgIHJldHVybiBmbjtcbiAgaWYgKGZuLl9uKSB7XG4gICAgcmV0dXJuIGZuO1xuICB9XG4gIGNvbnN0IHJlbmRlckZuV2l0aENvbnRleHQgPSAoLi4uYXJncykgPT4ge1xuICAgIGlmIChyZW5kZXJGbldpdGhDb250ZXh0Ll9kKSB7XG4gICAgICBzZXRCbG9ja1RyYWNraW5nKC0xKTtcbiAgICB9XG4gICAgY29uc3QgcHJldkluc3RhbmNlID0gc2V0Q3VycmVudFJlbmRlcmluZ0luc3RhbmNlKGN0eCk7XG4gICAgbGV0IHJlcztcbiAgICB0cnkge1xuICAgICAgcmVzID0gZm4oLi4uYXJncyk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHNldEN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZShwcmV2SW5zdGFuY2UpO1xuICAgICAgaWYgKHJlbmRlckZuV2l0aENvbnRleHQuX2QpIHtcbiAgICAgICAgc2V0QmxvY2tUcmFja2luZygxKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XG4gICAgICBkZXZ0b29sc0NvbXBvbmVudFVwZGF0ZWQoY3R4KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbiAgfTtcbiAgcmVuZGVyRm5XaXRoQ29udGV4dC5fbiA9IHRydWU7XG4gIHJlbmRlckZuV2l0aENvbnRleHQuX2MgPSB0cnVlO1xuICByZW5kZXJGbldpdGhDb250ZXh0Ll9kID0gdHJ1ZTtcbiAgcmV0dXJuIHJlbmRlckZuV2l0aENvbnRleHQ7XG59XG5cbmxldCBhY2Nlc3NlZEF0dHJzID0gZmFsc2U7XG5mdW5jdGlvbiBtYXJrQXR0cnNBY2Nlc3NlZCgpIHtcbiAgYWNjZXNzZWRBdHRycyA9IHRydWU7XG59XG5mdW5jdGlvbiByZW5kZXJDb21wb25lbnRSb290KGluc3RhbmNlKSB7XG4gIGNvbnN0IHtcbiAgICB0eXBlOiBDb21wb25lbnQsXG4gICAgdm5vZGUsXG4gICAgcHJveHksXG4gICAgd2l0aFByb3h5LFxuICAgIHByb3BzLFxuICAgIHByb3BzT3B0aW9uczogW3Byb3BzT3B0aW9uc10sXG4gICAgc2xvdHMsXG4gICAgYXR0cnMsXG4gICAgZW1pdCxcbiAgICByZW5kZXIsXG4gICAgcmVuZGVyQ2FjaGUsXG4gICAgZGF0YSxcbiAgICBzZXR1cFN0YXRlLFxuICAgIGN0eCxcbiAgICBpbmhlcml0QXR0cnNcbiAgfSA9IGluc3RhbmNlO1xuICBsZXQgcmVzdWx0O1xuICBsZXQgZmFsbHRocm91Z2hBdHRycztcbiAgY29uc3QgcHJldiA9IHNldEN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZShpbnN0YW5jZSk7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgYWNjZXNzZWRBdHRycyA9IGZhbHNlO1xuICB9XG4gIHRyeSB7XG4gICAgaWYgKHZub2RlLnNoYXBlRmxhZyAmIDQpIHtcbiAgICAgIGNvbnN0IHByb3h5VG9Vc2UgPSB3aXRoUHJveHkgfHwgcHJveHk7XG4gICAgICByZXN1bHQgPSBub3JtYWxpemVWTm9kZShcbiAgICAgICAgcmVuZGVyLmNhbGwoXG4gICAgICAgICAgcHJveHlUb1VzZSxcbiAgICAgICAgICBwcm94eVRvVXNlLFxuICAgICAgICAgIHJlbmRlckNhY2hlLFxuICAgICAgICAgIHByb3BzLFxuICAgICAgICAgIHNldHVwU3RhdGUsXG4gICAgICAgICAgZGF0YSxcbiAgICAgICAgICBjdHhcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICAgIGZhbGx0aHJvdWdoQXR0cnMgPSBhdHRycztcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgcmVuZGVyMiA9IENvbXBvbmVudDtcbiAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGF0dHJzID09PSBwcm9wcykge1xuICAgICAgICBtYXJrQXR0cnNBY2Nlc3NlZCgpO1xuICAgICAgfVxuICAgICAgcmVzdWx0ID0gbm9ybWFsaXplVk5vZGUoXG4gICAgICAgIHJlbmRlcjIubGVuZ3RoID4gMSA/IHJlbmRlcjIoXG4gICAgICAgICAgcHJvcHMsXG4gICAgICAgICAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IHtcbiAgICAgICAgICAgIGdldCBhdHRycygpIHtcbiAgICAgICAgICAgICAgbWFya0F0dHJzQWNjZXNzZWQoKTtcbiAgICAgICAgICAgICAgcmV0dXJuIGF0dHJzO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNsb3RzLFxuICAgICAgICAgICAgZW1pdFxuICAgICAgICAgIH0gOiB7IGF0dHJzLCBzbG90cywgZW1pdCB9XG4gICAgICAgICkgOiByZW5kZXIyKFxuICAgICAgICAgIHByb3BzLFxuICAgICAgICAgIG51bGxcbiAgICAgICAgICAvKiB3ZSBrbm93IGl0IGRvZXNuJ3QgbmVlZCBpdCAqL1xuICAgICAgICApXG4gICAgICApO1xuICAgICAgZmFsbHRocm91Z2hBdHRycyA9IENvbXBvbmVudC5wcm9wcyA/IGF0dHJzIDogZ2V0RnVuY3Rpb25hbEZhbGx0aHJvdWdoKGF0dHJzKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGJsb2NrU3RhY2subGVuZ3RoID0gMDtcbiAgICBoYW5kbGVFcnJvcihlcnIsIGluc3RhbmNlLCAxKTtcbiAgICByZXN1bHQgPSBjcmVhdGVWTm9kZShDb21tZW50KTtcbiAgfVxuICBsZXQgcm9vdCA9IHJlc3VsdDtcbiAgbGV0IHNldFJvb3QgPSB2b2lkIDA7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHJlc3VsdC5wYXRjaEZsYWcgPiAwICYmIHJlc3VsdC5wYXRjaEZsYWcgJiAyMDQ4KSB7XG4gICAgW3Jvb3QsIHNldFJvb3RdID0gZ2V0Q2hpbGRSb290KHJlc3VsdCk7XG4gIH1cbiAgaWYgKGZhbGx0aHJvdWdoQXR0cnMgJiYgaW5oZXJpdEF0dHJzICE9PSBmYWxzZSkge1xuICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhmYWxsdGhyb3VnaEF0dHJzKTtcbiAgICBjb25zdCB7IHNoYXBlRmxhZyB9ID0gcm9vdDtcbiAgICBpZiAoa2V5cy5sZW5ndGgpIHtcbiAgICAgIGlmIChzaGFwZUZsYWcgJiAoMSB8IDYpKSB7XG4gICAgICAgIGlmIChwcm9wc09wdGlvbnMgJiYga2V5cy5zb21lKGlzTW9kZWxMaXN0ZW5lcikpIHtcbiAgICAgICAgICBmYWxsdGhyb3VnaEF0dHJzID0gZmlsdGVyTW9kZWxMaXN0ZW5lcnMoXG4gICAgICAgICAgICBmYWxsdGhyb3VnaEF0dHJzLFxuICAgICAgICAgICAgcHJvcHNPcHRpb25zXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICByb290ID0gY2xvbmVWTm9kZShyb290LCBmYWxsdGhyb3VnaEF0dHJzKTtcbiAgICAgIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhYWNjZXNzZWRBdHRycyAmJiByb290LnR5cGUgIT09IENvbW1lbnQpIHtcbiAgICAgICAgY29uc3QgYWxsQXR0cnMgPSBPYmplY3Qua2V5cyhhdHRycyk7XG4gICAgICAgIGNvbnN0IGV2ZW50QXR0cnMgPSBbXTtcbiAgICAgICAgY29uc3QgZXh0cmFBdHRycyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgbCA9IGFsbEF0dHJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIGNvbnN0IGtleSA9IGFsbEF0dHJzW2ldO1xuICAgICAgICAgIGlmIChpc09uKGtleSkpIHtcbiAgICAgICAgICAgIGlmICghaXNNb2RlbExpc3RlbmVyKGtleSkpIHtcbiAgICAgICAgICAgICAgZXZlbnRBdHRycy5wdXNoKGtleVsyXS50b0xvd2VyQ2FzZSgpICsga2V5LnNsaWNlKDMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXh0cmFBdHRycy5wdXNoKGtleSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChleHRyYUF0dHJzLmxlbmd0aCkge1xuICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICBgRXh0cmFuZW91cyBub24tcHJvcHMgYXR0cmlidXRlcyAoJHtleHRyYUF0dHJzLmpvaW4oXCIsIFwiKX0pIHdlcmUgcGFzc2VkIHRvIGNvbXBvbmVudCBidXQgY291bGQgbm90IGJlIGF1dG9tYXRpY2FsbHkgaW5oZXJpdGVkIGJlY2F1c2UgY29tcG9uZW50IHJlbmRlcnMgZnJhZ21lbnQgb3IgdGV4dCByb290IG5vZGVzLmBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChldmVudEF0dHJzLmxlbmd0aCkge1xuICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICBgRXh0cmFuZW91cyBub24tZW1pdHMgZXZlbnQgbGlzdGVuZXJzICgke2V2ZW50QXR0cnMuam9pbihcIiwgXCIpfSkgd2VyZSBwYXNzZWQgdG8gY29tcG9uZW50IGJ1dCBjb3VsZCBub3QgYmUgYXV0b21hdGljYWxseSBpbmhlcml0ZWQgYmVjYXVzZSBjb21wb25lbnQgcmVuZGVycyBmcmFnbWVudCBvciB0ZXh0IHJvb3Qgbm9kZXMuIElmIHRoZSBsaXN0ZW5lciBpcyBpbnRlbmRlZCB0byBiZSBhIGNvbXBvbmVudCBjdXN0b20gZXZlbnQgbGlzdGVuZXIgb25seSwgZGVjbGFyZSBpdCB1c2luZyB0aGUgXCJlbWl0c1wiIG9wdGlvbi5gXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAodm5vZGUuZGlycykge1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICFpc0VsZW1lbnRSb290KHJvb3QpKSB7XG4gICAgICB3YXJuKFxuICAgICAgICBgUnVudGltZSBkaXJlY3RpdmUgdXNlZCBvbiBjb21wb25lbnQgd2l0aCBub24tZWxlbWVudCByb290IG5vZGUuIFRoZSBkaXJlY3RpdmVzIHdpbGwgbm90IGZ1bmN0aW9uIGFzIGludGVuZGVkLmBcbiAgICAgICk7XG4gICAgfVxuICAgIHJvb3QgPSBjbG9uZVZOb2RlKHJvb3QpO1xuICAgIHJvb3QuZGlycyA9IHJvb3QuZGlycyA/IHJvb3QuZGlycy5jb25jYXQodm5vZGUuZGlycykgOiB2bm9kZS5kaXJzO1xuICB9XG4gIGlmICh2bm9kZS50cmFuc2l0aW9uKSB7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgIWlzRWxlbWVudFJvb3Qocm9vdCkpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIGBDb21wb25lbnQgaW5zaWRlIDxUcmFuc2l0aW9uPiByZW5kZXJzIG5vbi1lbGVtZW50IHJvb3Qgbm9kZSB0aGF0IGNhbm5vdCBiZSBhbmltYXRlZC5gXG4gICAgICApO1xuICAgIH1cbiAgICByb290LnRyYW5zaXRpb24gPSB2bm9kZS50cmFuc2l0aW9uO1xuICB9XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHNldFJvb3QpIHtcbiAgICBzZXRSb290KHJvb3QpO1xuICB9IGVsc2Uge1xuICAgIHJlc3VsdCA9IHJvb3Q7XG4gIH1cbiAgc2V0Q3VycmVudFJlbmRlcmluZ0luc3RhbmNlKHByZXYpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuY29uc3QgZ2V0Q2hpbGRSb290ID0gKHZub2RlKSA9PiB7XG4gIGNvbnN0IHJhd0NoaWxkcmVuID0gdm5vZGUuY2hpbGRyZW47XG4gIGNvbnN0IGR5bmFtaWNDaGlsZHJlbiA9IHZub2RlLmR5bmFtaWNDaGlsZHJlbjtcbiAgY29uc3QgY2hpbGRSb290ID0gZmlsdGVyU2luZ2xlUm9vdChyYXdDaGlsZHJlbik7XG4gIGlmICghY2hpbGRSb290KSB7XG4gICAgcmV0dXJuIFt2bm9kZSwgdm9pZCAwXTtcbiAgfVxuICBjb25zdCBpbmRleCA9IHJhd0NoaWxkcmVuLmluZGV4T2YoY2hpbGRSb290KTtcbiAgY29uc3QgZHluYW1pY0luZGV4ID0gZHluYW1pY0NoaWxkcmVuID8gZHluYW1pY0NoaWxkcmVuLmluZGV4T2YoY2hpbGRSb290KSA6IC0xO1xuICBjb25zdCBzZXRSb290ID0gKHVwZGF0ZWRSb290KSA9PiB7XG4gICAgcmF3Q2hpbGRyZW5baW5kZXhdID0gdXBkYXRlZFJvb3Q7XG4gICAgaWYgKGR5bmFtaWNDaGlsZHJlbikge1xuICAgICAgaWYgKGR5bmFtaWNJbmRleCA+IC0xKSB7XG4gICAgICAgIGR5bmFtaWNDaGlsZHJlbltkeW5hbWljSW5kZXhdID0gdXBkYXRlZFJvb3Q7XG4gICAgICB9IGVsc2UgaWYgKHVwZGF0ZWRSb290LnBhdGNoRmxhZyA+IDApIHtcbiAgICAgICAgdm5vZGUuZHluYW1pY0NoaWxkcmVuID0gWy4uLmR5bmFtaWNDaGlsZHJlbiwgdXBkYXRlZFJvb3RdO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgcmV0dXJuIFtub3JtYWxpemVWTm9kZShjaGlsZFJvb3QpLCBzZXRSb290XTtcbn07XG5mdW5jdGlvbiBmaWx0ZXJTaW5nbGVSb290KGNoaWxkcmVuKSB7XG4gIGxldCBzaW5nbGVSb290O1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICBpZiAoaXNWTm9kZShjaGlsZCkpIHtcbiAgICAgIGlmIChjaGlsZC50eXBlICE9PSBDb21tZW50IHx8IGNoaWxkLmNoaWxkcmVuID09PSBcInYtaWZcIikge1xuICAgICAgICBpZiAoc2luZ2xlUm9vdCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzaW5nbGVSb290ID0gY2hpbGQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc2luZ2xlUm9vdDtcbn1cbmNvbnN0IGdldEZ1bmN0aW9uYWxGYWxsdGhyb3VnaCA9IChhdHRycykgPT4ge1xuICBsZXQgcmVzO1xuICBmb3IgKGNvbnN0IGtleSBpbiBhdHRycykge1xuICAgIGlmIChrZXkgPT09IFwiY2xhc3NcIiB8fCBrZXkgPT09IFwic3R5bGVcIiB8fCBpc09uKGtleSkpIHtcbiAgICAgIChyZXMgfHwgKHJlcyA9IHt9KSlba2V5XSA9IGF0dHJzW2tleV07XG4gICAgfVxuICB9XG4gIHJldHVybiByZXM7XG59O1xuY29uc3QgZmlsdGVyTW9kZWxMaXN0ZW5lcnMgPSAoYXR0cnMsIHByb3BzKSA9PiB7XG4gIGNvbnN0IHJlcyA9IHt9O1xuICBmb3IgKGNvbnN0IGtleSBpbiBhdHRycykge1xuICAgIGlmICghaXNNb2RlbExpc3RlbmVyKGtleSkgfHwgIShrZXkuc2xpY2UoOSkgaW4gcHJvcHMpKSB7XG4gICAgICByZXNba2V5XSA9IGF0dHJzW2tleV07XG4gICAgfVxuICB9XG4gIHJldHVybiByZXM7XG59O1xuY29uc3QgaXNFbGVtZW50Um9vdCA9ICh2bm9kZSkgPT4ge1xuICByZXR1cm4gdm5vZGUuc2hhcGVGbGFnICYgKDYgfCAxKSB8fCB2bm9kZS50eXBlID09PSBDb21tZW50O1xufTtcbmZ1bmN0aW9uIHNob3VsZFVwZGF0ZUNvbXBvbmVudChwcmV2Vk5vZGUsIG5leHRWTm9kZSwgb3B0aW1pemVkKSB7XG4gIGNvbnN0IHsgcHJvcHM6IHByZXZQcm9wcywgY2hpbGRyZW46IHByZXZDaGlsZHJlbiwgY29tcG9uZW50IH0gPSBwcmV2Vk5vZGU7XG4gIGNvbnN0IHsgcHJvcHM6IG5leHRQcm9wcywgY2hpbGRyZW46IG5leHRDaGlsZHJlbiwgcGF0Y2hGbGFnIH0gPSBuZXh0Vk5vZGU7XG4gIGNvbnN0IGVtaXRzID0gY29tcG9uZW50LmVtaXRzT3B0aW9ucztcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgKHByZXZDaGlsZHJlbiB8fCBuZXh0Q2hpbGRyZW4pICYmIGlzSG1yVXBkYXRpbmcpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAobmV4dFZOb2RlLmRpcnMgfHwgbmV4dFZOb2RlLnRyYW5zaXRpb24pIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAob3B0aW1pemVkICYmIHBhdGNoRmxhZyA+PSAwKSB7XG4gICAgaWYgKHBhdGNoRmxhZyAmIDEwMjQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAocGF0Y2hGbGFnICYgMTYpIHtcbiAgICAgIGlmICghcHJldlByb3BzKSB7XG4gICAgICAgIHJldHVybiAhIW5leHRQcm9wcztcbiAgICAgIH1cbiAgICAgIHJldHVybiBoYXNQcm9wc0NoYW5nZWQocHJldlByb3BzLCBuZXh0UHJvcHMsIGVtaXRzKTtcbiAgICB9IGVsc2UgaWYgKHBhdGNoRmxhZyAmIDgpIHtcbiAgICAgIGNvbnN0IGR5bmFtaWNQcm9wcyA9IG5leHRWTm9kZS5keW5hbWljUHJvcHM7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGR5bmFtaWNQcm9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBrZXkgPSBkeW5hbWljUHJvcHNbaV07XG4gICAgICAgIGlmIChuZXh0UHJvcHNba2V5XSAhPT0gcHJldlByb3BzW2tleV0gJiYgIWlzRW1pdExpc3RlbmVyKGVtaXRzLCBrZXkpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKHByZXZDaGlsZHJlbiB8fCBuZXh0Q2hpbGRyZW4pIHtcbiAgICAgIGlmICghbmV4dENoaWxkcmVuIHx8ICFuZXh0Q2hpbGRyZW4uJHN0YWJsZSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHByZXZQcm9wcyA9PT0gbmV4dFByb3BzKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICghcHJldlByb3BzKSB7XG4gICAgICByZXR1cm4gISFuZXh0UHJvcHM7XG4gICAgfVxuICAgIGlmICghbmV4dFByb3BzKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGhhc1Byb3BzQ2hhbmdlZChwcmV2UHJvcHMsIG5leHRQcm9wcywgZW1pdHMpO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGhhc1Byb3BzQ2hhbmdlZChwcmV2UHJvcHMsIG5leHRQcm9wcywgZW1pdHNPcHRpb25zKSB7XG4gIGNvbnN0IG5leHRLZXlzID0gT2JqZWN0LmtleXMobmV4dFByb3BzKTtcbiAgaWYgKG5leHRLZXlzLmxlbmd0aCAhPT0gT2JqZWN0LmtleXMocHJldlByb3BzKS5sZW5ndGgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IG5leHRLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qga2V5ID0gbmV4dEtleXNbaV07XG4gICAgaWYgKG5leHRQcm9wc1trZXldICE9PSBwcmV2UHJvcHNba2V5XSAmJiAhaXNFbWl0TGlzdGVuZXIoZW1pdHNPcHRpb25zLCBrZXkpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gdXBkYXRlSE9DSG9zdEVsKHsgdm5vZGUsIHBhcmVudCB9LCBlbCkge1xuICB3aGlsZSAocGFyZW50ICYmIHBhcmVudC5zdWJUcmVlID09PSB2bm9kZSkge1xuICAgICh2bm9kZSA9IHBhcmVudC52bm9kZSkuZWwgPSBlbDtcbiAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xuICB9XG59XG5cbmNvbnN0IGlzU3VzcGVuc2UgPSAodHlwZSkgPT4gdHlwZS5fX2lzU3VzcGVuc2U7XG5jb25zdCBTdXNwZW5zZUltcGwgPSB7XG4gIG5hbWU6IFwiU3VzcGVuc2VcIixcbiAgLy8gSW4gb3JkZXIgdG8gbWFrZSBTdXNwZW5zZSB0cmVlLXNoYWthYmxlLCB3ZSBuZWVkIHRvIGF2b2lkIGltcG9ydGluZyBpdFxuICAvLyBkaXJlY3RseSBpbiB0aGUgcmVuZGVyZXIuIFRoZSByZW5kZXJlciBjaGVja3MgZm9yIHRoZSBfX2lzU3VzcGVuc2UgZmxhZ1xuICAvLyBvbiBhIHZub2RlJ3MgdHlwZSBhbmQgY2FsbHMgdGhlIGBwcm9jZXNzYCBtZXRob2QsIHBhc3NpbmcgaW4gcmVuZGVyZXJcbiAgLy8gaW50ZXJuYWxzLlxuICBfX2lzU3VzcGVuc2U6IHRydWUsXG4gIHByb2Nlc3MobjEsIG4yLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkLCByZW5kZXJlckludGVybmFscykge1xuICAgIGlmIChuMSA9PSBudWxsKSB7XG4gICAgICBtb3VudFN1c3BlbnNlKFxuICAgICAgICBuMixcbiAgICAgICAgY29udGFpbmVyLFxuICAgICAgICBhbmNob3IsXG4gICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgIGlzU1ZHLFxuICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgIG9wdGltaXplZCxcbiAgICAgICAgcmVuZGVyZXJJbnRlcm5hbHNcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhdGNoU3VzcGVuc2UoXG4gICAgICAgIG4xLFxuICAgICAgICBuMixcbiAgICAgICAgY29udGFpbmVyLFxuICAgICAgICBhbmNob3IsXG4gICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgaXNTVkcsXG4gICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgb3B0aW1pemVkLFxuICAgICAgICByZW5kZXJlckludGVybmFsc1xuICAgICAgKTtcbiAgICB9XG4gIH0sXG4gIGh5ZHJhdGU6IGh5ZHJhdGVTdXNwZW5zZSxcbiAgY3JlYXRlOiBjcmVhdGVTdXNwZW5zZUJvdW5kYXJ5LFxuICBub3JtYWxpemU6IG5vcm1hbGl6ZVN1c3BlbnNlQ2hpbGRyZW5cbn07XG5jb25zdCBTdXNwZW5zZSA9IFN1c3BlbnNlSW1wbCA7XG5mdW5jdGlvbiB0cmlnZ2VyRXZlbnQodm5vZGUsIG5hbWUpIHtcbiAgY29uc3QgZXZlbnRMaXN0ZW5lciA9IHZub2RlLnByb3BzICYmIHZub2RlLnByb3BzW25hbWVdO1xuICBpZiAoaXNGdW5jdGlvbihldmVudExpc3RlbmVyKSkge1xuICAgIGV2ZW50TGlzdGVuZXIoKTtcbiAgfVxufVxuZnVuY3Rpb24gbW91bnRTdXNwZW5zZSh2bm9kZSwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCwgcmVuZGVyZXJJbnRlcm5hbHMpIHtcbiAgY29uc3Qge1xuICAgIHA6IHBhdGNoLFxuICAgIG86IHsgY3JlYXRlRWxlbWVudCB9XG4gIH0gPSByZW5kZXJlckludGVybmFscztcbiAgY29uc3QgaGlkZGVuQ29udGFpbmVyID0gY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgY29uc3Qgc3VzcGVuc2UgPSB2bm9kZS5zdXNwZW5zZSA9IGNyZWF0ZVN1c3BlbnNlQm91bmRhcnkoXG4gICAgdm5vZGUsXG4gICAgcGFyZW50U3VzcGVuc2UsXG4gICAgcGFyZW50Q29tcG9uZW50LFxuICAgIGNvbnRhaW5lcixcbiAgICBoaWRkZW5Db250YWluZXIsXG4gICAgYW5jaG9yLFxuICAgIGlzU1ZHLFxuICAgIHNsb3RTY29wZUlkcyxcbiAgICBvcHRpbWl6ZWQsXG4gICAgcmVuZGVyZXJJbnRlcm5hbHNcbiAgKTtcbiAgcGF0Y2goXG4gICAgbnVsbCxcbiAgICBzdXNwZW5zZS5wZW5kaW5nQnJhbmNoID0gdm5vZGUuc3NDb250ZW50LFxuICAgIGhpZGRlbkNvbnRhaW5lcixcbiAgICBudWxsLFxuICAgIHBhcmVudENvbXBvbmVudCxcbiAgICBzdXNwZW5zZSxcbiAgICBpc1NWRyxcbiAgICBzbG90U2NvcGVJZHNcbiAgKTtcbiAgaWYgKHN1c3BlbnNlLmRlcHMgPiAwKSB7XG4gICAgdHJpZ2dlckV2ZW50KHZub2RlLCBcIm9uUGVuZGluZ1wiKTtcbiAgICB0cmlnZ2VyRXZlbnQodm5vZGUsIFwib25GYWxsYmFja1wiKTtcbiAgICBwYXRjaChcbiAgICAgIG51bGwsXG4gICAgICB2bm9kZS5zc0ZhbGxiYWNrLFxuICAgICAgY29udGFpbmVyLFxuICAgICAgYW5jaG9yLFxuICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgbnVsbCxcbiAgICAgIC8vIGZhbGxiYWNrIHRyZWUgd2lsbCBub3QgaGF2ZSBzdXNwZW5zZSBjb250ZXh0XG4gICAgICBpc1NWRyxcbiAgICAgIHNsb3RTY29wZUlkc1xuICAgICk7XG4gICAgc2V0QWN0aXZlQnJhbmNoKHN1c3BlbnNlLCB2bm9kZS5zc0ZhbGxiYWNrKTtcbiAgfSBlbHNlIHtcbiAgICBzdXNwZW5zZS5yZXNvbHZlKGZhbHNlLCB0cnVlKTtcbiAgfVxufVxuZnVuY3Rpb24gcGF0Y2hTdXNwZW5zZShuMSwgbjIsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCwgeyBwOiBwYXRjaCwgdW06IHVubW91bnQsIG86IHsgY3JlYXRlRWxlbWVudCB9IH0pIHtcbiAgY29uc3Qgc3VzcGVuc2UgPSBuMi5zdXNwZW5zZSA9IG4xLnN1c3BlbnNlO1xuICBzdXNwZW5zZS52bm9kZSA9IG4yO1xuICBuMi5lbCA9IG4xLmVsO1xuICBjb25zdCBuZXdCcmFuY2ggPSBuMi5zc0NvbnRlbnQ7XG4gIGNvbnN0IG5ld0ZhbGxiYWNrID0gbjIuc3NGYWxsYmFjaztcbiAgY29uc3QgeyBhY3RpdmVCcmFuY2gsIHBlbmRpbmdCcmFuY2gsIGlzSW5GYWxsYmFjaywgaXNIeWRyYXRpbmcgfSA9IHN1c3BlbnNlO1xuICBpZiAocGVuZGluZ0JyYW5jaCkge1xuICAgIHN1c3BlbnNlLnBlbmRpbmdCcmFuY2ggPSBuZXdCcmFuY2g7XG4gICAgaWYgKGlzU2FtZVZOb2RlVHlwZShuZXdCcmFuY2gsIHBlbmRpbmdCcmFuY2gpKSB7XG4gICAgICBwYXRjaChcbiAgICAgICAgcGVuZGluZ0JyYW5jaCxcbiAgICAgICAgbmV3QnJhbmNoLFxuICAgICAgICBzdXNwZW5zZS5oaWRkZW5Db250YWluZXIsXG4gICAgICAgIG51bGwsXG4gICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgc3VzcGVuc2UsXG4gICAgICAgIGlzU1ZHLFxuICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgIG9wdGltaXplZFxuICAgICAgKTtcbiAgICAgIGlmIChzdXNwZW5zZS5kZXBzIDw9IDApIHtcbiAgICAgICAgc3VzcGVuc2UucmVzb2x2ZSgpO1xuICAgICAgfSBlbHNlIGlmIChpc0luRmFsbGJhY2spIHtcbiAgICAgICAgcGF0Y2goXG4gICAgICAgICAgYWN0aXZlQnJhbmNoLFxuICAgICAgICAgIG5ld0ZhbGxiYWNrLFxuICAgICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgICBhbmNob3IsXG4gICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgIG51bGwsXG4gICAgICAgICAgLy8gZmFsbGJhY2sgdHJlZSB3aWxsIG5vdCBoYXZlIHN1c3BlbnNlIGNvbnRleHRcbiAgICAgICAgICBpc1NWRyxcbiAgICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgICAgb3B0aW1pemVkXG4gICAgICAgICk7XG4gICAgICAgIHNldEFjdGl2ZUJyYW5jaChzdXNwZW5zZSwgbmV3RmFsbGJhY2spO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzdXNwZW5zZS5wZW5kaW5nSWQrKztcbiAgICAgIGlmIChpc0h5ZHJhdGluZykge1xuICAgICAgICBzdXNwZW5zZS5pc0h5ZHJhdGluZyA9IGZhbHNlO1xuICAgICAgICBzdXNwZW5zZS5hY3RpdmVCcmFuY2ggPSBwZW5kaW5nQnJhbmNoO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdW5tb3VudChwZW5kaW5nQnJhbmNoLCBwYXJlbnRDb21wb25lbnQsIHN1c3BlbnNlKTtcbiAgICAgIH1cbiAgICAgIHN1c3BlbnNlLmRlcHMgPSAwO1xuICAgICAgc3VzcGVuc2UuZWZmZWN0cy5sZW5ndGggPSAwO1xuICAgICAgc3VzcGVuc2UuaGlkZGVuQ29udGFpbmVyID0gY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgIGlmIChpc0luRmFsbGJhY2spIHtcbiAgICAgICAgcGF0Y2goXG4gICAgICAgICAgbnVsbCxcbiAgICAgICAgICBuZXdCcmFuY2gsXG4gICAgICAgICAgc3VzcGVuc2UuaGlkZGVuQ29udGFpbmVyLFxuICAgICAgICAgIG51bGwsXG4gICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgIHN1c3BlbnNlLFxuICAgICAgICAgIGlzU1ZHLFxuICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKHN1c3BlbnNlLmRlcHMgPD0gMCkge1xuICAgICAgICAgIHN1c3BlbnNlLnJlc29sdmUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwYXRjaChcbiAgICAgICAgICAgIGFjdGl2ZUJyYW5jaCxcbiAgICAgICAgICAgIG5ld0ZhbGxiYWNrLFxuICAgICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgICAgYW5jaG9yLFxuICAgICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgIC8vIGZhbGxiYWNrIHRyZWUgd2lsbCBub3QgaGF2ZSBzdXNwZW5zZSBjb250ZXh0XG4gICAgICAgICAgICBpc1NWRyxcbiAgICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICAgIG9wdGltaXplZFxuICAgICAgICAgICk7XG4gICAgICAgICAgc2V0QWN0aXZlQnJhbmNoKHN1c3BlbnNlLCBuZXdGYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoYWN0aXZlQnJhbmNoICYmIGlzU2FtZVZOb2RlVHlwZShuZXdCcmFuY2gsIGFjdGl2ZUJyYW5jaCkpIHtcbiAgICAgICAgcGF0Y2goXG4gICAgICAgICAgYWN0aXZlQnJhbmNoLFxuICAgICAgICAgIG5ld0JyYW5jaCxcbiAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgYW5jaG9yLFxuICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICBzdXNwZW5zZSxcbiAgICAgICAgICBpc1NWRyxcbiAgICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgICAgb3B0aW1pemVkXG4gICAgICAgICk7XG4gICAgICAgIHN1c3BlbnNlLnJlc29sdmUodHJ1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXRjaChcbiAgICAgICAgICBudWxsLFxuICAgICAgICAgIG5ld0JyYW5jaCxcbiAgICAgICAgICBzdXNwZW5zZS5oaWRkZW5Db250YWluZXIsXG4gICAgICAgICAgbnVsbCxcbiAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgc3VzcGVuc2UsXG4gICAgICAgICAgaXNTVkcsXG4gICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgIG9wdGltaXplZFxuICAgICAgICApO1xuICAgICAgICBpZiAoc3VzcGVuc2UuZGVwcyA8PSAwKSB7XG4gICAgICAgICAgc3VzcGVuc2UucmVzb2x2ZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChhY3RpdmVCcmFuY2ggJiYgaXNTYW1lVk5vZGVUeXBlKG5ld0JyYW5jaCwgYWN0aXZlQnJhbmNoKSkge1xuICAgICAgcGF0Y2goXG4gICAgICAgIGFjdGl2ZUJyYW5jaCxcbiAgICAgICAgbmV3QnJhbmNoLFxuICAgICAgICBjb250YWluZXIsXG4gICAgICAgIGFuY2hvcixcbiAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICBzdXNwZW5zZSxcbiAgICAgICAgaXNTVkcsXG4gICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgb3B0aW1pemVkXG4gICAgICApO1xuICAgICAgc2V0QWN0aXZlQnJhbmNoKHN1c3BlbnNlLCBuZXdCcmFuY2gpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0cmlnZ2VyRXZlbnQobjIsIFwib25QZW5kaW5nXCIpO1xuICAgICAgc3VzcGVuc2UucGVuZGluZ0JyYW5jaCA9IG5ld0JyYW5jaDtcbiAgICAgIHN1c3BlbnNlLnBlbmRpbmdJZCsrO1xuICAgICAgcGF0Y2goXG4gICAgICAgIG51bGwsXG4gICAgICAgIG5ld0JyYW5jaCxcbiAgICAgICAgc3VzcGVuc2UuaGlkZGVuQ29udGFpbmVyLFxuICAgICAgICBudWxsLFxuICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgIHN1c3BlbnNlLFxuICAgICAgICBpc1NWRyxcbiAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICk7XG4gICAgICBpZiAoc3VzcGVuc2UuZGVwcyA8PSAwKSB7XG4gICAgICAgIHN1c3BlbnNlLnJlc29sdmUoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHsgdGltZW91dCwgcGVuZGluZ0lkIH0gPSBzdXNwZW5zZTtcbiAgICAgICAgaWYgKHRpbWVvdXQgPiAwKSB7XG4gICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBpZiAoc3VzcGVuc2UucGVuZGluZ0lkID09PSBwZW5kaW5nSWQpIHtcbiAgICAgICAgICAgICAgc3VzcGVuc2UuZmFsbGJhY2sobmV3RmFsbGJhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIHRpbWVvdXQpO1xuICAgICAgICB9IGVsc2UgaWYgKHRpbWVvdXQgPT09IDApIHtcbiAgICAgICAgICBzdXNwZW5zZS5mYWxsYmFjayhuZXdGYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmxldCBoYXNXYXJuZWQgPSBmYWxzZTtcbmZ1bmN0aW9uIGNyZWF0ZVN1c3BlbnNlQm91bmRhcnkodm5vZGUsIHBhcmVudFN1c3BlbnNlLCBwYXJlbnRDb21wb25lbnQsIGNvbnRhaW5lciwgaGlkZGVuQ29udGFpbmVyLCBhbmNob3IsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCwgcmVuZGVyZXJJbnRlcm5hbHMsIGlzSHlkcmF0aW5nID0gZmFsc2UpIHtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgdHJ1ZSAmJiAhaGFzV2FybmVkKSB7XG4gICAgaGFzV2FybmVkID0gdHJ1ZTtcbiAgICBjb25zb2xlW2NvbnNvbGUuaW5mbyA/IFwiaW5mb1wiIDogXCJsb2dcIl0oXG4gICAgICBgPFN1c3BlbnNlPiBpcyBhbiBleHBlcmltZW50YWwgZmVhdHVyZSBhbmQgaXRzIEFQSSB3aWxsIGxpa2VseSBjaGFuZ2UuYFxuICAgICk7XG4gIH1cbiAgY29uc3Qge1xuICAgIHA6IHBhdGNoLFxuICAgIG06IG1vdmUsXG4gICAgdW06IHVubW91bnQsXG4gICAgbjogbmV4dCxcbiAgICBvOiB7IHBhcmVudE5vZGUsIHJlbW92ZSB9XG4gIH0gPSByZW5kZXJlckludGVybmFscztcbiAgbGV0IHBhcmVudFN1c3BlbnNlSWQ7XG4gIGNvbnN0IGlzU3VzcGVuc2libGUgPSBpc1ZOb2RlU3VzcGVuc2libGUodm5vZGUpO1xuICBpZiAoaXNTdXNwZW5zaWJsZSkge1xuICAgIGlmIChwYXJlbnRTdXNwZW5zZSA9PSBudWxsID8gdm9pZCAwIDogcGFyZW50U3VzcGVuc2UucGVuZGluZ0JyYW5jaCkge1xuICAgICAgcGFyZW50U3VzcGVuc2VJZCA9IHBhcmVudFN1c3BlbnNlLnBlbmRpbmdJZDtcbiAgICAgIHBhcmVudFN1c3BlbnNlLmRlcHMrKztcbiAgICB9XG4gIH1cbiAgY29uc3QgdGltZW91dCA9IHZub2RlLnByb3BzID8gdG9OdW1iZXIodm5vZGUucHJvcHMudGltZW91dCkgOiB2b2lkIDA7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgYXNzZXJ0TnVtYmVyKHRpbWVvdXQsIGBTdXNwZW5zZSB0aW1lb3V0YCk7XG4gIH1cbiAgY29uc3Qgc3VzcGVuc2UgPSB7XG4gICAgdm5vZGUsXG4gICAgcGFyZW50OiBwYXJlbnRTdXNwZW5zZSxcbiAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgaXNTVkcsXG4gICAgY29udGFpbmVyLFxuICAgIGhpZGRlbkNvbnRhaW5lcixcbiAgICBhbmNob3IsXG4gICAgZGVwczogMCxcbiAgICBwZW5kaW5nSWQ6IDAsXG4gICAgdGltZW91dDogdHlwZW9mIHRpbWVvdXQgPT09IFwibnVtYmVyXCIgPyB0aW1lb3V0IDogLTEsXG4gICAgYWN0aXZlQnJhbmNoOiBudWxsLFxuICAgIHBlbmRpbmdCcmFuY2g6IG51bGwsXG4gICAgaXNJbkZhbGxiYWNrOiB0cnVlLFxuICAgIGlzSHlkcmF0aW5nLFxuICAgIGlzVW5tb3VudGVkOiBmYWxzZSxcbiAgICBlZmZlY3RzOiBbXSxcbiAgICByZXNvbHZlKHJlc3VtZSA9IGZhbHNlLCBzeW5jID0gZmFsc2UpIHtcbiAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgIGlmICghcmVzdW1lICYmICFzdXNwZW5zZS5wZW5kaW5nQnJhbmNoKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYHN1c3BlbnNlLnJlc29sdmUoKSBpcyBjYWxsZWQgd2l0aG91dCBhIHBlbmRpbmcgYnJhbmNoLmBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdXNwZW5zZS5pc1VubW91bnRlZCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBzdXNwZW5zZS5yZXNvbHZlKCkgaXMgY2FsbGVkIG9uIGFuIGFscmVhZHkgdW5tb3VudGVkIHN1c3BlbnNlIGJvdW5kYXJ5LmBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCB7XG4gICAgICAgIHZub2RlOiB2bm9kZTIsXG4gICAgICAgIGFjdGl2ZUJyYW5jaCxcbiAgICAgICAgcGVuZGluZ0JyYW5jaCxcbiAgICAgICAgcGVuZGluZ0lkLFxuICAgICAgICBlZmZlY3RzLFxuICAgICAgICBwYXJlbnRDb21wb25lbnQ6IHBhcmVudENvbXBvbmVudDIsXG4gICAgICAgIGNvbnRhaW5lcjogY29udGFpbmVyMlxuICAgICAgfSA9IHN1c3BlbnNlO1xuICAgICAgaWYgKHN1c3BlbnNlLmlzSHlkcmF0aW5nKSB7XG4gICAgICAgIHN1c3BlbnNlLmlzSHlkcmF0aW5nID0gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKCFyZXN1bWUpIHtcbiAgICAgICAgY29uc3QgZGVsYXlFbnRlciA9IGFjdGl2ZUJyYW5jaCAmJiBwZW5kaW5nQnJhbmNoLnRyYW5zaXRpb24gJiYgcGVuZGluZ0JyYW5jaC50cmFuc2l0aW9uLm1vZGUgPT09IFwib3V0LWluXCI7XG4gICAgICAgIGlmIChkZWxheUVudGVyKSB7XG4gICAgICAgICAgYWN0aXZlQnJhbmNoLnRyYW5zaXRpb24uYWZ0ZXJMZWF2ZSA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmIChwZW5kaW5nSWQgPT09IHN1c3BlbnNlLnBlbmRpbmdJZCkge1xuICAgICAgICAgICAgICBtb3ZlKHBlbmRpbmdCcmFuY2gsIGNvbnRhaW5lcjIsIGFuY2hvcjIsIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHsgYW5jaG9yOiBhbmNob3IyIH0gPSBzdXNwZW5zZTtcbiAgICAgICAgaWYgKGFjdGl2ZUJyYW5jaCkge1xuICAgICAgICAgIGFuY2hvcjIgPSBuZXh0KGFjdGl2ZUJyYW5jaCk7XG4gICAgICAgICAgdW5tb3VudChhY3RpdmVCcmFuY2gsIHBhcmVudENvbXBvbmVudDIsIHN1c3BlbnNlLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWRlbGF5RW50ZXIpIHtcbiAgICAgICAgICBtb3ZlKHBlbmRpbmdCcmFuY2gsIGNvbnRhaW5lcjIsIGFuY2hvcjIsIDApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzZXRBY3RpdmVCcmFuY2goc3VzcGVuc2UsIHBlbmRpbmdCcmFuY2gpO1xuICAgICAgc3VzcGVuc2UucGVuZGluZ0JyYW5jaCA9IG51bGw7XG4gICAgICBzdXNwZW5zZS5pc0luRmFsbGJhY2sgPSBmYWxzZTtcbiAgICAgIGxldCBwYXJlbnQgPSBzdXNwZW5zZS5wYXJlbnQ7XG4gICAgICBsZXQgaGFzVW5yZXNvbHZlZEFuY2VzdG9yID0gZmFsc2U7XG4gICAgICB3aGlsZSAocGFyZW50KSB7XG4gICAgICAgIGlmIChwYXJlbnQucGVuZGluZ0JyYW5jaCkge1xuICAgICAgICAgIHBhcmVudC5lZmZlY3RzLnB1c2goLi4uZWZmZWN0cyk7XG4gICAgICAgICAgaGFzVW5yZXNvbHZlZEFuY2VzdG9yID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xuICAgICAgfVxuICAgICAgaWYgKCFoYXNVbnJlc29sdmVkQW5jZXN0b3IpIHtcbiAgICAgICAgcXVldWVQb3N0Rmx1c2hDYihlZmZlY3RzKTtcbiAgICAgIH1cbiAgICAgIHN1c3BlbnNlLmVmZmVjdHMgPSBbXTtcbiAgICAgIGlmIChpc1N1c3BlbnNpYmxlKSB7XG4gICAgICAgIGlmIChwYXJlbnRTdXNwZW5zZSAmJiBwYXJlbnRTdXNwZW5zZS5wZW5kaW5nQnJhbmNoICYmIHBhcmVudFN1c3BlbnNlSWQgPT09IHBhcmVudFN1c3BlbnNlLnBlbmRpbmdJZCkge1xuICAgICAgICAgIHBhcmVudFN1c3BlbnNlLmRlcHMtLTtcbiAgICAgICAgICBpZiAocGFyZW50U3VzcGVuc2UuZGVwcyA9PT0gMCAmJiAhc3luYykge1xuICAgICAgICAgICAgcGFyZW50U3VzcGVuc2UucmVzb2x2ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdHJpZ2dlckV2ZW50KHZub2RlMiwgXCJvblJlc29sdmVcIik7XG4gICAgfSxcbiAgICBmYWxsYmFjayhmYWxsYmFja1ZOb2RlKSB7XG4gICAgICBpZiAoIXN1c3BlbnNlLnBlbmRpbmdCcmFuY2gpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgeyB2bm9kZTogdm5vZGUyLCBhY3RpdmVCcmFuY2gsIHBhcmVudENvbXBvbmVudDogcGFyZW50Q29tcG9uZW50MiwgY29udGFpbmVyOiBjb250YWluZXIyLCBpc1NWRzogaXNTVkcyIH0gPSBzdXNwZW5zZTtcbiAgICAgIHRyaWdnZXJFdmVudCh2bm9kZTIsIFwib25GYWxsYmFja1wiKTtcbiAgICAgIGNvbnN0IGFuY2hvcjIgPSBuZXh0KGFjdGl2ZUJyYW5jaCk7XG4gICAgICBjb25zdCBtb3VudEZhbGxiYWNrID0gKCkgPT4ge1xuICAgICAgICBpZiAoIXN1c3BlbnNlLmlzSW5GYWxsYmFjaykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBwYXRjaChcbiAgICAgICAgICBudWxsLFxuICAgICAgICAgIGZhbGxiYWNrVk5vZGUsXG4gICAgICAgICAgY29udGFpbmVyMixcbiAgICAgICAgICBhbmNob3IyLFxuICAgICAgICAgIHBhcmVudENvbXBvbmVudDIsXG4gICAgICAgICAgbnVsbCxcbiAgICAgICAgICAvLyBmYWxsYmFjayB0cmVlIHdpbGwgbm90IGhhdmUgc3VzcGVuc2UgY29udGV4dFxuICAgICAgICAgIGlzU1ZHMixcbiAgICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgICAgb3B0aW1pemVkXG4gICAgICAgICk7XG4gICAgICAgIHNldEFjdGl2ZUJyYW5jaChzdXNwZW5zZSwgZmFsbGJhY2tWTm9kZSk7XG4gICAgICB9O1xuICAgICAgY29uc3QgZGVsYXlFbnRlciA9IGZhbGxiYWNrVk5vZGUudHJhbnNpdGlvbiAmJiBmYWxsYmFja1ZOb2RlLnRyYW5zaXRpb24ubW9kZSA9PT0gXCJvdXQtaW5cIjtcbiAgICAgIGlmIChkZWxheUVudGVyKSB7XG4gICAgICAgIGFjdGl2ZUJyYW5jaC50cmFuc2l0aW9uLmFmdGVyTGVhdmUgPSBtb3VudEZhbGxiYWNrO1xuICAgICAgfVxuICAgICAgc3VzcGVuc2UuaXNJbkZhbGxiYWNrID0gdHJ1ZTtcbiAgICAgIHVubW91bnQoXG4gICAgICAgIGFjdGl2ZUJyYW5jaCxcbiAgICAgICAgcGFyZW50Q29tcG9uZW50MixcbiAgICAgICAgbnVsbCxcbiAgICAgICAgLy8gbm8gc3VzcGVuc2Ugc28gdW5tb3VudCBob29rcyBmaXJlIG5vd1xuICAgICAgICB0cnVlXG4gICAgICAgIC8vIHNob3VsZFJlbW92ZVxuICAgICAgKTtcbiAgICAgIGlmICghZGVsYXlFbnRlcikge1xuICAgICAgICBtb3VudEZhbGxiYWNrKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBtb3ZlKGNvbnRhaW5lcjIsIGFuY2hvcjIsIHR5cGUpIHtcbiAgICAgIHN1c3BlbnNlLmFjdGl2ZUJyYW5jaCAmJiBtb3ZlKHN1c3BlbnNlLmFjdGl2ZUJyYW5jaCwgY29udGFpbmVyMiwgYW5jaG9yMiwgdHlwZSk7XG4gICAgICBzdXNwZW5zZS5jb250YWluZXIgPSBjb250YWluZXIyO1xuICAgIH0sXG4gICAgbmV4dCgpIHtcbiAgICAgIHJldHVybiBzdXNwZW5zZS5hY3RpdmVCcmFuY2ggJiYgbmV4dChzdXNwZW5zZS5hY3RpdmVCcmFuY2gpO1xuICAgIH0sXG4gICAgcmVnaXN0ZXJEZXAoaW5zdGFuY2UsIHNldHVwUmVuZGVyRWZmZWN0KSB7XG4gICAgICBjb25zdCBpc0luUGVuZGluZ1N1c3BlbnNlID0gISFzdXNwZW5zZS5wZW5kaW5nQnJhbmNoO1xuICAgICAgaWYgKGlzSW5QZW5kaW5nU3VzcGVuc2UpIHtcbiAgICAgICAgc3VzcGVuc2UuZGVwcysrO1xuICAgICAgfVxuICAgICAgY29uc3QgaHlkcmF0ZWRFbCA9IGluc3RhbmNlLnZub2RlLmVsO1xuICAgICAgaW5zdGFuY2UuYXN5bmNEZXAuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICBoYW5kbGVFcnJvcihlcnIsIGluc3RhbmNlLCAwKTtcbiAgICAgIH0pLnRoZW4oKGFzeW5jU2V0dXBSZXN1bHQpID0+IHtcbiAgICAgICAgaWYgKGluc3RhbmNlLmlzVW5tb3VudGVkIHx8IHN1c3BlbnNlLmlzVW5tb3VudGVkIHx8IHN1c3BlbnNlLnBlbmRpbmdJZCAhPT0gaW5zdGFuY2Uuc3VzcGVuc2VJZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpbnN0YW5jZS5hc3luY1Jlc29sdmVkID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgeyB2bm9kZTogdm5vZGUyIH0gPSBpbnN0YW5jZTtcbiAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICBwdXNoV2FybmluZ0NvbnRleHQodm5vZGUyKTtcbiAgICAgICAgfVxuICAgICAgICBoYW5kbGVTZXR1cFJlc3VsdChpbnN0YW5jZSwgYXN5bmNTZXR1cFJlc3VsdCwgZmFsc2UpO1xuICAgICAgICBpZiAoaHlkcmF0ZWRFbCkge1xuICAgICAgICAgIHZub2RlMi5lbCA9IGh5ZHJhdGVkRWw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGxhY2Vob2xkZXIgPSAhaHlkcmF0ZWRFbCAmJiBpbnN0YW5jZS5zdWJUcmVlLmVsO1xuICAgICAgICBzZXR1cFJlbmRlckVmZmVjdChcbiAgICAgICAgICBpbnN0YW5jZSxcbiAgICAgICAgICB2bm9kZTIsXG4gICAgICAgICAgLy8gY29tcG9uZW50IG1heSBoYXZlIGJlZW4gbW92ZWQgYmVmb3JlIHJlc29sdmUuXG4gICAgICAgICAgLy8gaWYgdGhpcyBpcyBub3QgYSBoeWRyYXRpb24sIGluc3RhbmNlLnN1YlRyZWUgd2lsbCBiZSB0aGUgY29tbWVudFxuICAgICAgICAgIC8vIHBsYWNlaG9sZGVyLlxuICAgICAgICAgIHBhcmVudE5vZGUoaHlkcmF0ZWRFbCB8fCBpbnN0YW5jZS5zdWJUcmVlLmVsKSxcbiAgICAgICAgICAvLyBhbmNob3Igd2lsbCBub3QgYmUgdXNlZCBpZiB0aGlzIGlzIGh5ZHJhdGlvbiwgc28gb25seSBuZWVkIHRvXG4gICAgICAgICAgLy8gY29uc2lkZXIgdGhlIGNvbW1lbnQgcGxhY2Vob2xkZXIgY2FzZS5cbiAgICAgICAgICBoeWRyYXRlZEVsID8gbnVsbCA6IG5leHQoaW5zdGFuY2Uuc3ViVHJlZSksXG4gICAgICAgICAgc3VzcGVuc2UsXG4gICAgICAgICAgaXNTVkcsXG4gICAgICAgICAgb3B0aW1pemVkXG4gICAgICAgICk7XG4gICAgICAgIGlmIChwbGFjZWhvbGRlcikge1xuICAgICAgICAgIHJlbW92ZShwbGFjZWhvbGRlcik7XG4gICAgICAgIH1cbiAgICAgICAgdXBkYXRlSE9DSG9zdEVsKGluc3RhbmNlLCB2bm9kZTIuZWwpO1xuICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgIHBvcFdhcm5pbmdDb250ZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzSW5QZW5kaW5nU3VzcGVuc2UgJiYgLS1zdXNwZW5zZS5kZXBzID09PSAwKSB7XG4gICAgICAgICAgc3VzcGVuc2UucmVzb2x2ZSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LFxuICAgIHVubW91bnQocGFyZW50U3VzcGVuc2UyLCBkb1JlbW92ZSkge1xuICAgICAgc3VzcGVuc2UuaXNVbm1vdW50ZWQgPSB0cnVlO1xuICAgICAgaWYgKHN1c3BlbnNlLmFjdGl2ZUJyYW5jaCkge1xuICAgICAgICB1bm1vdW50KFxuICAgICAgICAgIHN1c3BlbnNlLmFjdGl2ZUJyYW5jaCxcbiAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgcGFyZW50U3VzcGVuc2UyLFxuICAgICAgICAgIGRvUmVtb3ZlXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAoc3VzcGVuc2UucGVuZGluZ0JyYW5jaCkge1xuICAgICAgICB1bm1vdW50KFxuICAgICAgICAgIHN1c3BlbnNlLnBlbmRpbmdCcmFuY2gsXG4gICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgIHBhcmVudFN1c3BlbnNlMixcbiAgICAgICAgICBkb1JlbW92ZVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgcmV0dXJuIHN1c3BlbnNlO1xufVxuZnVuY3Rpb24gaHlkcmF0ZVN1c3BlbnNlKG5vZGUsIHZub2RlLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQsIHJlbmRlcmVySW50ZXJuYWxzLCBoeWRyYXRlTm9kZSkge1xuICBjb25zdCBzdXNwZW5zZSA9IHZub2RlLnN1c3BlbnNlID0gY3JlYXRlU3VzcGVuc2VCb3VuZGFyeShcbiAgICB2bm9kZSxcbiAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgbm9kZS5wYXJlbnROb2RlLFxuICAgIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksXG4gICAgbnVsbCxcbiAgICBpc1NWRyxcbiAgICBzbG90U2NvcGVJZHMsXG4gICAgb3B0aW1pemVkLFxuICAgIHJlbmRlcmVySW50ZXJuYWxzLFxuICAgIHRydWVcbiAgICAvKiBoeWRyYXRpbmcgKi9cbiAgKTtcbiAgY29uc3QgcmVzdWx0ID0gaHlkcmF0ZU5vZGUoXG4gICAgbm9kZSxcbiAgICBzdXNwZW5zZS5wZW5kaW5nQnJhbmNoID0gdm5vZGUuc3NDb250ZW50LFxuICAgIHBhcmVudENvbXBvbmVudCxcbiAgICBzdXNwZW5zZSxcbiAgICBzbG90U2NvcGVJZHMsXG4gICAgb3B0aW1pemVkXG4gICk7XG4gIGlmIChzdXNwZW5zZS5kZXBzID09PSAwKSB7XG4gICAgc3VzcGVuc2UucmVzb2x2ZShmYWxzZSwgdHJ1ZSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZVN1c3BlbnNlQ2hpbGRyZW4odm5vZGUpIHtcbiAgY29uc3QgeyBzaGFwZUZsYWcsIGNoaWxkcmVuIH0gPSB2bm9kZTtcbiAgY29uc3QgaXNTbG90Q2hpbGRyZW4gPSBzaGFwZUZsYWcgJiAzMjtcbiAgdm5vZGUuc3NDb250ZW50ID0gbm9ybWFsaXplU3VzcGVuc2VTbG90KFxuICAgIGlzU2xvdENoaWxkcmVuID8gY2hpbGRyZW4uZGVmYXVsdCA6IGNoaWxkcmVuXG4gICk7XG4gIHZub2RlLnNzRmFsbGJhY2sgPSBpc1Nsb3RDaGlsZHJlbiA/IG5vcm1hbGl6ZVN1c3BlbnNlU2xvdChjaGlsZHJlbi5mYWxsYmFjaykgOiBjcmVhdGVWTm9kZShDb21tZW50KTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZVN1c3BlbnNlU2xvdChzKSB7XG4gIGxldCBibG9jaztcbiAgaWYgKGlzRnVuY3Rpb24ocykpIHtcbiAgICBjb25zdCB0cmFja0Jsb2NrID0gaXNCbG9ja1RyZWVFbmFibGVkICYmIHMuX2M7XG4gICAgaWYgKHRyYWNrQmxvY2spIHtcbiAgICAgIHMuX2QgPSBmYWxzZTtcbiAgICAgIG9wZW5CbG9jaygpO1xuICAgIH1cbiAgICBzID0gcygpO1xuICAgIGlmICh0cmFja0Jsb2NrKSB7XG4gICAgICBzLl9kID0gdHJ1ZTtcbiAgICAgIGJsb2NrID0gY3VycmVudEJsb2NrO1xuICAgICAgY2xvc2VCbG9jaygpO1xuICAgIH1cbiAgfVxuICBpZiAoaXNBcnJheShzKSkge1xuICAgIGNvbnN0IHNpbmdsZUNoaWxkID0gZmlsdGVyU2luZ2xlUm9vdChzKTtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhc2luZ2xlQ2hpbGQpIHtcbiAgICAgIHdhcm4oYDxTdXNwZW5zZT4gc2xvdHMgZXhwZWN0IGEgc2luZ2xlIHJvb3Qgbm9kZS5gKTtcbiAgICB9XG4gICAgcyA9IHNpbmdsZUNoaWxkO1xuICB9XG4gIHMgPSBub3JtYWxpemVWTm9kZShzKTtcbiAgaWYgKGJsb2NrICYmICFzLmR5bmFtaWNDaGlsZHJlbikge1xuICAgIHMuZHluYW1pY0NoaWxkcmVuID0gYmxvY2suZmlsdGVyKChjKSA9PiBjICE9PSBzKTtcbiAgfVxuICByZXR1cm4gcztcbn1cbmZ1bmN0aW9uIHF1ZXVlRWZmZWN0V2l0aFN1c3BlbnNlKGZuLCBzdXNwZW5zZSkge1xuICBpZiAoc3VzcGVuc2UgJiYgc3VzcGVuc2UucGVuZGluZ0JyYW5jaCkge1xuICAgIGlmIChpc0FycmF5KGZuKSkge1xuICAgICAgc3VzcGVuc2UuZWZmZWN0cy5wdXNoKC4uLmZuKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3VzcGVuc2UuZWZmZWN0cy5wdXNoKGZuKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcXVldWVQb3N0Rmx1c2hDYihmbik7XG4gIH1cbn1cbmZ1bmN0aW9uIHNldEFjdGl2ZUJyYW5jaChzdXNwZW5zZSwgYnJhbmNoKSB7XG4gIHN1c3BlbnNlLmFjdGl2ZUJyYW5jaCA9IGJyYW5jaDtcbiAgY29uc3QgeyB2bm9kZSwgcGFyZW50Q29tcG9uZW50IH0gPSBzdXNwZW5zZTtcbiAgY29uc3QgZWwgPSB2bm9kZS5lbCA9IGJyYW5jaC5lbDtcbiAgaWYgKHBhcmVudENvbXBvbmVudCAmJiBwYXJlbnRDb21wb25lbnQuc3ViVHJlZSA9PT0gdm5vZGUpIHtcbiAgICBwYXJlbnRDb21wb25lbnQudm5vZGUuZWwgPSBlbDtcbiAgICB1cGRhdGVIT0NIb3N0RWwocGFyZW50Q29tcG9uZW50LCBlbCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGlzVk5vZGVTdXNwZW5zaWJsZSh2bm9kZSkge1xuICB2YXIgX2E7XG4gIHJldHVybiAoKF9hID0gdm5vZGUucHJvcHMpID09IG51bGwgPyB2b2lkIDAgOiBfYS5zdXNwZW5zaWJsZSkgIT0gbnVsbCAmJiB2bm9kZS5wcm9wcy5zdXNwZW5zaWJsZSAhPT0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIHdhdGNoRWZmZWN0KGVmZmVjdCwgb3B0aW9ucykge1xuICByZXR1cm4gZG9XYXRjaChlZmZlY3QsIG51bGwsIG9wdGlvbnMpO1xufVxuZnVuY3Rpb24gd2F0Y2hQb3N0RWZmZWN0KGVmZmVjdCwgb3B0aW9ucykge1xuICByZXR1cm4gZG9XYXRjaChcbiAgICBlZmZlY3QsXG4gICAgbnVsbCxcbiAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gZXh0ZW5kKHt9LCBvcHRpb25zLCB7IGZsdXNoOiBcInBvc3RcIiB9KSA6IHsgZmx1c2g6IFwicG9zdFwiIH1cbiAgKTtcbn1cbmZ1bmN0aW9uIHdhdGNoU3luY0VmZmVjdChlZmZlY3QsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIGRvV2F0Y2goXG4gICAgZWZmZWN0LFxuICAgIG51bGwsXG4gICAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IGV4dGVuZCh7fSwgb3B0aW9ucywgeyBmbHVzaDogXCJzeW5jXCIgfSkgOiB7IGZsdXNoOiBcInN5bmNcIiB9XG4gICk7XG59XG5jb25zdCBJTklUSUFMX1dBVENIRVJfVkFMVUUgPSB7fTtcbmZ1bmN0aW9uIHdhdGNoKHNvdXJjZSwgY2IsIG9wdGlvbnMpIHtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgIWlzRnVuY3Rpb24oY2IpKSB7XG4gICAgd2FybihcbiAgICAgIGBcXGB3YXRjaChmbiwgb3B0aW9ucz8pXFxgIHNpZ25hdHVyZSBoYXMgYmVlbiBtb3ZlZCB0byBhIHNlcGFyYXRlIEFQSS4gVXNlIFxcYHdhdGNoRWZmZWN0KGZuLCBvcHRpb25zPylcXGAgaW5zdGVhZC4gXFxgd2F0Y2hcXGAgbm93IG9ubHkgc3VwcG9ydHMgXFxgd2F0Y2goc291cmNlLCBjYiwgb3B0aW9ucz8pIHNpZ25hdHVyZS5gXG4gICAgKTtcbiAgfVxuICByZXR1cm4gZG9XYXRjaChzb3VyY2UsIGNiLCBvcHRpb25zKTtcbn1cbmZ1bmN0aW9uIGRvV2F0Y2goc291cmNlLCBjYiwgeyBpbW1lZGlhdGUsIGRlZXAsIGZsdXNoLCBvblRyYWNrLCBvblRyaWdnZXIgfSA9IEVNUFRZX09CSikge1xuICB2YXIgX2E7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICFjYikge1xuICAgIGlmIChpbW1lZGlhdGUgIT09IHZvaWQgMCkge1xuICAgICAgd2FybihcbiAgICAgICAgYHdhdGNoKCkgXCJpbW1lZGlhdGVcIiBvcHRpb24gaXMgb25seSByZXNwZWN0ZWQgd2hlbiB1c2luZyB0aGUgd2F0Y2goc291cmNlLCBjYWxsYmFjaywgb3B0aW9ucz8pIHNpZ25hdHVyZS5gXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoZGVlcCAhPT0gdm9pZCAwKSB7XG4gICAgICB3YXJuKFxuICAgICAgICBgd2F0Y2goKSBcImRlZXBcIiBvcHRpb24gaXMgb25seSByZXNwZWN0ZWQgd2hlbiB1c2luZyB0aGUgd2F0Y2goc291cmNlLCBjYWxsYmFjaywgb3B0aW9ucz8pIHNpZ25hdHVyZS5gXG4gICAgICApO1xuICAgIH1cbiAgfVxuICBjb25zdCB3YXJuSW52YWxpZFNvdXJjZSA9IChzKSA9PiB7XG4gICAgd2FybihcbiAgICAgIGBJbnZhbGlkIHdhdGNoIHNvdXJjZTogYCxcbiAgICAgIHMsXG4gICAgICBgQSB3YXRjaCBzb3VyY2UgY2FuIG9ubHkgYmUgYSBnZXR0ZXIvZWZmZWN0IGZ1bmN0aW9uLCBhIHJlZiwgYSByZWFjdGl2ZSBvYmplY3QsIG9yIGFuIGFycmF5IG9mIHRoZXNlIHR5cGVzLmBcbiAgICApO1xuICB9O1xuICBjb25zdCBpbnN0YW5jZSA9IGdldEN1cnJlbnRTY29wZSgpID09PSAoKF9hID0gY3VycmVudEluc3RhbmNlKSA9PSBudWxsID8gdm9pZCAwIDogX2Euc2NvcGUpID8gY3VycmVudEluc3RhbmNlIDogbnVsbDtcbiAgbGV0IGdldHRlcjtcbiAgbGV0IGZvcmNlVHJpZ2dlciA9IGZhbHNlO1xuICBsZXQgaXNNdWx0aVNvdXJjZSA9IGZhbHNlO1xuICBpZiAoaXNSZWYoc291cmNlKSkge1xuICAgIGdldHRlciA9ICgpID0+IHNvdXJjZS52YWx1ZTtcbiAgICBmb3JjZVRyaWdnZXIgPSBpc1NoYWxsb3ckMShzb3VyY2UpO1xuICB9IGVsc2UgaWYgKGlzUmVhY3RpdmUoc291cmNlKSkge1xuICAgIGdldHRlciA9ICgpID0+IHNvdXJjZTtcbiAgICBkZWVwID0gdHJ1ZTtcbiAgfSBlbHNlIGlmIChpc0FycmF5KHNvdXJjZSkpIHtcbiAgICBpc011bHRpU291cmNlID0gdHJ1ZTtcbiAgICBmb3JjZVRyaWdnZXIgPSBzb3VyY2Uuc29tZSgocykgPT4gaXNSZWFjdGl2ZShzKSB8fCBpc1NoYWxsb3ckMShzKSk7XG4gICAgZ2V0dGVyID0gKCkgPT4gc291cmNlLm1hcCgocykgPT4ge1xuICAgICAgaWYgKGlzUmVmKHMpKSB7XG4gICAgICAgIHJldHVybiBzLnZhbHVlO1xuICAgICAgfSBlbHNlIGlmIChpc1JlYWN0aXZlKHMpKSB7XG4gICAgICAgIHJldHVybiB0cmF2ZXJzZShzKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNGdW5jdGlvbihzKSkge1xuICAgICAgICByZXR1cm4gY2FsbFdpdGhFcnJvckhhbmRsaW5nKHMsIGluc3RhbmNlLCAyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgd2FybkludmFsaWRTb3VyY2Uocyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAoaXNGdW5jdGlvbihzb3VyY2UpKSB7XG4gICAgaWYgKGNiKSB7XG4gICAgICBnZXR0ZXIgPSAoKSA9PiBjYWxsV2l0aEVycm9ySGFuZGxpbmcoc291cmNlLCBpbnN0YW5jZSwgMik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdldHRlciA9ICgpID0+IHtcbiAgICAgICAgaWYgKGluc3RhbmNlICYmIGluc3RhbmNlLmlzVW5tb3VudGVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjbGVhbnVwKSB7XG4gICAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZyhcbiAgICAgICAgICBzb3VyY2UsXG4gICAgICAgICAgaW5zdGFuY2UsXG4gICAgICAgICAgMyxcbiAgICAgICAgICBbb25DbGVhbnVwXVxuICAgICAgICApO1xuICAgICAgfTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZ2V0dGVyID0gTk9PUDtcbiAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHdhcm5JbnZhbGlkU291cmNlKHNvdXJjZSk7XG4gIH1cbiAgaWYgKGNiICYmIGRlZXApIHtcbiAgICBjb25zdCBiYXNlR2V0dGVyID0gZ2V0dGVyO1xuICAgIGdldHRlciA9ICgpID0+IHRyYXZlcnNlKGJhc2VHZXR0ZXIoKSk7XG4gIH1cbiAgbGV0IGNsZWFudXA7XG4gIGxldCBvbkNsZWFudXAgPSAoZm4pID0+IHtcbiAgICBjbGVhbnVwID0gZWZmZWN0Lm9uU3RvcCA9ICgpID0+IHtcbiAgICAgIGNhbGxXaXRoRXJyb3JIYW5kbGluZyhmbiwgaW5zdGFuY2UsIDQpO1xuICAgIH07XG4gIH07XG4gIGxldCBzc3JDbGVhbnVwO1xuICBpZiAoaXNJblNTUkNvbXBvbmVudFNldHVwKSB7XG4gICAgb25DbGVhbnVwID0gTk9PUDtcbiAgICBpZiAoIWNiKSB7XG4gICAgICBnZXR0ZXIoKTtcbiAgICB9IGVsc2UgaWYgKGltbWVkaWF0ZSkge1xuICAgICAgY2FsbFdpdGhBc3luY0Vycm9ySGFuZGxpbmcoY2IsIGluc3RhbmNlLCAzLCBbXG4gICAgICAgIGdldHRlcigpLFxuICAgICAgICBpc011bHRpU291cmNlID8gW10gOiB2b2lkIDAsXG4gICAgICAgIG9uQ2xlYW51cFxuICAgICAgXSk7XG4gICAgfVxuICAgIGlmIChmbHVzaCA9PT0gXCJzeW5jXCIpIHtcbiAgICAgIGNvbnN0IGN0eCA9IHVzZVNTUkNvbnRleHQoKTtcbiAgICAgIHNzckNsZWFudXAgPSBjdHguX193YXRjaGVySGFuZGxlcyB8fCAoY3R4Ll9fd2F0Y2hlckhhbmRsZXMgPSBbXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBOT09QO1xuICAgIH1cbiAgfVxuICBsZXQgb2xkVmFsdWUgPSBpc011bHRpU291cmNlID8gbmV3IEFycmF5KHNvdXJjZS5sZW5ndGgpLmZpbGwoSU5JVElBTF9XQVRDSEVSX1ZBTFVFKSA6IElOSVRJQUxfV0FUQ0hFUl9WQUxVRTtcbiAgY29uc3Qgam9iID0gKCkgPT4ge1xuICAgIGlmICghZWZmZWN0LmFjdGl2ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoY2IpIHtcbiAgICAgIGNvbnN0IG5ld1ZhbHVlID0gZWZmZWN0LnJ1bigpO1xuICAgICAgaWYgKGRlZXAgfHwgZm9yY2VUcmlnZ2VyIHx8IChpc011bHRpU291cmNlID8gbmV3VmFsdWUuc29tZShcbiAgICAgICAgKHYsIGkpID0+IGhhc0NoYW5nZWQodiwgb2xkVmFsdWVbaV0pXG4gICAgICApIDogaGFzQ2hhbmdlZChuZXdWYWx1ZSwgb2xkVmFsdWUpKSB8fCBmYWxzZSkge1xuICAgICAgICBpZiAoY2xlYW51cCkge1xuICAgICAgICAgIGNsZWFudXAoKTtcbiAgICAgICAgfVxuICAgICAgICBjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZyhjYiwgaW5zdGFuY2UsIDMsIFtcbiAgICAgICAgICBuZXdWYWx1ZSxcbiAgICAgICAgICAvLyBwYXNzIHVuZGVmaW5lZCBhcyB0aGUgb2xkIHZhbHVlIHdoZW4gaXQncyBjaGFuZ2VkIGZvciB0aGUgZmlyc3QgdGltZVxuICAgICAgICAgIG9sZFZhbHVlID09PSBJTklUSUFMX1dBVENIRVJfVkFMVUUgPyB2b2lkIDAgOiBpc011bHRpU291cmNlICYmIG9sZFZhbHVlWzBdID09PSBJTklUSUFMX1dBVENIRVJfVkFMVUUgPyBbXSA6IG9sZFZhbHVlLFxuICAgICAgICAgIG9uQ2xlYW51cFxuICAgICAgICBdKTtcbiAgICAgICAgb2xkVmFsdWUgPSBuZXdWYWx1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZWZmZWN0LnJ1bigpO1xuICAgIH1cbiAgfTtcbiAgam9iLmFsbG93UmVjdXJzZSA9ICEhY2I7XG4gIGxldCBzY2hlZHVsZXI7XG4gIGlmIChmbHVzaCA9PT0gXCJzeW5jXCIpIHtcbiAgICBzY2hlZHVsZXIgPSBqb2I7XG4gIH0gZWxzZSBpZiAoZmx1c2ggPT09IFwicG9zdFwiKSB7XG4gICAgc2NoZWR1bGVyID0gKCkgPT4gcXVldWVQb3N0UmVuZGVyRWZmZWN0KGpvYiwgaW5zdGFuY2UgJiYgaW5zdGFuY2Uuc3VzcGVuc2UpO1xuICB9IGVsc2Uge1xuICAgIGpvYi5wcmUgPSB0cnVlO1xuICAgIGlmIChpbnN0YW5jZSlcbiAgICAgIGpvYi5pZCA9IGluc3RhbmNlLnVpZDtcbiAgICBzY2hlZHVsZXIgPSAoKSA9PiBxdWV1ZUpvYihqb2IpO1xuICB9XG4gIGNvbnN0IGVmZmVjdCA9IG5ldyBSZWFjdGl2ZUVmZmVjdChnZXR0ZXIsIHNjaGVkdWxlcik7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgZWZmZWN0Lm9uVHJhY2sgPSBvblRyYWNrO1xuICAgIGVmZmVjdC5vblRyaWdnZXIgPSBvblRyaWdnZXI7XG4gIH1cbiAgaWYgKGNiKSB7XG4gICAgaWYgKGltbWVkaWF0ZSkge1xuICAgICAgam9iKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9sZFZhbHVlID0gZWZmZWN0LnJ1bigpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChmbHVzaCA9PT0gXCJwb3N0XCIpIHtcbiAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QoXG4gICAgICBlZmZlY3QucnVuLmJpbmQoZWZmZWN0KSxcbiAgICAgIGluc3RhbmNlICYmIGluc3RhbmNlLnN1c3BlbnNlXG4gICAgKTtcbiAgfSBlbHNlIHtcbiAgICBlZmZlY3QucnVuKCk7XG4gIH1cbiAgY29uc3QgdW53YXRjaCA9ICgpID0+IHtcbiAgICBlZmZlY3Quc3RvcCgpO1xuICAgIGlmIChpbnN0YW5jZSAmJiBpbnN0YW5jZS5zY29wZSkge1xuICAgICAgcmVtb3ZlKGluc3RhbmNlLnNjb3BlLmVmZmVjdHMsIGVmZmVjdCk7XG4gICAgfVxuICB9O1xuICBpZiAoc3NyQ2xlYW51cClcbiAgICBzc3JDbGVhbnVwLnB1c2godW53YXRjaCk7XG4gIHJldHVybiB1bndhdGNoO1xufVxuZnVuY3Rpb24gaW5zdGFuY2VXYXRjaChzb3VyY2UsIHZhbHVlLCBvcHRpb25zKSB7XG4gIGNvbnN0IHB1YmxpY1RoaXMgPSB0aGlzLnByb3h5O1xuICBjb25zdCBnZXR0ZXIgPSBpc1N0cmluZyhzb3VyY2UpID8gc291cmNlLmluY2x1ZGVzKFwiLlwiKSA/IGNyZWF0ZVBhdGhHZXR0ZXIocHVibGljVGhpcywgc291cmNlKSA6ICgpID0+IHB1YmxpY1RoaXNbc291cmNlXSA6IHNvdXJjZS5iaW5kKHB1YmxpY1RoaXMsIHB1YmxpY1RoaXMpO1xuICBsZXQgY2I7XG4gIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgIGNiID0gdmFsdWU7XG4gIH0gZWxzZSB7XG4gICAgY2IgPSB2YWx1ZS5oYW5kbGVyO1xuICAgIG9wdGlvbnMgPSB2YWx1ZTtcbiAgfVxuICBjb25zdCBjdXIgPSBjdXJyZW50SW5zdGFuY2U7XG4gIHNldEN1cnJlbnRJbnN0YW5jZSh0aGlzKTtcbiAgY29uc3QgcmVzID0gZG9XYXRjaChnZXR0ZXIsIGNiLmJpbmQocHVibGljVGhpcyksIG9wdGlvbnMpO1xuICBpZiAoY3VyKSB7XG4gICAgc2V0Q3VycmVudEluc3RhbmNlKGN1cik7XG4gIH0gZWxzZSB7XG4gICAgdW5zZXRDdXJyZW50SW5zdGFuY2UoKTtcbiAgfVxuICByZXR1cm4gcmVzO1xufVxuZnVuY3Rpb24gY3JlYXRlUGF0aEdldHRlcihjdHgsIHBhdGgpIHtcbiAgY29uc3Qgc2VnbWVudHMgPSBwYXRoLnNwbGl0KFwiLlwiKTtcbiAgcmV0dXJuICgpID0+IHtcbiAgICBsZXQgY3VyID0gY3R4O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2VnbWVudHMubGVuZ3RoICYmIGN1cjsgaSsrKSB7XG4gICAgICBjdXIgPSBjdXJbc2VnbWVudHNbaV1dO1xuICAgIH1cbiAgICByZXR1cm4gY3VyO1xuICB9O1xufVxuZnVuY3Rpb24gdHJhdmVyc2UodmFsdWUsIHNlZW4pIHtcbiAgaWYgKCFpc09iamVjdCh2YWx1ZSkgfHwgdmFsdWVbXCJfX3Zfc2tpcFwiXSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBzZWVuID0gc2VlbiB8fCAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBpZiAoc2Vlbi5oYXModmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHNlZW4uYWRkKHZhbHVlKTtcbiAgaWYgKGlzUmVmKHZhbHVlKSkge1xuICAgIHRyYXZlcnNlKHZhbHVlLnZhbHVlLCBzZWVuKTtcbiAgfSBlbHNlIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRyYXZlcnNlKHZhbHVlW2ldLCBzZWVuKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNTZXQodmFsdWUpIHx8IGlzTWFwKHZhbHVlKSkge1xuICAgIHZhbHVlLmZvckVhY2goKHYpID0+IHtcbiAgICAgIHRyYXZlcnNlKHYsIHNlZW4pO1xuICAgIH0pO1xuICB9IGVsc2UgaWYgKGlzUGxhaW5PYmplY3QodmFsdWUpKSB7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gdmFsdWUpIHtcbiAgICAgIHRyYXZlcnNlKHZhbHVlW2tleV0sIHNlZW4pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlRGlyZWN0aXZlTmFtZShuYW1lKSB7XG4gIGlmIChpc0J1aWx0SW5EaXJlY3RpdmUobmFtZSkpIHtcbiAgICB3YXJuKFwiRG8gbm90IHVzZSBidWlsdC1pbiBkaXJlY3RpdmUgaWRzIGFzIGN1c3RvbSBkaXJlY3RpdmUgaWQ6IFwiICsgbmFtZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHdpdGhEaXJlY3RpdmVzKHZub2RlLCBkaXJlY3RpdmVzKSB7XG4gIGNvbnN0IGludGVybmFsSW5zdGFuY2UgPSBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2U7XG4gIGlmIChpbnRlcm5hbEluc3RhbmNlID09PSBudWxsKSB7XG4gICAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiB3YXJuKGB3aXRoRGlyZWN0aXZlcyBjYW4gb25seSBiZSB1c2VkIGluc2lkZSByZW5kZXIgZnVuY3Rpb25zLmApO1xuICAgIHJldHVybiB2bm9kZTtcbiAgfVxuICBjb25zdCBpbnN0YW5jZSA9IGdldEV4cG9zZVByb3h5KGludGVybmFsSW5zdGFuY2UpIHx8IGludGVybmFsSW5zdGFuY2UucHJveHk7XG4gIGNvbnN0IGJpbmRpbmdzID0gdm5vZGUuZGlycyB8fCAodm5vZGUuZGlycyA9IFtdKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBkaXJlY3RpdmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgbGV0IFtkaXIsIHZhbHVlLCBhcmcsIG1vZGlmaWVycyA9IEVNUFRZX09CSl0gPSBkaXJlY3RpdmVzW2ldO1xuICAgIGlmIChkaXIpIHtcbiAgICAgIGlmIChpc0Z1bmN0aW9uKGRpcikpIHtcbiAgICAgICAgZGlyID0ge1xuICAgICAgICAgIG1vdW50ZWQ6IGRpcixcbiAgICAgICAgICB1cGRhdGVkOiBkaXJcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGlmIChkaXIuZGVlcCkge1xuICAgICAgICB0cmF2ZXJzZSh2YWx1ZSk7XG4gICAgICB9XG4gICAgICBiaW5kaW5ncy5wdXNoKHtcbiAgICAgICAgZGlyLFxuICAgICAgICBpbnN0YW5jZSxcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIG9sZFZhbHVlOiB2b2lkIDAsXG4gICAgICAgIGFyZyxcbiAgICAgICAgbW9kaWZpZXJzXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHZub2RlO1xufVxuZnVuY3Rpb24gaW52b2tlRGlyZWN0aXZlSG9vayh2bm9kZSwgcHJldlZOb2RlLCBpbnN0YW5jZSwgbmFtZSkge1xuICBjb25zdCBiaW5kaW5ncyA9IHZub2RlLmRpcnM7XG4gIGNvbnN0IG9sZEJpbmRpbmdzID0gcHJldlZOb2RlICYmIHByZXZWTm9kZS5kaXJzO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGJpbmRpbmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgYmluZGluZyA9IGJpbmRpbmdzW2ldO1xuICAgIGlmIChvbGRCaW5kaW5ncykge1xuICAgICAgYmluZGluZy5vbGRWYWx1ZSA9IG9sZEJpbmRpbmdzW2ldLnZhbHVlO1xuICAgIH1cbiAgICBsZXQgaG9vayA9IGJpbmRpbmcuZGlyW25hbWVdO1xuICAgIGlmIChob29rKSB7XG4gICAgICBwYXVzZVRyYWNraW5nKCk7XG4gICAgICBjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZyhob29rLCBpbnN0YW5jZSwgOCwgW1xuICAgICAgICB2bm9kZS5lbCxcbiAgICAgICAgYmluZGluZyxcbiAgICAgICAgdm5vZGUsXG4gICAgICAgIHByZXZWTm9kZVxuICAgICAgXSk7XG4gICAgICByZXNldFRyYWNraW5nKCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHVzZVRyYW5zaXRpb25TdGF0ZSgpIHtcbiAgY29uc3Qgc3RhdGUgPSB7XG4gICAgaXNNb3VudGVkOiBmYWxzZSxcbiAgICBpc0xlYXZpbmc6IGZhbHNlLFxuICAgIGlzVW5tb3VudGluZzogZmFsc2UsXG4gICAgbGVhdmluZ1ZOb2RlczogLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKVxuICB9O1xuICBvbk1vdW50ZWQoKCkgPT4ge1xuICAgIHN0YXRlLmlzTW91bnRlZCA9IHRydWU7XG4gIH0pO1xuICBvbkJlZm9yZVVubW91bnQoKCkgPT4ge1xuICAgIHN0YXRlLmlzVW5tb3VudGluZyA9IHRydWU7XG4gIH0pO1xuICByZXR1cm4gc3RhdGU7XG59XG5jb25zdCBUcmFuc2l0aW9uSG9va1ZhbGlkYXRvciA9IFtGdW5jdGlvbiwgQXJyYXldO1xuY29uc3QgQmFzZVRyYW5zaXRpb25Qcm9wc1ZhbGlkYXRvcnMgPSB7XG4gIG1vZGU6IFN0cmluZyxcbiAgYXBwZWFyOiBCb29sZWFuLFxuICBwZXJzaXN0ZWQ6IEJvb2xlYW4sXG4gIC8vIGVudGVyXG4gIG9uQmVmb3JlRW50ZXI6IFRyYW5zaXRpb25Ib29rVmFsaWRhdG9yLFxuICBvbkVudGVyOiBUcmFuc2l0aW9uSG9va1ZhbGlkYXRvcixcbiAgb25BZnRlckVudGVyOiBUcmFuc2l0aW9uSG9va1ZhbGlkYXRvcixcbiAgb25FbnRlckNhbmNlbGxlZDogVHJhbnNpdGlvbkhvb2tWYWxpZGF0b3IsXG4gIC8vIGxlYXZlXG4gIG9uQmVmb3JlTGVhdmU6IFRyYW5zaXRpb25Ib29rVmFsaWRhdG9yLFxuICBvbkxlYXZlOiBUcmFuc2l0aW9uSG9va1ZhbGlkYXRvcixcbiAgb25BZnRlckxlYXZlOiBUcmFuc2l0aW9uSG9va1ZhbGlkYXRvcixcbiAgb25MZWF2ZUNhbmNlbGxlZDogVHJhbnNpdGlvbkhvb2tWYWxpZGF0b3IsXG4gIC8vIGFwcGVhclxuICBvbkJlZm9yZUFwcGVhcjogVHJhbnNpdGlvbkhvb2tWYWxpZGF0b3IsXG4gIG9uQXBwZWFyOiBUcmFuc2l0aW9uSG9va1ZhbGlkYXRvcixcbiAgb25BZnRlckFwcGVhcjogVHJhbnNpdGlvbkhvb2tWYWxpZGF0b3IsXG4gIG9uQXBwZWFyQ2FuY2VsbGVkOiBUcmFuc2l0aW9uSG9va1ZhbGlkYXRvclxufTtcbmNvbnN0IEJhc2VUcmFuc2l0aW9uSW1wbCA9IHtcbiAgbmFtZTogYEJhc2VUcmFuc2l0aW9uYCxcbiAgcHJvcHM6IEJhc2VUcmFuc2l0aW9uUHJvcHNWYWxpZGF0b3JzLFxuICBzZXR1cChwcm9wcywgeyBzbG90cyB9KSB7XG4gICAgY29uc3QgaW5zdGFuY2UgPSBnZXRDdXJyZW50SW5zdGFuY2UoKTtcbiAgICBjb25zdCBzdGF0ZSA9IHVzZVRyYW5zaXRpb25TdGF0ZSgpO1xuICAgIGxldCBwcmV2VHJhbnNpdGlvbktleTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgY29uc3QgY2hpbGRyZW4gPSBzbG90cy5kZWZhdWx0ICYmIGdldFRyYW5zaXRpb25SYXdDaGlsZHJlbihzbG90cy5kZWZhdWx0KCksIHRydWUpO1xuICAgICAgaWYgKCFjaGlsZHJlbiB8fCAhY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGxldCBjaGlsZCA9IGNoaWxkcmVuWzBdO1xuICAgICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgbGV0IGhhc0ZvdW5kID0gZmFsc2U7XG4gICAgICAgIGZvciAoY29uc3QgYyBvZiBjaGlsZHJlbikge1xuICAgICAgICAgIGlmIChjLnR5cGUgIT09IENvbW1lbnQpIHtcbiAgICAgICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGhhc0ZvdW5kKSB7XG4gICAgICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAgICAgXCI8dHJhbnNpdGlvbj4gY2FuIG9ubHkgYmUgdXNlZCBvbiBhIHNpbmdsZSBlbGVtZW50IG9yIGNvbXBvbmVudC4gVXNlIDx0cmFuc2l0aW9uLWdyb3VwPiBmb3IgbGlzdHMuXCJcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjaGlsZCA9IGM7XG4gICAgICAgICAgICBoYXNGb3VuZCA9IHRydWU7XG4gICAgICAgICAgICBpZiAoISEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpXG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgcmF3UHJvcHMgPSB0b1Jhdyhwcm9wcyk7XG4gICAgICBjb25zdCB7IG1vZGUgfSA9IHJhd1Byb3BzO1xuICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgbW9kZSAmJiBtb2RlICE9PSBcImluLW91dFwiICYmIG1vZGUgIT09IFwib3V0LWluXCIgJiYgbW9kZSAhPT0gXCJkZWZhdWx0XCIpIHtcbiAgICAgICAgd2FybihgaW52YWxpZCA8dHJhbnNpdGlvbj4gbW9kZTogJHttb2RlfWApO1xuICAgICAgfVxuICAgICAgaWYgKHN0YXRlLmlzTGVhdmluZykge1xuICAgICAgICByZXR1cm4gZW1wdHlQbGFjZWhvbGRlcihjaGlsZCk7XG4gICAgICB9XG4gICAgICBjb25zdCBpbm5lckNoaWxkID0gZ2V0S2VlcEFsaXZlQ2hpbGQoY2hpbGQpO1xuICAgICAgaWYgKCFpbm5lckNoaWxkKSB7XG4gICAgICAgIHJldHVybiBlbXB0eVBsYWNlaG9sZGVyKGNoaWxkKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGVudGVySG9va3MgPSByZXNvbHZlVHJhbnNpdGlvbkhvb2tzKFxuICAgICAgICBpbm5lckNoaWxkLFxuICAgICAgICByYXdQcm9wcyxcbiAgICAgICAgc3RhdGUsXG4gICAgICAgIGluc3RhbmNlXG4gICAgICApO1xuICAgICAgc2V0VHJhbnNpdGlvbkhvb2tzKGlubmVyQ2hpbGQsIGVudGVySG9va3MpO1xuICAgICAgY29uc3Qgb2xkQ2hpbGQgPSBpbnN0YW5jZS5zdWJUcmVlO1xuICAgICAgY29uc3Qgb2xkSW5uZXJDaGlsZCA9IG9sZENoaWxkICYmIGdldEtlZXBBbGl2ZUNoaWxkKG9sZENoaWxkKTtcbiAgICAgIGxldCB0cmFuc2l0aW9uS2V5Q2hhbmdlZCA9IGZhbHNlO1xuICAgICAgY29uc3QgeyBnZXRUcmFuc2l0aW9uS2V5IH0gPSBpbm5lckNoaWxkLnR5cGU7XG4gICAgICBpZiAoZ2V0VHJhbnNpdGlvbktleSkge1xuICAgICAgICBjb25zdCBrZXkgPSBnZXRUcmFuc2l0aW9uS2V5KCk7XG4gICAgICAgIGlmIChwcmV2VHJhbnNpdGlvbktleSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgcHJldlRyYW5zaXRpb25LZXkgPSBrZXk7XG4gICAgICAgIH0gZWxzZSBpZiAoa2V5ICE9PSBwcmV2VHJhbnNpdGlvbktleSkge1xuICAgICAgICAgIHByZXZUcmFuc2l0aW9uS2V5ID0ga2V5O1xuICAgICAgICAgIHRyYW5zaXRpb25LZXlDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG9sZElubmVyQ2hpbGQgJiYgb2xkSW5uZXJDaGlsZC50eXBlICE9PSBDb21tZW50ICYmICghaXNTYW1lVk5vZGVUeXBlKGlubmVyQ2hpbGQsIG9sZElubmVyQ2hpbGQpIHx8IHRyYW5zaXRpb25LZXlDaGFuZ2VkKSkge1xuICAgICAgICBjb25zdCBsZWF2aW5nSG9va3MgPSByZXNvbHZlVHJhbnNpdGlvbkhvb2tzKFxuICAgICAgICAgIG9sZElubmVyQ2hpbGQsXG4gICAgICAgICAgcmF3UHJvcHMsXG4gICAgICAgICAgc3RhdGUsXG4gICAgICAgICAgaW5zdGFuY2VcbiAgICAgICAgKTtcbiAgICAgICAgc2V0VHJhbnNpdGlvbkhvb2tzKG9sZElubmVyQ2hpbGQsIGxlYXZpbmdIb29rcyk7XG4gICAgICAgIGlmIChtb2RlID09PSBcIm91dC1pblwiKSB7XG4gICAgICAgICAgc3RhdGUuaXNMZWF2aW5nID0gdHJ1ZTtcbiAgICAgICAgICBsZWF2aW5nSG9va3MuYWZ0ZXJMZWF2ZSA9ICgpID0+IHtcbiAgICAgICAgICAgIHN0YXRlLmlzTGVhdmluZyA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKGluc3RhbmNlLnVwZGF0ZS5hY3RpdmUgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgIGluc3RhbmNlLnVwZGF0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgICAgcmV0dXJuIGVtcHR5UGxhY2Vob2xkZXIoY2hpbGQpO1xuICAgICAgICB9IGVsc2UgaWYgKG1vZGUgPT09IFwiaW4tb3V0XCIgJiYgaW5uZXJDaGlsZC50eXBlICE9PSBDb21tZW50KSB7XG4gICAgICAgICAgbGVhdmluZ0hvb2tzLmRlbGF5TGVhdmUgPSAoZWwsIGVhcmx5UmVtb3ZlLCBkZWxheWVkTGVhdmUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGxlYXZpbmdWTm9kZXNDYWNoZSA9IGdldExlYXZpbmdOb2Rlc0ZvclR5cGUoXG4gICAgICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgICAgICBvbGRJbm5lckNoaWxkXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgbGVhdmluZ1ZOb2Rlc0NhY2hlW1N0cmluZyhvbGRJbm5lckNoaWxkLmtleSldID0gb2xkSW5uZXJDaGlsZDtcbiAgICAgICAgICAgIGVsLl9sZWF2ZUNiID0gKCkgPT4ge1xuICAgICAgICAgICAgICBlYXJseVJlbW92ZSgpO1xuICAgICAgICAgICAgICBlbC5fbGVhdmVDYiA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgZGVsZXRlIGVudGVySG9va3MuZGVsYXllZExlYXZlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGVudGVySG9va3MuZGVsYXllZExlYXZlID0gZGVsYXllZExlYXZlO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBjaGlsZDtcbiAgICB9O1xuICB9XG59O1xuY29uc3QgQmFzZVRyYW5zaXRpb24gPSBCYXNlVHJhbnNpdGlvbkltcGw7XG5mdW5jdGlvbiBnZXRMZWF2aW5nTm9kZXNGb3JUeXBlKHN0YXRlLCB2bm9kZSkge1xuICBjb25zdCB7IGxlYXZpbmdWTm9kZXMgfSA9IHN0YXRlO1xuICBsZXQgbGVhdmluZ1ZOb2Rlc0NhY2hlID0gbGVhdmluZ1ZOb2Rlcy5nZXQodm5vZGUudHlwZSk7XG4gIGlmICghbGVhdmluZ1ZOb2Rlc0NhY2hlKSB7XG4gICAgbGVhdmluZ1ZOb2Rlc0NhY2hlID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgbGVhdmluZ1ZOb2Rlcy5zZXQodm5vZGUudHlwZSwgbGVhdmluZ1ZOb2Rlc0NhY2hlKTtcbiAgfVxuICByZXR1cm4gbGVhdmluZ1ZOb2Rlc0NhY2hlO1xufVxuZnVuY3Rpb24gcmVzb2x2ZVRyYW5zaXRpb25Ib29rcyh2bm9kZSwgcHJvcHMsIHN0YXRlLCBpbnN0YW5jZSkge1xuICBjb25zdCB7XG4gICAgYXBwZWFyLFxuICAgIG1vZGUsXG4gICAgcGVyc2lzdGVkID0gZmFsc2UsXG4gICAgb25CZWZvcmVFbnRlcixcbiAgICBvbkVudGVyLFxuICAgIG9uQWZ0ZXJFbnRlcixcbiAgICBvbkVudGVyQ2FuY2VsbGVkLFxuICAgIG9uQmVmb3JlTGVhdmUsXG4gICAgb25MZWF2ZSxcbiAgICBvbkFmdGVyTGVhdmUsXG4gICAgb25MZWF2ZUNhbmNlbGxlZCxcbiAgICBvbkJlZm9yZUFwcGVhcixcbiAgICBvbkFwcGVhcixcbiAgICBvbkFmdGVyQXBwZWFyLFxuICAgIG9uQXBwZWFyQ2FuY2VsbGVkXG4gIH0gPSBwcm9wcztcbiAgY29uc3Qga2V5ID0gU3RyaW5nKHZub2RlLmtleSk7XG4gIGNvbnN0IGxlYXZpbmdWTm9kZXNDYWNoZSA9IGdldExlYXZpbmdOb2Rlc0ZvclR5cGUoc3RhdGUsIHZub2RlKTtcbiAgY29uc3QgY2FsbEhvb2sgPSAoaG9vaywgYXJncykgPT4ge1xuICAgIGhvb2sgJiYgY2FsbFdpdGhBc3luY0Vycm9ySGFuZGxpbmcoXG4gICAgICBob29rLFxuICAgICAgaW5zdGFuY2UsXG4gICAgICA5LFxuICAgICAgYXJnc1xuICAgICk7XG4gIH07XG4gIGNvbnN0IGNhbGxBc3luY0hvb2sgPSAoaG9vaywgYXJncykgPT4ge1xuICAgIGNvbnN0IGRvbmUgPSBhcmdzWzFdO1xuICAgIGNhbGxIb29rKGhvb2ssIGFyZ3MpO1xuICAgIGlmIChpc0FycmF5KGhvb2spKSB7XG4gICAgICBpZiAoaG9vay5ldmVyeSgoaG9vazIpID0+IGhvb2syLmxlbmd0aCA8PSAxKSlcbiAgICAgICAgZG9uZSgpO1xuICAgIH0gZWxzZSBpZiAoaG9vay5sZW5ndGggPD0gMSkge1xuICAgICAgZG9uZSgpO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgaG9va3MgPSB7XG4gICAgbW9kZSxcbiAgICBwZXJzaXN0ZWQsXG4gICAgYmVmb3JlRW50ZXIoZWwpIHtcbiAgICAgIGxldCBob29rID0gb25CZWZvcmVFbnRlcjtcbiAgICAgIGlmICghc3RhdGUuaXNNb3VudGVkKSB7XG4gICAgICAgIGlmIChhcHBlYXIpIHtcbiAgICAgICAgICBob29rID0gb25CZWZvcmVBcHBlYXIgfHwgb25CZWZvcmVFbnRlcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChlbC5fbGVhdmVDYikge1xuICAgICAgICBlbC5fbGVhdmVDYihcbiAgICAgICAgICB0cnVlXG4gICAgICAgICAgLyogY2FuY2VsbGVkICovXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBjb25zdCBsZWF2aW5nVk5vZGUgPSBsZWF2aW5nVk5vZGVzQ2FjaGVba2V5XTtcbiAgICAgIGlmIChsZWF2aW5nVk5vZGUgJiYgaXNTYW1lVk5vZGVUeXBlKHZub2RlLCBsZWF2aW5nVk5vZGUpICYmIGxlYXZpbmdWTm9kZS5lbC5fbGVhdmVDYikge1xuICAgICAgICBsZWF2aW5nVk5vZGUuZWwuX2xlYXZlQ2IoKTtcbiAgICAgIH1cbiAgICAgIGNhbGxIb29rKGhvb2ssIFtlbF0pO1xuICAgIH0sXG4gICAgZW50ZXIoZWwpIHtcbiAgICAgIGxldCBob29rID0gb25FbnRlcjtcbiAgICAgIGxldCBhZnRlckhvb2sgPSBvbkFmdGVyRW50ZXI7XG4gICAgICBsZXQgY2FuY2VsSG9vayA9IG9uRW50ZXJDYW5jZWxsZWQ7XG4gICAgICBpZiAoIXN0YXRlLmlzTW91bnRlZCkge1xuICAgICAgICBpZiAoYXBwZWFyKSB7XG4gICAgICAgICAgaG9vayA9IG9uQXBwZWFyIHx8IG9uRW50ZXI7XG4gICAgICAgICAgYWZ0ZXJIb29rID0gb25BZnRlckFwcGVhciB8fCBvbkFmdGVyRW50ZXI7XG4gICAgICAgICAgY2FuY2VsSG9vayA9IG9uQXBwZWFyQ2FuY2VsbGVkIHx8IG9uRW50ZXJDYW5jZWxsZWQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBsZXQgY2FsbGVkID0gZmFsc2U7XG4gICAgICBjb25zdCBkb25lID0gZWwuX2VudGVyQ2IgPSAoY2FuY2VsbGVkKSA9PiB7XG4gICAgICAgIGlmIChjYWxsZWQpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjYWxsZWQgPSB0cnVlO1xuICAgICAgICBpZiAoY2FuY2VsbGVkKSB7XG4gICAgICAgICAgY2FsbEhvb2soY2FuY2VsSG9vaywgW2VsXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2FsbEhvb2soYWZ0ZXJIb29rLCBbZWxdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaG9va3MuZGVsYXllZExlYXZlKSB7XG4gICAgICAgICAgaG9va3MuZGVsYXllZExlYXZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWwuX2VudGVyQ2IgPSB2b2lkIDA7XG4gICAgICB9O1xuICAgICAgaWYgKGhvb2spIHtcbiAgICAgICAgY2FsbEFzeW5jSG9vayhob29rLCBbZWwsIGRvbmVdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRvbmUoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGxlYXZlKGVsLCByZW1vdmUpIHtcbiAgICAgIGNvbnN0IGtleTIgPSBTdHJpbmcodm5vZGUua2V5KTtcbiAgICAgIGlmIChlbC5fZW50ZXJDYikge1xuICAgICAgICBlbC5fZW50ZXJDYihcbiAgICAgICAgICB0cnVlXG4gICAgICAgICAgLyogY2FuY2VsbGVkICovXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAoc3RhdGUuaXNVbm1vdW50aW5nKSB7XG4gICAgICAgIHJldHVybiByZW1vdmUoKTtcbiAgICAgIH1cbiAgICAgIGNhbGxIb29rKG9uQmVmb3JlTGVhdmUsIFtlbF0pO1xuICAgICAgbGV0IGNhbGxlZCA9IGZhbHNlO1xuICAgICAgY29uc3QgZG9uZSA9IGVsLl9sZWF2ZUNiID0gKGNhbmNlbGxlZCkgPT4ge1xuICAgICAgICBpZiAoY2FsbGVkKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgcmVtb3ZlKCk7XG4gICAgICAgIGlmIChjYW5jZWxsZWQpIHtcbiAgICAgICAgICBjYWxsSG9vayhvbkxlYXZlQ2FuY2VsbGVkLCBbZWxdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjYWxsSG9vayhvbkFmdGVyTGVhdmUsIFtlbF0pO1xuICAgICAgICB9XG4gICAgICAgIGVsLl9sZWF2ZUNiID0gdm9pZCAwO1xuICAgICAgICBpZiAobGVhdmluZ1ZOb2Rlc0NhY2hlW2tleTJdID09PSB2bm9kZSkge1xuICAgICAgICAgIGRlbGV0ZSBsZWF2aW5nVk5vZGVzQ2FjaGVba2V5Ml07XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBsZWF2aW5nVk5vZGVzQ2FjaGVba2V5Ml0gPSB2bm9kZTtcbiAgICAgIGlmIChvbkxlYXZlKSB7XG4gICAgICAgIGNhbGxBc3luY0hvb2sob25MZWF2ZSwgW2VsLCBkb25lXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkb25lKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBjbG9uZSh2bm9kZTIpIHtcbiAgICAgIHJldHVybiByZXNvbHZlVHJhbnNpdGlvbkhvb2tzKHZub2RlMiwgcHJvcHMsIHN0YXRlLCBpbnN0YW5jZSk7XG4gICAgfVxuICB9O1xuICByZXR1cm4gaG9va3M7XG59XG5mdW5jdGlvbiBlbXB0eVBsYWNlaG9sZGVyKHZub2RlKSB7XG4gIGlmIChpc0tlZXBBbGl2ZSh2bm9kZSkpIHtcbiAgICB2bm9kZSA9IGNsb25lVk5vZGUodm5vZGUpO1xuICAgIHZub2RlLmNoaWxkcmVuID0gbnVsbDtcbiAgICByZXR1cm4gdm5vZGU7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldEtlZXBBbGl2ZUNoaWxkKHZub2RlKSB7XG4gIHJldHVybiBpc0tlZXBBbGl2ZSh2bm9kZSkgPyB2bm9kZS5jaGlsZHJlbiA/IHZub2RlLmNoaWxkcmVuWzBdIDogdm9pZCAwIDogdm5vZGU7XG59XG5mdW5jdGlvbiBzZXRUcmFuc2l0aW9uSG9va3Modm5vZGUsIGhvb2tzKSB7XG4gIGlmICh2bm9kZS5zaGFwZUZsYWcgJiA2ICYmIHZub2RlLmNvbXBvbmVudCkge1xuICAgIHNldFRyYW5zaXRpb25Ib29rcyh2bm9kZS5jb21wb25lbnQuc3ViVHJlZSwgaG9va3MpO1xuICB9IGVsc2UgaWYgKHZub2RlLnNoYXBlRmxhZyAmIDEyOCkge1xuICAgIHZub2RlLnNzQ29udGVudC50cmFuc2l0aW9uID0gaG9va3MuY2xvbmUodm5vZGUuc3NDb250ZW50KTtcbiAgICB2bm9kZS5zc0ZhbGxiYWNrLnRyYW5zaXRpb24gPSBob29rcy5jbG9uZSh2bm9kZS5zc0ZhbGxiYWNrKTtcbiAgfSBlbHNlIHtcbiAgICB2bm9kZS50cmFuc2l0aW9uID0gaG9va3M7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldFRyYW5zaXRpb25SYXdDaGlsZHJlbihjaGlsZHJlbiwga2VlcENvbW1lbnQgPSBmYWxzZSwgcGFyZW50S2V5KSB7XG4gIGxldCByZXQgPSBbXTtcbiAgbGV0IGtleWVkRnJhZ21lbnRDb3VudCA9IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICBsZXQgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICBjb25zdCBrZXkgPSBwYXJlbnRLZXkgPT0gbnVsbCA/IGNoaWxkLmtleSA6IFN0cmluZyhwYXJlbnRLZXkpICsgU3RyaW5nKGNoaWxkLmtleSAhPSBudWxsID8gY2hpbGQua2V5IDogaSk7XG4gICAgaWYgKGNoaWxkLnR5cGUgPT09IEZyYWdtZW50KSB7XG4gICAgICBpZiAoY2hpbGQucGF0Y2hGbGFnICYgMTI4KVxuICAgICAgICBrZXllZEZyYWdtZW50Q291bnQrKztcbiAgICAgIHJldCA9IHJldC5jb25jYXQoXG4gICAgICAgIGdldFRyYW5zaXRpb25SYXdDaGlsZHJlbihjaGlsZC5jaGlsZHJlbiwga2VlcENvbW1lbnQsIGtleSlcbiAgICAgICk7XG4gICAgfSBlbHNlIGlmIChrZWVwQ29tbWVudCB8fCBjaGlsZC50eXBlICE9PSBDb21tZW50KSB7XG4gICAgICByZXQucHVzaChrZXkgIT0gbnVsbCA/IGNsb25lVk5vZGUoY2hpbGQsIHsga2V5IH0pIDogY2hpbGQpO1xuICAgIH1cbiAgfVxuICBpZiAoa2V5ZWRGcmFnbWVudENvdW50ID4gMSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmV0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICByZXRbaV0ucGF0Y2hGbGFnID0gLTI7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGRlZmluZUNvbXBvbmVudChvcHRpb25zLCBleHRyYU9wdGlvbnMpIHtcbiAgcmV0dXJuIGlzRnVuY3Rpb24ob3B0aW9ucykgPyAoXG4gICAgLy8gIzgzMjY6IGV4dGVuZCBjYWxsIGFuZCBvcHRpb25zLm5hbWUgYWNjZXNzIGFyZSBjb25zaWRlcmVkIHNpZGUtZWZmZWN0c1xuICAgIC8vIGJ5IFJvbGx1cCwgc28gd2UgaGF2ZSB0byB3cmFwIGl0IGluIGEgcHVyZS1hbm5vdGF0ZWQgSUlGRS5cbiAgICAvKiBAX19QVVJFX18gKi8gKCgpID0+IGV4dGVuZCh7IG5hbWU6IG9wdGlvbnMubmFtZSB9LCBleHRyYU9wdGlvbnMsIHsgc2V0dXA6IG9wdGlvbnMgfSkpKClcbiAgKSA6IG9wdGlvbnM7XG59XG5cbmNvbnN0IGlzQXN5bmNXcmFwcGVyID0gKGkpID0+ICEhaS50eXBlLl9fYXN5bmNMb2FkZXI7XG5mdW5jdGlvbiBkZWZpbmVBc3luY0NvbXBvbmVudChzb3VyY2UpIHtcbiAgaWYgKGlzRnVuY3Rpb24oc291cmNlKSkge1xuICAgIHNvdXJjZSA9IHsgbG9hZGVyOiBzb3VyY2UgfTtcbiAgfVxuICBjb25zdCB7XG4gICAgbG9hZGVyLFxuICAgIGxvYWRpbmdDb21wb25lbnQsXG4gICAgZXJyb3JDb21wb25lbnQsXG4gICAgZGVsYXkgPSAyMDAsXG4gICAgdGltZW91dCxcbiAgICAvLyB1bmRlZmluZWQgPSBuZXZlciB0aW1lcyBvdXRcbiAgICBzdXNwZW5zaWJsZSA9IHRydWUsXG4gICAgb25FcnJvcjogdXNlck9uRXJyb3JcbiAgfSA9IHNvdXJjZTtcbiAgbGV0IHBlbmRpbmdSZXF1ZXN0ID0gbnVsbDtcbiAgbGV0IHJlc29sdmVkQ29tcDtcbiAgbGV0IHJldHJpZXMgPSAwO1xuICBjb25zdCByZXRyeSA9ICgpID0+IHtcbiAgICByZXRyaWVzKys7XG4gICAgcGVuZGluZ1JlcXVlc3QgPSBudWxsO1xuICAgIHJldHVybiBsb2FkKCk7XG4gIH07XG4gIGNvbnN0IGxvYWQgPSAoKSA9PiB7XG4gICAgbGV0IHRoaXNSZXF1ZXN0O1xuICAgIHJldHVybiBwZW5kaW5nUmVxdWVzdCB8fCAodGhpc1JlcXVlc3QgPSBwZW5kaW5nUmVxdWVzdCA9IGxvYWRlcigpLmNhdGNoKChlcnIpID0+IHtcbiAgICAgIGVyciA9IGVyciBpbnN0YW5jZW9mIEVycm9yID8gZXJyIDogbmV3IEVycm9yKFN0cmluZyhlcnIpKTtcbiAgICAgIGlmICh1c2VyT25FcnJvcikge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHVzZXJSZXRyeSA9ICgpID0+IHJlc29sdmUocmV0cnkoKSk7XG4gICAgICAgICAgY29uc3QgdXNlckZhaWwgPSAoKSA9PiByZWplY3QoZXJyKTtcbiAgICAgICAgICB1c2VyT25FcnJvcihlcnIsIHVzZXJSZXRyeSwgdXNlckZhaWwsIHJldHJpZXMgKyAxKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9XG4gICAgfSkudGhlbigoY29tcCkgPT4ge1xuICAgICAgaWYgKHRoaXNSZXF1ZXN0ICE9PSBwZW5kaW5nUmVxdWVzdCAmJiBwZW5kaW5nUmVxdWVzdCkge1xuICAgICAgICByZXR1cm4gcGVuZGluZ1JlcXVlc3Q7XG4gICAgICB9XG4gICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhY29tcCkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIGBBc3luYyBjb21wb25lbnQgbG9hZGVyIHJlc29sdmVkIHRvIHVuZGVmaW5lZC4gSWYgeW91IGFyZSB1c2luZyByZXRyeSgpLCBtYWtlIHN1cmUgdG8gcmV0dXJuIGl0cyByZXR1cm4gdmFsdWUuYFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKGNvbXAgJiYgKGNvbXAuX19lc01vZHVsZSB8fCBjb21wW1N5bWJvbC50b1N0cmluZ1RhZ10gPT09IFwiTW9kdWxlXCIpKSB7XG4gICAgICAgIGNvbXAgPSBjb21wLmRlZmF1bHQ7XG4gICAgICB9XG4gICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBjb21wICYmICFpc09iamVjdChjb21wKSAmJiAhaXNGdW5jdGlvbihjb21wKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgYXN5bmMgY29tcG9uZW50IGxvYWQgcmVzdWx0OiAke2NvbXB9YCk7XG4gICAgICB9XG4gICAgICByZXNvbHZlZENvbXAgPSBjb21wO1xuICAgICAgcmV0dXJuIGNvbXA7XG4gICAgfSkpO1xuICB9O1xuICByZXR1cm4gZGVmaW5lQ29tcG9uZW50KHtcbiAgICBuYW1lOiBcIkFzeW5jQ29tcG9uZW50V3JhcHBlclwiLFxuICAgIF9fYXN5bmNMb2FkZXI6IGxvYWQsXG4gICAgZ2V0IF9fYXN5bmNSZXNvbHZlZCgpIHtcbiAgICAgIHJldHVybiByZXNvbHZlZENvbXA7XG4gICAgfSxcbiAgICBzZXR1cCgpIHtcbiAgICAgIGNvbnN0IGluc3RhbmNlID0gY3VycmVudEluc3RhbmNlO1xuICAgICAgaWYgKHJlc29sdmVkQ29tcCkge1xuICAgICAgICByZXR1cm4gKCkgPT4gY3JlYXRlSW5uZXJDb21wKHJlc29sdmVkQ29tcCwgaW5zdGFuY2UpO1xuICAgICAgfVxuICAgICAgY29uc3Qgb25FcnJvciA9IChlcnIpID0+IHtcbiAgICAgICAgcGVuZGluZ1JlcXVlc3QgPSBudWxsO1xuICAgICAgICBoYW5kbGVFcnJvcihcbiAgICAgICAgICBlcnIsXG4gICAgICAgICAgaW5zdGFuY2UsXG4gICAgICAgICAgMTMsXG4gICAgICAgICAgIWVycm9yQ29tcG9uZW50XG4gICAgICAgICAgLyogZG8gbm90IHRocm93IGluIGRldiBpZiB1c2VyIHByb3ZpZGVkIGVycm9yIGNvbXBvbmVudCAqL1xuICAgICAgICApO1xuICAgICAgfTtcbiAgICAgIGlmIChzdXNwZW5zaWJsZSAmJiBpbnN0YW5jZS5zdXNwZW5zZSB8fCBpc0luU1NSQ29tcG9uZW50U2V0dXApIHtcbiAgICAgICAgcmV0dXJuIGxvYWQoKS50aGVuKChjb21wKSA9PiB7XG4gICAgICAgICAgcmV0dXJuICgpID0+IGNyZWF0ZUlubmVyQ29tcChjb21wLCBpbnN0YW5jZSk7XG4gICAgICAgIH0pLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICBvbkVycm9yKGVycik7XG4gICAgICAgICAgcmV0dXJuICgpID0+IGVycm9yQ29tcG9uZW50ID8gY3JlYXRlVk5vZGUoZXJyb3JDb21wb25lbnQsIHtcbiAgICAgICAgICAgIGVycm9yOiBlcnJcbiAgICAgICAgICB9KSA6IG51bGw7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgY29uc3QgbG9hZGVkID0gcmVmKGZhbHNlKTtcbiAgICAgIGNvbnN0IGVycm9yID0gcmVmKCk7XG4gICAgICBjb25zdCBkZWxheWVkID0gcmVmKCEhZGVsYXkpO1xuICAgICAgaWYgKGRlbGF5KSB7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIGRlbGF5ZWQudmFsdWUgPSBmYWxzZTtcbiAgICAgICAgfSwgZGVsYXkpO1xuICAgICAgfVxuICAgICAgaWYgKHRpbWVvdXQgIT0gbnVsbCkge1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICBpZiAoIWxvYWRlZC52YWx1ZSAmJiAhZXJyb3IudmFsdWUpIHtcbiAgICAgICAgICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgYEFzeW5jIGNvbXBvbmVudCB0aW1lZCBvdXQgYWZ0ZXIgJHt0aW1lb3V0fW1zLmBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBvbkVycm9yKGVycik7XG4gICAgICAgICAgICBlcnJvci52YWx1ZSA9IGVycjtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHRpbWVvdXQpO1xuICAgICAgfVxuICAgICAgbG9hZCgpLnRoZW4oKCkgPT4ge1xuICAgICAgICBsb2FkZWQudmFsdWUgPSB0cnVlO1xuICAgICAgICBpZiAoaW5zdGFuY2UucGFyZW50ICYmIGlzS2VlcEFsaXZlKGluc3RhbmNlLnBhcmVudC52bm9kZSkpIHtcbiAgICAgICAgICBxdWV1ZUpvYihpbnN0YW5jZS5wYXJlbnQudXBkYXRlKTtcbiAgICAgICAgfVxuICAgICAgfSkuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICBvbkVycm9yKGVycik7XG4gICAgICAgIGVycm9yLnZhbHVlID0gZXJyO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBpZiAobG9hZGVkLnZhbHVlICYmIHJlc29sdmVkQ29tcCkge1xuICAgICAgICAgIHJldHVybiBjcmVhdGVJbm5lckNvbXAocmVzb2x2ZWRDb21wLCBpbnN0YW5jZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoZXJyb3IudmFsdWUgJiYgZXJyb3JDb21wb25lbnQpIHtcbiAgICAgICAgICByZXR1cm4gY3JlYXRlVk5vZGUoZXJyb3JDb21wb25lbnQsIHtcbiAgICAgICAgICAgIGVycm9yOiBlcnJvci52YWx1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKGxvYWRpbmdDb21wb25lbnQgJiYgIWRlbGF5ZWQudmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gY3JlYXRlVk5vZGUobG9hZGluZ0NvbXBvbmVudCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUlubmVyQ29tcChjb21wLCBwYXJlbnQpIHtcbiAgY29uc3QgeyByZWY6IHJlZjIsIHByb3BzLCBjaGlsZHJlbiwgY2UgfSA9IHBhcmVudC52bm9kZTtcbiAgY29uc3Qgdm5vZGUgPSBjcmVhdGVWTm9kZShjb21wLCBwcm9wcywgY2hpbGRyZW4pO1xuICB2bm9kZS5yZWYgPSByZWYyO1xuICB2bm9kZS5jZSA9IGNlO1xuICBkZWxldGUgcGFyZW50LnZub2RlLmNlO1xuICByZXR1cm4gdm5vZGU7XG59XG5cbmNvbnN0IGlzS2VlcEFsaXZlID0gKHZub2RlKSA9PiB2bm9kZS50eXBlLl9faXNLZWVwQWxpdmU7XG5jb25zdCBLZWVwQWxpdmVJbXBsID0ge1xuICBuYW1lOiBgS2VlcEFsaXZlYCxcbiAgLy8gTWFya2VyIGZvciBzcGVjaWFsIGhhbmRsaW5nIGluc2lkZSB0aGUgcmVuZGVyZXIuIFdlIGFyZSBub3QgdXNpbmcgYSA9PT1cbiAgLy8gY2hlY2sgZGlyZWN0bHkgb24gS2VlcEFsaXZlIGluIHRoZSByZW5kZXJlciwgYmVjYXVzZSBpbXBvcnRpbmcgaXQgZGlyZWN0bHlcbiAgLy8gd291bGQgcHJldmVudCBpdCBmcm9tIGJlaW5nIHRyZWUtc2hha2VuLlxuICBfX2lzS2VlcEFsaXZlOiB0cnVlLFxuICBwcm9wczoge1xuICAgIGluY2x1ZGU6IFtTdHJpbmcsIFJlZ0V4cCwgQXJyYXldLFxuICAgIGV4Y2x1ZGU6IFtTdHJpbmcsIFJlZ0V4cCwgQXJyYXldLFxuICAgIG1heDogW1N0cmluZywgTnVtYmVyXVxuICB9LFxuICBzZXR1cChwcm9wcywgeyBzbG90cyB9KSB7XG4gICAgY29uc3QgaW5zdGFuY2UgPSBnZXRDdXJyZW50SW5zdGFuY2UoKTtcbiAgICBjb25zdCBzaGFyZWRDb250ZXh0ID0gaW5zdGFuY2UuY3R4O1xuICAgIGlmICghc2hhcmVkQ29udGV4dC5yZW5kZXJlcikge1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBzbG90cy5kZWZhdWx0ICYmIHNsb3RzLmRlZmF1bHQoKTtcbiAgICAgICAgcmV0dXJuIGNoaWxkcmVuICYmIGNoaWxkcmVuLmxlbmd0aCA9PT0gMSA/IGNoaWxkcmVuWzBdIDogY2hpbGRyZW47XG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBjYWNoZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgY29uc3Qga2V5cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgbGV0IGN1cnJlbnQgPSBudWxsO1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykge1xuICAgICAgaW5zdGFuY2UuX192X2NhY2hlID0gY2FjaGU7XG4gICAgfVxuICAgIGNvbnN0IHBhcmVudFN1c3BlbnNlID0gaW5zdGFuY2Uuc3VzcGVuc2U7XG4gICAgY29uc3Qge1xuICAgICAgcmVuZGVyZXI6IHtcbiAgICAgICAgcDogcGF0Y2gsXG4gICAgICAgIG06IG1vdmUsXG4gICAgICAgIHVtOiBfdW5tb3VudCxcbiAgICAgICAgbzogeyBjcmVhdGVFbGVtZW50IH1cbiAgICAgIH1cbiAgICB9ID0gc2hhcmVkQ29udGV4dDtcbiAgICBjb25zdCBzdG9yYWdlQ29udGFpbmVyID0gY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICBzaGFyZWRDb250ZXh0LmFjdGl2YXRlID0gKHZub2RlLCBjb250YWluZXIsIGFuY2hvciwgaXNTVkcsIG9wdGltaXplZCkgPT4ge1xuICAgICAgY29uc3QgaW5zdGFuY2UyID0gdm5vZGUuY29tcG9uZW50O1xuICAgICAgbW92ZSh2bm9kZSwgY29udGFpbmVyLCBhbmNob3IsIDAsIHBhcmVudFN1c3BlbnNlKTtcbiAgICAgIHBhdGNoKFxuICAgICAgICBpbnN0YW5jZTIudm5vZGUsXG4gICAgICAgIHZub2RlLFxuICAgICAgICBjb250YWluZXIsXG4gICAgICAgIGFuY2hvcixcbiAgICAgICAgaW5zdGFuY2UyLFxuICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgaXNTVkcsXG4gICAgICAgIHZub2RlLnNsb3RTY29wZUlkcyxcbiAgICAgICAgb3B0aW1pemVkXG4gICAgICApO1xuICAgICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaW5zdGFuY2UyLmlzRGVhY3RpdmF0ZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKGluc3RhbmNlMi5hKSB7XG4gICAgICAgICAgaW52b2tlQXJyYXlGbnMoaW5zdGFuY2UyLmEpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZub2RlSG9vayA9IHZub2RlLnByb3BzICYmIHZub2RlLnByb3BzLm9uVm5vZGVNb3VudGVkO1xuICAgICAgICBpZiAodm5vZGVIb29rKSB7XG4gICAgICAgICAgaW52b2tlVk5vZGVIb29rKHZub2RlSG9vaywgaW5zdGFuY2UyLnBhcmVudCwgdm5vZGUpO1xuICAgICAgICB9XG4gICAgICB9LCBwYXJlbnRTdXNwZW5zZSk7XG4gICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcbiAgICAgICAgZGV2dG9vbHNDb21wb25lbnRBZGRlZChpbnN0YW5jZTIpO1xuICAgICAgfVxuICAgIH07XG4gICAgc2hhcmVkQ29udGV4dC5kZWFjdGl2YXRlID0gKHZub2RlKSA9PiB7XG4gICAgICBjb25zdCBpbnN0YW5jZTIgPSB2bm9kZS5jb21wb25lbnQ7XG4gICAgICBtb3ZlKHZub2RlLCBzdG9yYWdlQ29udGFpbmVyLCBudWxsLCAxLCBwYXJlbnRTdXNwZW5zZSk7XG4gICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoaW5zdGFuY2UyLmRhKSB7XG4gICAgICAgICAgaW52b2tlQXJyYXlGbnMoaW5zdGFuY2UyLmRhKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2bm9kZUhvb2sgPSB2bm9kZS5wcm9wcyAmJiB2bm9kZS5wcm9wcy5vblZub2RlVW5tb3VudGVkO1xuICAgICAgICBpZiAodm5vZGVIb29rKSB7XG4gICAgICAgICAgaW52b2tlVk5vZGVIb29rKHZub2RlSG9vaywgaW5zdGFuY2UyLnBhcmVudCwgdm5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGluc3RhbmNlMi5pc0RlYWN0aXZhdGVkID0gdHJ1ZTtcbiAgICAgIH0sIHBhcmVudFN1c3BlbnNlKTtcbiAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykge1xuICAgICAgICBkZXZ0b29sc0NvbXBvbmVudEFkZGVkKGluc3RhbmNlMik7XG4gICAgICB9XG4gICAgfTtcbiAgICBmdW5jdGlvbiB1bm1vdW50KHZub2RlKSB7XG4gICAgICByZXNldFNoYXBlRmxhZyh2bm9kZSk7XG4gICAgICBfdW5tb3VudCh2bm9kZSwgaW5zdGFuY2UsIHBhcmVudFN1c3BlbnNlLCB0cnVlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHJ1bmVDYWNoZShmaWx0ZXIpIHtcbiAgICAgIGNhY2hlLmZvckVhY2goKHZub2RlLCBrZXkpID0+IHtcbiAgICAgICAgY29uc3QgbmFtZSA9IGdldENvbXBvbmVudE5hbWUodm5vZGUudHlwZSk7XG4gICAgICAgIGlmIChuYW1lICYmICghZmlsdGVyIHx8ICFmaWx0ZXIobmFtZSkpKSB7XG4gICAgICAgICAgcHJ1bmVDYWNoZUVudHJ5KGtleSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwcnVuZUNhY2hlRW50cnkoa2V5KSB7XG4gICAgICBjb25zdCBjYWNoZWQgPSBjYWNoZS5nZXQoa2V5KTtcbiAgICAgIGlmICghY3VycmVudCB8fCAhaXNTYW1lVk5vZGVUeXBlKGNhY2hlZCwgY3VycmVudCkpIHtcbiAgICAgICAgdW5tb3VudChjYWNoZWQpO1xuICAgICAgfSBlbHNlIGlmIChjdXJyZW50KSB7XG4gICAgICAgIHJlc2V0U2hhcGVGbGFnKGN1cnJlbnQpO1xuICAgICAgfVxuICAgICAgY2FjaGUuZGVsZXRlKGtleSk7XG4gICAgICBrZXlzLmRlbGV0ZShrZXkpO1xuICAgIH1cbiAgICB3YXRjaChcbiAgICAgICgpID0+IFtwcm9wcy5pbmNsdWRlLCBwcm9wcy5leGNsdWRlXSxcbiAgICAgIChbaW5jbHVkZSwgZXhjbHVkZV0pID0+IHtcbiAgICAgICAgaW5jbHVkZSAmJiBwcnVuZUNhY2hlKChuYW1lKSA9PiBtYXRjaGVzKGluY2x1ZGUsIG5hbWUpKTtcbiAgICAgICAgZXhjbHVkZSAmJiBwcnVuZUNhY2hlKChuYW1lKSA9PiAhbWF0Y2hlcyhleGNsdWRlLCBuYW1lKSk7XG4gICAgICB9LFxuICAgICAgLy8gcHJ1bmUgcG9zdC1yZW5kZXIgYWZ0ZXIgYGN1cnJlbnRgIGhhcyBiZWVuIHVwZGF0ZWRcbiAgICAgIHsgZmx1c2g6IFwicG9zdFwiLCBkZWVwOiB0cnVlIH1cbiAgICApO1xuICAgIGxldCBwZW5kaW5nQ2FjaGVLZXkgPSBudWxsO1xuICAgIGNvbnN0IGNhY2hlU3VidHJlZSA9ICgpID0+IHtcbiAgICAgIGlmIChwZW5kaW5nQ2FjaGVLZXkgIT0gbnVsbCkge1xuICAgICAgICBjYWNoZS5zZXQocGVuZGluZ0NhY2hlS2V5LCBnZXRJbm5lckNoaWxkKGluc3RhbmNlLnN1YlRyZWUpKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIG9uTW91bnRlZChjYWNoZVN1YnRyZWUpO1xuICAgIG9uVXBkYXRlZChjYWNoZVN1YnRyZWUpO1xuICAgIG9uQmVmb3JlVW5tb3VudCgoKSA9PiB7XG4gICAgICBjYWNoZS5mb3JFYWNoKChjYWNoZWQpID0+IHtcbiAgICAgICAgY29uc3QgeyBzdWJUcmVlLCBzdXNwZW5zZSB9ID0gaW5zdGFuY2U7XG4gICAgICAgIGNvbnN0IHZub2RlID0gZ2V0SW5uZXJDaGlsZChzdWJUcmVlKTtcbiAgICAgICAgaWYgKGNhY2hlZC50eXBlID09PSB2bm9kZS50eXBlICYmIGNhY2hlZC5rZXkgPT09IHZub2RlLmtleSkge1xuICAgICAgICAgIHJlc2V0U2hhcGVGbGFnKHZub2RlKTtcbiAgICAgICAgICBjb25zdCBkYSA9IHZub2RlLmNvbXBvbmVudC5kYTtcbiAgICAgICAgICBkYSAmJiBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QoZGEsIHN1c3BlbnNlKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdW5tb3VudChjYWNoZWQpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHBlbmRpbmdDYWNoZUtleSA9IG51bGw7XG4gICAgICBpZiAoIXNsb3RzLmRlZmF1bHQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBjb25zdCBjaGlsZHJlbiA9IHNsb3RzLmRlZmF1bHQoKTtcbiAgICAgIGNvbnN0IHJhd1ZOb2RlID0gY2hpbGRyZW5bMF07XG4gICAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoID4gMSkge1xuICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgIHdhcm4oYEtlZXBBbGl2ZSBzaG91bGQgY29udGFpbiBleGFjdGx5IG9uZSBjb21wb25lbnQgY2hpbGQuYCk7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudCA9IG51bGw7XG4gICAgICAgIHJldHVybiBjaGlsZHJlbjtcbiAgICAgIH0gZWxzZSBpZiAoIWlzVk5vZGUocmF3Vk5vZGUpIHx8ICEocmF3Vk5vZGUuc2hhcGVGbGFnICYgNCkgJiYgIShyYXdWTm9kZS5zaGFwZUZsYWcgJiAxMjgpKSB7XG4gICAgICAgIGN1cnJlbnQgPSBudWxsO1xuICAgICAgICByZXR1cm4gcmF3Vk5vZGU7XG4gICAgICB9XG4gICAgICBsZXQgdm5vZGUgPSBnZXRJbm5lckNoaWxkKHJhd1ZOb2RlKTtcbiAgICAgIGNvbnN0IGNvbXAgPSB2bm9kZS50eXBlO1xuICAgICAgY29uc3QgbmFtZSA9IGdldENvbXBvbmVudE5hbWUoXG4gICAgICAgIGlzQXN5bmNXcmFwcGVyKHZub2RlKSA/IHZub2RlLnR5cGUuX19hc3luY1Jlc29sdmVkIHx8IHt9IDogY29tcFxuICAgICAgKTtcbiAgICAgIGNvbnN0IHsgaW5jbHVkZSwgZXhjbHVkZSwgbWF4IH0gPSBwcm9wcztcbiAgICAgIGlmIChpbmNsdWRlICYmICghbmFtZSB8fCAhbWF0Y2hlcyhpbmNsdWRlLCBuYW1lKSkgfHwgZXhjbHVkZSAmJiBuYW1lICYmIG1hdGNoZXMoZXhjbHVkZSwgbmFtZSkpIHtcbiAgICAgICAgY3VycmVudCA9IHZub2RlO1xuICAgICAgICByZXR1cm4gcmF3Vk5vZGU7XG4gICAgICB9XG4gICAgICBjb25zdCBrZXkgPSB2bm9kZS5rZXkgPT0gbnVsbCA/IGNvbXAgOiB2bm9kZS5rZXk7XG4gICAgICBjb25zdCBjYWNoZWRWTm9kZSA9IGNhY2hlLmdldChrZXkpO1xuICAgICAgaWYgKHZub2RlLmVsKSB7XG4gICAgICAgIHZub2RlID0gY2xvbmVWTm9kZSh2bm9kZSk7XG4gICAgICAgIGlmIChyYXdWTm9kZS5zaGFwZUZsYWcgJiAxMjgpIHtcbiAgICAgICAgICByYXdWTm9kZS5zc0NvbnRlbnQgPSB2bm9kZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcGVuZGluZ0NhY2hlS2V5ID0ga2V5O1xuICAgICAgaWYgKGNhY2hlZFZOb2RlKSB7XG4gICAgICAgIHZub2RlLmVsID0gY2FjaGVkVk5vZGUuZWw7XG4gICAgICAgIHZub2RlLmNvbXBvbmVudCA9IGNhY2hlZFZOb2RlLmNvbXBvbmVudDtcbiAgICAgICAgaWYgKHZub2RlLnRyYW5zaXRpb24pIHtcbiAgICAgICAgICBzZXRUcmFuc2l0aW9uSG9va3Modm5vZGUsIHZub2RlLnRyYW5zaXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIHZub2RlLnNoYXBlRmxhZyB8PSA1MTI7XG4gICAgICAgIGtleXMuZGVsZXRlKGtleSk7XG4gICAgICAgIGtleXMuYWRkKGtleSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBrZXlzLmFkZChrZXkpO1xuICAgICAgICBpZiAobWF4ICYmIGtleXMuc2l6ZSA+IHBhcnNlSW50KG1heCwgMTApKSB7XG4gICAgICAgICAgcHJ1bmVDYWNoZUVudHJ5KGtleXMudmFsdWVzKCkubmV4dCgpLnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdm5vZGUuc2hhcGVGbGFnIHw9IDI1NjtcbiAgICAgIGN1cnJlbnQgPSB2bm9kZTtcbiAgICAgIHJldHVybiBpc1N1c3BlbnNlKHJhd1ZOb2RlLnR5cGUpID8gcmF3Vk5vZGUgOiB2bm9kZTtcbiAgICB9O1xuICB9XG59O1xuY29uc3QgS2VlcEFsaXZlID0gS2VlcEFsaXZlSW1wbDtcbmZ1bmN0aW9uIG1hdGNoZXMocGF0dGVybiwgbmFtZSkge1xuICBpZiAoaXNBcnJheShwYXR0ZXJuKSkge1xuICAgIHJldHVybiBwYXR0ZXJuLnNvbWUoKHApID0+IG1hdGNoZXMocCwgbmFtZSkpO1xuICB9IGVsc2UgaWYgKGlzU3RyaW5nKHBhdHRlcm4pKSB7XG4gICAgcmV0dXJuIHBhdHRlcm4uc3BsaXQoXCIsXCIpLmluY2x1ZGVzKG5hbWUpO1xuICB9IGVsc2UgaWYgKGlzUmVnRXhwKHBhdHRlcm4pKSB7XG4gICAgcmV0dXJuIHBhdHRlcm4udGVzdChuYW1lKTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBvbkFjdGl2YXRlZChob29rLCB0YXJnZXQpIHtcbiAgcmVnaXN0ZXJLZWVwQWxpdmVIb29rKGhvb2ssIFwiYVwiLCB0YXJnZXQpO1xufVxuZnVuY3Rpb24gb25EZWFjdGl2YXRlZChob29rLCB0YXJnZXQpIHtcbiAgcmVnaXN0ZXJLZWVwQWxpdmVIb29rKGhvb2ssIFwiZGFcIiwgdGFyZ2V0KTtcbn1cbmZ1bmN0aW9uIHJlZ2lzdGVyS2VlcEFsaXZlSG9vayhob29rLCB0eXBlLCB0YXJnZXQgPSBjdXJyZW50SW5zdGFuY2UpIHtcbiAgY29uc3Qgd3JhcHBlZEhvb2sgPSBob29rLl9fd2RjIHx8IChob29rLl9fd2RjID0gKCkgPT4ge1xuICAgIGxldCBjdXJyZW50ID0gdGFyZ2V0O1xuICAgIHdoaWxlIChjdXJyZW50KSB7XG4gICAgICBpZiAoY3VycmVudC5pc0RlYWN0aXZhdGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnBhcmVudDtcbiAgICB9XG4gICAgcmV0dXJuIGhvb2soKTtcbiAgfSk7XG4gIGluamVjdEhvb2sodHlwZSwgd3JhcHBlZEhvb2ssIHRhcmdldCk7XG4gIGlmICh0YXJnZXQpIHtcbiAgICBsZXQgY3VycmVudCA9IHRhcmdldC5wYXJlbnQ7XG4gICAgd2hpbGUgKGN1cnJlbnQgJiYgY3VycmVudC5wYXJlbnQpIHtcbiAgICAgIGlmIChpc0tlZXBBbGl2ZShjdXJyZW50LnBhcmVudC52bm9kZSkpIHtcbiAgICAgICAgaW5qZWN0VG9LZWVwQWxpdmVSb290KHdyYXBwZWRIb29rLCB0eXBlLCB0YXJnZXQsIGN1cnJlbnQpO1xuICAgICAgfVxuICAgICAgY3VycmVudCA9IGN1cnJlbnQucGFyZW50O1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gaW5qZWN0VG9LZWVwQWxpdmVSb290KGhvb2ssIHR5cGUsIHRhcmdldCwga2VlcEFsaXZlUm9vdCkge1xuICBjb25zdCBpbmplY3RlZCA9IGluamVjdEhvb2soXG4gICAgdHlwZSxcbiAgICBob29rLFxuICAgIGtlZXBBbGl2ZVJvb3QsXG4gICAgdHJ1ZVxuICAgIC8qIHByZXBlbmQgKi9cbiAgKTtcbiAgb25Vbm1vdW50ZWQoKCkgPT4ge1xuICAgIHJlbW92ZShrZWVwQWxpdmVSb290W3R5cGVdLCBpbmplY3RlZCk7XG4gIH0sIHRhcmdldCk7XG59XG5mdW5jdGlvbiByZXNldFNoYXBlRmxhZyh2bm9kZSkge1xuICB2bm9kZS5zaGFwZUZsYWcgJj0gfjI1NjtcbiAgdm5vZGUuc2hhcGVGbGFnICY9IH41MTI7XG59XG5mdW5jdGlvbiBnZXRJbm5lckNoaWxkKHZub2RlKSB7XG4gIHJldHVybiB2bm9kZS5zaGFwZUZsYWcgJiAxMjggPyB2bm9kZS5zc0NvbnRlbnQgOiB2bm9kZTtcbn1cblxuZnVuY3Rpb24gaW5qZWN0SG9vayh0eXBlLCBob29rLCB0YXJnZXQgPSBjdXJyZW50SW5zdGFuY2UsIHByZXBlbmQgPSBmYWxzZSkge1xuICBpZiAodGFyZ2V0KSB7XG4gICAgY29uc3QgaG9va3MgPSB0YXJnZXRbdHlwZV0gfHwgKHRhcmdldFt0eXBlXSA9IFtdKTtcbiAgICBjb25zdCB3cmFwcGVkSG9vayA9IGhvb2suX193ZWggfHwgKGhvb2suX193ZWggPSAoLi4uYXJncykgPT4ge1xuICAgICAgaWYgKHRhcmdldC5pc1VubW91bnRlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBwYXVzZVRyYWNraW5nKCk7XG4gICAgICBzZXRDdXJyZW50SW5zdGFuY2UodGFyZ2V0KTtcbiAgICAgIGNvbnN0IHJlcyA9IGNhbGxXaXRoQXN5bmNFcnJvckhhbmRsaW5nKGhvb2ssIHRhcmdldCwgdHlwZSwgYXJncyk7XG4gICAgICB1bnNldEN1cnJlbnRJbnN0YW5jZSgpO1xuICAgICAgcmVzZXRUcmFja2luZygpO1xuICAgICAgcmV0dXJuIHJlcztcbiAgICB9KTtcbiAgICBpZiAocHJlcGVuZCkge1xuICAgICAgaG9va3MudW5zaGlmdCh3cmFwcGVkSG9vayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGhvb2tzLnB1c2god3JhcHBlZEhvb2spO1xuICAgIH1cbiAgICByZXR1cm4gd3JhcHBlZEhvb2s7XG4gIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIGNvbnN0IGFwaU5hbWUgPSB0b0hhbmRsZXJLZXkoRXJyb3JUeXBlU3RyaW5nc1t0eXBlXS5yZXBsYWNlKC8gaG9vayQvLCBcIlwiKSk7XG4gICAgd2FybihcbiAgICAgIGAke2FwaU5hbWV9IGlzIGNhbGxlZCB3aGVuIHRoZXJlIGlzIG5vIGFjdGl2ZSBjb21wb25lbnQgaW5zdGFuY2UgdG8gYmUgYXNzb2NpYXRlZCB3aXRoLiBMaWZlY3ljbGUgaW5qZWN0aW9uIEFQSXMgY2FuIG9ubHkgYmUgdXNlZCBkdXJpbmcgZXhlY3V0aW9uIG9mIHNldHVwKCkuYCArIChgIElmIHlvdSBhcmUgdXNpbmcgYXN5bmMgc2V0dXAoKSwgbWFrZSBzdXJlIHRvIHJlZ2lzdGVyIGxpZmVjeWNsZSBob29rcyBiZWZvcmUgdGhlIGZpcnN0IGF3YWl0IHN0YXRlbWVudC5gIClcbiAgICApO1xuICB9XG59XG5jb25zdCBjcmVhdGVIb29rID0gKGxpZmVjeWNsZSkgPT4gKGhvb2ssIHRhcmdldCA9IGN1cnJlbnRJbnN0YW5jZSkgPT4gKFxuICAvLyBwb3N0LWNyZWF0ZSBsaWZlY3ljbGUgcmVnaXN0cmF0aW9ucyBhcmUgbm9vcHMgZHVyaW5nIFNTUiAoZXhjZXB0IGZvciBzZXJ2ZXJQcmVmZXRjaClcbiAgKCFpc0luU1NSQ29tcG9uZW50U2V0dXAgfHwgbGlmZWN5Y2xlID09PSBcInNwXCIpICYmIGluamVjdEhvb2sobGlmZWN5Y2xlLCAoLi4uYXJncykgPT4gaG9vayguLi5hcmdzKSwgdGFyZ2V0KVxuKTtcbmNvbnN0IG9uQmVmb3JlTW91bnQgPSBjcmVhdGVIb29rKFwiYm1cIik7XG5jb25zdCBvbk1vdW50ZWQgPSBjcmVhdGVIb29rKFwibVwiKTtcbmNvbnN0IG9uQmVmb3JlVXBkYXRlID0gY3JlYXRlSG9vayhcImJ1XCIpO1xuY29uc3Qgb25VcGRhdGVkID0gY3JlYXRlSG9vayhcInVcIik7XG5jb25zdCBvbkJlZm9yZVVubW91bnQgPSBjcmVhdGVIb29rKFwiYnVtXCIpO1xuY29uc3Qgb25Vbm1vdW50ZWQgPSBjcmVhdGVIb29rKFwidW1cIik7XG5jb25zdCBvblNlcnZlclByZWZldGNoID0gY3JlYXRlSG9vayhcInNwXCIpO1xuY29uc3Qgb25SZW5kZXJUcmlnZ2VyZWQgPSBjcmVhdGVIb29rKFxuICBcInJ0Z1wiXG4pO1xuY29uc3Qgb25SZW5kZXJUcmFja2VkID0gY3JlYXRlSG9vayhcbiAgXCJydGNcIlxuKTtcbmZ1bmN0aW9uIG9uRXJyb3JDYXB0dXJlZChob29rLCB0YXJnZXQgPSBjdXJyZW50SW5zdGFuY2UpIHtcbiAgaW5qZWN0SG9vayhcImVjXCIsIGhvb2ssIHRhcmdldCk7XG59XG5cbmNvbnN0IENPTVBPTkVOVFMgPSBcImNvbXBvbmVudHNcIjtcbmNvbnN0IERJUkVDVElWRVMgPSBcImRpcmVjdGl2ZXNcIjtcbmZ1bmN0aW9uIHJlc29sdmVDb21wb25lbnQobmFtZSwgbWF5YmVTZWxmUmVmZXJlbmNlKSB7XG4gIHJldHVybiByZXNvbHZlQXNzZXQoQ09NUE9ORU5UUywgbmFtZSwgdHJ1ZSwgbWF5YmVTZWxmUmVmZXJlbmNlKSB8fCBuYW1lO1xufVxuY29uc3QgTlVMTF9EWU5BTUlDX0NPTVBPTkVOVCA9IFN5bWJvbC5mb3IoXCJ2LW5kY1wiKTtcbmZ1bmN0aW9uIHJlc29sdmVEeW5hbWljQ29tcG9uZW50KGNvbXBvbmVudCkge1xuICBpZiAoaXNTdHJpbmcoY29tcG9uZW50KSkge1xuICAgIHJldHVybiByZXNvbHZlQXNzZXQoQ09NUE9ORU5UUywgY29tcG9uZW50LCBmYWxzZSkgfHwgY29tcG9uZW50O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBjb21wb25lbnQgfHwgTlVMTF9EWU5BTUlDX0NPTVBPTkVOVDtcbiAgfVxufVxuZnVuY3Rpb24gcmVzb2x2ZURpcmVjdGl2ZShuYW1lKSB7XG4gIHJldHVybiByZXNvbHZlQXNzZXQoRElSRUNUSVZFUywgbmFtZSk7XG59XG5mdW5jdGlvbiByZXNvbHZlQXNzZXQodHlwZSwgbmFtZSwgd2Fybk1pc3NpbmcgPSB0cnVlLCBtYXliZVNlbGZSZWZlcmVuY2UgPSBmYWxzZSkge1xuICBjb25zdCBpbnN0YW5jZSA9IGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSB8fCBjdXJyZW50SW5zdGFuY2U7XG4gIGlmIChpbnN0YW5jZSkge1xuICAgIGNvbnN0IENvbXBvbmVudCA9IGluc3RhbmNlLnR5cGU7XG4gICAgaWYgKHR5cGUgPT09IENPTVBPTkVOVFMpIHtcbiAgICAgIGNvbnN0IHNlbGZOYW1lID0gZ2V0Q29tcG9uZW50TmFtZShcbiAgICAgICAgQ29tcG9uZW50LFxuICAgICAgICBmYWxzZVxuICAgICAgICAvKiBkbyBub3QgaW5jbHVkZSBpbmZlcnJlZCBuYW1lIHRvIGF2b2lkIGJyZWFraW5nIGV4aXN0aW5nIGNvZGUgKi9cbiAgICAgICk7XG4gICAgICBpZiAoc2VsZk5hbWUgJiYgKHNlbGZOYW1lID09PSBuYW1lIHx8IHNlbGZOYW1lID09PSBjYW1lbGl6ZShuYW1lKSB8fCBzZWxmTmFtZSA9PT0gY2FwaXRhbGl6ZShjYW1lbGl6ZShuYW1lKSkpKSB7XG4gICAgICAgIHJldHVybiBDb21wb25lbnQ7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHJlcyA9IChcbiAgICAgIC8vIGxvY2FsIHJlZ2lzdHJhdGlvblxuICAgICAgLy8gY2hlY2sgaW5zdGFuY2VbdHlwZV0gZmlyc3Qgd2hpY2ggaXMgcmVzb2x2ZWQgZm9yIG9wdGlvbnMgQVBJXG4gICAgICByZXNvbHZlKGluc3RhbmNlW3R5cGVdIHx8IENvbXBvbmVudFt0eXBlXSwgbmFtZSkgfHwgLy8gZ2xvYmFsIHJlZ2lzdHJhdGlvblxuICAgICAgcmVzb2x2ZShpbnN0YW5jZS5hcHBDb250ZXh0W3R5cGVdLCBuYW1lKVxuICAgICk7XG4gICAgaWYgKCFyZXMgJiYgbWF5YmVTZWxmUmVmZXJlbmNlKSB7XG4gICAgICByZXR1cm4gQ29tcG9uZW50O1xuICAgIH1cbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiB3YXJuTWlzc2luZyAmJiAhcmVzKSB7XG4gICAgICBjb25zdCBleHRyYSA9IHR5cGUgPT09IENPTVBPTkVOVFMgPyBgXG5JZiB0aGlzIGlzIGEgbmF0aXZlIGN1c3RvbSBlbGVtZW50LCBtYWtlIHN1cmUgdG8gZXhjbHVkZSBpdCBmcm9tIGNvbXBvbmVudCByZXNvbHV0aW9uIHZpYSBjb21waWxlck9wdGlvbnMuaXNDdXN0b21FbGVtZW50LmAgOiBgYDtcbiAgICAgIHdhcm4oYEZhaWxlZCB0byByZXNvbHZlICR7dHlwZS5zbGljZSgwLCAtMSl9OiAke25hbWV9JHtleHRyYX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbiAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgd2FybihcbiAgICAgIGByZXNvbHZlJHtjYXBpdGFsaXplKHR5cGUuc2xpY2UoMCwgLTEpKX0gY2FuIG9ubHkgYmUgdXNlZCBpbiByZW5kZXIoKSBvciBzZXR1cCgpLmBcbiAgICApO1xuICB9XG59XG5mdW5jdGlvbiByZXNvbHZlKHJlZ2lzdHJ5LCBuYW1lKSB7XG4gIHJldHVybiByZWdpc3RyeSAmJiAocmVnaXN0cnlbbmFtZV0gfHwgcmVnaXN0cnlbY2FtZWxpemUobmFtZSldIHx8IHJlZ2lzdHJ5W2NhcGl0YWxpemUoY2FtZWxpemUobmFtZSkpXSk7XG59XG5cbmZ1bmN0aW9uIHJlbmRlckxpc3Qoc291cmNlLCByZW5kZXJJdGVtLCBjYWNoZSwgaW5kZXgpIHtcbiAgbGV0IHJldDtcbiAgY29uc3QgY2FjaGVkID0gY2FjaGUgJiYgY2FjaGVbaW5kZXhdO1xuICBpZiAoaXNBcnJheShzb3VyY2UpIHx8IGlzU3RyaW5nKHNvdXJjZSkpIHtcbiAgICByZXQgPSBuZXcgQXJyYXkoc291cmNlLmxlbmd0aCk7XG4gICAgZm9yIChsZXQgaSA9IDAsIGwgPSBzb3VyY2UubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICByZXRbaV0gPSByZW5kZXJJdGVtKHNvdXJjZVtpXSwgaSwgdm9pZCAwLCBjYWNoZWQgJiYgY2FjaGVkW2ldKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIHNvdXJjZSA9PT0gXCJudW1iZXJcIikge1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICFOdW1iZXIuaXNJbnRlZ2VyKHNvdXJjZSkpIHtcbiAgICAgIHdhcm4oYFRoZSB2LWZvciByYW5nZSBleHBlY3QgYW4gaW50ZWdlciB2YWx1ZSBidXQgZ290ICR7c291cmNlfS5gKTtcbiAgICB9XG4gICAgcmV0ID0gbmV3IEFycmF5KHNvdXJjZSk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzb3VyY2U7IGkrKykge1xuICAgICAgcmV0W2ldID0gcmVuZGVySXRlbShpICsgMSwgaSwgdm9pZCAwLCBjYWNoZWQgJiYgY2FjaGVkW2ldKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNPYmplY3Qoc291cmNlKSkge1xuICAgIGlmIChzb3VyY2VbU3ltYm9sLml0ZXJhdG9yXSkge1xuICAgICAgcmV0ID0gQXJyYXkuZnJvbShcbiAgICAgICAgc291cmNlLFxuICAgICAgICAoaXRlbSwgaSkgPT4gcmVuZGVySXRlbShpdGVtLCBpLCB2b2lkIDAsIGNhY2hlZCAmJiBjYWNoZWRbaV0pXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcbiAgICAgIHJldCA9IG5ldyBBcnJheShrZXlzLmxlbmd0aCk7XG4gICAgICBmb3IgKGxldCBpID0gMCwgbCA9IGtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IGtleXNbaV07XG4gICAgICAgIHJldFtpXSA9IHJlbmRlckl0ZW0oc291cmNlW2tleV0sIGtleSwgaSwgY2FjaGVkICYmIGNhY2hlZFtpXSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJldCA9IFtdO1xuICB9XG4gIGlmIChjYWNoZSkge1xuICAgIGNhY2hlW2luZGV4XSA9IHJldDtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVTbG90cyhzbG90cywgZHluYW1pY1Nsb3RzKSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZHluYW1pY1Nsb3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qgc2xvdCA9IGR5bmFtaWNTbG90c1tpXTtcbiAgICBpZiAoaXNBcnJheShzbG90KSkge1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBzbG90Lmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHNsb3RzW3Nsb3Rbal0ubmFtZV0gPSBzbG90W2pdLmZuO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoc2xvdCkge1xuICAgICAgc2xvdHNbc2xvdC5uYW1lXSA9IHNsb3Qua2V5ID8gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgY29uc3QgcmVzID0gc2xvdC5mbiguLi5hcmdzKTtcbiAgICAgICAgaWYgKHJlcylcbiAgICAgICAgICByZXMua2V5ID0gc2xvdC5rZXk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgICB9IDogc2xvdC5mbjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHNsb3RzO1xufVxuXG5mdW5jdGlvbiByZW5kZXJTbG90KHNsb3RzLCBuYW1lLCBwcm9wcyA9IHt9LCBmYWxsYmFjaywgbm9TbG90dGVkKSB7XG4gIGlmIChjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UuaXNDRSB8fCBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UucGFyZW50ICYmIGlzQXN5bmNXcmFwcGVyKGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZS5wYXJlbnQpICYmIGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZS5wYXJlbnQuaXNDRSkge1xuICAgIGlmIChuYW1lICE9PSBcImRlZmF1bHRcIilcbiAgICAgIHByb3BzLm5hbWUgPSBuYW1lO1xuICAgIHJldHVybiBjcmVhdGVWTm9kZShcInNsb3RcIiwgcHJvcHMsIGZhbGxiYWNrICYmIGZhbGxiYWNrKCkpO1xuICB9XG4gIGxldCBzbG90ID0gc2xvdHNbbmFtZV07XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHNsb3QgJiYgc2xvdC5sZW5ndGggPiAxKSB7XG4gICAgd2FybihcbiAgICAgIGBTU1Itb3B0aW1pemVkIHNsb3QgZnVuY3Rpb24gZGV0ZWN0ZWQgaW4gYSBub24tU1NSLW9wdGltaXplZCByZW5kZXIgZnVuY3Rpb24uIFlvdSBuZWVkIHRvIG1hcmsgdGhpcyBjb21wb25lbnQgd2l0aCAkZHluYW1pYy1zbG90cyBpbiB0aGUgcGFyZW50IHRlbXBsYXRlLmBcbiAgICApO1xuICAgIHNsb3QgPSAoKSA9PiBbXTtcbiAgfVxuICBpZiAoc2xvdCAmJiBzbG90Ll9jKSB7XG4gICAgc2xvdC5fZCA9IGZhbHNlO1xuICB9XG4gIG9wZW5CbG9jaygpO1xuICBjb25zdCB2YWxpZFNsb3RDb250ZW50ID0gc2xvdCAmJiBlbnN1cmVWYWxpZFZOb2RlKHNsb3QocHJvcHMpKTtcbiAgY29uc3QgcmVuZGVyZWQgPSBjcmVhdGVCbG9jayhcbiAgICBGcmFnbWVudCxcbiAgICB7XG4gICAgICBrZXk6IHByb3BzLmtleSB8fCAvLyBzbG90IGNvbnRlbnQgYXJyYXkgb2YgYSBkeW5hbWljIGNvbmRpdGlvbmFsIHNsb3QgbWF5IGhhdmUgYSBicmFuY2hcbiAgICAgIC8vIGtleSBhdHRhY2hlZCBpbiB0aGUgYGNyZWF0ZVNsb3RzYCBoZWxwZXIsIHJlc3BlY3QgdGhhdFxuICAgICAgdmFsaWRTbG90Q29udGVudCAmJiB2YWxpZFNsb3RDb250ZW50LmtleSB8fCBgXyR7bmFtZX1gXG4gICAgfSxcbiAgICB2YWxpZFNsb3RDb250ZW50IHx8IChmYWxsYmFjayA/IGZhbGxiYWNrKCkgOiBbXSksXG4gICAgdmFsaWRTbG90Q29udGVudCAmJiBzbG90cy5fID09PSAxID8gNjQgOiAtMlxuICApO1xuICBpZiAoIW5vU2xvdHRlZCAmJiByZW5kZXJlZC5zY29wZUlkKSB7XG4gICAgcmVuZGVyZWQuc2xvdFNjb3BlSWRzID0gW3JlbmRlcmVkLnNjb3BlSWQgKyBcIi1zXCJdO1xuICB9XG4gIGlmIChzbG90ICYmIHNsb3QuX2MpIHtcbiAgICBzbG90Ll9kID0gdHJ1ZTtcbiAgfVxuICByZXR1cm4gcmVuZGVyZWQ7XG59XG5mdW5jdGlvbiBlbnN1cmVWYWxpZFZOb2RlKHZub2Rlcykge1xuICByZXR1cm4gdm5vZGVzLnNvbWUoKGNoaWxkKSA9PiB7XG4gICAgaWYgKCFpc1ZOb2RlKGNoaWxkKSlcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIGlmIChjaGlsZC50eXBlID09PSBDb21tZW50KVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChjaGlsZC50eXBlID09PSBGcmFnbWVudCAmJiAhZW5zdXJlVmFsaWRWTm9kZShjaGlsZC5jaGlsZHJlbikpXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0pID8gdm5vZGVzIDogbnVsbDtcbn1cblxuZnVuY3Rpb24gdG9IYW5kbGVycyhvYmosIHByZXNlcnZlQ2FzZUlmTmVjZXNzYXJ5KSB7XG4gIGNvbnN0IHJldCA9IHt9O1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhaXNPYmplY3Qob2JqKSkge1xuICAgIHdhcm4oYHYtb24gd2l0aCBubyBhcmd1bWVudCBleHBlY3RzIGFuIG9iamVjdCB2YWx1ZS5gKTtcbiAgICByZXR1cm4gcmV0O1xuICB9XG4gIGZvciAoY29uc3Qga2V5IGluIG9iaikge1xuICAgIHJldFtwcmVzZXJ2ZUNhc2VJZk5lY2Vzc2FyeSAmJiAvW0EtWl0vLnRlc3Qoa2V5KSA/IGBvbjoke2tleX1gIDogdG9IYW5kbGVyS2V5KGtleSldID0gb2JqW2tleV07XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuY29uc3QgZ2V0UHVibGljSW5zdGFuY2UgPSAoaSkgPT4ge1xuICBpZiAoIWkpXG4gICAgcmV0dXJuIG51bGw7XG4gIGlmIChpc1N0YXRlZnVsQ29tcG9uZW50KGkpKVxuICAgIHJldHVybiBnZXRFeHBvc2VQcm94eShpKSB8fCBpLnByb3h5O1xuICByZXR1cm4gZ2V0UHVibGljSW5zdGFuY2UoaS5wYXJlbnQpO1xufTtcbmNvbnN0IHB1YmxpY1Byb3BlcnRpZXNNYXAgPSAoXG4gIC8vIE1vdmUgUFVSRSBtYXJrZXIgdG8gbmV3IGxpbmUgdG8gd29ya2Fyb3VuZCBjb21waWxlciBkaXNjYXJkaW5nIGl0XG4gIC8vIGR1ZSB0byB0eXBlIGFubm90YXRpb25cbiAgLyogQF9fUFVSRV9fICovIGV4dGVuZCgvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKSwge1xuICAgICQ6IChpKSA9PiBpLFxuICAgICRlbDogKGkpID0+IGkudm5vZGUuZWwsXG4gICAgJGRhdGE6IChpKSA9PiBpLmRhdGEsXG4gICAgJHByb3BzOiAoaSkgPT4gISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IHNoYWxsb3dSZWFkb25seShpLnByb3BzKSA6IGkucHJvcHMsXG4gICAgJGF0dHJzOiAoaSkgPT4gISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IHNoYWxsb3dSZWFkb25seShpLmF0dHJzKSA6IGkuYXR0cnMsXG4gICAgJHNsb3RzOiAoaSkgPT4gISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IHNoYWxsb3dSZWFkb25seShpLnNsb3RzKSA6IGkuc2xvdHMsXG4gICAgJHJlZnM6IChpKSA9PiAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gc2hhbGxvd1JlYWRvbmx5KGkucmVmcykgOiBpLnJlZnMsXG4gICAgJHBhcmVudDogKGkpID0+IGdldFB1YmxpY0luc3RhbmNlKGkucGFyZW50KSxcbiAgICAkcm9vdDogKGkpID0+IGdldFB1YmxpY0luc3RhbmNlKGkucm9vdCksXG4gICAgJGVtaXQ6IChpKSA9PiBpLmVtaXQsXG4gICAgJG9wdGlvbnM6IChpKSA9PiBfX1ZVRV9PUFRJT05TX0FQSV9fID8gcmVzb2x2ZU1lcmdlZE9wdGlvbnMoaSkgOiBpLnR5cGUsXG4gICAgJGZvcmNlVXBkYXRlOiAoaSkgPT4gaS5mIHx8IChpLmYgPSAoKSA9PiBxdWV1ZUpvYihpLnVwZGF0ZSkpLFxuICAgICRuZXh0VGljazogKGkpID0+IGkubiB8fCAoaS5uID0gbmV4dFRpY2suYmluZChpLnByb3h5KSksXG4gICAgJHdhdGNoOiAoaSkgPT4gX19WVUVfT1BUSU9OU19BUElfXyA/IGluc3RhbmNlV2F0Y2guYmluZChpKSA6IE5PT1BcbiAgfSlcbik7XG5jb25zdCBpc1Jlc2VydmVkUHJlZml4ID0gKGtleSkgPT4ga2V5ID09PSBcIl9cIiB8fCBrZXkgPT09IFwiJFwiO1xuY29uc3QgaGFzU2V0dXBCaW5kaW5nID0gKHN0YXRlLCBrZXkpID0+IHN0YXRlICE9PSBFTVBUWV9PQkogJiYgIXN0YXRlLl9faXNTY3JpcHRTZXR1cCAmJiBoYXNPd24oc3RhdGUsIGtleSk7XG5jb25zdCBQdWJsaWNJbnN0YW5jZVByb3h5SGFuZGxlcnMgPSB7XG4gIGdldCh7IF86IGluc3RhbmNlIH0sIGtleSkge1xuICAgIGNvbnN0IHsgY3R4LCBzZXR1cFN0YXRlLCBkYXRhLCBwcm9wcywgYWNjZXNzQ2FjaGUsIHR5cGUsIGFwcENvbnRleHQgfSA9IGluc3RhbmNlO1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGtleSA9PT0gXCJfX2lzVnVlXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBsZXQgbm9ybWFsaXplZFByb3BzO1xuICAgIGlmIChrZXlbMF0gIT09IFwiJFwiKSB7XG4gICAgICBjb25zdCBuID0gYWNjZXNzQ2FjaGVba2V5XTtcbiAgICAgIGlmIChuICE9PSB2b2lkIDApIHtcbiAgICAgICAgc3dpdGNoIChuKSB7XG4gICAgICAgICAgY2FzZSAxIC8qIFNFVFVQICovOlxuICAgICAgICAgICAgcmV0dXJuIHNldHVwU3RhdGVba2V5XTtcbiAgICAgICAgICBjYXNlIDIgLyogREFUQSAqLzpcbiAgICAgICAgICAgIHJldHVybiBkYXRhW2tleV07XG4gICAgICAgICAgY2FzZSA0IC8qIENPTlRFWFQgKi86XG4gICAgICAgICAgICByZXR1cm4gY3R4W2tleV07XG4gICAgICAgICAgY2FzZSAzIC8qIFBST1BTICovOlxuICAgICAgICAgICAgcmV0dXJuIHByb3BzW2tleV07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaGFzU2V0dXBCaW5kaW5nKHNldHVwU3RhdGUsIGtleSkpIHtcbiAgICAgICAgYWNjZXNzQ2FjaGVba2V5XSA9IDEgLyogU0VUVVAgKi87XG4gICAgICAgIHJldHVybiBzZXR1cFN0YXRlW2tleV07XG4gICAgICB9IGVsc2UgaWYgKGRhdGEgIT09IEVNUFRZX09CSiAmJiBoYXNPd24oZGF0YSwga2V5KSkge1xuICAgICAgICBhY2Nlc3NDYWNoZVtrZXldID0gMiAvKiBEQVRBICovO1xuICAgICAgICByZXR1cm4gZGF0YVtrZXldO1xuICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgLy8gb25seSBjYWNoZSBvdGhlciBwcm9wZXJ0aWVzIHdoZW4gaW5zdGFuY2UgaGFzIGRlY2xhcmVkICh0aHVzIHN0YWJsZSlcbiAgICAgICAgLy8gcHJvcHNcbiAgICAgICAgKG5vcm1hbGl6ZWRQcm9wcyA9IGluc3RhbmNlLnByb3BzT3B0aW9uc1swXSkgJiYgaGFzT3duKG5vcm1hbGl6ZWRQcm9wcywga2V5KVxuICAgICAgKSB7XG4gICAgICAgIGFjY2Vzc0NhY2hlW2tleV0gPSAzIC8qIFBST1BTICovO1xuICAgICAgICByZXR1cm4gcHJvcHNba2V5XTtcbiAgICAgIH0gZWxzZSBpZiAoY3R4ICE9PSBFTVBUWV9PQkogJiYgaGFzT3duKGN0eCwga2V5KSkge1xuICAgICAgICBhY2Nlc3NDYWNoZVtrZXldID0gNCAvKiBDT05URVhUICovO1xuICAgICAgICByZXR1cm4gY3R4W2tleV07XG4gICAgICB9IGVsc2UgaWYgKCFfX1ZVRV9PUFRJT05TX0FQSV9fIHx8IHNob3VsZENhY2hlQWNjZXNzKSB7XG4gICAgICAgIGFjY2Vzc0NhY2hlW2tleV0gPSAwIC8qIE9USEVSICovO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBwdWJsaWNHZXR0ZXIgPSBwdWJsaWNQcm9wZXJ0aWVzTWFwW2tleV07XG4gICAgbGV0IGNzc01vZHVsZSwgZ2xvYmFsUHJvcGVydGllcztcbiAgICBpZiAocHVibGljR2V0dGVyKSB7XG4gICAgICBpZiAoa2V5ID09PSBcIiRhdHRyc1wiKSB7XG4gICAgICAgIHRyYWNrKGluc3RhbmNlLCBcImdldFwiLCBrZXkpO1xuICAgICAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIG1hcmtBdHRyc0FjY2Vzc2VkKCk7XG4gICAgICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYga2V5ID09PSBcIiRzbG90c1wiKSB7XG4gICAgICAgIHRyYWNrKGluc3RhbmNlLCBcImdldFwiLCBrZXkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHB1YmxpY0dldHRlcihpbnN0YW5jZSk7XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIC8vIGNzcyBtb2R1bGUgKGluamVjdGVkIGJ5IHZ1ZS1sb2FkZXIpXG4gICAgICAoY3NzTW9kdWxlID0gdHlwZS5fX2Nzc01vZHVsZXMpICYmIChjc3NNb2R1bGUgPSBjc3NNb2R1bGVba2V5XSlcbiAgICApIHtcbiAgICAgIHJldHVybiBjc3NNb2R1bGU7XG4gICAgfSBlbHNlIGlmIChjdHggIT09IEVNUFRZX09CSiAmJiBoYXNPd24oY3R4LCBrZXkpKSB7XG4gICAgICBhY2Nlc3NDYWNoZVtrZXldID0gNCAvKiBDT05URVhUICovO1xuICAgICAgcmV0dXJuIGN0eFtrZXldO1xuICAgIH0gZWxzZSBpZiAoXG4gICAgICAvLyBnbG9iYWwgcHJvcGVydGllc1xuICAgICAgZ2xvYmFsUHJvcGVydGllcyA9IGFwcENvbnRleHQuY29uZmlnLmdsb2JhbFByb3BlcnRpZXMsIGhhc093bihnbG9iYWxQcm9wZXJ0aWVzLCBrZXkpXG4gICAgKSB7XG4gICAgICB7XG4gICAgICAgIHJldHVybiBnbG9iYWxQcm9wZXJ0aWVzW2tleV07XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSAmJiAoIWlzU3RyaW5nKGtleSkgfHwgLy8gIzEwOTEgYXZvaWQgaW50ZXJuYWwgaXNSZWYvaXNWTm9kZSBjaGVja3Mgb24gY29tcG9uZW50IGluc3RhbmNlIGxlYWRpbmdcbiAgICAvLyB0byBpbmZpbml0ZSB3YXJuaW5nIGxvb3BcbiAgICBrZXkuaW5kZXhPZihcIl9fdlwiKSAhPT0gMCkpIHtcbiAgICAgIGlmIChkYXRhICE9PSBFTVBUWV9PQkogJiYgaXNSZXNlcnZlZFByZWZpeChrZXlbMF0pICYmIGhhc093bihkYXRhLCBrZXkpKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgYFByb3BlcnR5ICR7SlNPTi5zdHJpbmdpZnkoXG4gICAgICAgICAgICBrZXlcbiAgICAgICAgICApfSBtdXN0IGJlIGFjY2Vzc2VkIHZpYSAkZGF0YSBiZWNhdXNlIGl0IHN0YXJ0cyB3aXRoIGEgcmVzZXJ2ZWQgY2hhcmFjdGVyIChcIiRcIiBvciBcIl9cIikgYW5kIGlzIG5vdCBwcm94aWVkIG9uIHRoZSByZW5kZXIgY29udGV4dC5gXG4gICAgICAgICk7XG4gICAgICB9IGVsc2UgaWYgKGluc3RhbmNlID09PSBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBgUHJvcGVydHkgJHtKU09OLnN0cmluZ2lmeShrZXkpfSB3YXMgYWNjZXNzZWQgZHVyaW5nIHJlbmRlciBidXQgaXMgbm90IGRlZmluZWQgb24gaW5zdGFuY2UuYFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgc2V0KHsgXzogaW5zdGFuY2UgfSwga2V5LCB2YWx1ZSkge1xuICAgIGNvbnN0IHsgZGF0YSwgc2V0dXBTdGF0ZSwgY3R4IH0gPSBpbnN0YW5jZTtcbiAgICBpZiAoaGFzU2V0dXBCaW5kaW5nKHNldHVwU3RhdGUsIGtleSkpIHtcbiAgICAgIHNldHVwU3RhdGVba2V5XSA9IHZhbHVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHNldHVwU3RhdGUuX19pc1NjcmlwdFNldHVwICYmIGhhc093bihzZXR1cFN0YXRlLCBrZXkpKSB7XG4gICAgICB3YXJuKGBDYW5ub3QgbXV0YXRlIDxzY3JpcHQgc2V0dXA+IGJpbmRpbmcgXCIke2tleX1cIiBmcm9tIE9wdGlvbnMgQVBJLmApO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSBpZiAoZGF0YSAhPT0gRU1QVFlfT0JKICYmIGhhc093bihkYXRhLCBrZXkpKSB7XG4gICAgICBkYXRhW2tleV0gPSB2YWx1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAoaGFzT3duKGluc3RhbmNlLnByb3BzLCBrZXkpKSB7XG4gICAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHdhcm4oYEF0dGVtcHRpbmcgdG8gbXV0YXRlIHByb3AgXCIke2tleX1cIi4gUHJvcHMgYXJlIHJlYWRvbmx5LmApO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoa2V5WzBdID09PSBcIiRcIiAmJiBrZXkuc2xpY2UoMSkgaW4gaW5zdGFuY2UpIHtcbiAgICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgd2FybihcbiAgICAgICAgYEF0dGVtcHRpbmcgdG8gbXV0YXRlIHB1YmxpYyBwcm9wZXJ0eSBcIiR7a2V5fVwiLiBQcm9wZXJ0aWVzIHN0YXJ0aW5nIHdpdGggJCBhcmUgcmVzZXJ2ZWQgYW5kIHJlYWRvbmx5LmBcbiAgICAgICk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGtleSBpbiBpbnN0YW5jZS5hcHBDb250ZXh0LmNvbmZpZy5nbG9iYWxQcm9wZXJ0aWVzKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdHgsIGtleSwge1xuICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgIHZhbHVlXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3R4W2tleV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sXG4gIGhhcyh7XG4gICAgXzogeyBkYXRhLCBzZXR1cFN0YXRlLCBhY2Nlc3NDYWNoZSwgY3R4LCBhcHBDb250ZXh0LCBwcm9wc09wdGlvbnMgfVxuICB9LCBrZXkpIHtcbiAgICBsZXQgbm9ybWFsaXplZFByb3BzO1xuICAgIHJldHVybiAhIWFjY2Vzc0NhY2hlW2tleV0gfHwgZGF0YSAhPT0gRU1QVFlfT0JKICYmIGhhc093bihkYXRhLCBrZXkpIHx8IGhhc1NldHVwQmluZGluZyhzZXR1cFN0YXRlLCBrZXkpIHx8IChub3JtYWxpemVkUHJvcHMgPSBwcm9wc09wdGlvbnNbMF0pICYmIGhhc093bihub3JtYWxpemVkUHJvcHMsIGtleSkgfHwgaGFzT3duKGN0eCwga2V5KSB8fCBoYXNPd24ocHVibGljUHJvcGVydGllc01hcCwga2V5KSB8fCBoYXNPd24oYXBwQ29udGV4dC5jb25maWcuZ2xvYmFsUHJvcGVydGllcywga2V5KTtcbiAgfSxcbiAgZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIGRlc2NyaXB0b3IpIHtcbiAgICBpZiAoZGVzY3JpcHRvci5nZXQgIT0gbnVsbCkge1xuICAgICAgdGFyZ2V0Ll8uYWNjZXNzQ2FjaGVba2V5XSA9IDA7XG4gICAgfSBlbHNlIGlmIChoYXNPd24oZGVzY3JpcHRvciwgXCJ2YWx1ZVwiKSkge1xuICAgICAgdGhpcy5zZXQodGFyZ2V0LCBrZXksIGRlc2NyaXB0b3IudmFsdWUsIG51bGwpO1xuICAgIH1cbiAgICByZXR1cm4gUmVmbGVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgZGVzY3JpcHRvcik7XG4gIH1cbn07XG5pZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiB0cnVlKSB7XG4gIFB1YmxpY0luc3RhbmNlUHJveHlIYW5kbGVycy5vd25LZXlzID0gKHRhcmdldCkgPT4ge1xuICAgIHdhcm4oXG4gICAgICBgQXZvaWQgYXBwIGxvZ2ljIHRoYXQgcmVsaWVzIG9uIGVudW1lcmF0aW5nIGtleXMgb24gYSBjb21wb25lbnQgaW5zdGFuY2UuIFRoZSBrZXlzIHdpbGwgYmUgZW1wdHkgaW4gcHJvZHVjdGlvbiBtb2RlIHRvIGF2b2lkIHBlcmZvcm1hbmNlIG92ZXJoZWFkLmBcbiAgICApO1xuICAgIHJldHVybiBSZWZsZWN0Lm93bktleXModGFyZ2V0KTtcbiAgfTtcbn1cbmNvbnN0IFJ1bnRpbWVDb21waWxlZFB1YmxpY0luc3RhbmNlUHJveHlIYW5kbGVycyA9IC8qIEBfX1BVUkVfXyAqLyBleHRlbmQoXG4gIHt9LFxuICBQdWJsaWNJbnN0YW5jZVByb3h5SGFuZGxlcnMsXG4gIHtcbiAgICBnZXQodGFyZ2V0LCBrZXkpIHtcbiAgICAgIGlmIChrZXkgPT09IFN5bWJvbC51bnNjb3BhYmxlcykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICByZXR1cm4gUHVibGljSW5zdGFuY2VQcm94eUhhbmRsZXJzLmdldCh0YXJnZXQsIGtleSwgdGFyZ2V0KTtcbiAgICB9LFxuICAgIGhhcyhfLCBrZXkpIHtcbiAgICAgIGNvbnN0IGhhcyA9IGtleVswXSAhPT0gXCJfXCIgJiYgIWlzR2xvYmFsbHlXaGl0ZWxpc3RlZChrZXkpO1xuICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgIWhhcyAmJiBQdWJsaWNJbnN0YW5jZVByb3h5SGFuZGxlcnMuaGFzKF8sIGtleSkpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBgUHJvcGVydHkgJHtKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICAgIGtleVxuICAgICAgICAgICl9IHNob3VsZCBub3Qgc3RhcnQgd2l0aCBfIHdoaWNoIGlzIGEgcmVzZXJ2ZWQgcHJlZml4IGZvciBWdWUgaW50ZXJuYWxzLmBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBoYXM7XG4gICAgfVxuICB9XG4pO1xuZnVuY3Rpb24gY3JlYXRlRGV2UmVuZGVyQ29udGV4dChpbnN0YW5jZSkge1xuICBjb25zdCB0YXJnZXQgPSB7fTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgYF9gLCB7XG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGdldDogKCkgPT4gaW5zdGFuY2VcbiAgfSk7XG4gIE9iamVjdC5rZXlzKHB1YmxpY1Byb3BlcnRpZXNNYXApLmZvckVhY2goKGtleSkgPT4ge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwge1xuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICBnZXQ6ICgpID0+IHB1YmxpY1Byb3BlcnRpZXNNYXBba2V5XShpbnN0YW5jZSksXG4gICAgICAvLyBpbnRlcmNlcHRlZCBieSB0aGUgcHJveHkgc28gbm8gbmVlZCBmb3IgaW1wbGVtZW50YXRpb24sXG4gICAgICAvLyBidXQgbmVlZGVkIHRvIHByZXZlbnQgc2V0IGVycm9yc1xuICAgICAgc2V0OiBOT09QXG4gICAgfSk7XG4gIH0pO1xuICByZXR1cm4gdGFyZ2V0O1xufVxuZnVuY3Rpb24gZXhwb3NlUHJvcHNPblJlbmRlckNvbnRleHQoaW5zdGFuY2UpIHtcbiAgY29uc3Qge1xuICAgIGN0eCxcbiAgICBwcm9wc09wdGlvbnM6IFtwcm9wc09wdGlvbnNdXG4gIH0gPSBpbnN0YW5jZTtcbiAgaWYgKHByb3BzT3B0aW9ucykge1xuICAgIE9iamVjdC5rZXlzKHByb3BzT3B0aW9ucykuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3R4LCBrZXksIHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6ICgpID0+IGluc3RhbmNlLnByb3BzW2tleV0sXG4gICAgICAgIHNldDogTk9PUFxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGV4cG9zZVNldHVwU3RhdGVPblJlbmRlckNvbnRleHQoaW5zdGFuY2UpIHtcbiAgY29uc3QgeyBjdHgsIHNldHVwU3RhdGUgfSA9IGluc3RhbmNlO1xuICBPYmplY3Qua2V5cyh0b1JhdyhzZXR1cFN0YXRlKSkuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgaWYgKCFzZXR1cFN0YXRlLl9faXNTY3JpcHRTZXR1cCkge1xuICAgICAgaWYgKGlzUmVzZXJ2ZWRQcmVmaXgoa2V5WzBdKSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIGBzZXR1cCgpIHJldHVybiBwcm9wZXJ0eSAke0pTT04uc3RyaW5naWZ5KFxuICAgICAgICAgICAga2V5XG4gICAgICAgICAgKX0gc2hvdWxkIG5vdCBzdGFydCB3aXRoIFwiJFwiIG9yIFwiX1wiIHdoaWNoIGFyZSByZXNlcnZlZCBwcmVmaXhlcyBmb3IgVnVlIGludGVybmFscy5gXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdHgsIGtleSwge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGdldDogKCkgPT4gc2V0dXBTdGF0ZVtrZXldLFxuICAgICAgICBzZXQ6IE5PT1BcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG59XG5cbmNvbnN0IHdhcm5SdW50aW1lVXNhZ2UgPSAobWV0aG9kKSA9PiB3YXJuKFxuICBgJHttZXRob2R9KCkgaXMgYSBjb21waWxlci1oaW50IGhlbHBlciB0aGF0IGlzIG9ubHkgdXNhYmxlIGluc2lkZSA8c2NyaXB0IHNldHVwPiBvZiBhIHNpbmdsZSBmaWxlIGNvbXBvbmVudC4gSXRzIGFyZ3VtZW50cyBzaG91bGQgYmUgY29tcGlsZWQgYXdheSBhbmQgcGFzc2luZyBpdCBhdCBydW50aW1lIGhhcyBubyBlZmZlY3QuYFxuKTtcbmZ1bmN0aW9uIGRlZmluZVByb3BzKCkge1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIHdhcm5SdW50aW1lVXNhZ2UoYGRlZmluZVByb3BzYCk7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBkZWZpbmVFbWl0cygpIHtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICB3YXJuUnVudGltZVVzYWdlKGBkZWZpbmVFbWl0c2ApO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gZGVmaW5lRXhwb3NlKGV4cG9zZWQpIHtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICB3YXJuUnVudGltZVVzYWdlKGBkZWZpbmVFeHBvc2VgKTtcbiAgfVxufVxuZnVuY3Rpb24gZGVmaW5lT3B0aW9ucyhvcHRpb25zKSB7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgd2FyblJ1bnRpbWVVc2FnZShgZGVmaW5lT3B0aW9uc2ApO1xuICB9XG59XG5mdW5jdGlvbiBkZWZpbmVTbG90cygpIHtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICB3YXJuUnVudGltZVVzYWdlKGBkZWZpbmVTbG90c2ApO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gZGVmaW5lTW9kZWwoKSB7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgd2FyblJ1bnRpbWVVc2FnZShcImRlZmluZU1vZGVsXCIpO1xuICB9XG59XG5mdW5jdGlvbiB3aXRoRGVmYXVsdHMocHJvcHMsIGRlZmF1bHRzKSB7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgd2FyblJ1bnRpbWVVc2FnZShgd2l0aERlZmF1bHRzYCk7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiB1c2VTbG90cygpIHtcbiAgcmV0dXJuIGdldENvbnRleHQoKS5zbG90cztcbn1cbmZ1bmN0aW9uIHVzZUF0dHJzKCkge1xuICByZXR1cm4gZ2V0Q29udGV4dCgpLmF0dHJzO1xufVxuZnVuY3Rpb24gdXNlTW9kZWwocHJvcHMsIG5hbWUsIG9wdGlvbnMpIHtcbiAgY29uc3QgaSA9IGdldEN1cnJlbnRJbnN0YW5jZSgpO1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhaSkge1xuICAgIHdhcm4oYHVzZU1vZGVsKCkgY2FsbGVkIHdpdGhvdXQgYWN0aXZlIGluc3RhbmNlLmApO1xuICAgIHJldHVybiByZWYoKTtcbiAgfVxuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhaS5wcm9wc09wdGlvbnNbMF1bbmFtZV0pIHtcbiAgICB3YXJuKGB1c2VNb2RlbCgpIGNhbGxlZCB3aXRoIHByb3AgXCIke25hbWV9XCIgd2hpY2ggaXMgbm90IGRlY2xhcmVkLmApO1xuICAgIHJldHVybiByZWYoKTtcbiAgfVxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmxvY2FsKSB7XG4gICAgY29uc3QgcHJveHkgPSByZWYocHJvcHNbbmFtZV0pO1xuICAgIHdhdGNoKFxuICAgICAgKCkgPT4gcHJvcHNbbmFtZV0sXG4gICAgICAodikgPT4gcHJveHkudmFsdWUgPSB2XG4gICAgKTtcbiAgICB3YXRjaChwcm94eSwgKHZhbHVlKSA9PiB7XG4gICAgICBpZiAodmFsdWUgIT09IHByb3BzW25hbWVdKSB7XG4gICAgICAgIGkuZW1pdChgdXBkYXRlOiR7bmFtZX1gLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHByb3h5O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB7XG4gICAgICBfX3ZfaXNSZWY6IHRydWUsXG4gICAgICBnZXQgdmFsdWUoKSB7XG4gICAgICAgIHJldHVybiBwcm9wc1tuYW1lXTtcbiAgICAgIH0sXG4gICAgICBzZXQgdmFsdWUodmFsdWUpIHtcbiAgICAgICAgaS5lbWl0KGB1cGRhdGU6JHtuYW1lfWAsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG59XG5mdW5jdGlvbiBnZXRDb250ZXh0KCkge1xuICBjb25zdCBpID0gZ2V0Q3VycmVudEluc3RhbmNlKCk7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICFpKSB7XG4gICAgd2FybihgdXNlQ29udGV4dCgpIGNhbGxlZCB3aXRob3V0IGFjdGl2ZSBpbnN0YW5jZS5gKTtcbiAgfVxuICByZXR1cm4gaS5zZXR1cENvbnRleHQgfHwgKGkuc2V0dXBDb250ZXh0ID0gY3JlYXRlU2V0dXBDb250ZXh0KGkpKTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZVByb3BzT3JFbWl0cyhwcm9wcykge1xuICByZXR1cm4gaXNBcnJheShwcm9wcykgPyBwcm9wcy5yZWR1Y2UoXG4gICAgKG5vcm1hbGl6ZWQsIHApID0+IChub3JtYWxpemVkW3BdID0gbnVsbCwgbm9ybWFsaXplZCksXG4gICAge31cbiAgKSA6IHByb3BzO1xufVxuZnVuY3Rpb24gbWVyZ2VEZWZhdWx0cyhyYXcsIGRlZmF1bHRzKSB7XG4gIGNvbnN0IHByb3BzID0gbm9ybWFsaXplUHJvcHNPckVtaXRzKHJhdyk7XG4gIGZvciAoY29uc3Qga2V5IGluIGRlZmF1bHRzKSB7XG4gICAgaWYgKGtleS5zdGFydHNXaXRoKFwiX19za2lwXCIpKVxuICAgICAgY29udGludWU7XG4gICAgbGV0IG9wdCA9IHByb3BzW2tleV07XG4gICAgaWYgKG9wdCkge1xuICAgICAgaWYgKGlzQXJyYXkob3B0KSB8fCBpc0Z1bmN0aW9uKG9wdCkpIHtcbiAgICAgICAgb3B0ID0gcHJvcHNba2V5XSA9IHsgdHlwZTogb3B0LCBkZWZhdWx0OiBkZWZhdWx0c1trZXldIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvcHQuZGVmYXVsdCA9IGRlZmF1bHRzW2tleV07XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChvcHQgPT09IG51bGwpIHtcbiAgICAgIG9wdCA9IHByb3BzW2tleV0gPSB7IGRlZmF1bHQ6IGRlZmF1bHRzW2tleV0gfTtcbiAgICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgIHdhcm4oYHByb3BzIGRlZmF1bHQga2V5IFwiJHtrZXl9XCIgaGFzIG5vIGNvcnJlc3BvbmRpbmcgZGVjbGFyYXRpb24uYCk7XG4gICAgfVxuICAgIGlmIChvcHQgJiYgZGVmYXVsdHNbYF9fc2tpcF8ke2tleX1gXSkge1xuICAgICAgb3B0LnNraXBGYWN0b3J5ID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHByb3BzO1xufVxuZnVuY3Rpb24gbWVyZ2VNb2RlbHMoYSwgYikge1xuICBpZiAoIWEgfHwgIWIpXG4gICAgcmV0dXJuIGEgfHwgYjtcbiAgaWYgKGlzQXJyYXkoYSkgJiYgaXNBcnJheShiKSlcbiAgICByZXR1cm4gYS5jb25jYXQoYik7XG4gIHJldHVybiBleHRlbmQoe30sIG5vcm1hbGl6ZVByb3BzT3JFbWl0cyhhKSwgbm9ybWFsaXplUHJvcHNPckVtaXRzKGIpKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVByb3BzUmVzdFByb3h5KHByb3BzLCBleGNsdWRlZEtleXMpIHtcbiAgY29uc3QgcmV0ID0ge307XG4gIGZvciAoY29uc3Qga2V5IGluIHByb3BzKSB7XG4gICAgaWYgKCFleGNsdWRlZEtleXMuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHJldCwga2V5LCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldDogKCkgPT4gcHJvcHNba2V5XVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXQ7XG59XG5mdW5jdGlvbiB3aXRoQXN5bmNDb250ZXh0KGdldEF3YWl0YWJsZSkge1xuICBjb25zdCBjdHggPSBnZXRDdXJyZW50SW5zdGFuY2UoKTtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgIWN0eCkge1xuICAgIHdhcm4oXG4gICAgICBgd2l0aEFzeW5jQ29udGV4dCBjYWxsZWQgd2l0aG91dCBhY3RpdmUgY3VycmVudCBpbnN0YW5jZS4gVGhpcyBpcyBsaWtlbHkgYSBidWcuYFxuICAgICk7XG4gIH1cbiAgbGV0IGF3YWl0YWJsZSA9IGdldEF3YWl0YWJsZSgpO1xuICB1bnNldEN1cnJlbnRJbnN0YW5jZSgpO1xuICBpZiAoaXNQcm9taXNlKGF3YWl0YWJsZSkpIHtcbiAgICBhd2FpdGFibGUgPSBhd2FpdGFibGUuY2F0Y2goKGUpID0+IHtcbiAgICAgIHNldEN1cnJlbnRJbnN0YW5jZShjdHgpO1xuICAgICAgdGhyb3cgZTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gW2F3YWl0YWJsZSwgKCkgPT4gc2V0Q3VycmVudEluc3RhbmNlKGN0eCldO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVEdXBsaWNhdGVDaGVja2VyKCkge1xuICBjb25zdCBjYWNoZSA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICByZXR1cm4gKHR5cGUsIGtleSkgPT4ge1xuICAgIGlmIChjYWNoZVtrZXldKSB7XG4gICAgICB3YXJuKGAke3R5cGV9IHByb3BlcnR5IFwiJHtrZXl9XCIgaXMgYWxyZWFkeSBkZWZpbmVkIGluICR7Y2FjaGVba2V5XX0uYCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhY2hlW2tleV0gPSB0eXBlO1xuICAgIH1cbiAgfTtcbn1cbmxldCBzaG91bGRDYWNoZUFjY2VzcyA9IHRydWU7XG5mdW5jdGlvbiBhcHBseU9wdGlvbnMoaW5zdGFuY2UpIHtcbiAgY29uc3Qgb3B0aW9ucyA9IHJlc29sdmVNZXJnZWRPcHRpb25zKGluc3RhbmNlKTtcbiAgY29uc3QgcHVibGljVGhpcyA9IGluc3RhbmNlLnByb3h5O1xuICBjb25zdCBjdHggPSBpbnN0YW5jZS5jdHg7XG4gIHNob3VsZENhY2hlQWNjZXNzID0gZmFsc2U7XG4gIGlmIChvcHRpb25zLmJlZm9yZUNyZWF0ZSkge1xuICAgIGNhbGxIb29rKG9wdGlvbnMuYmVmb3JlQ3JlYXRlLCBpbnN0YW5jZSwgXCJiY1wiKTtcbiAgfVxuICBjb25zdCB7XG4gICAgLy8gc3RhdGVcbiAgICBkYXRhOiBkYXRhT3B0aW9ucyxcbiAgICBjb21wdXRlZDogY29tcHV0ZWRPcHRpb25zLFxuICAgIG1ldGhvZHMsXG4gICAgd2F0Y2g6IHdhdGNoT3B0aW9ucyxcbiAgICBwcm92aWRlOiBwcm92aWRlT3B0aW9ucyxcbiAgICBpbmplY3Q6IGluamVjdE9wdGlvbnMsXG4gICAgLy8gbGlmZWN5Y2xlXG4gICAgY3JlYXRlZCxcbiAgICBiZWZvcmVNb3VudCxcbiAgICBtb3VudGVkLFxuICAgIGJlZm9yZVVwZGF0ZSxcbiAgICB1cGRhdGVkLFxuICAgIGFjdGl2YXRlZCxcbiAgICBkZWFjdGl2YXRlZCxcbiAgICBiZWZvcmVEZXN0cm95LFxuICAgIGJlZm9yZVVubW91bnQsXG4gICAgZGVzdHJveWVkLFxuICAgIHVubW91bnRlZCxcbiAgICByZW5kZXIsXG4gICAgcmVuZGVyVHJhY2tlZCxcbiAgICByZW5kZXJUcmlnZ2VyZWQsXG4gICAgZXJyb3JDYXB0dXJlZCxcbiAgICBzZXJ2ZXJQcmVmZXRjaCxcbiAgICAvLyBwdWJsaWMgQVBJXG4gICAgZXhwb3NlLFxuICAgIGluaGVyaXRBdHRycyxcbiAgICAvLyBhc3NldHNcbiAgICBjb21wb25lbnRzLFxuICAgIGRpcmVjdGl2ZXMsXG4gICAgZmlsdGVyc1xuICB9ID0gb3B0aW9ucztcbiAgY29uc3QgY2hlY2tEdXBsaWNhdGVQcm9wZXJ0aWVzID0gISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IGNyZWF0ZUR1cGxpY2F0ZUNoZWNrZXIoKSA6IG51bGw7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgY29uc3QgW3Byb3BzT3B0aW9uc10gPSBpbnN0YW5jZS5wcm9wc09wdGlvbnM7XG4gICAgaWYgKHByb3BzT3B0aW9ucykge1xuICAgICAgZm9yIChjb25zdCBrZXkgaW4gcHJvcHNPcHRpb25zKSB7XG4gICAgICAgIGNoZWNrRHVwbGljYXRlUHJvcGVydGllcyhcIlByb3BzXCIgLyogUFJPUFMgKi8sIGtleSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChpbmplY3RPcHRpb25zKSB7XG4gICAgcmVzb2x2ZUluamVjdGlvbnMoaW5qZWN0T3B0aW9ucywgY3R4LCBjaGVja0R1cGxpY2F0ZVByb3BlcnRpZXMpO1xuICB9XG4gIGlmIChtZXRob2RzKSB7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gbWV0aG9kcykge1xuICAgICAgY29uc3QgbWV0aG9kSGFuZGxlciA9IG1ldGhvZHNba2V5XTtcbiAgICAgIGlmIChpc0Z1bmN0aW9uKG1ldGhvZEhhbmRsZXIpKSB7XG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN0eCwga2V5LCB7XG4gICAgICAgICAgICB2YWx1ZTogbWV0aG9kSGFuZGxlci5iaW5kKHB1YmxpY1RoaXMpLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3R4W2tleV0gPSBtZXRob2RIYW5kbGVyLmJpbmQocHVibGljVGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICBjaGVja0R1cGxpY2F0ZVByb3BlcnRpZXMoXCJNZXRob2RzXCIgLyogTUVUSE9EUyAqLywga2V5KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgYE1ldGhvZCBcIiR7a2V5fVwiIGhhcyB0eXBlIFwiJHt0eXBlb2YgbWV0aG9kSGFuZGxlcn1cIiBpbiB0aGUgY29tcG9uZW50IGRlZmluaXRpb24uIERpZCB5b3UgcmVmZXJlbmNlIHRoZSBmdW5jdGlvbiBjb3JyZWN0bHk/YFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoZGF0YU9wdGlvbnMpIHtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhaXNGdW5jdGlvbihkYXRhT3B0aW9ucykpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIGBUaGUgZGF0YSBvcHRpb24gbXVzdCBiZSBhIGZ1bmN0aW9uLiBQbGFpbiBvYmplY3QgdXNhZ2UgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZC5gXG4gICAgICApO1xuICAgIH1cbiAgICBjb25zdCBkYXRhID0gZGF0YU9wdGlvbnMuY2FsbChwdWJsaWNUaGlzLCBwdWJsaWNUaGlzKTtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBpc1Byb21pc2UoZGF0YSkpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIGBkYXRhKCkgcmV0dXJuZWQgYSBQcm9taXNlIC0gbm90ZSBkYXRhKCkgY2Fubm90IGJlIGFzeW5jOyBJZiB5b3UgaW50ZW5kIHRvIHBlcmZvcm0gZGF0YSBmZXRjaGluZyBiZWZvcmUgY29tcG9uZW50IHJlbmRlcnMsIHVzZSBhc3luYyBzZXR1cCgpICsgPFN1c3BlbnNlPi5gXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoIWlzT2JqZWN0KGRhdGEpKSB7XG4gICAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHdhcm4oYGRhdGEoKSBzaG91bGQgcmV0dXJuIGFuIG9iamVjdC5gKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW5zdGFuY2UuZGF0YSA9IHJlYWN0aXZlKGRhdGEpO1xuICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gZGF0YSkge1xuICAgICAgICAgIGNoZWNrRHVwbGljYXRlUHJvcGVydGllcyhcIkRhdGFcIiAvKiBEQVRBICovLCBrZXkpO1xuICAgICAgICAgIGlmICghaXNSZXNlcnZlZFByZWZpeChrZXlbMF0pKSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3R4LCBrZXksIHtcbiAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICBnZXQ6ICgpID0+IGRhdGFba2V5XSxcbiAgICAgICAgICAgICAgc2V0OiBOT09QXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgc2hvdWxkQ2FjaGVBY2Nlc3MgPSB0cnVlO1xuICBpZiAoY29tcHV0ZWRPcHRpb25zKSB7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gY29tcHV0ZWRPcHRpb25zKSB7XG4gICAgICBjb25zdCBvcHQgPSBjb21wdXRlZE9wdGlvbnNba2V5XTtcbiAgICAgIGNvbnN0IGdldCA9IGlzRnVuY3Rpb24ob3B0KSA/IG9wdC5iaW5kKHB1YmxpY1RoaXMsIHB1YmxpY1RoaXMpIDogaXNGdW5jdGlvbihvcHQuZ2V0KSA/IG9wdC5nZXQuYmluZChwdWJsaWNUaGlzLCBwdWJsaWNUaGlzKSA6IE5PT1A7XG4gICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBnZXQgPT09IE5PT1ApIHtcbiAgICAgICAgd2FybihgQ29tcHV0ZWQgcHJvcGVydHkgXCIke2tleX1cIiBoYXMgbm8gZ2V0dGVyLmApO1xuICAgICAgfVxuICAgICAgY29uc3Qgc2V0ID0gIWlzRnVuY3Rpb24ob3B0KSAmJiBpc0Z1bmN0aW9uKG9wdC5zZXQpID8gb3B0LnNldC5iaW5kKHB1YmxpY1RoaXMpIDogISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/ICgpID0+IHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBgV3JpdGUgb3BlcmF0aW9uIGZhaWxlZDogY29tcHV0ZWQgcHJvcGVydHkgXCIke2tleX1cIiBpcyByZWFkb25seS5gXG4gICAgICAgICk7XG4gICAgICB9IDogTk9PUDtcbiAgICAgIGNvbnN0IGMgPSBjb21wdXRlZCh7XG4gICAgICAgIGdldCxcbiAgICAgICAgc2V0XG4gICAgICB9KTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdHgsIGtleSwge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGdldDogKCkgPT4gYy52YWx1ZSxcbiAgICAgICAgc2V0OiAodikgPT4gYy52YWx1ZSA9IHZcbiAgICAgIH0pO1xuICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgY2hlY2tEdXBsaWNhdGVQcm9wZXJ0aWVzKFwiQ29tcHV0ZWRcIiAvKiBDT01QVVRFRCAqLywga2V5KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKHdhdGNoT3B0aW9ucykge1xuICAgIGZvciAoY29uc3Qga2V5IGluIHdhdGNoT3B0aW9ucykge1xuICAgICAgY3JlYXRlV2F0Y2hlcih3YXRjaE9wdGlvbnNba2V5XSwgY3R4LCBwdWJsaWNUaGlzLCBrZXkpO1xuICAgIH1cbiAgfVxuICBpZiAocHJvdmlkZU9wdGlvbnMpIHtcbiAgICBjb25zdCBwcm92aWRlcyA9IGlzRnVuY3Rpb24ocHJvdmlkZU9wdGlvbnMpID8gcHJvdmlkZU9wdGlvbnMuY2FsbChwdWJsaWNUaGlzKSA6IHByb3ZpZGVPcHRpb25zO1xuICAgIFJlZmxlY3Qub3duS2V5cyhwcm92aWRlcykuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICBwcm92aWRlKGtleSwgcHJvdmlkZXNba2V5XSk7XG4gICAgfSk7XG4gIH1cbiAgaWYgKGNyZWF0ZWQpIHtcbiAgICBjYWxsSG9vayhjcmVhdGVkLCBpbnN0YW5jZSwgXCJjXCIpO1xuICB9XG4gIGZ1bmN0aW9uIHJlZ2lzdGVyTGlmZWN5Y2xlSG9vayhyZWdpc3RlciwgaG9vaykge1xuICAgIGlmIChpc0FycmF5KGhvb2spKSB7XG4gICAgICBob29rLmZvckVhY2goKF9ob29rKSA9PiByZWdpc3RlcihfaG9vay5iaW5kKHB1YmxpY1RoaXMpKSk7XG4gICAgfSBlbHNlIGlmIChob29rKSB7XG4gICAgICByZWdpc3Rlcihob29rLmJpbmQocHVibGljVGhpcykpO1xuICAgIH1cbiAgfVxuICByZWdpc3RlckxpZmVjeWNsZUhvb2sob25CZWZvcmVNb3VudCwgYmVmb3JlTW91bnQpO1xuICByZWdpc3RlckxpZmVjeWNsZUhvb2sob25Nb3VudGVkLCBtb3VudGVkKTtcbiAgcmVnaXN0ZXJMaWZlY3ljbGVIb29rKG9uQmVmb3JlVXBkYXRlLCBiZWZvcmVVcGRhdGUpO1xuICByZWdpc3RlckxpZmVjeWNsZUhvb2sob25VcGRhdGVkLCB1cGRhdGVkKTtcbiAgcmVnaXN0ZXJMaWZlY3ljbGVIb29rKG9uQWN0aXZhdGVkLCBhY3RpdmF0ZWQpO1xuICByZWdpc3RlckxpZmVjeWNsZUhvb2sob25EZWFjdGl2YXRlZCwgZGVhY3RpdmF0ZWQpO1xuICByZWdpc3RlckxpZmVjeWNsZUhvb2sob25FcnJvckNhcHR1cmVkLCBlcnJvckNhcHR1cmVkKTtcbiAgcmVnaXN0ZXJMaWZlY3ljbGVIb29rKG9uUmVuZGVyVHJhY2tlZCwgcmVuZGVyVHJhY2tlZCk7XG4gIHJlZ2lzdGVyTGlmZWN5Y2xlSG9vayhvblJlbmRlclRyaWdnZXJlZCwgcmVuZGVyVHJpZ2dlcmVkKTtcbiAgcmVnaXN0ZXJMaWZlY3ljbGVIb29rKG9uQmVmb3JlVW5tb3VudCwgYmVmb3JlVW5tb3VudCk7XG4gIHJlZ2lzdGVyTGlmZWN5Y2xlSG9vayhvblVubW91bnRlZCwgdW5tb3VudGVkKTtcbiAgcmVnaXN0ZXJMaWZlY3ljbGVIb29rKG9uU2VydmVyUHJlZmV0Y2gsIHNlcnZlclByZWZldGNoKTtcbiAgaWYgKGlzQXJyYXkoZXhwb3NlKSkge1xuICAgIGlmIChleHBvc2UubGVuZ3RoKSB7XG4gICAgICBjb25zdCBleHBvc2VkID0gaW5zdGFuY2UuZXhwb3NlZCB8fCAoaW5zdGFuY2UuZXhwb3NlZCA9IHt9KTtcbiAgICAgIGV4cG9zZS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9zZWQsIGtleSwge1xuICAgICAgICAgIGdldDogKCkgPT4gcHVibGljVGhpc1trZXldLFxuICAgICAgICAgIHNldDogKHZhbCkgPT4gcHVibGljVGhpc1trZXldID0gdmFsXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmICghaW5zdGFuY2UuZXhwb3NlZCkge1xuICAgICAgaW5zdGFuY2UuZXhwb3NlZCA9IHt9O1xuICAgIH1cbiAgfVxuICBpZiAocmVuZGVyICYmIGluc3RhbmNlLnJlbmRlciA9PT0gTk9PUCkge1xuICAgIGluc3RhbmNlLnJlbmRlciA9IHJlbmRlcjtcbiAgfVxuICBpZiAoaW5oZXJpdEF0dHJzICE9IG51bGwpIHtcbiAgICBpbnN0YW5jZS5pbmhlcml0QXR0cnMgPSBpbmhlcml0QXR0cnM7XG4gIH1cbiAgaWYgKGNvbXBvbmVudHMpXG4gICAgaW5zdGFuY2UuY29tcG9uZW50cyA9IGNvbXBvbmVudHM7XG4gIGlmIChkaXJlY3RpdmVzKVxuICAgIGluc3RhbmNlLmRpcmVjdGl2ZXMgPSBkaXJlY3RpdmVzO1xufVxuZnVuY3Rpb24gcmVzb2x2ZUluamVjdGlvbnMoaW5qZWN0T3B0aW9ucywgY3R4LCBjaGVja0R1cGxpY2F0ZVByb3BlcnRpZXMgPSBOT09QKSB7XG4gIGlmIChpc0FycmF5KGluamVjdE9wdGlvbnMpKSB7XG4gICAgaW5qZWN0T3B0aW9ucyA9IG5vcm1hbGl6ZUluamVjdChpbmplY3RPcHRpb25zKTtcbiAgfVxuICBmb3IgKGNvbnN0IGtleSBpbiBpbmplY3RPcHRpb25zKSB7XG4gICAgY29uc3Qgb3B0ID0gaW5qZWN0T3B0aW9uc1trZXldO1xuICAgIGxldCBpbmplY3RlZDtcbiAgICBpZiAoaXNPYmplY3Qob3B0KSkge1xuICAgICAgaWYgKFwiZGVmYXVsdFwiIGluIG9wdCkge1xuICAgICAgICBpbmplY3RlZCA9IGluamVjdChcbiAgICAgICAgICBvcHQuZnJvbSB8fCBrZXksXG4gICAgICAgICAgb3B0LmRlZmF1bHQsXG4gICAgICAgICAgdHJ1ZVxuICAgICAgICAgIC8qIHRyZWF0IGRlZmF1bHQgZnVuY3Rpb24gYXMgZmFjdG9yeSAqL1xuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5qZWN0ZWQgPSBpbmplY3Qob3B0LmZyb20gfHwga2V5KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaW5qZWN0ZWQgPSBpbmplY3Qob3B0KTtcbiAgICB9XG4gICAgaWYgKGlzUmVmKGluamVjdGVkKSkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN0eCwga2V5LCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiAoKSA9PiBpbmplY3RlZC52YWx1ZSxcbiAgICAgICAgc2V0OiAodikgPT4gaW5qZWN0ZWQudmFsdWUgPSB2XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3R4W2tleV0gPSBpbmplY3RlZDtcbiAgICB9XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgIGNoZWNrRHVwbGljYXRlUHJvcGVydGllcyhcIkluamVjdFwiIC8qIElOSkVDVCAqLywga2V5KTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGNhbGxIb29rKGhvb2ssIGluc3RhbmNlLCB0eXBlKSB7XG4gIGNhbGxXaXRoQXN5bmNFcnJvckhhbmRsaW5nKFxuICAgIGlzQXJyYXkoaG9vaykgPyBob29rLm1hcCgoaCkgPT4gaC5iaW5kKGluc3RhbmNlLnByb3h5KSkgOiBob29rLmJpbmQoaW5zdGFuY2UucHJveHkpLFxuICAgIGluc3RhbmNlLFxuICAgIHR5cGVcbiAgKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVdhdGNoZXIocmF3LCBjdHgsIHB1YmxpY1RoaXMsIGtleSkge1xuICBjb25zdCBnZXR0ZXIgPSBrZXkuaW5jbHVkZXMoXCIuXCIpID8gY3JlYXRlUGF0aEdldHRlcihwdWJsaWNUaGlzLCBrZXkpIDogKCkgPT4gcHVibGljVGhpc1trZXldO1xuICBpZiAoaXNTdHJpbmcocmF3KSkge1xuICAgIGNvbnN0IGhhbmRsZXIgPSBjdHhbcmF3XTtcbiAgICBpZiAoaXNGdW5jdGlvbihoYW5kbGVyKSkge1xuICAgICAgd2F0Y2goZ2V0dGVyLCBoYW5kbGVyKTtcbiAgICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgIHdhcm4oYEludmFsaWQgd2F0Y2ggaGFuZGxlciBzcGVjaWZpZWQgYnkga2V5IFwiJHtyYXd9XCJgLCBoYW5kbGVyKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNGdW5jdGlvbihyYXcpKSB7XG4gICAgd2F0Y2goZ2V0dGVyLCByYXcuYmluZChwdWJsaWNUaGlzKSk7XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QocmF3KSkge1xuICAgIGlmIChpc0FycmF5KHJhdykpIHtcbiAgICAgIHJhdy5mb3JFYWNoKChyKSA9PiBjcmVhdGVXYXRjaGVyKHIsIGN0eCwgcHVibGljVGhpcywga2V5KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGhhbmRsZXIgPSBpc0Z1bmN0aW9uKHJhdy5oYW5kbGVyKSA/IHJhdy5oYW5kbGVyLmJpbmQocHVibGljVGhpcykgOiBjdHhbcmF3LmhhbmRsZXJdO1xuICAgICAgaWYgKGlzRnVuY3Rpb24oaGFuZGxlcikpIHtcbiAgICAgICAgd2F0Y2goZ2V0dGVyLCBoYW5kbGVyLCByYXcpO1xuICAgICAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgIHdhcm4oYEludmFsaWQgd2F0Y2ggaGFuZGxlciBzcGVjaWZpZWQgYnkga2V5IFwiJHtyYXcuaGFuZGxlcn1cImAsIGhhbmRsZXIpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgd2FybihgSW52YWxpZCB3YXRjaCBvcHRpb246IFwiJHtrZXl9XCJgLCByYXcpO1xuICB9XG59XG5mdW5jdGlvbiByZXNvbHZlTWVyZ2VkT3B0aW9ucyhpbnN0YW5jZSkge1xuICBjb25zdCBiYXNlID0gaW5zdGFuY2UudHlwZTtcbiAgY29uc3QgeyBtaXhpbnMsIGV4dGVuZHM6IGV4dGVuZHNPcHRpb25zIH0gPSBiYXNlO1xuICBjb25zdCB7XG4gICAgbWl4aW5zOiBnbG9iYWxNaXhpbnMsXG4gICAgb3B0aW9uc0NhY2hlOiBjYWNoZSxcbiAgICBjb25maWc6IHsgb3B0aW9uTWVyZ2VTdHJhdGVnaWVzIH1cbiAgfSA9IGluc3RhbmNlLmFwcENvbnRleHQ7XG4gIGNvbnN0IGNhY2hlZCA9IGNhY2hlLmdldChiYXNlKTtcbiAgbGV0IHJlc29sdmVkO1xuICBpZiAoY2FjaGVkKSB7XG4gICAgcmVzb2x2ZWQgPSBjYWNoZWQ7XG4gIH0gZWxzZSBpZiAoIWdsb2JhbE1peGlucy5sZW5ndGggJiYgIW1peGlucyAmJiAhZXh0ZW5kc09wdGlvbnMpIHtcbiAgICB7XG4gICAgICByZXNvbHZlZCA9IGJhc2U7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJlc29sdmVkID0ge307XG4gICAgaWYgKGdsb2JhbE1peGlucy5sZW5ndGgpIHtcbiAgICAgIGdsb2JhbE1peGlucy5mb3JFYWNoKFxuICAgICAgICAobSkgPT4gbWVyZ2VPcHRpb25zKHJlc29sdmVkLCBtLCBvcHRpb25NZXJnZVN0cmF0ZWdpZXMsIHRydWUpXG4gICAgICApO1xuICAgIH1cbiAgICBtZXJnZU9wdGlvbnMocmVzb2x2ZWQsIGJhc2UsIG9wdGlvbk1lcmdlU3RyYXRlZ2llcyk7XG4gIH1cbiAgaWYgKGlzT2JqZWN0KGJhc2UpKSB7XG4gICAgY2FjaGUuc2V0KGJhc2UsIHJlc29sdmVkKTtcbiAgfVxuICByZXR1cm4gcmVzb2x2ZWQ7XG59XG5mdW5jdGlvbiBtZXJnZU9wdGlvbnModG8sIGZyb20sIHN0cmF0cywgYXNNaXhpbiA9IGZhbHNlKSB7XG4gIGNvbnN0IHsgbWl4aW5zLCBleHRlbmRzOiBleHRlbmRzT3B0aW9ucyB9ID0gZnJvbTtcbiAgaWYgKGV4dGVuZHNPcHRpb25zKSB7XG4gICAgbWVyZ2VPcHRpb25zKHRvLCBleHRlbmRzT3B0aW9ucywgc3RyYXRzLCB0cnVlKTtcbiAgfVxuICBpZiAobWl4aW5zKSB7XG4gICAgbWl4aW5zLmZvckVhY2goXG4gICAgICAobSkgPT4gbWVyZ2VPcHRpb25zKHRvLCBtLCBzdHJhdHMsIHRydWUpXG4gICAgKTtcbiAgfVxuICBmb3IgKGNvbnN0IGtleSBpbiBmcm9tKSB7XG4gICAgaWYgKGFzTWl4aW4gJiYga2V5ID09PSBcImV4cG9zZVwiKSB7XG4gICAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHdhcm4oXG4gICAgICAgIGBcImV4cG9zZVwiIG9wdGlvbiBpcyBpZ25vcmVkIHdoZW4gZGVjbGFyZWQgaW4gbWl4aW5zIG9yIGV4dGVuZHMuIEl0IHNob3VsZCBvbmx5IGJlIGRlY2xhcmVkIGluIHRoZSBiYXNlIGNvbXBvbmVudCBpdHNlbGYuYFxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgc3RyYXQgPSBpbnRlcm5hbE9wdGlvbk1lcmdlU3RyYXRzW2tleV0gfHwgc3RyYXRzICYmIHN0cmF0c1trZXldO1xuICAgICAgdG9ba2V5XSA9IHN0cmF0ID8gc3RyYXQodG9ba2V5XSwgZnJvbVtrZXldKSA6IGZyb21ba2V5XTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRvO1xufVxuY29uc3QgaW50ZXJuYWxPcHRpb25NZXJnZVN0cmF0cyA9IHtcbiAgZGF0YTogbWVyZ2VEYXRhRm4sXG4gIHByb3BzOiBtZXJnZUVtaXRzT3JQcm9wc09wdGlvbnMsXG4gIGVtaXRzOiBtZXJnZUVtaXRzT3JQcm9wc09wdGlvbnMsXG4gIC8vIG9iamVjdHNcbiAgbWV0aG9kczogbWVyZ2VPYmplY3RPcHRpb25zLFxuICBjb21wdXRlZDogbWVyZ2VPYmplY3RPcHRpb25zLFxuICAvLyBsaWZlY3ljbGVcbiAgYmVmb3JlQ3JlYXRlOiBtZXJnZUFzQXJyYXksXG4gIGNyZWF0ZWQ6IG1lcmdlQXNBcnJheSxcbiAgYmVmb3JlTW91bnQ6IG1lcmdlQXNBcnJheSxcbiAgbW91bnRlZDogbWVyZ2VBc0FycmF5LFxuICBiZWZvcmVVcGRhdGU6IG1lcmdlQXNBcnJheSxcbiAgdXBkYXRlZDogbWVyZ2VBc0FycmF5LFxuICBiZWZvcmVEZXN0cm95OiBtZXJnZUFzQXJyYXksXG4gIGJlZm9yZVVubW91bnQ6IG1lcmdlQXNBcnJheSxcbiAgZGVzdHJveWVkOiBtZXJnZUFzQXJyYXksXG4gIHVubW91bnRlZDogbWVyZ2VBc0FycmF5LFxuICBhY3RpdmF0ZWQ6IG1lcmdlQXNBcnJheSxcbiAgZGVhY3RpdmF0ZWQ6IG1lcmdlQXNBcnJheSxcbiAgZXJyb3JDYXB0dXJlZDogbWVyZ2VBc0FycmF5LFxuICBzZXJ2ZXJQcmVmZXRjaDogbWVyZ2VBc0FycmF5LFxuICAvLyBhc3NldHNcbiAgY29tcG9uZW50czogbWVyZ2VPYmplY3RPcHRpb25zLFxuICBkaXJlY3RpdmVzOiBtZXJnZU9iamVjdE9wdGlvbnMsXG4gIC8vIHdhdGNoXG4gIHdhdGNoOiBtZXJnZVdhdGNoT3B0aW9ucyxcbiAgLy8gcHJvdmlkZSAvIGluamVjdFxuICBwcm92aWRlOiBtZXJnZURhdGFGbixcbiAgaW5qZWN0OiBtZXJnZUluamVjdFxufTtcbmZ1bmN0aW9uIG1lcmdlRGF0YUZuKHRvLCBmcm9tKSB7XG4gIGlmICghZnJvbSkge1xuICAgIHJldHVybiB0bztcbiAgfVxuICBpZiAoIXRvKSB7XG4gICAgcmV0dXJuIGZyb207XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uIG1lcmdlZERhdGFGbigpIHtcbiAgICByZXR1cm4gKGV4dGVuZCkoXG4gICAgICBpc0Z1bmN0aW9uKHRvKSA/IHRvLmNhbGwodGhpcywgdGhpcykgOiB0byxcbiAgICAgIGlzRnVuY3Rpb24oZnJvbSkgPyBmcm9tLmNhbGwodGhpcywgdGhpcykgOiBmcm9tXG4gICAgKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIG1lcmdlSW5qZWN0KHRvLCBmcm9tKSB7XG4gIHJldHVybiBtZXJnZU9iamVjdE9wdGlvbnMobm9ybWFsaXplSW5qZWN0KHRvKSwgbm9ybWFsaXplSW5qZWN0KGZyb20pKTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZUluamVjdChyYXcpIHtcbiAgaWYgKGlzQXJyYXkocmF3KSkge1xuICAgIGNvbnN0IHJlcyA9IHt9O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmF3Lmxlbmd0aDsgaSsrKSB7XG4gICAgICByZXNbcmF3W2ldXSA9IHJhd1tpXTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbiAgfVxuICByZXR1cm4gcmF3O1xufVxuZnVuY3Rpb24gbWVyZ2VBc0FycmF5KHRvLCBmcm9tKSB7XG4gIHJldHVybiB0byA/IFsuLi5uZXcgU2V0KFtdLmNvbmNhdCh0bywgZnJvbSkpXSA6IGZyb207XG59XG5mdW5jdGlvbiBtZXJnZU9iamVjdE9wdGlvbnModG8sIGZyb20pIHtcbiAgcmV0dXJuIHRvID8gZXh0ZW5kKC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpLCB0bywgZnJvbSkgOiBmcm9tO1xufVxuZnVuY3Rpb24gbWVyZ2VFbWl0c09yUHJvcHNPcHRpb25zKHRvLCBmcm9tKSB7XG4gIGlmICh0bykge1xuICAgIGlmIChpc0FycmF5KHRvKSAmJiBpc0FycmF5KGZyb20pKSB7XG4gICAgICByZXR1cm4gWy4uLi8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFsuLi50bywgLi4uZnJvbV0pXTtcbiAgICB9XG4gICAgcmV0dXJuIGV4dGVuZChcbiAgICAgIC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpLFxuICAgICAgbm9ybWFsaXplUHJvcHNPckVtaXRzKHRvKSxcbiAgICAgIG5vcm1hbGl6ZVByb3BzT3JFbWl0cyhmcm9tICE9IG51bGwgPyBmcm9tIDoge30pXG4gICAgKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZnJvbTtcbiAgfVxufVxuZnVuY3Rpb24gbWVyZ2VXYXRjaE9wdGlvbnModG8sIGZyb20pIHtcbiAgaWYgKCF0bylcbiAgICByZXR1cm4gZnJvbTtcbiAgaWYgKCFmcm9tKVxuICAgIHJldHVybiB0bztcbiAgY29uc3QgbWVyZ2VkID0gZXh0ZW5kKC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpLCB0byk7XG4gIGZvciAoY29uc3Qga2V5IGluIGZyb20pIHtcbiAgICBtZXJnZWRba2V5XSA9IG1lcmdlQXNBcnJheSh0b1trZXldLCBmcm9tW2tleV0pO1xuICB9XG4gIHJldHVybiBtZXJnZWQ7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUFwcENvbnRleHQoKSB7XG4gIHJldHVybiB7XG4gICAgYXBwOiBudWxsLFxuICAgIGNvbmZpZzoge1xuICAgICAgaXNOYXRpdmVUYWc6IE5PLFxuICAgICAgcGVyZm9ybWFuY2U6IGZhbHNlLFxuICAgICAgZ2xvYmFsUHJvcGVydGllczoge30sXG4gICAgICBvcHRpb25NZXJnZVN0cmF0ZWdpZXM6IHt9LFxuICAgICAgZXJyb3JIYW5kbGVyOiB2b2lkIDAsXG4gICAgICB3YXJuSGFuZGxlcjogdm9pZCAwLFxuICAgICAgY29tcGlsZXJPcHRpb25zOiB7fVxuICAgIH0sXG4gICAgbWl4aW5zOiBbXSxcbiAgICBjb21wb25lbnRzOiB7fSxcbiAgICBkaXJlY3RpdmVzOiB7fSxcbiAgICBwcm92aWRlczogLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCksXG4gICAgb3B0aW9uc0NhY2hlOiAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKSxcbiAgICBwcm9wc0NhY2hlOiAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKSxcbiAgICBlbWl0c0NhY2hlOiAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKVxuICB9O1xufVxubGV0IHVpZCQxID0gMDtcbmZ1bmN0aW9uIGNyZWF0ZUFwcEFQSShyZW5kZXIsIGh5ZHJhdGUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGNyZWF0ZUFwcChyb290Q29tcG9uZW50LCByb290UHJvcHMgPSBudWxsKSB7XG4gICAgaWYgKCFpc0Z1bmN0aW9uKHJvb3RDb21wb25lbnQpKSB7XG4gICAgICByb290Q29tcG9uZW50ID0gZXh0ZW5kKHt9LCByb290Q29tcG9uZW50KTtcbiAgICB9XG4gICAgaWYgKHJvb3RQcm9wcyAhPSBudWxsICYmICFpc09iamVjdChyb290UHJvcHMpKSB7XG4gICAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHdhcm4oYHJvb3QgcHJvcHMgcGFzc2VkIHRvIGFwcC5tb3VudCgpIG11c3QgYmUgYW4gb2JqZWN0LmApO1xuICAgICAgcm9vdFByb3BzID0gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgY29udGV4dCA9IGNyZWF0ZUFwcENvbnRleHQoKTtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNvbnRleHQuY29uZmlnLCBcInVud3JhcEluamVjdGVkUmVmXCIsIHtcbiAgICAgICAgZ2V0KCkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9LFxuICAgICAgICBzZXQoKSB7XG4gICAgICAgICAgd2FybihcbiAgICAgICAgICAgIGBhcHAuY29uZmlnLnVud3JhcEluamVjdGVkUmVmIGhhcyBiZWVuIGRlcHJlY2F0ZWQuIDMuMyBub3cgYWxhd3lzIHVud3JhcHMgaW5qZWN0ZWQgcmVmcyBpbiBPcHRpb25zIEFQSS5gXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IGluc3RhbGxlZFBsdWdpbnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIGxldCBpc01vdW50ZWQgPSBmYWxzZTtcbiAgICBjb25zdCBhcHAgPSBjb250ZXh0LmFwcCA9IHtcbiAgICAgIF91aWQ6IHVpZCQxKyssXG4gICAgICBfY29tcG9uZW50OiByb290Q29tcG9uZW50LFxuICAgICAgX3Byb3BzOiByb290UHJvcHMsXG4gICAgICBfY29udGFpbmVyOiBudWxsLFxuICAgICAgX2NvbnRleHQ6IGNvbnRleHQsXG4gICAgICBfaW5zdGFuY2U6IG51bGwsXG4gICAgICB2ZXJzaW9uLFxuICAgICAgZ2V0IGNvbmZpZygpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRleHQuY29uZmlnO1xuICAgICAgfSxcbiAgICAgIHNldCBjb25maWcodikge1xuICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICBgYXBwLmNvbmZpZyBjYW5ub3QgYmUgcmVwbGFjZWQuIE1vZGlmeSBpbmRpdmlkdWFsIG9wdGlvbnMgaW5zdGVhZC5gXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHVzZShwbHVnaW4sIC4uLm9wdGlvbnMpIHtcbiAgICAgICAgaWYgKGluc3RhbGxlZFBsdWdpbnMuaGFzKHBsdWdpbikpIHtcbiAgICAgICAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHdhcm4oYFBsdWdpbiBoYXMgYWxyZWFkeSBiZWVuIGFwcGxpZWQgdG8gdGFyZ2V0IGFwcC5gKTtcbiAgICAgICAgfSBlbHNlIGlmIChwbHVnaW4gJiYgaXNGdW5jdGlvbihwbHVnaW4uaW5zdGFsbCkpIHtcbiAgICAgICAgICBpbnN0YWxsZWRQbHVnaW5zLmFkZChwbHVnaW4pO1xuICAgICAgICAgIHBsdWdpbi5pbnN0YWxsKGFwcCwgLi4ub3B0aW9ucyk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNGdW5jdGlvbihwbHVnaW4pKSB7XG4gICAgICAgICAgaW5zdGFsbGVkUGx1Z2lucy5hZGQocGx1Z2luKTtcbiAgICAgICAgICBwbHVnaW4oYXBwLCAuLi5vcHRpb25zKTtcbiAgICAgICAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgd2FybihcbiAgICAgICAgICAgIGBBIHBsdWdpbiBtdXN0IGVpdGhlciBiZSBhIGZ1bmN0aW9uIG9yIGFuIG9iamVjdCB3aXRoIGFuIFwiaW5zdGFsbFwiIGZ1bmN0aW9uLmBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcHA7XG4gICAgICB9LFxuICAgICAgbWl4aW4obWl4aW4pIHtcbiAgICAgICAgaWYgKF9fVlVFX09QVElPTlNfQVBJX18pIHtcbiAgICAgICAgICBpZiAoIWNvbnRleHQubWl4aW5zLmluY2x1ZGVzKG1peGluKSkge1xuICAgICAgICAgICAgY29udGV4dC5taXhpbnMucHVzaChtaXhpbik7XG4gICAgICAgICAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgICBcIk1peGluIGhhcyBhbHJlYWR5IGJlZW4gYXBwbGllZCB0byB0YXJnZXQgYXBwXCIgKyAobWl4aW4ubmFtZSA/IGA6ICR7bWl4aW4ubmFtZX1gIDogXCJcIilcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICB3YXJuKFwiTWl4aW5zIGFyZSBvbmx5IGF2YWlsYWJsZSBpbiBidWlsZHMgc3VwcG9ydGluZyBPcHRpb25zIEFQSVwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXBwO1xuICAgICAgfSxcbiAgICAgIGNvbXBvbmVudChuYW1lLCBjb21wb25lbnQpIHtcbiAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICB2YWxpZGF0ZUNvbXBvbmVudE5hbWUobmFtZSwgY29udGV4dC5jb25maWcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY29tcG9uZW50KSB7XG4gICAgICAgICAgcmV0dXJuIGNvbnRleHQuY29tcG9uZW50c1tuYW1lXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBjb250ZXh0LmNvbXBvbmVudHNbbmFtZV0pIHtcbiAgICAgICAgICB3YXJuKGBDb21wb25lbnQgXCIke25hbWV9XCIgaGFzIGFscmVhZHkgYmVlbiByZWdpc3RlcmVkIGluIHRhcmdldCBhcHAuYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29udGV4dC5jb21wb25lbnRzW25hbWVdID0gY29tcG9uZW50O1xuICAgICAgICByZXR1cm4gYXBwO1xuICAgICAgfSxcbiAgICAgIGRpcmVjdGl2ZShuYW1lLCBkaXJlY3RpdmUpIHtcbiAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICB2YWxpZGF0ZURpcmVjdGl2ZU5hbWUobmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkaXJlY3RpdmUpIHtcbiAgICAgICAgICByZXR1cm4gY29udGV4dC5kaXJlY3RpdmVzW25hbWVdO1xuICAgICAgICB9XG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGNvbnRleHQuZGlyZWN0aXZlc1tuYW1lXSkge1xuICAgICAgICAgIHdhcm4oYERpcmVjdGl2ZSBcIiR7bmFtZX1cIiBoYXMgYWxyZWFkeSBiZWVuIHJlZ2lzdGVyZWQgaW4gdGFyZ2V0IGFwcC5gKTtcbiAgICAgICAgfVxuICAgICAgICBjb250ZXh0LmRpcmVjdGl2ZXNbbmFtZV0gPSBkaXJlY3RpdmU7XG4gICAgICAgIHJldHVybiBhcHA7XG4gICAgICB9LFxuICAgICAgbW91bnQocm9vdENvbnRhaW5lciwgaXNIeWRyYXRlLCBpc1NWRykge1xuICAgICAgICBpZiAoIWlzTW91bnRlZCkge1xuICAgICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHJvb3RDb250YWluZXIuX192dWVfYXBwX18pIHtcbiAgICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAgIGBUaGVyZSBpcyBhbHJlYWR5IGFuIGFwcCBpbnN0YW5jZSBtb3VudGVkIG9uIHRoZSBob3N0IGNvbnRhaW5lci5cbiBJZiB5b3Ugd2FudCB0byBtb3VudCBhbm90aGVyIGFwcCBvbiB0aGUgc2FtZSBob3N0IGNvbnRhaW5lciwgeW91IG5lZWQgdG8gdW5tb3VudCB0aGUgcHJldmlvdXMgYXBwIGJ5IGNhbGxpbmcgXFxgYXBwLnVubW91bnQoKVxcYCBmaXJzdC5gXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCB2bm9kZSA9IGNyZWF0ZVZOb2RlKFxuICAgICAgICAgICAgcm9vdENvbXBvbmVudCxcbiAgICAgICAgICAgIHJvb3RQcm9wc1xuICAgICAgICAgICk7XG4gICAgICAgICAgdm5vZGUuYXBwQ29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICAgIGNvbnRleHQucmVsb2FkID0gKCkgPT4ge1xuICAgICAgICAgICAgICByZW5kZXIoY2xvbmVWTm9kZSh2bm9kZSksIHJvb3RDb250YWluZXIsIGlzU1ZHKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc0h5ZHJhdGUgJiYgaHlkcmF0ZSkge1xuICAgICAgICAgICAgaHlkcmF0ZSh2bm9kZSwgcm9vdENvbnRhaW5lcik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlbmRlcih2bm9kZSwgcm9vdENvbnRhaW5lciwgaXNTVkcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpc01vdW50ZWQgPSB0cnVlO1xuICAgICAgICAgIGFwcC5fY29udGFpbmVyID0gcm9vdENvbnRhaW5lcjtcbiAgICAgICAgICByb290Q29udGFpbmVyLl9fdnVlX2FwcF9fID0gYXBwO1xuICAgICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykge1xuICAgICAgICAgICAgYXBwLl9pbnN0YW5jZSA9IHZub2RlLmNvbXBvbmVudDtcbiAgICAgICAgICAgIGRldnRvb2xzSW5pdEFwcChhcHAsIHZlcnNpb24pO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZ2V0RXhwb3NlUHJveHkodm5vZGUuY29tcG9uZW50KSB8fCB2bm9kZS5jb21wb25lbnQucHJveHk7XG4gICAgICAgIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICBgQXBwIGhhcyBhbHJlYWR5IGJlZW4gbW91bnRlZC5cbklmIHlvdSB3YW50IHRvIHJlbW91bnQgdGhlIHNhbWUgYXBwLCBtb3ZlIHlvdXIgYXBwIGNyZWF0aW9uIGxvZ2ljIGludG8gYSBmYWN0b3J5IGZ1bmN0aW9uIGFuZCBjcmVhdGUgZnJlc2ggYXBwIGluc3RhbmNlcyBmb3IgZWFjaCBtb3VudCAtIGUuZy4gXFxgY29uc3QgY3JlYXRlTXlBcHAgPSAoKSA9PiBjcmVhdGVBcHAoQXBwKVxcYGBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdW5tb3VudCgpIHtcbiAgICAgICAgaWYgKGlzTW91bnRlZCkge1xuICAgICAgICAgIHJlbmRlcihudWxsLCBhcHAuX2NvbnRhaW5lcik7XG4gICAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XG4gICAgICAgICAgICBhcHAuX2luc3RhbmNlID0gbnVsbDtcbiAgICAgICAgICAgIGRldnRvb2xzVW5tb3VudEFwcChhcHApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkZWxldGUgYXBwLl9jb250YWluZXIuX192dWVfYXBwX187XG4gICAgICAgIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgIHdhcm4oYENhbm5vdCB1bm1vdW50IGFuIGFwcCB0aGF0IGlzIG5vdCBtb3VudGVkLmApO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgcHJvdmlkZShrZXksIHZhbHVlKSB7XG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGtleSBpbiBjb250ZXh0LnByb3ZpZGVzKSB7XG4gICAgICAgICAgd2FybihcbiAgICAgICAgICAgIGBBcHAgYWxyZWFkeSBwcm92aWRlcyBwcm9wZXJ0eSB3aXRoIGtleSBcIiR7U3RyaW5nKGtleSl9XCIuIEl0IHdpbGwgYmUgb3ZlcndyaXR0ZW4gd2l0aCB0aGUgbmV3IHZhbHVlLmBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRleHQucHJvdmlkZXNba2V5XSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gYXBwO1xuICAgICAgfSxcbiAgICAgIHJ1bldpdGhDb250ZXh0KGZuKSB7XG4gICAgICAgIGN1cnJlbnRBcHAgPSBhcHA7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIGZuKCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgY3VycmVudEFwcCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBhcHA7XG4gIH07XG59XG5sZXQgY3VycmVudEFwcCA9IG51bGw7XG5cbmZ1bmN0aW9uIHByb3ZpZGUoa2V5LCB2YWx1ZSkge1xuICBpZiAoIWN1cnJlbnRJbnN0YW5jZSkge1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICB3YXJuKGBwcm92aWRlKCkgY2FuIG9ubHkgYmUgdXNlZCBpbnNpZGUgc2V0dXAoKS5gKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbGV0IHByb3ZpZGVzID0gY3VycmVudEluc3RhbmNlLnByb3ZpZGVzO1xuICAgIGNvbnN0IHBhcmVudFByb3ZpZGVzID0gY3VycmVudEluc3RhbmNlLnBhcmVudCAmJiBjdXJyZW50SW5zdGFuY2UucGFyZW50LnByb3ZpZGVzO1xuICAgIGlmIChwYXJlbnRQcm92aWRlcyA9PT0gcHJvdmlkZXMpIHtcbiAgICAgIHByb3ZpZGVzID0gY3VycmVudEluc3RhbmNlLnByb3ZpZGVzID0gT2JqZWN0LmNyZWF0ZShwYXJlbnRQcm92aWRlcyk7XG4gICAgfVxuICAgIHByb3ZpZGVzW2tleV0gPSB2YWx1ZTtcbiAgfVxufVxuZnVuY3Rpb24gaW5qZWN0KGtleSwgZGVmYXVsdFZhbHVlLCB0cmVhdERlZmF1bHRBc0ZhY3RvcnkgPSBmYWxzZSkge1xuICBjb25zdCBpbnN0YW5jZSA9IGN1cnJlbnRJbnN0YW5jZSB8fCBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2U7XG4gIGlmIChpbnN0YW5jZSB8fCBjdXJyZW50QXBwKSB7XG4gICAgY29uc3QgcHJvdmlkZXMgPSBpbnN0YW5jZSA/IGluc3RhbmNlLnBhcmVudCA9PSBudWxsID8gaW5zdGFuY2Uudm5vZGUuYXBwQ29udGV4dCAmJiBpbnN0YW5jZS52bm9kZS5hcHBDb250ZXh0LnByb3ZpZGVzIDogaW5zdGFuY2UucGFyZW50LnByb3ZpZGVzIDogY3VycmVudEFwcC5fY29udGV4dC5wcm92aWRlcztcbiAgICBpZiAocHJvdmlkZXMgJiYga2V5IGluIHByb3ZpZGVzKSB7XG4gICAgICByZXR1cm4gcHJvdmlkZXNba2V5XTtcbiAgICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICByZXR1cm4gdHJlYXREZWZhdWx0QXNGYWN0b3J5ICYmIGlzRnVuY3Rpb24oZGVmYXVsdFZhbHVlKSA/IGRlZmF1bHRWYWx1ZS5jYWxsKGluc3RhbmNlICYmIGluc3RhbmNlLnByb3h5KSA6IGRlZmF1bHRWYWx1ZTtcbiAgICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgIHdhcm4oYGluamVjdGlvbiBcIiR7U3RyaW5nKGtleSl9XCIgbm90IGZvdW5kLmApO1xuICAgIH1cbiAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgd2FybihgaW5qZWN0KCkgY2FuIG9ubHkgYmUgdXNlZCBpbnNpZGUgc2V0dXAoKSBvciBmdW5jdGlvbmFsIGNvbXBvbmVudHMuYCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGhhc0luamVjdGlvbkNvbnRleHQoKSB7XG4gIHJldHVybiAhIShjdXJyZW50SW5zdGFuY2UgfHwgY3VycmVudFJlbmRlcmluZ0luc3RhbmNlIHx8IGN1cnJlbnRBcHApO1xufVxuXG5mdW5jdGlvbiBpbml0UHJvcHMoaW5zdGFuY2UsIHJhd1Byb3BzLCBpc1N0YXRlZnVsLCBpc1NTUiA9IGZhbHNlKSB7XG4gIGNvbnN0IHByb3BzID0ge307XG4gIGNvbnN0IGF0dHJzID0ge307XG4gIGRlZihhdHRycywgSW50ZXJuYWxPYmplY3RLZXksIDEpO1xuICBpbnN0YW5jZS5wcm9wc0RlZmF1bHRzID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHNldEZ1bGxQcm9wcyhpbnN0YW5jZSwgcmF3UHJvcHMsIHByb3BzLCBhdHRycyk7XG4gIGZvciAoY29uc3Qga2V5IGluIGluc3RhbmNlLnByb3BzT3B0aW9uc1swXSkge1xuICAgIGlmICghKGtleSBpbiBwcm9wcykpIHtcbiAgICAgIHByb3BzW2tleV0gPSB2b2lkIDA7XG4gICAgfVxuICB9XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgdmFsaWRhdGVQcm9wcyhyYXdQcm9wcyB8fCB7fSwgcHJvcHMsIGluc3RhbmNlKTtcbiAgfVxuICBpZiAoaXNTdGF0ZWZ1bCkge1xuICAgIGluc3RhbmNlLnByb3BzID0gaXNTU1IgPyBwcm9wcyA6IHNoYWxsb3dSZWFjdGl2ZShwcm9wcyk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKCFpbnN0YW5jZS50eXBlLnByb3BzKSB7XG4gICAgICBpbnN0YW5jZS5wcm9wcyA9IGF0dHJzO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbnN0YW5jZS5wcm9wcyA9IHByb3BzO1xuICAgIH1cbiAgfVxuICBpbnN0YW5jZS5hdHRycyA9IGF0dHJzO1xufVxuZnVuY3Rpb24gaXNJbkhtckNvbnRleHQoaW5zdGFuY2UpIHtcbiAgd2hpbGUgKGluc3RhbmNlKSB7XG4gICAgaWYgKGluc3RhbmNlLnR5cGUuX19obXJJZClcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIGluc3RhbmNlID0gaW5zdGFuY2UucGFyZW50O1xuICB9XG59XG5mdW5jdGlvbiB1cGRhdGVQcm9wcyhpbnN0YW5jZSwgcmF3UHJvcHMsIHJhd1ByZXZQcm9wcywgb3B0aW1pemVkKSB7XG4gIGNvbnN0IHtcbiAgICBwcm9wcyxcbiAgICBhdHRycyxcbiAgICB2bm9kZTogeyBwYXRjaEZsYWcgfVxuICB9ID0gaW5zdGFuY2U7XG4gIGNvbnN0IHJhd0N1cnJlbnRQcm9wcyA9IHRvUmF3KHByb3BzKTtcbiAgY29uc3QgW29wdGlvbnNdID0gaW5zdGFuY2UucHJvcHNPcHRpb25zO1xuICBsZXQgaGFzQXR0cnNDaGFuZ2VkID0gZmFsc2U7XG4gIGlmIChcbiAgICAvLyBhbHdheXMgZm9yY2UgZnVsbCBkaWZmIGluIGRldlxuICAgIC8vIC0gIzE5NDIgaWYgaG1yIGlzIGVuYWJsZWQgd2l0aCBzZmMgY29tcG9uZW50XG4gICAgLy8gLSB2aXRlIzg3MiBub24tc2ZjIGNvbXBvbmVudCB1c2VkIGJ5IHNmYyBjb21wb25lbnRcbiAgICAhKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgaXNJbkhtckNvbnRleHQoaW5zdGFuY2UpKSAmJiAob3B0aW1pemVkIHx8IHBhdGNoRmxhZyA+IDApICYmICEocGF0Y2hGbGFnICYgMTYpXG4gICkge1xuICAgIGlmIChwYXRjaEZsYWcgJiA4KSB7XG4gICAgICBjb25zdCBwcm9wc1RvVXBkYXRlID0gaW5zdGFuY2Uudm5vZGUuZHluYW1pY1Byb3BzO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcm9wc1RvVXBkYXRlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBrZXkgPSBwcm9wc1RvVXBkYXRlW2ldO1xuICAgICAgICBpZiAoaXNFbWl0TGlzdGVuZXIoaW5zdGFuY2UuZW1pdHNPcHRpb25zLCBrZXkpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmFsdWUgPSByYXdQcm9wc1trZXldO1xuICAgICAgICBpZiAob3B0aW9ucykge1xuICAgICAgICAgIGlmIChoYXNPd24oYXR0cnMsIGtleSkpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gYXR0cnNba2V5XSkge1xuICAgICAgICAgICAgICBhdHRyc1trZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgIGhhc0F0dHJzQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGNhbWVsaXplZEtleSA9IGNhbWVsaXplKGtleSk7XG4gICAgICAgICAgICBwcm9wc1tjYW1lbGl6ZWRLZXldID0gcmVzb2x2ZVByb3BWYWx1ZShcbiAgICAgICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICAgICAgcmF3Q3VycmVudFByb3BzLFxuICAgICAgICAgICAgICBjYW1lbGl6ZWRLZXksXG4gICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICBpbnN0YW5jZSxcbiAgICAgICAgICAgICAgZmFsc2VcbiAgICAgICAgICAgICAgLyogaXNBYnNlbnQgKi9cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh2YWx1ZSAhPT0gYXR0cnNba2V5XSkge1xuICAgICAgICAgICAgYXR0cnNba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgaGFzQXR0cnNDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKHNldEZ1bGxQcm9wcyhpbnN0YW5jZSwgcmF3UHJvcHMsIHByb3BzLCBhdHRycykpIHtcbiAgICAgIGhhc0F0dHJzQ2hhbmdlZCA9IHRydWU7XG4gICAgfVxuICAgIGxldCBrZWJhYktleTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiByYXdDdXJyZW50UHJvcHMpIHtcbiAgICAgIGlmICghcmF3UHJvcHMgfHwgLy8gZm9yIGNhbWVsQ2FzZVxuICAgICAgIWhhc093bihyYXdQcm9wcywga2V5KSAmJiAvLyBpdCdzIHBvc3NpYmxlIHRoZSBvcmlnaW5hbCBwcm9wcyB3YXMgcGFzc2VkIGluIGFzIGtlYmFiLWNhc2VcbiAgICAgIC8vIGFuZCBjb252ZXJ0ZWQgdG8gY2FtZWxDYXNlICgjOTU1KVxuICAgICAgKChrZWJhYktleSA9IGh5cGhlbmF0ZShrZXkpKSA9PT0ga2V5IHx8ICFoYXNPd24ocmF3UHJvcHMsIGtlYmFiS2V5KSkpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgICAgICBpZiAocmF3UHJldlByb3BzICYmIC8vIGZvciBjYW1lbENhc2VcbiAgICAgICAgICAocmF3UHJldlByb3BzW2tleV0gIT09IHZvaWQgMCB8fCAvLyBmb3Iga2ViYWItY2FzZVxuICAgICAgICAgIHJhd1ByZXZQcm9wc1trZWJhYktleV0gIT09IHZvaWQgMCkpIHtcbiAgICAgICAgICAgIHByb3BzW2tleV0gPSByZXNvbHZlUHJvcFZhbHVlKFxuICAgICAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgICAgICByYXdDdXJyZW50UHJvcHMsXG4gICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgdm9pZCAwLFxuICAgICAgICAgICAgICBpbnN0YW5jZSxcbiAgICAgICAgICAgICAgdHJ1ZVxuICAgICAgICAgICAgICAvKiBpc0Fic2VudCAqL1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGVsZXRlIHByb3BzW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGF0dHJzICE9PSByYXdDdXJyZW50UHJvcHMpIHtcbiAgICAgIGZvciAoY29uc3Qga2V5IGluIGF0dHJzKSB7XG4gICAgICAgIGlmICghcmF3UHJvcHMgfHwgIWhhc093bihyYXdQcm9wcywga2V5KSAmJiB0cnVlKSB7XG4gICAgICAgICAgZGVsZXRlIGF0dHJzW2tleV07XG4gICAgICAgICAgaGFzQXR0cnNDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoaGFzQXR0cnNDaGFuZ2VkKSB7XG4gICAgdHJpZ2dlcihpbnN0YW5jZSwgXCJzZXRcIiwgXCIkYXR0cnNcIik7XG4gIH1cbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICB2YWxpZGF0ZVByb3BzKHJhd1Byb3BzIHx8IHt9LCBwcm9wcywgaW5zdGFuY2UpO1xuICB9XG59XG5mdW5jdGlvbiBzZXRGdWxsUHJvcHMoaW5zdGFuY2UsIHJhd1Byb3BzLCBwcm9wcywgYXR0cnMpIHtcbiAgY29uc3QgW29wdGlvbnMsIG5lZWRDYXN0S2V5c10gPSBpbnN0YW5jZS5wcm9wc09wdGlvbnM7XG4gIGxldCBoYXNBdHRyc0NoYW5nZWQgPSBmYWxzZTtcbiAgbGV0IHJhd0Nhc3RWYWx1ZXM7XG4gIGlmIChyYXdQcm9wcykge1xuICAgIGZvciAobGV0IGtleSBpbiByYXdQcm9wcykge1xuICAgICAgaWYgKGlzUmVzZXJ2ZWRQcm9wKGtleSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCB2YWx1ZSA9IHJhd1Byb3BzW2tleV07XG4gICAgICBsZXQgY2FtZWxLZXk7XG4gICAgICBpZiAob3B0aW9ucyAmJiBoYXNPd24ob3B0aW9ucywgY2FtZWxLZXkgPSBjYW1lbGl6ZShrZXkpKSkge1xuICAgICAgICBpZiAoIW5lZWRDYXN0S2V5cyB8fCAhbmVlZENhc3RLZXlzLmluY2x1ZGVzKGNhbWVsS2V5KSkge1xuICAgICAgICAgIHByb3BzW2NhbWVsS2V5XSA9IHZhbHVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIChyYXdDYXN0VmFsdWVzIHx8IChyYXdDYXN0VmFsdWVzID0ge30pKVtjYW1lbEtleV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICghaXNFbWl0TGlzdGVuZXIoaW5zdGFuY2UuZW1pdHNPcHRpb25zLCBrZXkpKSB7XG4gICAgICAgIGlmICghKGtleSBpbiBhdHRycykgfHwgdmFsdWUgIT09IGF0dHJzW2tleV0pIHtcbiAgICAgICAgICBhdHRyc1trZXldID0gdmFsdWU7XG4gICAgICAgICAgaGFzQXR0cnNDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAobmVlZENhc3RLZXlzKSB7XG4gICAgY29uc3QgcmF3Q3VycmVudFByb3BzID0gdG9SYXcocHJvcHMpO1xuICAgIGNvbnN0IGNhc3RWYWx1ZXMgPSByYXdDYXN0VmFsdWVzIHx8IEVNUFRZX09CSjtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5lZWRDYXN0S2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qga2V5ID0gbmVlZENhc3RLZXlzW2ldO1xuICAgICAgcHJvcHNba2V5XSA9IHJlc29sdmVQcm9wVmFsdWUoXG4gICAgICAgIG9wdGlvbnMsXG4gICAgICAgIHJhd0N1cnJlbnRQcm9wcyxcbiAgICAgICAga2V5LFxuICAgICAgICBjYXN0VmFsdWVzW2tleV0sXG4gICAgICAgIGluc3RhbmNlLFxuICAgICAgICAhaGFzT3duKGNhc3RWYWx1ZXMsIGtleSlcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIHJldHVybiBoYXNBdHRyc0NoYW5nZWQ7XG59XG5mdW5jdGlvbiByZXNvbHZlUHJvcFZhbHVlKG9wdGlvbnMsIHByb3BzLCBrZXksIHZhbHVlLCBpbnN0YW5jZSwgaXNBYnNlbnQpIHtcbiAgY29uc3Qgb3B0ID0gb3B0aW9uc1trZXldO1xuICBpZiAob3B0ICE9IG51bGwpIHtcbiAgICBjb25zdCBoYXNEZWZhdWx0ID0gaGFzT3duKG9wdCwgXCJkZWZhdWx0XCIpO1xuICAgIGlmIChoYXNEZWZhdWx0ICYmIHZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgIGNvbnN0IGRlZmF1bHRWYWx1ZSA9IG9wdC5kZWZhdWx0O1xuICAgICAgaWYgKG9wdC50eXBlICE9PSBGdW5jdGlvbiAmJiAhb3B0LnNraXBGYWN0b3J5ICYmIGlzRnVuY3Rpb24oZGVmYXVsdFZhbHVlKSkge1xuICAgICAgICBjb25zdCB7IHByb3BzRGVmYXVsdHMgfSA9IGluc3RhbmNlO1xuICAgICAgICBpZiAoa2V5IGluIHByb3BzRGVmYXVsdHMpIHtcbiAgICAgICAgICB2YWx1ZSA9IHByb3BzRGVmYXVsdHNba2V5XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZXRDdXJyZW50SW5zdGFuY2UoaW5zdGFuY2UpO1xuICAgICAgICAgIHZhbHVlID0gcHJvcHNEZWZhdWx0c1trZXldID0gZGVmYXVsdFZhbHVlLmNhbGwoXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgcHJvcHNcbiAgICAgICAgICApO1xuICAgICAgICAgIHVuc2V0Q3VycmVudEluc3RhbmNlKCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbHVlID0gZGVmYXVsdFZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAob3B0WzAgLyogc2hvdWxkQ2FzdCAqL10pIHtcbiAgICAgIGlmIChpc0Fic2VudCAmJiAhaGFzRGVmYXVsdCkge1xuICAgICAgICB2YWx1ZSA9IGZhbHNlO1xuICAgICAgfSBlbHNlIGlmIChvcHRbMSAvKiBzaG91bGRDYXN0VHJ1ZSAqL10gJiYgKHZhbHVlID09PSBcIlwiIHx8IHZhbHVlID09PSBoeXBoZW5hdGUoa2V5KSkpIHtcbiAgICAgICAgdmFsdWUgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiBub3JtYWxpemVQcm9wc09wdGlvbnMoY29tcCwgYXBwQ29udGV4dCwgYXNNaXhpbiA9IGZhbHNlKSB7XG4gIGNvbnN0IGNhY2hlID0gYXBwQ29udGV4dC5wcm9wc0NhY2hlO1xuICBjb25zdCBjYWNoZWQgPSBjYWNoZS5nZXQoY29tcCk7XG4gIGlmIChjYWNoZWQpIHtcbiAgICByZXR1cm4gY2FjaGVkO1xuICB9XG4gIGNvbnN0IHJhdyA9IGNvbXAucHJvcHM7XG4gIGNvbnN0IG5vcm1hbGl6ZWQgPSB7fTtcbiAgY29uc3QgbmVlZENhc3RLZXlzID0gW107XG4gIGxldCBoYXNFeHRlbmRzID0gZmFsc2U7XG4gIGlmIChfX1ZVRV9PUFRJT05TX0FQSV9fICYmICFpc0Z1bmN0aW9uKGNvbXApKSB7XG4gICAgY29uc3QgZXh0ZW5kUHJvcHMgPSAocmF3MikgPT4ge1xuICAgICAgaGFzRXh0ZW5kcyA9IHRydWU7XG4gICAgICBjb25zdCBbcHJvcHMsIGtleXNdID0gbm9ybWFsaXplUHJvcHNPcHRpb25zKHJhdzIsIGFwcENvbnRleHQsIHRydWUpO1xuICAgICAgZXh0ZW5kKG5vcm1hbGl6ZWQsIHByb3BzKTtcbiAgICAgIGlmIChrZXlzKVxuICAgICAgICBuZWVkQ2FzdEtleXMucHVzaCguLi5rZXlzKTtcbiAgICB9O1xuICAgIGlmICghYXNNaXhpbiAmJiBhcHBDb250ZXh0Lm1peGlucy5sZW5ndGgpIHtcbiAgICAgIGFwcENvbnRleHQubWl4aW5zLmZvckVhY2goZXh0ZW5kUHJvcHMpO1xuICAgIH1cbiAgICBpZiAoY29tcC5leHRlbmRzKSB7XG4gICAgICBleHRlbmRQcm9wcyhjb21wLmV4dGVuZHMpO1xuICAgIH1cbiAgICBpZiAoY29tcC5taXhpbnMpIHtcbiAgICAgIGNvbXAubWl4aW5zLmZvckVhY2goZXh0ZW5kUHJvcHMpO1xuICAgIH1cbiAgfVxuICBpZiAoIXJhdyAmJiAhaGFzRXh0ZW5kcykge1xuICAgIGlmIChpc09iamVjdChjb21wKSkge1xuICAgICAgY2FjaGUuc2V0KGNvbXAsIEVNUFRZX0FSUik7XG4gICAgfVxuICAgIHJldHVybiBFTVBUWV9BUlI7XG4gIH1cbiAgaWYgKGlzQXJyYXkocmF3KSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmF3Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhaXNTdHJpbmcocmF3W2ldKSkge1xuICAgICAgICB3YXJuKGBwcm9wcyBtdXN0IGJlIHN0cmluZ3Mgd2hlbiB1c2luZyBhcnJheSBzeW50YXguYCwgcmF3W2ldKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG5vcm1hbGl6ZWRLZXkgPSBjYW1lbGl6ZShyYXdbaV0pO1xuICAgICAgaWYgKHZhbGlkYXRlUHJvcE5hbWUobm9ybWFsaXplZEtleSkpIHtcbiAgICAgICAgbm9ybWFsaXplZFtub3JtYWxpemVkS2V5XSA9IEVNUFRZX09CSjtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAocmF3KSB7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgIWlzT2JqZWN0KHJhdykpIHtcbiAgICAgIHdhcm4oYGludmFsaWQgcHJvcHMgb3B0aW9uc2AsIHJhdyk7XG4gICAgfVxuICAgIGZvciAoY29uc3Qga2V5IGluIHJhdykge1xuICAgICAgY29uc3Qgbm9ybWFsaXplZEtleSA9IGNhbWVsaXplKGtleSk7XG4gICAgICBpZiAodmFsaWRhdGVQcm9wTmFtZShub3JtYWxpemVkS2V5KSkge1xuICAgICAgICBjb25zdCBvcHQgPSByYXdba2V5XTtcbiAgICAgICAgY29uc3QgcHJvcCA9IG5vcm1hbGl6ZWRbbm9ybWFsaXplZEtleV0gPSBpc0FycmF5KG9wdCkgfHwgaXNGdW5jdGlvbihvcHQpID8geyB0eXBlOiBvcHQgfSA6IGV4dGVuZCh7fSwgb3B0KTtcbiAgICAgICAgaWYgKHByb3ApIHtcbiAgICAgICAgICBjb25zdCBib29sZWFuSW5kZXggPSBnZXRUeXBlSW5kZXgoQm9vbGVhbiwgcHJvcC50eXBlKTtcbiAgICAgICAgICBjb25zdCBzdHJpbmdJbmRleCA9IGdldFR5cGVJbmRleChTdHJpbmcsIHByb3AudHlwZSk7XG4gICAgICAgICAgcHJvcFswIC8qIHNob3VsZENhc3QgKi9dID0gYm9vbGVhbkluZGV4ID4gLTE7XG4gICAgICAgICAgcHJvcFsxIC8qIHNob3VsZENhc3RUcnVlICovXSA9IHN0cmluZ0luZGV4IDwgMCB8fCBib29sZWFuSW5kZXggPCBzdHJpbmdJbmRleDtcbiAgICAgICAgICBpZiAoYm9vbGVhbkluZGV4ID4gLTEgfHwgaGFzT3duKHByb3AsIFwiZGVmYXVsdFwiKSkge1xuICAgICAgICAgICAgbmVlZENhc3RLZXlzLnB1c2gobm9ybWFsaXplZEtleSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNvbnN0IHJlcyA9IFtub3JtYWxpemVkLCBuZWVkQ2FzdEtleXNdO1xuICBpZiAoaXNPYmplY3QoY29tcCkpIHtcbiAgICBjYWNoZS5zZXQoY29tcCwgcmVzKTtcbiAgfVxuICByZXR1cm4gcmVzO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wTmFtZShrZXkpIHtcbiAgaWYgKGtleVswXSAhPT0gXCIkXCIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgd2FybihgSW52YWxpZCBwcm9wIG5hbWU6IFwiJHtrZXl9XCIgaXMgYSByZXNlcnZlZCBwcm9wZXJ0eS5gKTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBnZXRUeXBlKGN0b3IpIHtcbiAgY29uc3QgbWF0Y2ggPSBjdG9yICYmIGN0b3IudG9TdHJpbmcoKS5tYXRjaCgvXlxccyooZnVuY3Rpb258Y2xhc3MpIChcXHcrKS8pO1xuICByZXR1cm4gbWF0Y2ggPyBtYXRjaFsyXSA6IGN0b3IgPT09IG51bGwgPyBcIm51bGxcIiA6IFwiXCI7XG59XG5mdW5jdGlvbiBpc1NhbWVUeXBlKGEsIGIpIHtcbiAgcmV0dXJuIGdldFR5cGUoYSkgPT09IGdldFR5cGUoYik7XG59XG5mdW5jdGlvbiBnZXRUeXBlSW5kZXgodHlwZSwgZXhwZWN0ZWRUeXBlcykge1xuICBpZiAoaXNBcnJheShleHBlY3RlZFR5cGVzKSkge1xuICAgIHJldHVybiBleHBlY3RlZFR5cGVzLmZpbmRJbmRleCgodCkgPT4gaXNTYW1lVHlwZSh0LCB0eXBlKSk7XG4gIH0gZWxzZSBpZiAoaXNGdW5jdGlvbihleHBlY3RlZFR5cGVzKSkge1xuICAgIHJldHVybiBpc1NhbWVUeXBlKGV4cGVjdGVkVHlwZXMsIHR5cGUpID8gMCA6IC0xO1xuICB9XG4gIHJldHVybiAtMTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcHMocmF3UHJvcHMsIHByb3BzLCBpbnN0YW5jZSkge1xuICBjb25zdCByZXNvbHZlZFZhbHVlcyA9IHRvUmF3KHByb3BzKTtcbiAgY29uc3Qgb3B0aW9ucyA9IGluc3RhbmNlLnByb3BzT3B0aW9uc1swXTtcbiAgZm9yIChjb25zdCBrZXkgaW4gb3B0aW9ucykge1xuICAgIGxldCBvcHQgPSBvcHRpb25zW2tleV07XG4gICAgaWYgKG9wdCA9PSBudWxsKVxuICAgICAgY29udGludWU7XG4gICAgdmFsaWRhdGVQcm9wKFxuICAgICAga2V5LFxuICAgICAgcmVzb2x2ZWRWYWx1ZXNba2V5XSxcbiAgICAgIG9wdCxcbiAgICAgICFoYXNPd24ocmF3UHJvcHMsIGtleSkgJiYgIWhhc093bihyYXdQcm9wcywgaHlwaGVuYXRlKGtleSkpXG4gICAgKTtcbiAgfVxufVxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wKG5hbWUsIHZhbHVlLCBwcm9wLCBpc0Fic2VudCkge1xuICBjb25zdCB7IHR5cGUsIHJlcXVpcmVkLCB2YWxpZGF0b3IsIHNraXBDaGVjayB9ID0gcHJvcDtcbiAgaWYgKHJlcXVpcmVkICYmIGlzQWJzZW50KSB7XG4gICAgd2FybignTWlzc2luZyByZXF1aXJlZCBwcm9wOiBcIicgKyBuYW1lICsgJ1wiJyk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICh2YWx1ZSA9PSBudWxsICYmICFyZXF1aXJlZCkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAodHlwZSAhPSBudWxsICYmIHR5cGUgIT09IHRydWUgJiYgIXNraXBDaGVjaykge1xuICAgIGxldCBpc1ZhbGlkID0gZmFsc2U7XG4gICAgY29uc3QgdHlwZXMgPSBpc0FycmF5KHR5cGUpID8gdHlwZSA6IFt0eXBlXTtcbiAgICBjb25zdCBleHBlY3RlZFR5cGVzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0eXBlcy5sZW5ndGggJiYgIWlzVmFsaWQ7IGkrKykge1xuICAgICAgY29uc3QgeyB2YWxpZCwgZXhwZWN0ZWRUeXBlIH0gPSBhc3NlcnRUeXBlKHZhbHVlLCB0eXBlc1tpXSk7XG4gICAgICBleHBlY3RlZFR5cGVzLnB1c2goZXhwZWN0ZWRUeXBlIHx8IFwiXCIpO1xuICAgICAgaXNWYWxpZCA9IHZhbGlkO1xuICAgIH1cbiAgICBpZiAoIWlzVmFsaWQpIHtcbiAgICAgIHdhcm4oZ2V0SW52YWxpZFR5cGVNZXNzYWdlKG5hbWUsIHZhbHVlLCBleHBlY3RlZFR5cGVzKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG4gIGlmICh2YWxpZGF0b3IgJiYgIXZhbGlkYXRvcih2YWx1ZSkpIHtcbiAgICB3YXJuKCdJbnZhbGlkIHByb3A6IGN1c3RvbSB2YWxpZGF0b3IgY2hlY2sgZmFpbGVkIGZvciBwcm9wIFwiJyArIG5hbWUgKyAnXCIuJyk7XG4gIH1cbn1cbmNvbnN0IGlzU2ltcGxlVHlwZSA9IC8qIEBfX1BVUkVfXyAqLyBtYWtlTWFwKFxuICBcIlN0cmluZyxOdW1iZXIsQm9vbGVhbixGdW5jdGlvbixTeW1ib2wsQmlnSW50XCJcbik7XG5mdW5jdGlvbiBhc3NlcnRUeXBlKHZhbHVlLCB0eXBlKSB7XG4gIGxldCB2YWxpZDtcbiAgY29uc3QgZXhwZWN0ZWRUeXBlID0gZ2V0VHlwZSh0eXBlKTtcbiAgaWYgKGlzU2ltcGxlVHlwZShleHBlY3RlZFR5cGUpKSB7XG4gICAgY29uc3QgdCA9IHR5cGVvZiB2YWx1ZTtcbiAgICB2YWxpZCA9IHQgPT09IGV4cGVjdGVkVHlwZS50b0xvd2VyQ2FzZSgpO1xuICAgIGlmICghdmFsaWQgJiYgdCA9PT0gXCJvYmplY3RcIikge1xuICAgICAgdmFsaWQgPSB2YWx1ZSBpbnN0YW5jZW9mIHR5cGU7XG4gICAgfVxuICB9IGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gXCJPYmplY3RcIikge1xuICAgIHZhbGlkID0gaXNPYmplY3QodmFsdWUpO1xuICB9IGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gXCJBcnJheVwiKSB7XG4gICAgdmFsaWQgPSBpc0FycmF5KHZhbHVlKTtcbiAgfSBlbHNlIGlmIChleHBlY3RlZFR5cGUgPT09IFwibnVsbFwiKSB7XG4gICAgdmFsaWQgPSB2YWx1ZSA9PT0gbnVsbDtcbiAgfSBlbHNlIHtcbiAgICB2YWxpZCA9IHZhbHVlIGluc3RhbmNlb2YgdHlwZTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHZhbGlkLFxuICAgIGV4cGVjdGVkVHlwZVxuICB9O1xufVxuZnVuY3Rpb24gZ2V0SW52YWxpZFR5cGVNZXNzYWdlKG5hbWUsIHZhbHVlLCBleHBlY3RlZFR5cGVzKSB7XG4gIGxldCBtZXNzYWdlID0gYEludmFsaWQgcHJvcDogdHlwZSBjaGVjayBmYWlsZWQgZm9yIHByb3AgXCIke25hbWV9XCIuIEV4cGVjdGVkICR7ZXhwZWN0ZWRUeXBlcy5tYXAoY2FwaXRhbGl6ZSkuam9pbihcIiB8IFwiKX1gO1xuICBjb25zdCBleHBlY3RlZFR5cGUgPSBleHBlY3RlZFR5cGVzWzBdO1xuICBjb25zdCByZWNlaXZlZFR5cGUgPSB0b1Jhd1R5cGUodmFsdWUpO1xuICBjb25zdCBleHBlY3RlZFZhbHVlID0gc3R5bGVWYWx1ZSh2YWx1ZSwgZXhwZWN0ZWRUeXBlKTtcbiAgY29uc3QgcmVjZWl2ZWRWYWx1ZSA9IHN0eWxlVmFsdWUodmFsdWUsIHJlY2VpdmVkVHlwZSk7XG4gIGlmIChleHBlY3RlZFR5cGVzLmxlbmd0aCA9PT0gMSAmJiBpc0V4cGxpY2FibGUoZXhwZWN0ZWRUeXBlKSAmJiAhaXNCb29sZWFuKGV4cGVjdGVkVHlwZSwgcmVjZWl2ZWRUeXBlKSkge1xuICAgIG1lc3NhZ2UgKz0gYCB3aXRoIHZhbHVlICR7ZXhwZWN0ZWRWYWx1ZX1gO1xuICB9XG4gIG1lc3NhZ2UgKz0gYCwgZ290ICR7cmVjZWl2ZWRUeXBlfSBgO1xuICBpZiAoaXNFeHBsaWNhYmxlKHJlY2VpdmVkVHlwZSkpIHtcbiAgICBtZXNzYWdlICs9IGB3aXRoIHZhbHVlICR7cmVjZWl2ZWRWYWx1ZX0uYDtcbiAgfVxuICByZXR1cm4gbWVzc2FnZTtcbn1cbmZ1bmN0aW9uIHN0eWxlVmFsdWUodmFsdWUsIHR5cGUpIHtcbiAgaWYgKHR5cGUgPT09IFwiU3RyaW5nXCIpIHtcbiAgICByZXR1cm4gYFwiJHt2YWx1ZX1cImA7XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJOdW1iZXJcIikge1xuICAgIHJldHVybiBgJHtOdW1iZXIodmFsdWUpfWA7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGAke3ZhbHVlfWA7XG4gIH1cbn1cbmZ1bmN0aW9uIGlzRXhwbGljYWJsZSh0eXBlKSB7XG4gIGNvbnN0IGV4cGxpY2l0VHlwZXMgPSBbXCJzdHJpbmdcIiwgXCJudW1iZXJcIiwgXCJib29sZWFuXCJdO1xuICByZXR1cm4gZXhwbGljaXRUeXBlcy5zb21lKChlbGVtKSA9PiB0eXBlLnRvTG93ZXJDYXNlKCkgPT09IGVsZW0pO1xufVxuZnVuY3Rpb24gaXNCb29sZWFuKC4uLmFyZ3MpIHtcbiAgcmV0dXJuIGFyZ3Muc29tZSgoZWxlbSkgPT4gZWxlbS50b0xvd2VyQ2FzZSgpID09PSBcImJvb2xlYW5cIik7XG59XG5cbmNvbnN0IGlzSW50ZXJuYWxLZXkgPSAoa2V5KSA9PiBrZXlbMF0gPT09IFwiX1wiIHx8IGtleSA9PT0gXCIkc3RhYmxlXCI7XG5jb25zdCBub3JtYWxpemVTbG90VmFsdWUgPSAodmFsdWUpID0+IGlzQXJyYXkodmFsdWUpID8gdmFsdWUubWFwKG5vcm1hbGl6ZVZOb2RlKSA6IFtub3JtYWxpemVWTm9kZSh2YWx1ZSldO1xuY29uc3Qgbm9ybWFsaXplU2xvdCA9IChrZXksIHJhd1Nsb3QsIGN0eCkgPT4ge1xuICBpZiAocmF3U2xvdC5fbikge1xuICAgIHJldHVybiByYXdTbG90O1xuICB9XG4gIGNvbnN0IG5vcm1hbGl6ZWQgPSB3aXRoQ3R4KCguLi5hcmdzKSA9PiB7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgY3VycmVudEluc3RhbmNlKSB7XG4gICAgICB3YXJuKFxuICAgICAgICBgU2xvdCBcIiR7a2V5fVwiIGludm9rZWQgb3V0c2lkZSBvZiB0aGUgcmVuZGVyIGZ1bmN0aW9uOiB0aGlzIHdpbGwgbm90IHRyYWNrIGRlcGVuZGVuY2llcyB1c2VkIGluIHRoZSBzbG90LiBJbnZva2UgdGhlIHNsb3QgZnVuY3Rpb24gaW5zaWRlIHRoZSByZW5kZXIgZnVuY3Rpb24gaW5zdGVhZC5gXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gbm9ybWFsaXplU2xvdFZhbHVlKHJhd1Nsb3QoLi4uYXJncykpO1xuICB9LCBjdHgpO1xuICBub3JtYWxpemVkLl9jID0gZmFsc2U7XG4gIHJldHVybiBub3JtYWxpemVkO1xufTtcbmNvbnN0IG5vcm1hbGl6ZU9iamVjdFNsb3RzID0gKHJhd1Nsb3RzLCBzbG90cywgaW5zdGFuY2UpID0+IHtcbiAgY29uc3QgY3R4ID0gcmF3U2xvdHMuX2N0eDtcbiAgZm9yIChjb25zdCBrZXkgaW4gcmF3U2xvdHMpIHtcbiAgICBpZiAoaXNJbnRlcm5hbEtleShrZXkpKVxuICAgICAgY29udGludWU7XG4gICAgY29uc3QgdmFsdWUgPSByYXdTbG90c1trZXldO1xuICAgIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgc2xvdHNba2V5XSA9IG5vcm1hbGl6ZVNsb3Qoa2V5LCB2YWx1ZSwgY3R4KTtcbiAgICB9IGVsc2UgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHRydWUpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBgTm9uLWZ1bmN0aW9uIHZhbHVlIGVuY291bnRlcmVkIGZvciBzbG90IFwiJHtrZXl9XCIuIFByZWZlciBmdW5jdGlvbiBzbG90cyBmb3IgYmV0dGVyIHBlcmZvcm1hbmNlLmBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSBub3JtYWxpemVTbG90VmFsdWUodmFsdWUpO1xuICAgICAgc2xvdHNba2V5XSA9ICgpID0+IG5vcm1hbGl6ZWQ7XG4gICAgfVxuICB9XG59O1xuY29uc3Qgbm9ybWFsaXplVk5vZGVTbG90cyA9IChpbnN0YW5jZSwgY2hpbGRyZW4pID0+IHtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgIWlzS2VlcEFsaXZlKGluc3RhbmNlLnZub2RlKSAmJiB0cnVlKSB7XG4gICAgd2FybihcbiAgICAgIGBOb24tZnVuY3Rpb24gdmFsdWUgZW5jb3VudGVyZWQgZm9yIGRlZmF1bHQgc2xvdC4gUHJlZmVyIGZ1bmN0aW9uIHNsb3RzIGZvciBiZXR0ZXIgcGVyZm9ybWFuY2UuYFxuICAgICk7XG4gIH1cbiAgY29uc3Qgbm9ybWFsaXplZCA9IG5vcm1hbGl6ZVNsb3RWYWx1ZShjaGlsZHJlbik7XG4gIGluc3RhbmNlLnNsb3RzLmRlZmF1bHQgPSAoKSA9PiBub3JtYWxpemVkO1xufTtcbmNvbnN0IGluaXRTbG90cyA9IChpbnN0YW5jZSwgY2hpbGRyZW4pID0+IHtcbiAgaWYgKGluc3RhbmNlLnZub2RlLnNoYXBlRmxhZyAmIDMyKSB7XG4gICAgY29uc3QgdHlwZSA9IGNoaWxkcmVuLl87XG4gICAgaWYgKHR5cGUpIHtcbiAgICAgIGluc3RhbmNlLnNsb3RzID0gdG9SYXcoY2hpbGRyZW4pO1xuICAgICAgZGVmKGNoaWxkcmVuLCBcIl9cIiwgdHlwZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vcm1hbGl6ZU9iamVjdFNsb3RzKFxuICAgICAgICBjaGlsZHJlbixcbiAgICAgICAgaW5zdGFuY2Uuc2xvdHMgPSB7fSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGluc3RhbmNlLnNsb3RzID0ge307XG4gICAgaWYgKGNoaWxkcmVuKSB7XG4gICAgICBub3JtYWxpemVWTm9kZVNsb3RzKGluc3RhbmNlLCBjaGlsZHJlbik7XG4gICAgfVxuICB9XG4gIGRlZihpbnN0YW5jZS5zbG90cywgSW50ZXJuYWxPYmplY3RLZXksIDEpO1xufTtcbmNvbnN0IHVwZGF0ZVNsb3RzID0gKGluc3RhbmNlLCBjaGlsZHJlbiwgb3B0aW1pemVkKSA9PiB7XG4gIGNvbnN0IHsgdm5vZGUsIHNsb3RzIH0gPSBpbnN0YW5jZTtcbiAgbGV0IG5lZWREZWxldGlvbkNoZWNrID0gdHJ1ZTtcbiAgbGV0IGRlbGV0aW9uQ29tcGFyaXNvblRhcmdldCA9IEVNUFRZX09CSjtcbiAgaWYgKHZub2RlLnNoYXBlRmxhZyAmIDMyKSB7XG4gICAgY29uc3QgdHlwZSA9IGNoaWxkcmVuLl87XG4gICAgaWYgKHR5cGUpIHtcbiAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGlzSG1yVXBkYXRpbmcpIHtcbiAgICAgICAgZXh0ZW5kKHNsb3RzLCBjaGlsZHJlbik7XG4gICAgICAgIHRyaWdnZXIoaW5zdGFuY2UsIFwic2V0XCIsIFwiJHNsb3RzXCIpO1xuICAgICAgfSBlbHNlIGlmIChvcHRpbWl6ZWQgJiYgdHlwZSA9PT0gMSkge1xuICAgICAgICBuZWVkRGVsZXRpb25DaGVjayA9IGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXh0ZW5kKHNsb3RzLCBjaGlsZHJlbik7XG4gICAgICAgIGlmICghb3B0aW1pemVkICYmIHR5cGUgPT09IDEpIHtcbiAgICAgICAgICBkZWxldGUgc2xvdHMuXztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBuZWVkRGVsZXRpb25DaGVjayA9ICFjaGlsZHJlbi4kc3RhYmxlO1xuICAgICAgbm9ybWFsaXplT2JqZWN0U2xvdHMoY2hpbGRyZW4sIHNsb3RzKTtcbiAgICB9XG4gICAgZGVsZXRpb25Db21wYXJpc29uVGFyZ2V0ID0gY2hpbGRyZW47XG4gIH0gZWxzZSBpZiAoY2hpbGRyZW4pIHtcbiAgICBub3JtYWxpemVWTm9kZVNsb3RzKGluc3RhbmNlLCBjaGlsZHJlbik7XG4gICAgZGVsZXRpb25Db21wYXJpc29uVGFyZ2V0ID0geyBkZWZhdWx0OiAxIH07XG4gIH1cbiAgaWYgKG5lZWREZWxldGlvbkNoZWNrKSB7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gc2xvdHMpIHtcbiAgICAgIGlmICghaXNJbnRlcm5hbEtleShrZXkpICYmICEoa2V5IGluIGRlbGV0aW9uQ29tcGFyaXNvblRhcmdldCkpIHtcbiAgICAgICAgZGVsZXRlIHNsb3RzW2tleV07XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBzZXRSZWYocmF3UmVmLCBvbGRSYXdSZWYsIHBhcmVudFN1c3BlbnNlLCB2bm9kZSwgaXNVbm1vdW50ID0gZmFsc2UpIHtcbiAgaWYgKGlzQXJyYXkocmF3UmVmKSkge1xuICAgIHJhd1JlZi5mb3JFYWNoKFxuICAgICAgKHIsIGkpID0+IHNldFJlZihcbiAgICAgICAgcixcbiAgICAgICAgb2xkUmF3UmVmICYmIChpc0FycmF5KG9sZFJhd1JlZikgPyBvbGRSYXdSZWZbaV0gOiBvbGRSYXdSZWYpLFxuICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgdm5vZGUsXG4gICAgICAgIGlzVW5tb3VudFxuICAgICAgKVxuICAgICk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChpc0FzeW5jV3JhcHBlcih2bm9kZSkgJiYgIWlzVW5tb3VudCkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCByZWZWYWx1ZSA9IHZub2RlLnNoYXBlRmxhZyAmIDQgPyBnZXRFeHBvc2VQcm94eSh2bm9kZS5jb21wb25lbnQpIHx8IHZub2RlLmNvbXBvbmVudC5wcm94eSA6IHZub2RlLmVsO1xuICBjb25zdCB2YWx1ZSA9IGlzVW5tb3VudCA/IG51bGwgOiByZWZWYWx1ZTtcbiAgY29uc3QgeyBpOiBvd25lciwgcjogcmVmIH0gPSByYXdSZWY7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICFvd25lcikge1xuICAgIHdhcm4oXG4gICAgICBgTWlzc2luZyByZWYgb3duZXIgY29udGV4dC4gcmVmIGNhbm5vdCBiZSB1c2VkIG9uIGhvaXN0ZWQgdm5vZGVzLiBBIHZub2RlIHdpdGggcmVmIG11c3QgYmUgY3JlYXRlZCBpbnNpZGUgdGhlIHJlbmRlciBmdW5jdGlvbi5gXG4gICAgKTtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3Qgb2xkUmVmID0gb2xkUmF3UmVmICYmIG9sZFJhd1JlZi5yO1xuICBjb25zdCByZWZzID0gb3duZXIucmVmcyA9PT0gRU1QVFlfT0JKID8gb3duZXIucmVmcyA9IHt9IDogb3duZXIucmVmcztcbiAgY29uc3Qgc2V0dXBTdGF0ZSA9IG93bmVyLnNldHVwU3RhdGU7XG4gIGlmIChvbGRSZWYgIT0gbnVsbCAmJiBvbGRSZWYgIT09IHJlZikge1xuICAgIGlmIChpc1N0cmluZyhvbGRSZWYpKSB7XG4gICAgICByZWZzW29sZFJlZl0gPSBudWxsO1xuICAgICAgaWYgKGhhc093bihzZXR1cFN0YXRlLCBvbGRSZWYpKSB7XG4gICAgICAgIHNldHVwU3RhdGVbb2xkUmVmXSA9IG51bGw7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc1JlZihvbGRSZWYpKSB7XG4gICAgICBvbGRSZWYudmFsdWUgPSBudWxsO1xuICAgIH1cbiAgfVxuICBpZiAoaXNGdW5jdGlvbihyZWYpKSB7XG4gICAgY2FsbFdpdGhFcnJvckhhbmRsaW5nKHJlZiwgb3duZXIsIDEyLCBbdmFsdWUsIHJlZnNdKTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBfaXNTdHJpbmcgPSBpc1N0cmluZyhyZWYpO1xuICAgIGNvbnN0IF9pc1JlZiA9IGlzUmVmKHJlZik7XG4gICAgaWYgKF9pc1N0cmluZyB8fCBfaXNSZWYpIHtcbiAgICAgIGNvbnN0IGRvU2V0ID0gKCkgPT4ge1xuICAgICAgICBpZiAocmF3UmVmLmYpIHtcbiAgICAgICAgICBjb25zdCBleGlzdGluZyA9IF9pc1N0cmluZyA/IGhhc093bihzZXR1cFN0YXRlLCByZWYpID8gc2V0dXBTdGF0ZVtyZWZdIDogcmVmc1tyZWZdIDogcmVmLnZhbHVlO1xuICAgICAgICAgIGlmIChpc1VubW91bnQpIHtcbiAgICAgICAgICAgIGlzQXJyYXkoZXhpc3RpbmcpICYmIHJlbW92ZShleGlzdGluZywgcmVmVmFsdWUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIWlzQXJyYXkoZXhpc3RpbmcpKSB7XG4gICAgICAgICAgICAgIGlmIChfaXNTdHJpbmcpIHtcbiAgICAgICAgICAgICAgICByZWZzW3JlZl0gPSBbcmVmVmFsdWVdO1xuICAgICAgICAgICAgICAgIGlmIChoYXNPd24oc2V0dXBTdGF0ZSwgcmVmKSkge1xuICAgICAgICAgICAgICAgICAgc2V0dXBTdGF0ZVtyZWZdID0gcmVmc1tyZWZdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZWYudmFsdWUgPSBbcmVmVmFsdWVdO1xuICAgICAgICAgICAgICAgIGlmIChyYXdSZWYuaylcbiAgICAgICAgICAgICAgICAgIHJlZnNbcmF3UmVmLmtdID0gcmVmLnZhbHVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFleGlzdGluZy5pbmNsdWRlcyhyZWZWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgZXhpc3RpbmcucHVzaChyZWZWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKF9pc1N0cmluZykge1xuICAgICAgICAgIHJlZnNbcmVmXSA9IHZhbHVlO1xuICAgICAgICAgIGlmIChoYXNPd24oc2V0dXBTdGF0ZSwgcmVmKSkge1xuICAgICAgICAgICAgc2V0dXBTdGF0ZVtyZWZdID0gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKF9pc1JlZikge1xuICAgICAgICAgIHJlZi52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgIGlmIChyYXdSZWYuaylcbiAgICAgICAgICAgIHJlZnNbcmF3UmVmLmtdID0gdmFsdWU7XG4gICAgICAgIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgIHdhcm4oXCJJbnZhbGlkIHRlbXBsYXRlIHJlZiB0eXBlOlwiLCByZWYsIGAoJHt0eXBlb2YgcmVmfSlgKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICBkb1NldC5pZCA9IC0xO1xuICAgICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QoZG9TZXQsIHBhcmVudFN1c3BlbnNlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRvU2V0KCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICB3YXJuKFwiSW52YWxpZCB0ZW1wbGF0ZSByZWYgdHlwZTpcIiwgcmVmLCBgKCR7dHlwZW9mIHJlZn0pYCk7XG4gICAgfVxuICB9XG59XG5cbmxldCBoYXNNaXNtYXRjaCA9IGZhbHNlO1xuY29uc3QgaXNTVkdDb250YWluZXIgPSAoY29udGFpbmVyKSA9PiAvc3ZnLy50ZXN0KGNvbnRhaW5lci5uYW1lc3BhY2VVUkkpICYmIGNvbnRhaW5lci50YWdOYW1lICE9PSBcImZvcmVpZ25PYmplY3RcIjtcbmNvbnN0IGlzQ29tbWVudCA9IChub2RlKSA9PiBub2RlLm5vZGVUeXBlID09PSA4IC8qIENPTU1FTlQgKi87XG5mdW5jdGlvbiBjcmVhdGVIeWRyYXRpb25GdW5jdGlvbnMocmVuZGVyZXJJbnRlcm5hbHMpIHtcbiAgY29uc3Qge1xuICAgIG10OiBtb3VudENvbXBvbmVudCxcbiAgICBwOiBwYXRjaCxcbiAgICBvOiB7XG4gICAgICBwYXRjaFByb3AsXG4gICAgICBjcmVhdGVUZXh0LFxuICAgICAgbmV4dFNpYmxpbmcsXG4gICAgICBwYXJlbnROb2RlLFxuICAgICAgcmVtb3ZlLFxuICAgICAgaW5zZXJ0LFxuICAgICAgY3JlYXRlQ29tbWVudFxuICAgIH1cbiAgfSA9IHJlbmRlcmVySW50ZXJuYWxzO1xuICBjb25zdCBoeWRyYXRlID0gKHZub2RlLCBjb250YWluZXIpID0+IHtcbiAgICBpZiAoIWNvbnRhaW5lci5oYXNDaGlsZE5vZGVzKCkpIHtcbiAgICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgd2FybihcbiAgICAgICAgYEF0dGVtcHRpbmcgdG8gaHlkcmF0ZSBleGlzdGluZyBtYXJrdXAgYnV0IGNvbnRhaW5lciBpcyBlbXB0eS4gUGVyZm9ybWluZyBmdWxsIG1vdW50IGluc3RlYWQuYFxuICAgICAgKTtcbiAgICAgIHBhdGNoKG51bGwsIHZub2RlLCBjb250YWluZXIpO1xuICAgICAgZmx1c2hQb3N0Rmx1c2hDYnMoKTtcbiAgICAgIGNvbnRhaW5lci5fdm5vZGUgPSB2bm9kZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaGFzTWlzbWF0Y2ggPSBmYWxzZTtcbiAgICBoeWRyYXRlTm9kZShjb250YWluZXIuZmlyc3RDaGlsZCwgdm5vZGUsIG51bGwsIG51bGwsIG51bGwpO1xuICAgIGZsdXNoUG9zdEZsdXNoQ2JzKCk7XG4gICAgY29udGFpbmVyLl92bm9kZSA9IHZub2RlO1xuICAgIGlmIChoYXNNaXNtYXRjaCAmJiB0cnVlKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGBIeWRyYXRpb24gY29tcGxldGVkIGJ1dCBjb250YWlucyBtaXNtYXRjaGVzLmApO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgaHlkcmF0ZU5vZGUgPSAobm9kZSwgdm5vZGUsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkID0gZmFsc2UpID0+IHtcbiAgICBjb25zdCBpc0ZyYWdtZW50U3RhcnQgPSBpc0NvbW1lbnQobm9kZSkgJiYgbm9kZS5kYXRhID09PSBcIltcIjtcbiAgICBjb25zdCBvbk1pc21hdGNoID0gKCkgPT4gaGFuZGxlTWlzbWF0Y2goXG4gICAgICBub2RlLFxuICAgICAgdm5vZGUsXG4gICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgIGlzRnJhZ21lbnRTdGFydFxuICAgICk7XG4gICAgY29uc3QgeyB0eXBlLCByZWYsIHNoYXBlRmxhZywgcGF0Y2hGbGFnIH0gPSB2bm9kZTtcbiAgICBsZXQgZG9tVHlwZSA9IG5vZGUubm9kZVR5cGU7XG4gICAgdm5vZGUuZWwgPSBub2RlO1xuICAgIGlmIChwYXRjaEZsYWcgPT09IC0yKSB7XG4gICAgICBvcHRpbWl6ZWQgPSBmYWxzZTtcbiAgICAgIHZub2RlLmR5bmFtaWNDaGlsZHJlbiA9IG51bGw7XG4gICAgfVxuICAgIGxldCBuZXh0Tm9kZSA9IG51bGw7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlIFRleHQ6XG4gICAgICAgIGlmIChkb21UeXBlICE9PSAzIC8qIFRFWFQgKi8pIHtcbiAgICAgICAgICBpZiAodm5vZGUuY2hpbGRyZW4gPT09IFwiXCIpIHtcbiAgICAgICAgICAgIGluc2VydCh2bm9kZS5lbCA9IGNyZWF0ZVRleHQoXCJcIiksIHBhcmVudE5vZGUobm9kZSksIG5vZGUpO1xuICAgICAgICAgICAgbmV4dE5vZGUgPSBub2RlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXh0Tm9kZSA9IG9uTWlzbWF0Y2goKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKG5vZGUuZGF0YSAhPT0gdm5vZGUuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGhhc01pc21hdGNoID0gdHJ1ZTtcbiAgICAgICAgICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgd2FybihcbiAgICAgICAgICAgICAgYEh5ZHJhdGlvbiB0ZXh0IG1pc21hdGNoOlxuLSBDbGllbnQ6ICR7SlNPTi5zdHJpbmdpZnkobm9kZS5kYXRhKX1cbi0gU2VydmVyOiAke0pTT04uc3RyaW5naWZ5KHZub2RlLmNoaWxkcmVuKX1gXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgbm9kZS5kYXRhID0gdm5vZGUuY2hpbGRyZW47XG4gICAgICAgICAgfVxuICAgICAgICAgIG5leHROb2RlID0gbmV4dFNpYmxpbmcobm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIENvbW1lbnQ6XG4gICAgICAgIGlmIChkb21UeXBlICE9PSA4IC8qIENPTU1FTlQgKi8gfHwgaXNGcmFnbWVudFN0YXJ0KSB7XG4gICAgICAgICAgbmV4dE5vZGUgPSBvbk1pc21hdGNoKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV4dE5vZGUgPSBuZXh0U2libGluZyhub2RlKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgU3RhdGljOlxuICAgICAgICBpZiAoaXNGcmFnbWVudFN0YXJ0KSB7XG4gICAgICAgICAgbm9kZSA9IG5leHRTaWJsaW5nKG5vZGUpO1xuICAgICAgICAgIGRvbVR5cGUgPSBub2RlLm5vZGVUeXBlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkb21UeXBlID09PSAxIC8qIEVMRU1FTlQgKi8gfHwgZG9tVHlwZSA9PT0gMyAvKiBURVhUICovKSB7XG4gICAgICAgICAgbmV4dE5vZGUgPSBub2RlO1xuICAgICAgICAgIGNvbnN0IG5lZWRUb0Fkb3B0Q29udGVudCA9ICF2bm9kZS5jaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2bm9kZS5zdGF0aWNDb3VudDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAobmVlZFRvQWRvcHRDb250ZW50KVxuICAgICAgICAgICAgICB2bm9kZS5jaGlsZHJlbiArPSBuZXh0Tm9kZS5ub2RlVHlwZSA9PT0gMSAvKiBFTEVNRU5UICovID8gbmV4dE5vZGUub3V0ZXJIVE1MIDogbmV4dE5vZGUuZGF0YTtcbiAgICAgICAgICAgIGlmIChpID09PSB2bm9kZS5zdGF0aWNDb3VudCAtIDEpIHtcbiAgICAgICAgICAgICAgdm5vZGUuYW5jaG9yID0gbmV4dE5vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXh0Tm9kZSA9IG5leHRTaWJsaW5nKG5leHROb2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGlzRnJhZ21lbnRTdGFydCA/IG5leHRTaWJsaW5nKG5leHROb2RlKSA6IG5leHROb2RlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9uTWlzbWF0Y2goKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRnJhZ21lbnQ6XG4gICAgICAgIGlmICghaXNGcmFnbWVudFN0YXJ0KSB7XG4gICAgICAgICAgbmV4dE5vZGUgPSBvbk1pc21hdGNoKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV4dE5vZGUgPSBoeWRyYXRlRnJhZ21lbnQoXG4gICAgICAgICAgICBub2RlLFxuICAgICAgICAgICAgdm5vZGUsXG4gICAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICAgIG9wdGltaXplZFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAoc2hhcGVGbGFnICYgMSkge1xuICAgICAgICAgIGlmIChkb21UeXBlICE9PSAxIC8qIEVMRU1FTlQgKi8gfHwgdm5vZGUudHlwZS50b0xvd2VyQ2FzZSgpICE9PSBub2RlLnRhZ05hbWUudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgICAgbmV4dE5vZGUgPSBvbk1pc21hdGNoKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5leHROb2RlID0gaHlkcmF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgICAgIHZub2RlLFxuICAgICAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgICAgICAgIG9wdGltaXplZFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoc2hhcGVGbGFnICYgNikge1xuICAgICAgICAgIHZub2RlLnNsb3RTY29wZUlkcyA9IHNsb3RTY29wZUlkcztcbiAgICAgICAgICBjb25zdCBjb250YWluZXIgPSBwYXJlbnROb2RlKG5vZGUpO1xuICAgICAgICAgIG1vdW50Q29tcG9uZW50KFxuICAgICAgICAgICAgdm5vZGUsXG4gICAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgICBpc1NWR0NvbnRhaW5lcihjb250YWluZXIpLFxuICAgICAgICAgICAgb3B0aW1pemVkXG4gICAgICAgICAgKTtcbiAgICAgICAgICBuZXh0Tm9kZSA9IGlzRnJhZ21lbnRTdGFydCA/IGxvY2F0ZUNsb3NpbmdBc3luY0FuY2hvcihub2RlKSA6IG5leHRTaWJsaW5nKG5vZGUpO1xuICAgICAgICAgIGlmIChuZXh0Tm9kZSAmJiBpc0NvbW1lbnQobmV4dE5vZGUpICYmIG5leHROb2RlLmRhdGEgPT09IFwidGVsZXBvcnQgZW5kXCIpIHtcbiAgICAgICAgICAgIG5leHROb2RlID0gbmV4dFNpYmxpbmcobmV4dE5vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNBc3luY1dyYXBwZXIodm5vZGUpKSB7XG4gICAgICAgICAgICBsZXQgc3ViVHJlZTtcbiAgICAgICAgICAgIGlmIChpc0ZyYWdtZW50U3RhcnQpIHtcbiAgICAgICAgICAgICAgc3ViVHJlZSA9IGNyZWF0ZVZOb2RlKEZyYWdtZW50KTtcbiAgICAgICAgICAgICAgc3ViVHJlZS5hbmNob3IgPSBuZXh0Tm9kZSA/IG5leHROb2RlLnByZXZpb3VzU2libGluZyA6IGNvbnRhaW5lci5sYXN0Q2hpbGQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzdWJUcmVlID0gbm9kZS5ub2RlVHlwZSA9PT0gMyA/IGNyZWF0ZVRleHRWTm9kZShcIlwiKSA6IGNyZWF0ZVZOb2RlKFwiZGl2XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3ViVHJlZS5lbCA9IG5vZGU7XG4gICAgICAgICAgICB2bm9kZS5jb21wb25lbnQuc3ViVHJlZSA9IHN1YlRyZWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHNoYXBlRmxhZyAmIDY0KSB7XG4gICAgICAgICAgaWYgKGRvbVR5cGUgIT09IDggLyogQ09NTUVOVCAqLykge1xuICAgICAgICAgICAgbmV4dE5vZGUgPSBvbk1pc21hdGNoKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5leHROb2RlID0gdm5vZGUudHlwZS5oeWRyYXRlKFxuICAgICAgICAgICAgICBub2RlLFxuICAgICAgICAgICAgICB2bm9kZSxcbiAgICAgICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgICAgICBvcHRpbWl6ZWQsXG4gICAgICAgICAgICAgIHJlbmRlcmVySW50ZXJuYWxzLFxuICAgICAgICAgICAgICBoeWRyYXRlQ2hpbGRyZW5cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHNoYXBlRmxhZyAmIDEyOCkge1xuICAgICAgICAgIG5leHROb2RlID0gdm5vZGUudHlwZS5oeWRyYXRlKFxuICAgICAgICAgICAgbm9kZSxcbiAgICAgICAgICAgIHZub2RlLFxuICAgICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgICBpc1NWR0NvbnRhaW5lcihwYXJlbnROb2RlKG5vZGUpKSxcbiAgICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICAgIG9wdGltaXplZCxcbiAgICAgICAgICAgIHJlbmRlcmVySW50ZXJuYWxzLFxuICAgICAgICAgICAgaHlkcmF0ZU5vZGVcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICB3YXJuKFwiSW52YWxpZCBIb3N0Vk5vZGUgdHlwZTpcIiwgdHlwZSwgYCgke3R5cGVvZiB0eXBlfSlgKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAocmVmICE9IG51bGwpIHtcbiAgICAgIHNldFJlZihyZWYsIG51bGwsIHBhcmVudFN1c3BlbnNlLCB2bm9kZSk7XG4gICAgfVxuICAgIHJldHVybiBuZXh0Tm9kZTtcbiAgfTtcbiAgY29uc3QgaHlkcmF0ZUVsZW1lbnQgPSAoZWwsIHZub2RlLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCkgPT4ge1xuICAgIG9wdGltaXplZCA9IG9wdGltaXplZCB8fCAhIXZub2RlLmR5bmFtaWNDaGlsZHJlbjtcbiAgICBjb25zdCB7IHR5cGUsIHByb3BzLCBwYXRjaEZsYWcsIHNoYXBlRmxhZywgZGlycyB9ID0gdm5vZGU7XG4gICAgY29uc3QgZm9yY2VQYXRjaFZhbHVlID0gdHlwZSA9PT0gXCJpbnB1dFwiICYmIGRpcnMgfHwgdHlwZSA9PT0gXCJvcHRpb25cIjtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB8fCBmb3JjZVBhdGNoVmFsdWUgfHwgcGF0Y2hGbGFnICE9PSAtMSkge1xuICAgICAgaWYgKGRpcnMpIHtcbiAgICAgICAgaW52b2tlRGlyZWN0aXZlSG9vayh2bm9kZSwgbnVsbCwgcGFyZW50Q29tcG9uZW50LCBcImNyZWF0ZWRcIik7XG4gICAgICB9XG4gICAgICBpZiAocHJvcHMpIHtcbiAgICAgICAgaWYgKGZvcmNlUGF0Y2hWYWx1ZSB8fCAhb3B0aW1pemVkIHx8IHBhdGNoRmxhZyAmICgxNiB8IDMyKSkge1xuICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIHByb3BzKSB7XG4gICAgICAgICAgICBpZiAoZm9yY2VQYXRjaFZhbHVlICYmIGtleS5lbmRzV2l0aChcInZhbHVlXCIpIHx8IGlzT24oa2V5KSAmJiAhaXNSZXNlcnZlZFByb3Aoa2V5KSkge1xuICAgICAgICAgICAgICBwYXRjaFByb3AoXG4gICAgICAgICAgICAgICAgZWwsXG4gICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgcHJvcHNba2V5XSxcbiAgICAgICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICAgICB2b2lkIDAsXG4gICAgICAgICAgICAgICAgcGFyZW50Q29tcG9uZW50XG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHByb3BzLm9uQ2xpY2spIHtcbiAgICAgICAgICBwYXRjaFByb3AoXG4gICAgICAgICAgICBlbCxcbiAgICAgICAgICAgIFwib25DbGlja1wiLFxuICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgIHByb3BzLm9uQ2xpY2ssXG4gICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgIHZvaWQgMCxcbiAgICAgICAgICAgIHBhcmVudENvbXBvbmVudFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGxldCB2bm9kZUhvb2tzO1xuICAgICAgaWYgKHZub2RlSG9va3MgPSBwcm9wcyAmJiBwcm9wcy5vblZub2RlQmVmb3JlTW91bnQpIHtcbiAgICAgICAgaW52b2tlVk5vZGVIb29rKHZub2RlSG9va3MsIHBhcmVudENvbXBvbmVudCwgdm5vZGUpO1xuICAgICAgfVxuICAgICAgaWYgKGRpcnMpIHtcbiAgICAgICAgaW52b2tlRGlyZWN0aXZlSG9vayh2bm9kZSwgbnVsbCwgcGFyZW50Q29tcG9uZW50LCBcImJlZm9yZU1vdW50XCIpO1xuICAgICAgfVxuICAgICAgaWYgKCh2bm9kZUhvb2tzID0gcHJvcHMgJiYgcHJvcHMub25Wbm9kZU1vdW50ZWQpIHx8IGRpcnMpIHtcbiAgICAgICAgcXVldWVFZmZlY3RXaXRoU3VzcGVuc2UoKCkgPT4ge1xuICAgICAgICAgIHZub2RlSG9va3MgJiYgaW52b2tlVk5vZGVIb29rKHZub2RlSG9va3MsIHBhcmVudENvbXBvbmVudCwgdm5vZGUpO1xuICAgICAgICAgIGRpcnMgJiYgaW52b2tlRGlyZWN0aXZlSG9vayh2bm9kZSwgbnVsbCwgcGFyZW50Q29tcG9uZW50LCBcIm1vdW50ZWRcIik7XG4gICAgICAgIH0sIHBhcmVudFN1c3BlbnNlKTtcbiAgICAgIH1cbiAgICAgIGlmIChzaGFwZUZsYWcgJiAxNiAmJiAvLyBza2lwIGlmIGVsZW1lbnQgaGFzIGlubmVySFRNTCAvIHRleHRDb250ZW50XG4gICAgICAhKHByb3BzICYmIChwcm9wcy5pbm5lckhUTUwgfHwgcHJvcHMudGV4dENvbnRlbnQpKSkge1xuICAgICAgICBsZXQgbmV4dCA9IGh5ZHJhdGVDaGlsZHJlbihcbiAgICAgICAgICBlbC5maXJzdENoaWxkLFxuICAgICAgICAgIHZub2RlLFxuICAgICAgICAgIGVsLFxuICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgICAgb3B0aW1pemVkXG4gICAgICAgICk7XG4gICAgICAgIGxldCBoYXNXYXJuZWQgPSBmYWxzZTtcbiAgICAgICAgd2hpbGUgKG5leHQpIHtcbiAgICAgICAgICBoYXNNaXNtYXRjaCA9IHRydWU7XG4gICAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgIWhhc1dhcm5lZCkge1xuICAgICAgICAgICAgd2FybihcbiAgICAgICAgICAgICAgYEh5ZHJhdGlvbiBjaGlsZHJlbiBtaXNtYXRjaCBpbiA8JHt2bm9kZS50eXBlfT46IHNlcnZlciByZW5kZXJlZCBlbGVtZW50IGNvbnRhaW5zIG1vcmUgY2hpbGQgbm9kZXMgdGhhbiBjbGllbnQgdmRvbS5gXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaGFzV2FybmVkID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgY3VyID0gbmV4dDtcbiAgICAgICAgICBuZXh0ID0gbmV4dC5uZXh0U2libGluZztcbiAgICAgICAgICByZW1vdmUoY3VyKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChzaGFwZUZsYWcgJiA4KSB7XG4gICAgICAgIGlmIChlbC50ZXh0Q29udGVudCAhPT0gdm5vZGUuY2hpbGRyZW4pIHtcbiAgICAgICAgICBoYXNNaXNtYXRjaCA9IHRydWU7XG4gICAgICAgICAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiB3YXJuKFxuICAgICAgICAgICAgYEh5ZHJhdGlvbiB0ZXh0IGNvbnRlbnQgbWlzbWF0Y2ggaW4gPCR7dm5vZGUudHlwZX0+OlxuLSBDbGllbnQ6ICR7ZWwudGV4dENvbnRlbnR9XG4tIFNlcnZlcjogJHt2bm9kZS5jaGlsZHJlbn1gXG4gICAgICAgICAgKTtcbiAgICAgICAgICBlbC50ZXh0Q29udGVudCA9IHZub2RlLmNoaWxkcmVuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlbC5uZXh0U2libGluZztcbiAgfTtcbiAgY29uc3QgaHlkcmF0ZUNoaWxkcmVuID0gKG5vZGUsIHBhcmVudFZOb2RlLCBjb250YWluZXIsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKSA9PiB7XG4gICAgb3B0aW1pemVkID0gb3B0aW1pemVkIHx8ICEhcGFyZW50Vk5vZGUuZHluYW1pY0NoaWxkcmVuO1xuICAgIGNvbnN0IGNoaWxkcmVuID0gcGFyZW50Vk5vZGUuY2hpbGRyZW47XG4gICAgY29uc3QgbCA9IGNoaWxkcmVuLmxlbmd0aDtcbiAgICBsZXQgaGFzV2FybmVkID0gZmFsc2U7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgIGNvbnN0IHZub2RlID0gb3B0aW1pemVkID8gY2hpbGRyZW5baV0gOiBjaGlsZHJlbltpXSA9IG5vcm1hbGl6ZVZOb2RlKGNoaWxkcmVuW2ldKTtcbiAgICAgIGlmIChub2RlKSB7XG4gICAgICAgIG5vZGUgPSBoeWRyYXRlTm9kZShcbiAgICAgICAgICBub2RlLFxuICAgICAgICAgIHZub2RlLFxuICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgICAgb3B0aW1pemVkXG4gICAgICAgICk7XG4gICAgICB9IGVsc2UgaWYgKHZub2RlLnR5cGUgPT09IFRleHQgJiYgIXZub2RlLmNoaWxkcmVuKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaGFzTWlzbWF0Y2ggPSB0cnVlO1xuICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhaGFzV2FybmVkKSB7XG4gICAgICAgICAgd2FybihcbiAgICAgICAgICAgIGBIeWRyYXRpb24gY2hpbGRyZW4gbWlzbWF0Y2ggaW4gPCR7Y29udGFpbmVyLnRhZ05hbWUudG9Mb3dlckNhc2UoKX0+OiBzZXJ2ZXIgcmVuZGVyZWQgZWxlbWVudCBjb250YWlucyBmZXdlciBjaGlsZCBub2RlcyB0aGFuIGNsaWVudCB2ZG9tLmBcbiAgICAgICAgICApO1xuICAgICAgICAgIGhhc1dhcm5lZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcGF0Y2goXG4gICAgICAgICAgbnVsbCxcbiAgICAgICAgICB2bm9kZSxcbiAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgbnVsbCxcbiAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgaXNTVkdDb250YWluZXIoY29udGFpbmVyKSxcbiAgICAgICAgICBzbG90U2NvcGVJZHNcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5vZGU7XG4gIH07XG4gIGNvbnN0IGh5ZHJhdGVGcmFnbWVudCA9IChub2RlLCB2bm9kZSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpID0+IHtcbiAgICBjb25zdCB7IHNsb3RTY29wZUlkczogZnJhZ21lbnRTbG90U2NvcGVJZHMgfSA9IHZub2RlO1xuICAgIGlmIChmcmFnbWVudFNsb3RTY29wZUlkcykge1xuICAgICAgc2xvdFNjb3BlSWRzID0gc2xvdFNjb3BlSWRzID8gc2xvdFNjb3BlSWRzLmNvbmNhdChmcmFnbWVudFNsb3RTY29wZUlkcykgOiBmcmFnbWVudFNsb3RTY29wZUlkcztcbiAgICB9XG4gICAgY29uc3QgY29udGFpbmVyID0gcGFyZW50Tm9kZShub2RlKTtcbiAgICBjb25zdCBuZXh0ID0gaHlkcmF0ZUNoaWxkcmVuKFxuICAgICAgbmV4dFNpYmxpbmcobm9kZSksXG4gICAgICB2bm9kZSxcbiAgICAgIGNvbnRhaW5lcixcbiAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgb3B0aW1pemVkXG4gICAgKTtcbiAgICBpZiAobmV4dCAmJiBpc0NvbW1lbnQobmV4dCkgJiYgbmV4dC5kYXRhID09PSBcIl1cIikge1xuICAgICAgcmV0dXJuIG5leHRTaWJsaW5nKHZub2RlLmFuY2hvciA9IG5leHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBoYXNNaXNtYXRjaCA9IHRydWU7XG4gICAgICBpbnNlcnQodm5vZGUuYW5jaG9yID0gY3JlYXRlQ29tbWVudChgXWApLCBjb250YWluZXIsIG5leHQpO1xuICAgICAgcmV0dXJuIG5leHQ7XG4gICAgfVxuICB9O1xuICBjb25zdCBoYW5kbGVNaXNtYXRjaCA9IChub2RlLCB2bm9kZSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgc2xvdFNjb3BlSWRzLCBpc0ZyYWdtZW50KSA9PiB7XG4gICAgaGFzTWlzbWF0Y2ggPSB0cnVlO1xuICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgd2FybihcbiAgICAgIGBIeWRyYXRpb24gbm9kZSBtaXNtYXRjaDpcbi0gQ2xpZW50IHZub2RlOmAsXG4gICAgICB2bm9kZS50eXBlLFxuICAgICAgYFxuLSBTZXJ2ZXIgcmVuZGVyZWQgRE9NOmAsXG4gICAgICBub2RlLFxuICAgICAgbm9kZS5ub2RlVHlwZSA9PT0gMyAvKiBURVhUICovID8gYCh0ZXh0KWAgOiBpc0NvbW1lbnQobm9kZSkgJiYgbm9kZS5kYXRhID09PSBcIltcIiA/IGAoc3RhcnQgb2YgZnJhZ21lbnQpYCA6IGBgXG4gICAgKTtcbiAgICB2bm9kZS5lbCA9IG51bGw7XG4gICAgaWYgKGlzRnJhZ21lbnQpIHtcbiAgICAgIGNvbnN0IGVuZCA9IGxvY2F0ZUNsb3NpbmdBc3luY0FuY2hvcihub2RlKTtcbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGNvbnN0IG5leHQyID0gbmV4dFNpYmxpbmcobm9kZSk7XG4gICAgICAgIGlmIChuZXh0MiAmJiBuZXh0MiAhPT0gZW5kKSB7XG4gICAgICAgICAgcmVtb3ZlKG5leHQyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBuZXh0ID0gbmV4dFNpYmxpbmcobm9kZSk7XG4gICAgY29uc3QgY29udGFpbmVyID0gcGFyZW50Tm9kZShub2RlKTtcbiAgICByZW1vdmUobm9kZSk7XG4gICAgcGF0Y2goXG4gICAgICBudWxsLFxuICAgICAgdm5vZGUsXG4gICAgICBjb250YWluZXIsXG4gICAgICBuZXh0LFxuICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICBpc1NWR0NvbnRhaW5lcihjb250YWluZXIpLFxuICAgICAgc2xvdFNjb3BlSWRzXG4gICAgKTtcbiAgICByZXR1cm4gbmV4dDtcbiAgfTtcbiAgY29uc3QgbG9jYXRlQ2xvc2luZ0FzeW5jQW5jaG9yID0gKG5vZGUpID0+IHtcbiAgICBsZXQgbWF0Y2ggPSAwO1xuICAgIHdoaWxlIChub2RlKSB7XG4gICAgICBub2RlID0gbmV4dFNpYmxpbmcobm9kZSk7XG4gICAgICBpZiAobm9kZSAmJiBpc0NvbW1lbnQobm9kZSkpIHtcbiAgICAgICAgaWYgKG5vZGUuZGF0YSA9PT0gXCJbXCIpXG4gICAgICAgICAgbWF0Y2grKztcbiAgICAgICAgaWYgKG5vZGUuZGF0YSA9PT0gXCJdXCIpIHtcbiAgICAgICAgICBpZiAobWF0Y2ggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBuZXh0U2libGluZyhub2RlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWF0Y2gtLTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5vZGU7XG4gIH07XG4gIHJldHVybiBbaHlkcmF0ZSwgaHlkcmF0ZU5vZGVdO1xufVxuXG5sZXQgc3VwcG9ydGVkO1xubGV0IHBlcmY7XG5mdW5jdGlvbiBzdGFydE1lYXN1cmUoaW5zdGFuY2UsIHR5cGUpIHtcbiAgaWYgKGluc3RhbmNlLmFwcENvbnRleHQuY29uZmlnLnBlcmZvcm1hbmNlICYmIGlzU3VwcG9ydGVkKCkpIHtcbiAgICBwZXJmLm1hcmsoYHZ1ZS0ke3R5cGV9LSR7aW5zdGFuY2UudWlkfWApO1xuICB9XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykge1xuICAgIGRldnRvb2xzUGVyZlN0YXJ0KGluc3RhbmNlLCB0eXBlLCBpc1N1cHBvcnRlZCgpID8gcGVyZi5ub3coKSA6IERhdGUubm93KCkpO1xuICB9XG59XG5mdW5jdGlvbiBlbmRNZWFzdXJlKGluc3RhbmNlLCB0eXBlKSB7XG4gIGlmIChpbnN0YW5jZS5hcHBDb250ZXh0LmNvbmZpZy5wZXJmb3JtYW5jZSAmJiBpc1N1cHBvcnRlZCgpKSB7XG4gICAgY29uc3Qgc3RhcnRUYWcgPSBgdnVlLSR7dHlwZX0tJHtpbnN0YW5jZS51aWR9YDtcbiAgICBjb25zdCBlbmRUYWcgPSBzdGFydFRhZyArIGA6ZW5kYDtcbiAgICBwZXJmLm1hcmsoZW5kVGFnKTtcbiAgICBwZXJmLm1lYXN1cmUoXG4gICAgICBgPCR7Zm9ybWF0Q29tcG9uZW50TmFtZShpbnN0YW5jZSwgaW5zdGFuY2UudHlwZSl9PiAke3R5cGV9YCxcbiAgICAgIHN0YXJ0VGFnLFxuICAgICAgZW5kVGFnXG4gICAgKTtcbiAgICBwZXJmLmNsZWFyTWFya3Moc3RhcnRUYWcpO1xuICAgIHBlcmYuY2xlYXJNYXJrcyhlbmRUYWcpO1xuICB9XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykge1xuICAgIGRldnRvb2xzUGVyZkVuZChpbnN0YW5jZSwgdHlwZSwgaXNTdXBwb3J0ZWQoKSA/IHBlcmYubm93KCkgOiBEYXRlLm5vdygpKTtcbiAgfVxufVxuZnVuY3Rpb24gaXNTdXBwb3J0ZWQoKSB7XG4gIGlmIChzdXBwb3J0ZWQgIT09IHZvaWQgMCkge1xuICAgIHJldHVybiBzdXBwb3J0ZWQ7XG4gIH1cbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93LnBlcmZvcm1hbmNlKSB7XG4gICAgc3VwcG9ydGVkID0gdHJ1ZTtcbiAgICBwZXJmID0gd2luZG93LnBlcmZvcm1hbmNlO1xuICB9IGVsc2Uge1xuICAgIHN1cHBvcnRlZCA9IGZhbHNlO1xuICB9XG4gIHJldHVybiBzdXBwb3J0ZWQ7XG59XG5cbmZ1bmN0aW9uIGluaXRGZWF0dXJlRmxhZ3MoKSB7XG4gIGNvbnN0IG5lZWRXYXJuID0gW107XG4gIGlmICh0eXBlb2YgX19WVUVfT1BUSU9OU19BUElfXyAhPT0gXCJib29sZWFuXCIpIHtcbiAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIG5lZWRXYXJuLnB1c2goYF9fVlVFX09QVElPTlNfQVBJX19gKTtcbiAgICBnZXRHbG9iYWxUaGlzKCkuX19WVUVfT1BUSU9OU19BUElfXyA9IHRydWU7XG4gIH1cbiAgaWYgKHR5cGVvZiBfX1ZVRV9QUk9EX0RFVlRPT0xTX18gIT09IFwiYm9vbGVhblwiKSB7XG4gICAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBuZWVkV2Fybi5wdXNoKGBfX1ZVRV9QUk9EX0RFVlRPT0xTX19gKTtcbiAgICBnZXRHbG9iYWxUaGlzKCkuX19WVUVfUFJPRF9ERVZUT09MU19fID0gZmFsc2U7XG4gIH1cbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgbmVlZFdhcm4ubGVuZ3RoKSB7XG4gICAgY29uc3QgbXVsdGkgPSBuZWVkV2Fybi5sZW5ndGggPiAxO1xuICAgIGNvbnNvbGUud2FybihcbiAgICAgIGBGZWF0dXJlIGZsYWcke211bHRpID8gYHNgIDogYGB9ICR7bmVlZFdhcm4uam9pbihcIiwgXCIpfSAke211bHRpID8gYGFyZWAgOiBgaXNgfSBub3QgZXhwbGljaXRseSBkZWZpbmVkLiBZb3UgYXJlIHJ1bm5pbmcgdGhlIGVzbS1idW5kbGVyIGJ1aWxkIG9mIFZ1ZSwgd2hpY2ggZXhwZWN0cyB0aGVzZSBjb21waWxlLXRpbWUgZmVhdHVyZSBmbGFncyB0byBiZSBnbG9iYWxseSBpbmplY3RlZCB2aWEgdGhlIGJ1bmRsZXIgY29uZmlnIGluIG9yZGVyIHRvIGdldCBiZXR0ZXIgdHJlZS1zaGFraW5nIGluIHRoZSBwcm9kdWN0aW9uIGJ1bmRsZS5cblxuRm9yIG1vcmUgZGV0YWlscywgc2VlIGh0dHBzOi8vbGluay52dWVqcy5vcmcvZmVhdHVyZS1mbGFncy5gXG4gICAgKTtcbiAgfVxufVxuXG5jb25zdCBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QgPSBxdWV1ZUVmZmVjdFdpdGhTdXNwZW5zZSA7XG5mdW5jdGlvbiBjcmVhdGVSZW5kZXJlcihvcHRpb25zKSB7XG4gIHJldHVybiBiYXNlQ3JlYXRlUmVuZGVyZXIob3B0aW9ucyk7XG59XG5mdW5jdGlvbiBjcmVhdGVIeWRyYXRpb25SZW5kZXJlcihvcHRpb25zKSB7XG4gIHJldHVybiBiYXNlQ3JlYXRlUmVuZGVyZXIob3B0aW9ucywgY3JlYXRlSHlkcmF0aW9uRnVuY3Rpb25zKTtcbn1cbmZ1bmN0aW9uIGJhc2VDcmVhdGVSZW5kZXJlcihvcHRpb25zLCBjcmVhdGVIeWRyYXRpb25GbnMpIHtcbiAge1xuICAgIGluaXRGZWF0dXJlRmxhZ3MoKTtcbiAgfVxuICBjb25zdCB0YXJnZXQgPSBnZXRHbG9iYWxUaGlzKCk7XG4gIHRhcmdldC5fX1ZVRV9fID0gdHJ1ZTtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XG4gICAgc2V0RGV2dG9vbHNIb29rKHRhcmdldC5fX1ZVRV9ERVZUT09MU19HTE9CQUxfSE9PS19fLCB0YXJnZXQpO1xuICB9XG4gIGNvbnN0IHtcbiAgICBpbnNlcnQ6IGhvc3RJbnNlcnQsXG4gICAgcmVtb3ZlOiBob3N0UmVtb3ZlLFxuICAgIHBhdGNoUHJvcDogaG9zdFBhdGNoUHJvcCxcbiAgICBjcmVhdGVFbGVtZW50OiBob3N0Q3JlYXRlRWxlbWVudCxcbiAgICBjcmVhdGVUZXh0OiBob3N0Q3JlYXRlVGV4dCxcbiAgICBjcmVhdGVDb21tZW50OiBob3N0Q3JlYXRlQ29tbWVudCxcbiAgICBzZXRUZXh0OiBob3N0U2V0VGV4dCxcbiAgICBzZXRFbGVtZW50VGV4dDogaG9zdFNldEVsZW1lbnRUZXh0LFxuICAgIHBhcmVudE5vZGU6IGhvc3RQYXJlbnROb2RlLFxuICAgIG5leHRTaWJsaW5nOiBob3N0TmV4dFNpYmxpbmcsXG4gICAgc2V0U2NvcGVJZDogaG9zdFNldFNjb3BlSWQgPSBOT09QLFxuICAgIGluc2VydFN0YXRpY0NvbnRlbnQ6IGhvc3RJbnNlcnRTdGF0aWNDb250ZW50XG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCBwYXRjaCA9IChuMSwgbjIsIGNvbnRhaW5lciwgYW5jaG9yID0gbnVsbCwgcGFyZW50Q29tcG9uZW50ID0gbnVsbCwgcGFyZW50U3VzcGVuc2UgPSBudWxsLCBpc1NWRyA9IGZhbHNlLCBzbG90U2NvcGVJZHMgPSBudWxsLCBvcHRpbWl6ZWQgPSAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGlzSG1yVXBkYXRpbmcgPyBmYWxzZSA6ICEhbjIuZHluYW1pY0NoaWxkcmVuKSA9PiB7XG4gICAgaWYgKG4xID09PSBuMikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAobjEgJiYgIWlzU2FtZVZOb2RlVHlwZShuMSwgbjIpKSB7XG4gICAgICBhbmNob3IgPSBnZXROZXh0SG9zdE5vZGUobjEpO1xuICAgICAgdW5tb3VudChuMSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgdHJ1ZSk7XG4gICAgICBuMSA9IG51bGw7XG4gICAgfVxuICAgIGlmIChuMi5wYXRjaEZsYWcgPT09IC0yKSB7XG4gICAgICBvcHRpbWl6ZWQgPSBmYWxzZTtcbiAgICAgIG4yLmR5bmFtaWNDaGlsZHJlbiA9IG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHsgdHlwZSwgcmVmLCBzaGFwZUZsYWcgfSA9IG4yO1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSBUZXh0OlxuICAgICAgICBwcm9jZXNzVGV4dChuMSwgbjIsIGNvbnRhaW5lciwgYW5jaG9yKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIENvbW1lbnQ6XG4gICAgICAgIHByb2Nlc3NDb21tZW50Tm9kZShuMSwgbjIsIGNvbnRhaW5lciwgYW5jaG9yKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFN0YXRpYzpcbiAgICAgICAgaWYgKG4xID09IG51bGwpIHtcbiAgICAgICAgICBtb3VudFN0YXRpY05vZGUobjIsIGNvbnRhaW5lciwgYW5jaG9yLCBpc1NWRyk7XG4gICAgICAgIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgIHBhdGNoU3RhdGljTm9kZShuMSwgbjIsIGNvbnRhaW5lciwgaXNTVkcpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBGcmFnbWVudDpcbiAgICAgICAgcHJvY2Vzc0ZyYWdtZW50KFxuICAgICAgICAgIG4xLFxuICAgICAgICAgIG4yLFxuICAgICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgICBhbmNob3IsXG4gICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgIGlzU1ZHLFxuICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICAgKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAoc2hhcGVGbGFnICYgMSkge1xuICAgICAgICAgIHByb2Nlc3NFbGVtZW50KFxuICAgICAgICAgICAgbjEsXG4gICAgICAgICAgICBuMixcbiAgICAgICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgICAgIGFuY2hvcixcbiAgICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgICAgaXNTVkcsXG4gICAgICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2UgaWYgKHNoYXBlRmxhZyAmIDYpIHtcbiAgICAgICAgICBwcm9jZXNzQ29tcG9uZW50KFxuICAgICAgICAgICAgbjEsXG4gICAgICAgICAgICBuMixcbiAgICAgICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgICAgIGFuY2hvcixcbiAgICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgICAgaXNTVkcsXG4gICAgICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2UgaWYgKHNoYXBlRmxhZyAmIDY0KSB7XG4gICAgICAgICAgdHlwZS5wcm9jZXNzKFxuICAgICAgICAgICAgbjEsXG4gICAgICAgICAgICBuMixcbiAgICAgICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgICAgIGFuY2hvcixcbiAgICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgICAgaXNTVkcsXG4gICAgICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgICAgICBvcHRpbWl6ZWQsXG4gICAgICAgICAgICBpbnRlcm5hbHNcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2UgaWYgKHNoYXBlRmxhZyAmIDEyOCkge1xuICAgICAgICAgIHR5cGUucHJvY2VzcyhcbiAgICAgICAgICAgIG4xLFxuICAgICAgICAgICAgbjIsXG4gICAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgICBhbmNob3IsXG4gICAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICAgIGlzU1ZHLFxuICAgICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgICAgb3B0aW1pemVkLFxuICAgICAgICAgICAgaW50ZXJuYWxzXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgd2FybihcIkludmFsaWQgVk5vZGUgdHlwZTpcIiwgdHlwZSwgYCgke3R5cGVvZiB0eXBlfSlgKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAocmVmICE9IG51bGwgJiYgcGFyZW50Q29tcG9uZW50KSB7XG4gICAgICBzZXRSZWYocmVmLCBuMSAmJiBuMS5yZWYsIHBhcmVudFN1c3BlbnNlLCBuMiB8fCBuMSwgIW4yKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHByb2Nlc3NUZXh0ID0gKG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IpID0+IHtcbiAgICBpZiAobjEgPT0gbnVsbCkge1xuICAgICAgaG9zdEluc2VydChcbiAgICAgICAgbjIuZWwgPSBob3N0Q3JlYXRlVGV4dChuMi5jaGlsZHJlbiksXG4gICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgYW5jaG9yXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBlbCA9IG4yLmVsID0gbjEuZWw7XG4gICAgICBpZiAobjIuY2hpbGRyZW4gIT09IG4xLmNoaWxkcmVuKSB7XG4gICAgICAgIGhvc3RTZXRUZXh0KGVsLCBuMi5jaGlsZHJlbik7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBjb25zdCBwcm9jZXNzQ29tbWVudE5vZGUgPSAobjEsIG4yLCBjb250YWluZXIsIGFuY2hvcikgPT4ge1xuICAgIGlmIChuMSA9PSBudWxsKSB7XG4gICAgICBob3N0SW5zZXJ0KFxuICAgICAgICBuMi5lbCA9IGhvc3RDcmVhdGVDb21tZW50KG4yLmNoaWxkcmVuIHx8IFwiXCIpLFxuICAgICAgICBjb250YWluZXIsXG4gICAgICAgIGFuY2hvclxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbjIuZWwgPSBuMS5lbDtcbiAgICB9XG4gIH07XG4gIGNvbnN0IG1vdW50U3RhdGljTm9kZSA9IChuMiwgY29udGFpbmVyLCBhbmNob3IsIGlzU1ZHKSA9PiB7XG4gICAgW24yLmVsLCBuMi5hbmNob3JdID0gaG9zdEluc2VydFN0YXRpY0NvbnRlbnQoXG4gICAgICBuMi5jaGlsZHJlbixcbiAgICAgIGNvbnRhaW5lcixcbiAgICAgIGFuY2hvcixcbiAgICAgIGlzU1ZHLFxuICAgICAgbjIuZWwsXG4gICAgICBuMi5hbmNob3JcbiAgICApO1xuICB9O1xuICBjb25zdCBwYXRjaFN0YXRpY05vZGUgPSAobjEsIG4yLCBjb250YWluZXIsIGlzU1ZHKSA9PiB7XG4gICAgaWYgKG4yLmNoaWxkcmVuICE9PSBuMS5jaGlsZHJlbikge1xuICAgICAgY29uc3QgYW5jaG9yID0gaG9zdE5leHRTaWJsaW5nKG4xLmFuY2hvcik7XG4gICAgICByZW1vdmVTdGF0aWNOb2RlKG4xKTtcbiAgICAgIFtuMi5lbCwgbjIuYW5jaG9yXSA9IGhvc3RJbnNlcnRTdGF0aWNDb250ZW50KFxuICAgICAgICBuMi5jaGlsZHJlbixcbiAgICAgICAgY29udGFpbmVyLFxuICAgICAgICBhbmNob3IsXG4gICAgICAgIGlzU1ZHXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBuMi5lbCA9IG4xLmVsO1xuICAgICAgbjIuYW5jaG9yID0gbjEuYW5jaG9yO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgbW92ZVN0YXRpY05vZGUgPSAoeyBlbCwgYW5jaG9yIH0sIGNvbnRhaW5lciwgbmV4dFNpYmxpbmcpID0+IHtcbiAgICBsZXQgbmV4dDtcbiAgICB3aGlsZSAoZWwgJiYgZWwgIT09IGFuY2hvcikge1xuICAgICAgbmV4dCA9IGhvc3ROZXh0U2libGluZyhlbCk7XG4gICAgICBob3N0SW5zZXJ0KGVsLCBjb250YWluZXIsIG5leHRTaWJsaW5nKTtcbiAgICAgIGVsID0gbmV4dDtcbiAgICB9XG4gICAgaG9zdEluc2VydChhbmNob3IsIGNvbnRhaW5lciwgbmV4dFNpYmxpbmcpO1xuICB9O1xuICBjb25zdCByZW1vdmVTdGF0aWNOb2RlID0gKHsgZWwsIGFuY2hvciB9KSA9PiB7XG4gICAgbGV0IG5leHQ7XG4gICAgd2hpbGUgKGVsICYmIGVsICE9PSBhbmNob3IpIHtcbiAgICAgIG5leHQgPSBob3N0TmV4dFNpYmxpbmcoZWwpO1xuICAgICAgaG9zdFJlbW92ZShlbCk7XG4gICAgICBlbCA9IG5leHQ7XG4gICAgfVxuICAgIGhvc3RSZW1vdmUoYW5jaG9yKTtcbiAgfTtcbiAgY29uc3QgcHJvY2Vzc0VsZW1lbnQgPSAobjEsIG4yLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKSA9PiB7XG4gICAgaXNTVkcgPSBpc1NWRyB8fCBuMi50eXBlID09PSBcInN2Z1wiO1xuICAgIGlmIChuMSA9PSBudWxsKSB7XG4gICAgICBtb3VudEVsZW1lbnQoXG4gICAgICAgIG4yLFxuICAgICAgICBjb250YWluZXIsXG4gICAgICAgIGFuY2hvcixcbiAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgaXNTVkcsXG4gICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgb3B0aW1pemVkXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXRjaEVsZW1lbnQoXG4gICAgICAgIG4xLFxuICAgICAgICBuMixcbiAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgaXNTVkcsXG4gICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgb3B0aW1pemVkXG4gICAgICApO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgbW91bnRFbGVtZW50ID0gKHZub2RlLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKSA9PiB7XG4gICAgbGV0IGVsO1xuICAgIGxldCB2bm9kZUhvb2s7XG4gICAgY29uc3QgeyB0eXBlLCBwcm9wcywgc2hhcGVGbGFnLCB0cmFuc2l0aW9uLCBkaXJzIH0gPSB2bm9kZTtcbiAgICBlbCA9IHZub2RlLmVsID0gaG9zdENyZWF0ZUVsZW1lbnQoXG4gICAgICB2bm9kZS50eXBlLFxuICAgICAgaXNTVkcsXG4gICAgICBwcm9wcyAmJiBwcm9wcy5pcyxcbiAgICAgIHByb3BzXG4gICAgKTtcbiAgICBpZiAoc2hhcGVGbGFnICYgOCkge1xuICAgICAgaG9zdFNldEVsZW1lbnRUZXh0KGVsLCB2bm9kZS5jaGlsZHJlbik7XG4gICAgfSBlbHNlIGlmIChzaGFwZUZsYWcgJiAxNikge1xuICAgICAgbW91bnRDaGlsZHJlbihcbiAgICAgICAgdm5vZGUuY2hpbGRyZW4sXG4gICAgICAgIGVsLFxuICAgICAgICBudWxsLFxuICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICBpc1NWRyAmJiB0eXBlICE9PSBcImZvcmVpZ25PYmplY3RcIixcbiAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChkaXJzKSB7XG4gICAgICBpbnZva2VEaXJlY3RpdmVIb29rKHZub2RlLCBudWxsLCBwYXJlbnRDb21wb25lbnQsIFwiY3JlYXRlZFwiKTtcbiAgICB9XG4gICAgc2V0U2NvcGVJZChlbCwgdm5vZGUsIHZub2RlLnNjb3BlSWQsIHNsb3RTY29wZUlkcywgcGFyZW50Q29tcG9uZW50KTtcbiAgICBpZiAocHJvcHMpIHtcbiAgICAgIGZvciAoY29uc3Qga2V5IGluIHByb3BzKSB7XG4gICAgICAgIGlmIChrZXkgIT09IFwidmFsdWVcIiAmJiAhaXNSZXNlcnZlZFByb3Aoa2V5KSkge1xuICAgICAgICAgIGhvc3RQYXRjaFByb3AoXG4gICAgICAgICAgICBlbCxcbiAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICBwcm9wc1trZXldLFxuICAgICAgICAgICAgaXNTVkcsXG4gICAgICAgICAgICB2bm9kZS5jaGlsZHJlbixcbiAgICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgICAgdW5tb3VudENoaWxkcmVuXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKFwidmFsdWVcIiBpbiBwcm9wcykge1xuICAgICAgICBob3N0UGF0Y2hQcm9wKGVsLCBcInZhbHVlXCIsIG51bGwsIHByb3BzLnZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGlmICh2bm9kZUhvb2sgPSBwcm9wcy5vblZub2RlQmVmb3JlTW91bnQpIHtcbiAgICAgICAgaW52b2tlVk5vZGVIb29rKHZub2RlSG9vaywgcGFyZW50Q29tcG9uZW50LCB2bm9kZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsLCBcIl9fdm5vZGVcIiwge1xuICAgICAgICB2YWx1ZTogdm5vZGUsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlXG4gICAgICB9KTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbCwgXCJfX3Z1ZVBhcmVudENvbXBvbmVudFwiLCB7XG4gICAgICAgIHZhbHVlOiBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGRpcnMpIHtcbiAgICAgIGludm9rZURpcmVjdGl2ZUhvb2sodm5vZGUsIG51bGwsIHBhcmVudENvbXBvbmVudCwgXCJiZWZvcmVNb3VudFwiKTtcbiAgICB9XG4gICAgY29uc3QgbmVlZENhbGxUcmFuc2l0aW9uSG9va3MgPSAoIXBhcmVudFN1c3BlbnNlIHx8IHBhcmVudFN1c3BlbnNlICYmICFwYXJlbnRTdXNwZW5zZS5wZW5kaW5nQnJhbmNoKSAmJiB0cmFuc2l0aW9uICYmICF0cmFuc2l0aW9uLnBlcnNpc3RlZDtcbiAgICBpZiAobmVlZENhbGxUcmFuc2l0aW9uSG9va3MpIHtcbiAgICAgIHRyYW5zaXRpb24uYmVmb3JlRW50ZXIoZWwpO1xuICAgIH1cbiAgICBob3N0SW5zZXJ0KGVsLCBjb250YWluZXIsIGFuY2hvcik7XG4gICAgaWYgKCh2bm9kZUhvb2sgPSBwcm9wcyAmJiBwcm9wcy5vblZub2RlTW91bnRlZCkgfHwgbmVlZENhbGxUcmFuc2l0aW9uSG9va3MgfHwgZGlycykge1xuICAgICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KCgpID0+IHtcbiAgICAgICAgdm5vZGVIb29rICYmIGludm9rZVZOb2RlSG9vayh2bm9kZUhvb2ssIHBhcmVudENvbXBvbmVudCwgdm5vZGUpO1xuICAgICAgICBuZWVkQ2FsbFRyYW5zaXRpb25Ib29rcyAmJiB0cmFuc2l0aW9uLmVudGVyKGVsKTtcbiAgICAgICAgZGlycyAmJiBpbnZva2VEaXJlY3RpdmVIb29rKHZub2RlLCBudWxsLCBwYXJlbnRDb21wb25lbnQsIFwibW91bnRlZFwiKTtcbiAgICAgIH0sIHBhcmVudFN1c3BlbnNlKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHNldFNjb3BlSWQgPSAoZWwsIHZub2RlLCBzY29wZUlkLCBzbG90U2NvcGVJZHMsIHBhcmVudENvbXBvbmVudCkgPT4ge1xuICAgIGlmIChzY29wZUlkKSB7XG4gICAgICBob3N0U2V0U2NvcGVJZChlbCwgc2NvcGVJZCk7XG4gICAgfVxuICAgIGlmIChzbG90U2NvcGVJZHMpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2xvdFNjb3BlSWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGhvc3RTZXRTY29wZUlkKGVsLCBzbG90U2NvcGVJZHNbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocGFyZW50Q29tcG9uZW50KSB7XG4gICAgICBsZXQgc3ViVHJlZSA9IHBhcmVudENvbXBvbmVudC5zdWJUcmVlO1xuICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgc3ViVHJlZS5wYXRjaEZsYWcgPiAwICYmIHN1YlRyZWUucGF0Y2hGbGFnICYgMjA0OCkge1xuICAgICAgICBzdWJUcmVlID0gZmlsdGVyU2luZ2xlUm9vdChzdWJUcmVlLmNoaWxkcmVuKSB8fCBzdWJUcmVlO1xuICAgICAgfVxuICAgICAgaWYgKHZub2RlID09PSBzdWJUcmVlKSB7XG4gICAgICAgIGNvbnN0IHBhcmVudFZOb2RlID0gcGFyZW50Q29tcG9uZW50LnZub2RlO1xuICAgICAgICBzZXRTY29wZUlkKFxuICAgICAgICAgIGVsLFxuICAgICAgICAgIHBhcmVudFZOb2RlLFxuICAgICAgICAgIHBhcmVudFZOb2RlLnNjb3BlSWQsXG4gICAgICAgICAgcGFyZW50Vk5vZGUuc2xvdFNjb3BlSWRzLFxuICAgICAgICAgIHBhcmVudENvbXBvbmVudC5wYXJlbnRcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIGNvbnN0IG1vdW50Q2hpbGRyZW4gPSAoY2hpbGRyZW4sIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQsIHN0YXJ0ID0gMCkgPT4ge1xuICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBjaGlsZCA9IGNoaWxkcmVuW2ldID0gb3B0aW1pemVkID8gY2xvbmVJZk1vdW50ZWQoY2hpbGRyZW5baV0pIDogbm9ybWFsaXplVk5vZGUoY2hpbGRyZW5baV0pO1xuICAgICAgcGF0Y2goXG4gICAgICAgIG51bGwsXG4gICAgICAgIGNoaWxkLFxuICAgICAgICBjb250YWluZXIsXG4gICAgICAgIGFuY2hvcixcbiAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgaXNTVkcsXG4gICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgb3B0aW1pemVkXG4gICAgICApO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgcGF0Y2hFbGVtZW50ID0gKG4xLCBuMiwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKSA9PiB7XG4gICAgY29uc3QgZWwgPSBuMi5lbCA9IG4xLmVsO1xuICAgIGxldCB7IHBhdGNoRmxhZywgZHluYW1pY0NoaWxkcmVuLCBkaXJzIH0gPSBuMjtcbiAgICBwYXRjaEZsYWcgfD0gbjEucGF0Y2hGbGFnICYgMTY7XG4gICAgY29uc3Qgb2xkUHJvcHMgPSBuMS5wcm9wcyB8fCBFTVBUWV9PQko7XG4gICAgY29uc3QgbmV3UHJvcHMgPSBuMi5wcm9wcyB8fCBFTVBUWV9PQko7XG4gICAgbGV0IHZub2RlSG9vaztcbiAgICBwYXJlbnRDb21wb25lbnQgJiYgdG9nZ2xlUmVjdXJzZShwYXJlbnRDb21wb25lbnQsIGZhbHNlKTtcbiAgICBpZiAodm5vZGVIb29rID0gbmV3UHJvcHMub25Wbm9kZUJlZm9yZVVwZGF0ZSkge1xuICAgICAgaW52b2tlVk5vZGVIb29rKHZub2RlSG9vaywgcGFyZW50Q29tcG9uZW50LCBuMiwgbjEpO1xuICAgIH1cbiAgICBpZiAoZGlycykge1xuICAgICAgaW52b2tlRGlyZWN0aXZlSG9vayhuMiwgbjEsIHBhcmVudENvbXBvbmVudCwgXCJiZWZvcmVVcGRhdGVcIik7XG4gICAgfVxuICAgIHBhcmVudENvbXBvbmVudCAmJiB0b2dnbGVSZWN1cnNlKHBhcmVudENvbXBvbmVudCwgdHJ1ZSk7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgaXNIbXJVcGRhdGluZykge1xuICAgICAgcGF0Y2hGbGFnID0gMDtcbiAgICAgIG9wdGltaXplZCA9IGZhbHNlO1xuICAgICAgZHluYW1pY0NoaWxkcmVuID0gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgYXJlQ2hpbGRyZW5TVkcgPSBpc1NWRyAmJiBuMi50eXBlICE9PSBcImZvcmVpZ25PYmplY3RcIjtcbiAgICBpZiAoZHluYW1pY0NoaWxkcmVuKSB7XG4gICAgICBwYXRjaEJsb2NrQ2hpbGRyZW4oXG4gICAgICAgIG4xLmR5bmFtaWNDaGlsZHJlbixcbiAgICAgICAgZHluYW1pY0NoaWxkcmVuLFxuICAgICAgICBlbCxcbiAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgYXJlQ2hpbGRyZW5TVkcsXG4gICAgICAgIHNsb3RTY29wZUlkc1xuICAgICAgKTtcbiAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgIHRyYXZlcnNlU3RhdGljQ2hpbGRyZW4objEsIG4yKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFvcHRpbWl6ZWQpIHtcbiAgICAgIHBhdGNoQ2hpbGRyZW4oXG4gICAgICAgIG4xLFxuICAgICAgICBuMixcbiAgICAgICAgZWwsXG4gICAgICAgIG51bGwsXG4gICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgIGFyZUNoaWxkcmVuU1ZHLFxuICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgIGZhbHNlXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAocGF0Y2hGbGFnID4gMCkge1xuICAgICAgaWYgKHBhdGNoRmxhZyAmIDE2KSB7XG4gICAgICAgIHBhdGNoUHJvcHMoXG4gICAgICAgICAgZWwsXG4gICAgICAgICAgbjIsXG4gICAgICAgICAgb2xkUHJvcHMsXG4gICAgICAgICAgbmV3UHJvcHMsXG4gICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgIGlzU1ZHXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocGF0Y2hGbGFnICYgMikge1xuICAgICAgICAgIGlmIChvbGRQcm9wcy5jbGFzcyAhPT0gbmV3UHJvcHMuY2xhc3MpIHtcbiAgICAgICAgICAgIGhvc3RQYXRjaFByb3AoZWwsIFwiY2xhc3NcIiwgbnVsbCwgbmV3UHJvcHMuY2xhc3MsIGlzU1ZHKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhdGNoRmxhZyAmIDQpIHtcbiAgICAgICAgICBob3N0UGF0Y2hQcm9wKGVsLCBcInN0eWxlXCIsIG9sZFByb3BzLnN0eWxlLCBuZXdQcm9wcy5zdHlsZSwgaXNTVkcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXRjaEZsYWcgJiA4KSB7XG4gICAgICAgICAgY29uc3QgcHJvcHNUb1VwZGF0ZSA9IG4yLmR5bmFtaWNQcm9wcztcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByb3BzVG9VcGRhdGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IHByb3BzVG9VcGRhdGVbaV07XG4gICAgICAgICAgICBjb25zdCBwcmV2ID0gb2xkUHJvcHNba2V5XTtcbiAgICAgICAgICAgIGNvbnN0IG5leHQgPSBuZXdQcm9wc1trZXldO1xuICAgICAgICAgICAgaWYgKG5leHQgIT09IHByZXYgfHwga2V5ID09PSBcInZhbHVlXCIpIHtcbiAgICAgICAgICAgICAgaG9zdFBhdGNoUHJvcChcbiAgICAgICAgICAgICAgICBlbCxcbiAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgcHJldixcbiAgICAgICAgICAgICAgICBuZXh0LFxuICAgICAgICAgICAgICAgIGlzU1ZHLFxuICAgICAgICAgICAgICAgIG4xLmNoaWxkcmVuLFxuICAgICAgICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICAgICAgICB1bm1vdW50Q2hpbGRyZW5cbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChwYXRjaEZsYWcgJiAxKSB7XG4gICAgICAgIGlmIChuMS5jaGlsZHJlbiAhPT0gbjIuY2hpbGRyZW4pIHtcbiAgICAgICAgICBob3N0U2V0RWxlbWVudFRleHQoZWwsIG4yLmNoaWxkcmVuKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIW9wdGltaXplZCAmJiBkeW5hbWljQ2hpbGRyZW4gPT0gbnVsbCkge1xuICAgICAgcGF0Y2hQcm9wcyhcbiAgICAgICAgZWwsXG4gICAgICAgIG4yLFxuICAgICAgICBvbGRQcm9wcyxcbiAgICAgICAgbmV3UHJvcHMsXG4gICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgIGlzU1ZHXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoKHZub2RlSG9vayA9IG5ld1Byb3BzLm9uVm5vZGVVcGRhdGVkKSB8fCBkaXJzKSB7XG4gICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QoKCkgPT4ge1xuICAgICAgICB2bm9kZUhvb2sgJiYgaW52b2tlVk5vZGVIb29rKHZub2RlSG9vaywgcGFyZW50Q29tcG9uZW50LCBuMiwgbjEpO1xuICAgICAgICBkaXJzICYmIGludm9rZURpcmVjdGl2ZUhvb2sobjIsIG4xLCBwYXJlbnRDb21wb25lbnQsIFwidXBkYXRlZFwiKTtcbiAgICAgIH0sIHBhcmVudFN1c3BlbnNlKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHBhdGNoQmxvY2tDaGlsZHJlbiA9IChvbGRDaGlsZHJlbiwgbmV3Q2hpbGRyZW4sIGZhbGxiYWNrQ29udGFpbmVyLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzKSA9PiB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuZXdDaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qgb2xkVk5vZGUgPSBvbGRDaGlsZHJlbltpXTtcbiAgICAgIGNvbnN0IG5ld1ZOb2RlID0gbmV3Q2hpbGRyZW5baV07XG4gICAgICBjb25zdCBjb250YWluZXIgPSAoXG4gICAgICAgIC8vIG9sZFZOb2RlIG1heSBiZSBhbiBlcnJvcmVkIGFzeW5jIHNldHVwKCkgY29tcG9uZW50IGluc2lkZSBTdXNwZW5zZVxuICAgICAgICAvLyB3aGljaCB3aWxsIG5vdCBoYXZlIGEgbW91bnRlZCBlbGVtZW50XG4gICAgICAgIG9sZFZOb2RlLmVsICYmIC8vIC0gSW4gdGhlIGNhc2Ugb2YgYSBGcmFnbWVudCwgd2UgbmVlZCB0byBwcm92aWRlIHRoZSBhY3R1YWwgcGFyZW50XG4gICAgICAgIC8vIG9mIHRoZSBGcmFnbWVudCBpdHNlbGYgc28gaXQgY2FuIG1vdmUgaXRzIGNoaWxkcmVuLlxuICAgICAgICAob2xkVk5vZGUudHlwZSA9PT0gRnJhZ21lbnQgfHwgLy8gLSBJbiB0aGUgY2FzZSBvZiBkaWZmZXJlbnQgbm9kZXMsIHRoZXJlIGlzIGdvaW5nIHRvIGJlIGEgcmVwbGFjZW1lbnRcbiAgICAgICAgLy8gd2hpY2ggYWxzbyByZXF1aXJlcyB0aGUgY29ycmVjdCBwYXJlbnQgY29udGFpbmVyXG4gICAgICAgICFpc1NhbWVWTm9kZVR5cGUob2xkVk5vZGUsIG5ld1ZOb2RlKSB8fCAvLyAtIEluIHRoZSBjYXNlIG9mIGEgY29tcG9uZW50LCBpdCBjb3VsZCBjb250YWluIGFueXRoaW5nLlxuICAgICAgICBvbGRWTm9kZS5zaGFwZUZsYWcgJiAoNiB8IDY0KSkgPyBob3N0UGFyZW50Tm9kZShvbGRWTm9kZS5lbCkgOiAoXG4gICAgICAgICAgLy8gSW4gb3RoZXIgY2FzZXMsIHRoZSBwYXJlbnQgY29udGFpbmVyIGlzIG5vdCBhY3R1YWxseSB1c2VkIHNvIHdlXG4gICAgICAgICAgLy8ganVzdCBwYXNzIHRoZSBibG9jayBlbGVtZW50IGhlcmUgdG8gYXZvaWQgYSBET00gcGFyZW50Tm9kZSBjYWxsLlxuICAgICAgICAgIGZhbGxiYWNrQ29udGFpbmVyXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgICBwYXRjaChcbiAgICAgICAgb2xkVk5vZGUsXG4gICAgICAgIG5ld1ZOb2RlLFxuICAgICAgICBjb250YWluZXIsXG4gICAgICAgIG51bGwsXG4gICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgIGlzU1ZHLFxuICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgIHRydWVcbiAgICAgICk7XG4gICAgfVxuICB9O1xuICBjb25zdCBwYXRjaFByb3BzID0gKGVsLCB2bm9kZSwgb2xkUHJvcHMsIG5ld1Byb3BzLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRykgPT4ge1xuICAgIGlmIChvbGRQcm9wcyAhPT0gbmV3UHJvcHMpIHtcbiAgICAgIGlmIChvbGRQcm9wcyAhPT0gRU1QVFlfT0JKKSB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIG9sZFByb3BzKSB7XG4gICAgICAgICAgaWYgKCFpc1Jlc2VydmVkUHJvcChrZXkpICYmICEoa2V5IGluIG5ld1Byb3BzKSkge1xuICAgICAgICAgICAgaG9zdFBhdGNoUHJvcChcbiAgICAgICAgICAgICAgZWwsXG4gICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgb2xkUHJvcHNba2V5XSxcbiAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgaXNTVkcsXG4gICAgICAgICAgICAgIHZub2RlLmNoaWxkcmVuLFxuICAgICAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgICAgICB1bm1vdW50Q2hpbGRyZW5cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiBuZXdQcm9wcykge1xuICAgICAgICBpZiAoaXNSZXNlcnZlZFByb3Aoa2V5KSlcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgY29uc3QgbmV4dCA9IG5ld1Byb3BzW2tleV07XG4gICAgICAgIGNvbnN0IHByZXYgPSBvbGRQcm9wc1trZXldO1xuICAgICAgICBpZiAobmV4dCAhPT0gcHJldiAmJiBrZXkgIT09IFwidmFsdWVcIikge1xuICAgICAgICAgIGhvc3RQYXRjaFByb3AoXG4gICAgICAgICAgICBlbCxcbiAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgIHByZXYsXG4gICAgICAgICAgICBuZXh0LFxuICAgICAgICAgICAgaXNTVkcsXG4gICAgICAgICAgICB2bm9kZS5jaGlsZHJlbixcbiAgICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgICAgdW5tb3VudENoaWxkcmVuXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKFwidmFsdWVcIiBpbiBuZXdQcm9wcykge1xuICAgICAgICBob3N0UGF0Y2hQcm9wKGVsLCBcInZhbHVlXCIsIG9sZFByb3BzLnZhbHVlLCBuZXdQcm9wcy52YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBjb25zdCBwcm9jZXNzRnJhZ21lbnQgPSAobjEsIG4yLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKSA9PiB7XG4gICAgY29uc3QgZnJhZ21lbnRTdGFydEFuY2hvciA9IG4yLmVsID0gbjEgPyBuMS5lbCA6IGhvc3RDcmVhdGVUZXh0KFwiXCIpO1xuICAgIGNvbnN0IGZyYWdtZW50RW5kQW5jaG9yID0gbjIuYW5jaG9yID0gbjEgPyBuMS5hbmNob3IgOiBob3N0Q3JlYXRlVGV4dChcIlwiKTtcbiAgICBsZXQgeyBwYXRjaEZsYWcsIGR5bmFtaWNDaGlsZHJlbiwgc2xvdFNjb3BlSWRzOiBmcmFnbWVudFNsb3RTY29wZUlkcyB9ID0gbjI7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgLy8gIzU1MjMgZGV2IHJvb3QgZnJhZ21lbnQgbWF5IGluaGVyaXQgZGlyZWN0aXZlc1xuICAgIChpc0htclVwZGF0aW5nIHx8IHBhdGNoRmxhZyAmIDIwNDgpKSB7XG4gICAgICBwYXRjaEZsYWcgPSAwO1xuICAgICAgb3B0aW1pemVkID0gZmFsc2U7XG4gICAgICBkeW5hbWljQ2hpbGRyZW4gPSBudWxsO1xuICAgIH1cbiAgICBpZiAoZnJhZ21lbnRTbG90U2NvcGVJZHMpIHtcbiAgICAgIHNsb3RTY29wZUlkcyA9IHNsb3RTY29wZUlkcyA/IHNsb3RTY29wZUlkcy5jb25jYXQoZnJhZ21lbnRTbG90U2NvcGVJZHMpIDogZnJhZ21lbnRTbG90U2NvcGVJZHM7XG4gICAgfVxuICAgIGlmIChuMSA9PSBudWxsKSB7XG4gICAgICBob3N0SW5zZXJ0KGZyYWdtZW50U3RhcnRBbmNob3IsIGNvbnRhaW5lciwgYW5jaG9yKTtcbiAgICAgIGhvc3RJbnNlcnQoZnJhZ21lbnRFbmRBbmNob3IsIGNvbnRhaW5lciwgYW5jaG9yKTtcbiAgICAgIG1vdW50Q2hpbGRyZW4oXG4gICAgICAgIG4yLmNoaWxkcmVuLFxuICAgICAgICBjb250YWluZXIsXG4gICAgICAgIGZyYWdtZW50RW5kQW5jaG9yLFxuICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICBpc1NWRyxcbiAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChwYXRjaEZsYWcgPiAwICYmIHBhdGNoRmxhZyAmIDY0ICYmIGR5bmFtaWNDaGlsZHJlbiAmJiAvLyAjMjcxNSB0aGUgcHJldmlvdXMgZnJhZ21lbnQgY291bGQndmUgYmVlbiBhIEJBSUxlZCBvbmUgYXMgYSByZXN1bHRcbiAgICAgIC8vIG9mIHJlbmRlclNsb3QoKSB3aXRoIG5vIHZhbGlkIGNoaWxkcmVuXG4gICAgICBuMS5keW5hbWljQ2hpbGRyZW4pIHtcbiAgICAgICAgcGF0Y2hCbG9ja0NoaWxkcmVuKFxuICAgICAgICAgIG4xLmR5bmFtaWNDaGlsZHJlbixcbiAgICAgICAgICBkeW5hbWljQ2hpbGRyZW4sXG4gICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICBpc1NWRyxcbiAgICAgICAgICBzbG90U2NvcGVJZHNcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICB0cmF2ZXJzZVN0YXRpY0NoaWxkcmVuKG4xLCBuMik7XG4gICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgLy8gIzIwODAgaWYgdGhlIHN0YWJsZSBmcmFnbWVudCBoYXMgYSBrZXksIGl0J3MgYSA8dGVtcGxhdGUgdi1mb3I+IHRoYXQgbWF5XG4gICAgICAgICAgLy8gIGdldCBtb3ZlZCBhcm91bmQuIE1ha2Ugc3VyZSBhbGwgcm9vdCBsZXZlbCB2bm9kZXMgaW5oZXJpdCBlbC5cbiAgICAgICAgICAvLyAjMjEzNCBvciBpZiBpdCdzIGEgY29tcG9uZW50IHJvb3QsIGl0IG1heSBhbHNvIGdldCBtb3ZlZCBhcm91bmRcbiAgICAgICAgICAvLyBhcyB0aGUgY29tcG9uZW50IGlzIGJlaW5nIG1vdmVkLlxuICAgICAgICAgIG4yLmtleSAhPSBudWxsIHx8IHBhcmVudENvbXBvbmVudCAmJiBuMiA9PT0gcGFyZW50Q29tcG9uZW50LnN1YlRyZWVcbiAgICAgICAgKSB7XG4gICAgICAgICAgdHJhdmVyc2VTdGF0aWNDaGlsZHJlbihcbiAgICAgICAgICAgIG4xLFxuICAgICAgICAgICAgbjIsXG4gICAgICAgICAgICB0cnVlXG4gICAgICAgICAgICAvKiBzaGFsbG93ICovXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGF0Y2hDaGlsZHJlbihcbiAgICAgICAgICBuMSxcbiAgICAgICAgICBuMixcbiAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgZnJhZ21lbnRFbmRBbmNob3IsXG4gICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgIGlzU1ZHLFxuICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIGNvbnN0IHByb2Nlc3NDb21wb25lbnQgPSAobjEsIG4yLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKSA9PiB7XG4gICAgbjIuc2xvdFNjb3BlSWRzID0gc2xvdFNjb3BlSWRzO1xuICAgIGlmIChuMSA9PSBudWxsKSB7XG4gICAgICBpZiAobjIuc2hhcGVGbGFnICYgNTEyKSB7XG4gICAgICAgIHBhcmVudENvbXBvbmVudC5jdHguYWN0aXZhdGUoXG4gICAgICAgICAgbjIsXG4gICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgIGFuY2hvcixcbiAgICAgICAgICBpc1NWRyxcbiAgICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1vdW50Q29tcG9uZW50KFxuICAgICAgICAgIG4yLFxuICAgICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgICBhbmNob3IsXG4gICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgIGlzU1ZHLFxuICAgICAgICAgIG9wdGltaXplZFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB1cGRhdGVDb21wb25lbnQobjEsIG4yLCBvcHRpbWl6ZWQpO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgbW91bnRDb21wb25lbnQgPSAoaW5pdGlhbFZOb2RlLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIG9wdGltaXplZCkgPT4ge1xuICAgIGNvbnN0IGluc3RhbmNlID0gKGluaXRpYWxWTm9kZS5jb21wb25lbnQgPSBjcmVhdGVDb21wb25lbnRJbnN0YW5jZShcbiAgICAgIGluaXRpYWxWTm9kZSxcbiAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgIHBhcmVudFN1c3BlbnNlXG4gICAgKSk7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgaW5zdGFuY2UudHlwZS5fX2htcklkKSB7XG4gICAgICByZWdpc3RlckhNUihpbnN0YW5jZSk7XG4gICAgfVxuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICBwdXNoV2FybmluZ0NvbnRleHQoaW5pdGlhbFZOb2RlKTtcbiAgICAgIHN0YXJ0TWVhc3VyZShpbnN0YW5jZSwgYG1vdW50YCk7XG4gICAgfVxuICAgIGlmIChpc0tlZXBBbGl2ZShpbml0aWFsVk5vZGUpKSB7XG4gICAgICBpbnN0YW5jZS5jdHgucmVuZGVyZXIgPSBpbnRlcm5hbHM7XG4gICAgfVxuICAgIHtcbiAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgIHN0YXJ0TWVhc3VyZShpbnN0YW5jZSwgYGluaXRgKTtcbiAgICAgIH1cbiAgICAgIHNldHVwQ29tcG9uZW50KGluc3RhbmNlKTtcbiAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgIGVuZE1lYXN1cmUoaW5zdGFuY2UsIGBpbml0YCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpbnN0YW5jZS5hc3luY0RlcCkge1xuICAgICAgcGFyZW50U3VzcGVuc2UgJiYgcGFyZW50U3VzcGVuc2UucmVnaXN0ZXJEZXAoaW5zdGFuY2UsIHNldHVwUmVuZGVyRWZmZWN0KTtcbiAgICAgIGlmICghaW5pdGlhbFZOb2RlLmVsKSB7XG4gICAgICAgIGNvbnN0IHBsYWNlaG9sZGVyID0gaW5zdGFuY2Uuc3ViVHJlZSA9IGNyZWF0ZVZOb2RlKENvbW1lbnQpO1xuICAgICAgICBwcm9jZXNzQ29tbWVudE5vZGUobnVsbCwgcGxhY2Vob2xkZXIsIGNvbnRhaW5lciwgYW5jaG9yKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc2V0dXBSZW5kZXJFZmZlY3QoXG4gICAgICBpbnN0YW5jZSxcbiAgICAgIGluaXRpYWxWTm9kZSxcbiAgICAgIGNvbnRhaW5lcixcbiAgICAgIGFuY2hvcixcbiAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgaXNTVkcsXG4gICAgICBvcHRpbWl6ZWRcbiAgICApO1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICBwb3BXYXJuaW5nQ29udGV4dCgpO1xuICAgICAgZW5kTWVhc3VyZShpbnN0YW5jZSwgYG1vdW50YCk7XG4gICAgfVxuICB9O1xuICBjb25zdCB1cGRhdGVDb21wb25lbnQgPSAobjEsIG4yLCBvcHRpbWl6ZWQpID0+IHtcbiAgICBjb25zdCBpbnN0YW5jZSA9IG4yLmNvbXBvbmVudCA9IG4xLmNvbXBvbmVudDtcbiAgICBpZiAoc2hvdWxkVXBkYXRlQ29tcG9uZW50KG4xLCBuMiwgb3B0aW1pemVkKSkge1xuICAgICAgaWYgKGluc3RhbmNlLmFzeW5jRGVwICYmICFpbnN0YW5jZS5hc3luY1Jlc29sdmVkKSB7XG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgcHVzaFdhcm5pbmdDb250ZXh0KG4yKTtcbiAgICAgICAgfVxuICAgICAgICB1cGRhdGVDb21wb25lbnRQcmVSZW5kZXIoaW5zdGFuY2UsIG4yLCBvcHRpbWl6ZWQpO1xuICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgIHBvcFdhcm5pbmdDb250ZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5zdGFuY2UubmV4dCA9IG4yO1xuICAgICAgICBpbnZhbGlkYXRlSm9iKGluc3RhbmNlLnVwZGF0ZSk7XG4gICAgICAgIGluc3RhbmNlLnVwZGF0ZSgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBuMi5lbCA9IG4xLmVsO1xuICAgICAgaW5zdGFuY2Uudm5vZGUgPSBuMjtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHNldHVwUmVuZGVyRWZmZWN0ID0gKGluc3RhbmNlLCBpbml0aWFsVk5vZGUsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIG9wdGltaXplZCkgPT4ge1xuICAgIGNvbnN0IGNvbXBvbmVudFVwZGF0ZUZuID0gKCkgPT4ge1xuICAgICAgaWYgKCFpbnN0YW5jZS5pc01vdW50ZWQpIHtcbiAgICAgICAgbGV0IHZub2RlSG9vaztcbiAgICAgICAgY29uc3QgeyBlbCwgcHJvcHMgfSA9IGluaXRpYWxWTm9kZTtcbiAgICAgICAgY29uc3QgeyBibSwgbSwgcGFyZW50IH0gPSBpbnN0YW5jZTtcbiAgICAgICAgY29uc3QgaXNBc3luY1dyYXBwZXJWTm9kZSA9IGlzQXN5bmNXcmFwcGVyKGluaXRpYWxWTm9kZSk7XG4gICAgICAgIHRvZ2dsZVJlY3Vyc2UoaW5zdGFuY2UsIGZhbHNlKTtcbiAgICAgICAgaWYgKGJtKSB7XG4gICAgICAgICAgaW52b2tlQXJyYXlGbnMoYm0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNBc3luY1dyYXBwZXJWTm9kZSAmJiAodm5vZGVIb29rID0gcHJvcHMgJiYgcHJvcHMub25Wbm9kZUJlZm9yZU1vdW50KSkge1xuICAgICAgICAgIGludm9rZVZOb2RlSG9vayh2bm9kZUhvb2ssIHBhcmVudCwgaW5pdGlhbFZOb2RlKTtcbiAgICAgICAgfVxuICAgICAgICB0b2dnbGVSZWN1cnNlKGluc3RhbmNlLCB0cnVlKTtcbiAgICAgICAgaWYgKGVsICYmIGh5ZHJhdGVOb2RlKSB7XG4gICAgICAgICAgY29uc3QgaHlkcmF0ZVN1YlRyZWUgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgICAgICBzdGFydE1lYXN1cmUoaW5zdGFuY2UsIGByZW5kZXJgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGluc3RhbmNlLnN1YlRyZWUgPSByZW5kZXJDb21wb25lbnRSb290KGluc3RhbmNlKTtcbiAgICAgICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgICAgIGVuZE1lYXN1cmUoaW5zdGFuY2UsIGByZW5kZXJgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgICAgIHN0YXJ0TWVhc3VyZShpbnN0YW5jZSwgYGh5ZHJhdGVgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGh5ZHJhdGVOb2RlKFxuICAgICAgICAgICAgICBlbCxcbiAgICAgICAgICAgICAgaW5zdGFuY2Uuc3ViVHJlZSxcbiAgICAgICAgICAgICAgaW5zdGFuY2UsXG4gICAgICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgICAgICBudWxsXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICAgICAgZW5kTWVhc3VyZShpbnN0YW5jZSwgYGh5ZHJhdGVgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICAgIGlmIChpc0FzeW5jV3JhcHBlclZOb2RlKSB7XG4gICAgICAgICAgICBpbml0aWFsVk5vZGUudHlwZS5fX2FzeW5jTG9hZGVyKCkudGhlbihcbiAgICAgICAgICAgICAgLy8gbm90ZTogd2UgYXJlIG1vdmluZyB0aGUgcmVuZGVyIGNhbGwgaW50byBhbiBhc3luYyBjYWxsYmFjayxcbiAgICAgICAgICAgICAgLy8gd2hpY2ggbWVhbnMgaXQgd29uJ3QgdHJhY2sgZGVwZW5kZW5jaWVzIC0gYnV0IGl0J3Mgb2sgYmVjYXVzZVxuICAgICAgICAgICAgICAvLyBhIHNlcnZlci1yZW5kZXJlZCBhc3luYyB3cmFwcGVyIGlzIGFscmVhZHkgaW4gcmVzb2x2ZWQgc3RhdGVcbiAgICAgICAgICAgICAgLy8gYW5kIGl0IHdpbGwgbmV2ZXIgbmVlZCB0byBjaGFuZ2UuXG4gICAgICAgICAgICAgICgpID0+ICFpbnN0YW5jZS5pc1VubW91bnRlZCAmJiBoeWRyYXRlU3ViVHJlZSgpXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBoeWRyYXRlU3ViVHJlZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgICAgc3RhcnRNZWFzdXJlKGluc3RhbmNlLCBgcmVuZGVyYCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHN1YlRyZWUgPSBpbnN0YW5jZS5zdWJUcmVlID0gcmVuZGVyQ29tcG9uZW50Um9vdChpbnN0YW5jZSk7XG4gICAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICAgIGVuZE1lYXN1cmUoaW5zdGFuY2UsIGByZW5kZXJgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICAgIHN0YXJ0TWVhc3VyZShpbnN0YW5jZSwgYHBhdGNoYCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHBhdGNoKFxuICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgIHN1YlRyZWUsXG4gICAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgICBhbmNob3IsXG4gICAgICAgICAgICBpbnN0YW5jZSxcbiAgICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgICAgaXNTVkdcbiAgICAgICAgICApO1xuICAgICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgICBlbmRNZWFzdXJlKGluc3RhbmNlLCBgcGF0Y2hgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaW5pdGlhbFZOb2RlLmVsID0gc3ViVHJlZS5lbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAobSkge1xuICAgICAgICAgIHF1ZXVlUG9zdFJlbmRlckVmZmVjdChtLCBwYXJlbnRTdXNwZW5zZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc0FzeW5jV3JhcHBlclZOb2RlICYmICh2bm9kZUhvb2sgPSBwcm9wcyAmJiBwcm9wcy5vblZub2RlTW91bnRlZCkpIHtcbiAgICAgICAgICBjb25zdCBzY29wZWRJbml0aWFsVk5vZGUgPSBpbml0aWFsVk5vZGU7XG4gICAgICAgICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KFxuICAgICAgICAgICAgKCkgPT4gaW52b2tlVk5vZGVIb29rKHZub2RlSG9vaywgcGFyZW50LCBzY29wZWRJbml0aWFsVk5vZGUpLFxuICAgICAgICAgICAgcGFyZW50U3VzcGVuc2VcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbml0aWFsVk5vZGUuc2hhcGVGbGFnICYgMjU2IHx8IHBhcmVudCAmJiBpc0FzeW5jV3JhcHBlcihwYXJlbnQudm5vZGUpICYmIHBhcmVudC52bm9kZS5zaGFwZUZsYWcgJiAyNTYpIHtcbiAgICAgICAgICBpbnN0YW5jZS5hICYmIHF1ZXVlUG9zdFJlbmRlckVmZmVjdChpbnN0YW5jZS5hLCBwYXJlbnRTdXNwZW5zZSk7XG4gICAgICAgIH1cbiAgICAgICAgaW5zdGFuY2UuaXNNb3VudGVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XG4gICAgICAgICAgZGV2dG9vbHNDb21wb25lbnRBZGRlZChpbnN0YW5jZSk7XG4gICAgICAgIH1cbiAgICAgICAgaW5pdGlhbFZOb2RlID0gY29udGFpbmVyID0gYW5jaG9yID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCB7IG5leHQsIGJ1LCB1LCBwYXJlbnQsIHZub2RlIH0gPSBpbnN0YW5jZTtcbiAgICAgICAgbGV0IG9yaWdpbk5leHQgPSBuZXh0O1xuICAgICAgICBsZXQgdm5vZGVIb29rO1xuICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgIHB1c2hXYXJuaW5nQ29udGV4dChuZXh0IHx8IGluc3RhbmNlLnZub2RlKTtcbiAgICAgICAgfVxuICAgICAgICB0b2dnbGVSZWN1cnNlKGluc3RhbmNlLCBmYWxzZSk7XG4gICAgICAgIGlmIChuZXh0KSB7XG4gICAgICAgICAgbmV4dC5lbCA9IHZub2RlLmVsO1xuICAgICAgICAgIHVwZGF0ZUNvbXBvbmVudFByZVJlbmRlcihpbnN0YW5jZSwgbmV4dCwgb3B0aW1pemVkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXh0ID0gdm5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJ1KSB7XG4gICAgICAgICAgaW52b2tlQXJyYXlGbnMoYnUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2bm9kZUhvb2sgPSBuZXh0LnByb3BzICYmIG5leHQucHJvcHMub25Wbm9kZUJlZm9yZVVwZGF0ZSkge1xuICAgICAgICAgIGludm9rZVZOb2RlSG9vayh2bm9kZUhvb2ssIHBhcmVudCwgbmV4dCwgdm5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIHRvZ2dsZVJlY3Vyc2UoaW5zdGFuY2UsIHRydWUpO1xuICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgIHN0YXJ0TWVhc3VyZShpbnN0YW5jZSwgYHJlbmRlcmApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5leHRUcmVlID0gcmVuZGVyQ29tcG9uZW50Um9vdChpbnN0YW5jZSk7XG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgZW5kTWVhc3VyZShpbnN0YW5jZSwgYHJlbmRlcmApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByZXZUcmVlID0gaW5zdGFuY2Uuc3ViVHJlZTtcbiAgICAgICAgaW5zdGFuY2Uuc3ViVHJlZSA9IG5leHRUcmVlO1xuICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgIHN0YXJ0TWVhc3VyZShpbnN0YW5jZSwgYHBhdGNoYCk7XG4gICAgICAgIH1cbiAgICAgICAgcGF0Y2goXG4gICAgICAgICAgcHJldlRyZWUsXG4gICAgICAgICAgbmV4dFRyZWUsXG4gICAgICAgICAgLy8gcGFyZW50IG1heSBoYXZlIGNoYW5nZWQgaWYgaXQncyBpbiBhIHRlbGVwb3J0XG4gICAgICAgICAgaG9zdFBhcmVudE5vZGUocHJldlRyZWUuZWwpLFxuICAgICAgICAgIC8vIGFuY2hvciBtYXkgaGF2ZSBjaGFuZ2VkIGlmIGl0J3MgaW4gYSBmcmFnbWVudFxuICAgICAgICAgIGdldE5leHRIb3N0Tm9kZShwcmV2VHJlZSksXG4gICAgICAgICAgaW5zdGFuY2UsXG4gICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgaXNTVkdcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICBlbmRNZWFzdXJlKGluc3RhbmNlLCBgcGF0Y2hgKTtcbiAgICAgICAgfVxuICAgICAgICBuZXh0LmVsID0gbmV4dFRyZWUuZWw7XG4gICAgICAgIGlmIChvcmlnaW5OZXh0ID09PSBudWxsKSB7XG4gICAgICAgICAgdXBkYXRlSE9DSG9zdEVsKGluc3RhbmNlLCBuZXh0VHJlZS5lbCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHUpIHtcbiAgICAgICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QodSwgcGFyZW50U3VzcGVuc2UpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2bm9kZUhvb2sgPSBuZXh0LnByb3BzICYmIG5leHQucHJvcHMub25Wbm9kZVVwZGF0ZWQpIHtcbiAgICAgICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QoXG4gICAgICAgICAgICAoKSA9PiBpbnZva2VWTm9kZUhvb2sodm5vZGVIb29rLCBwYXJlbnQsIG5leHQsIHZub2RlKSxcbiAgICAgICAgICAgIHBhcmVudFN1c3BlbnNlXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcbiAgICAgICAgICBkZXZ0b29sc0NvbXBvbmVudFVwZGF0ZWQoaW5zdGFuY2UpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgcG9wV2FybmluZ0NvbnRleHQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgZWZmZWN0ID0gaW5zdGFuY2UuZWZmZWN0ID0gbmV3IFJlYWN0aXZlRWZmZWN0KFxuICAgICAgY29tcG9uZW50VXBkYXRlRm4sXG4gICAgICAoKSA9PiBxdWV1ZUpvYih1cGRhdGUpLFxuICAgICAgaW5zdGFuY2Uuc2NvcGVcbiAgICAgIC8vIHRyYWNrIGl0IGluIGNvbXBvbmVudCdzIGVmZmVjdCBzY29wZVxuICAgICk7XG4gICAgY29uc3QgdXBkYXRlID0gaW5zdGFuY2UudXBkYXRlID0gKCkgPT4gZWZmZWN0LnJ1bigpO1xuICAgIHVwZGF0ZS5pZCA9IGluc3RhbmNlLnVpZDtcbiAgICB0b2dnbGVSZWN1cnNlKGluc3RhbmNlLCB0cnVlKTtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgZWZmZWN0Lm9uVHJhY2sgPSBpbnN0YW5jZS5ydGMgPyAoZSkgPT4gaW52b2tlQXJyYXlGbnMoaW5zdGFuY2UucnRjLCBlKSA6IHZvaWQgMDtcbiAgICAgIGVmZmVjdC5vblRyaWdnZXIgPSBpbnN0YW5jZS5ydGcgPyAoZSkgPT4gaW52b2tlQXJyYXlGbnMoaW5zdGFuY2UucnRnLCBlKSA6IHZvaWQgMDtcbiAgICAgIHVwZGF0ZS5vd25lckluc3RhbmNlID0gaW5zdGFuY2U7XG4gICAgfVxuICAgIHVwZGF0ZSgpO1xuICB9O1xuICBjb25zdCB1cGRhdGVDb21wb25lbnRQcmVSZW5kZXIgPSAoaW5zdGFuY2UsIG5leHRWTm9kZSwgb3B0aW1pemVkKSA9PiB7XG4gICAgbmV4dFZOb2RlLmNvbXBvbmVudCA9IGluc3RhbmNlO1xuICAgIGNvbnN0IHByZXZQcm9wcyA9IGluc3RhbmNlLnZub2RlLnByb3BzO1xuICAgIGluc3RhbmNlLnZub2RlID0gbmV4dFZOb2RlO1xuICAgIGluc3RhbmNlLm5leHQgPSBudWxsO1xuICAgIHVwZGF0ZVByb3BzKGluc3RhbmNlLCBuZXh0Vk5vZGUucHJvcHMsIHByZXZQcm9wcywgb3B0aW1pemVkKTtcbiAgICB1cGRhdGVTbG90cyhpbnN0YW5jZSwgbmV4dFZOb2RlLmNoaWxkcmVuLCBvcHRpbWl6ZWQpO1xuICAgIHBhdXNlVHJhY2tpbmcoKTtcbiAgICBmbHVzaFByZUZsdXNoQ2JzKCk7XG4gICAgcmVzZXRUcmFja2luZygpO1xuICB9O1xuICBjb25zdCBwYXRjaENoaWxkcmVuID0gKG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCA9IGZhbHNlKSA9PiB7XG4gICAgY29uc3QgYzEgPSBuMSAmJiBuMS5jaGlsZHJlbjtcbiAgICBjb25zdCBwcmV2U2hhcGVGbGFnID0gbjEgPyBuMS5zaGFwZUZsYWcgOiAwO1xuICAgIGNvbnN0IGMyID0gbjIuY2hpbGRyZW47XG4gICAgY29uc3QgeyBwYXRjaEZsYWcsIHNoYXBlRmxhZyB9ID0gbjI7XG4gICAgaWYgKHBhdGNoRmxhZyA+IDApIHtcbiAgICAgIGlmIChwYXRjaEZsYWcgJiAxMjgpIHtcbiAgICAgICAgcGF0Y2hLZXllZENoaWxkcmVuKFxuICAgICAgICAgIGMxLFxuICAgICAgICAgIGMyLFxuICAgICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgICBhbmNob3IsXG4gICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgIGlzU1ZHLFxuICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIGlmIChwYXRjaEZsYWcgJiAyNTYpIHtcbiAgICAgICAgcGF0Y2hVbmtleWVkQ2hpbGRyZW4oXG4gICAgICAgICAgYzEsXG4gICAgICAgICAgYzIsXG4gICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgIGFuY2hvcixcbiAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgaXNTVkcsXG4gICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgIG9wdGltaXplZFxuICAgICAgICApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChzaGFwZUZsYWcgJiA4KSB7XG4gICAgICBpZiAocHJldlNoYXBlRmxhZyAmIDE2KSB7XG4gICAgICAgIHVubW91bnRDaGlsZHJlbihjMSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSk7XG4gICAgICB9XG4gICAgICBpZiAoYzIgIT09IGMxKSB7XG4gICAgICAgIGhvc3RTZXRFbGVtZW50VGV4dChjb250YWluZXIsIGMyKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHByZXZTaGFwZUZsYWcgJiAxNikge1xuICAgICAgICBpZiAoc2hhcGVGbGFnICYgMTYpIHtcbiAgICAgICAgICBwYXRjaEtleWVkQ2hpbGRyZW4oXG4gICAgICAgICAgICBjMSxcbiAgICAgICAgICAgIGMyLFxuICAgICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgICAgYW5jaG9yLFxuICAgICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgICBpc1NWRyxcbiAgICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICAgIG9wdGltaXplZFxuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdW5tb3VudENoaWxkcmVuKGMxLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHByZXZTaGFwZUZsYWcgJiA4KSB7XG4gICAgICAgICAgaG9zdFNldEVsZW1lbnRUZXh0KGNvbnRhaW5lciwgXCJcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNoYXBlRmxhZyAmIDE2KSB7XG4gICAgICAgICAgbW91bnRDaGlsZHJlbihcbiAgICAgICAgICAgIGMyLFxuICAgICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgICAgYW5jaG9yLFxuICAgICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgICBpc1NWRyxcbiAgICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICAgIG9wdGltaXplZFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIGNvbnN0IHBhdGNoVW5rZXllZENoaWxkcmVuID0gKGMxLCBjMiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCkgPT4ge1xuICAgIGMxID0gYzEgfHwgRU1QVFlfQVJSO1xuICAgIGMyID0gYzIgfHwgRU1QVFlfQVJSO1xuICAgIGNvbnN0IG9sZExlbmd0aCA9IGMxLmxlbmd0aDtcbiAgICBjb25zdCBuZXdMZW5ndGggPSBjMi5sZW5ndGg7XG4gICAgY29uc3QgY29tbW9uTGVuZ3RoID0gTWF0aC5taW4ob2xkTGVuZ3RoLCBuZXdMZW5ndGgpO1xuICAgIGxldCBpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBjb21tb25MZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgbmV4dENoaWxkID0gYzJbaV0gPSBvcHRpbWl6ZWQgPyBjbG9uZUlmTW91bnRlZChjMltpXSkgOiBub3JtYWxpemVWTm9kZShjMltpXSk7XG4gICAgICBwYXRjaChcbiAgICAgICAgYzFbaV0sXG4gICAgICAgIG5leHRDaGlsZCxcbiAgICAgICAgY29udGFpbmVyLFxuICAgICAgICBudWxsLFxuICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICBpc1NWRyxcbiAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChvbGRMZW5ndGggPiBuZXdMZW5ndGgpIHtcbiAgICAgIHVubW91bnRDaGlsZHJlbihcbiAgICAgICAgYzEsXG4gICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgIHRydWUsXG4gICAgICAgIGZhbHNlLFxuICAgICAgICBjb21tb25MZW5ndGhcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1vdW50Q2hpbGRyZW4oXG4gICAgICAgIGMyLFxuICAgICAgICBjb250YWluZXIsXG4gICAgICAgIGFuY2hvcixcbiAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgaXNTVkcsXG4gICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgb3B0aW1pemVkLFxuICAgICAgICBjb21tb25MZW5ndGhcbiAgICAgICk7XG4gICAgfVxuICB9O1xuICBjb25zdCBwYXRjaEtleWVkQ2hpbGRyZW4gPSAoYzEsIGMyLCBjb250YWluZXIsIHBhcmVudEFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKSA9PiB7XG4gICAgbGV0IGkgPSAwO1xuICAgIGNvbnN0IGwyID0gYzIubGVuZ3RoO1xuICAgIGxldCBlMSA9IGMxLmxlbmd0aCAtIDE7XG4gICAgbGV0IGUyID0gbDIgLSAxO1xuICAgIHdoaWxlIChpIDw9IGUxICYmIGkgPD0gZTIpIHtcbiAgICAgIGNvbnN0IG4xID0gYzFbaV07XG4gICAgICBjb25zdCBuMiA9IGMyW2ldID0gb3B0aW1pemVkID8gY2xvbmVJZk1vdW50ZWQoYzJbaV0pIDogbm9ybWFsaXplVk5vZGUoYzJbaV0pO1xuICAgICAgaWYgKGlzU2FtZVZOb2RlVHlwZShuMSwgbjIpKSB7XG4gICAgICAgIHBhdGNoKFxuICAgICAgICAgIG4xLFxuICAgICAgICAgIG4yLFxuICAgICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgICBudWxsLFxuICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICBpc1NWRyxcbiAgICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgICAgb3B0aW1pemVkXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGkrKztcbiAgICB9XG4gICAgd2hpbGUgKGkgPD0gZTEgJiYgaSA8PSBlMikge1xuICAgICAgY29uc3QgbjEgPSBjMVtlMV07XG4gICAgICBjb25zdCBuMiA9IGMyW2UyXSA9IG9wdGltaXplZCA/IGNsb25lSWZNb3VudGVkKGMyW2UyXSkgOiBub3JtYWxpemVWTm9kZShjMltlMl0pO1xuICAgICAgaWYgKGlzU2FtZVZOb2RlVHlwZShuMSwgbjIpKSB7XG4gICAgICAgIHBhdGNoKFxuICAgICAgICAgIG4xLFxuICAgICAgICAgIG4yLFxuICAgICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgICBudWxsLFxuICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICBpc1NWRyxcbiAgICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgICAgb3B0aW1pemVkXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGUxLS07XG4gICAgICBlMi0tO1xuICAgIH1cbiAgICBpZiAoaSA+IGUxKSB7XG4gICAgICBpZiAoaSA8PSBlMikge1xuICAgICAgICBjb25zdCBuZXh0UG9zID0gZTIgKyAxO1xuICAgICAgICBjb25zdCBhbmNob3IgPSBuZXh0UG9zIDwgbDIgPyBjMltuZXh0UG9zXS5lbCA6IHBhcmVudEFuY2hvcjtcbiAgICAgICAgd2hpbGUgKGkgPD0gZTIpIHtcbiAgICAgICAgICBwYXRjaChcbiAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICBjMltpXSA9IG9wdGltaXplZCA/IGNsb25lSWZNb3VudGVkKGMyW2ldKSA6IG5vcm1hbGl6ZVZOb2RlKGMyW2ldKSxcbiAgICAgICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgICAgIGFuY2hvcixcbiAgICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgICAgaXNTVkcsXG4gICAgICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICAgICApO1xuICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaSA+IGUyKSB7XG4gICAgICB3aGlsZSAoaSA8PSBlMSkge1xuICAgICAgICB1bm1vdW50KGMxW2ldLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCB0cnVlKTtcbiAgICAgICAgaSsrO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBzMSA9IGk7XG4gICAgICBjb25zdCBzMiA9IGk7XG4gICAgICBjb25zdCBrZXlUb05ld0luZGV4TWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICAgIGZvciAoaSA9IHMyOyBpIDw9IGUyOyBpKyspIHtcbiAgICAgICAgY29uc3QgbmV4dENoaWxkID0gYzJbaV0gPSBvcHRpbWl6ZWQgPyBjbG9uZUlmTW91bnRlZChjMltpXSkgOiBub3JtYWxpemVWTm9kZShjMltpXSk7XG4gICAgICAgIGlmIChuZXh0Q2hpbGQua2V5ICE9IG51bGwpIHtcbiAgICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBrZXlUb05ld0luZGV4TWFwLmhhcyhuZXh0Q2hpbGQua2V5KSkge1xuICAgICAgICAgICAgd2FybihcbiAgICAgICAgICAgICAgYER1cGxpY2F0ZSBrZXlzIGZvdW5kIGR1cmluZyB1cGRhdGU6YCxcbiAgICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkobmV4dENoaWxkLmtleSksXG4gICAgICAgICAgICAgIGBNYWtlIHN1cmUga2V5cyBhcmUgdW5pcXVlLmBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGtleVRvTmV3SW5kZXhNYXAuc2V0KG5leHRDaGlsZC5rZXksIGkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBsZXQgajtcbiAgICAgIGxldCBwYXRjaGVkID0gMDtcbiAgICAgIGNvbnN0IHRvQmVQYXRjaGVkID0gZTIgLSBzMiArIDE7XG4gICAgICBsZXQgbW92ZWQgPSBmYWxzZTtcbiAgICAgIGxldCBtYXhOZXdJbmRleFNvRmFyID0gMDtcbiAgICAgIGNvbnN0IG5ld0luZGV4VG9PbGRJbmRleE1hcCA9IG5ldyBBcnJheSh0b0JlUGF0Y2hlZCk7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgdG9CZVBhdGNoZWQ7IGkrKylcbiAgICAgICAgbmV3SW5kZXhUb09sZEluZGV4TWFwW2ldID0gMDtcbiAgICAgIGZvciAoaSA9IHMxOyBpIDw9IGUxOyBpKyspIHtcbiAgICAgICAgY29uc3QgcHJldkNoaWxkID0gYzFbaV07XG4gICAgICAgIGlmIChwYXRjaGVkID49IHRvQmVQYXRjaGVkKSB7XG4gICAgICAgICAgdW5tb3VudChwcmV2Q2hpbGQsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHRydWUpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBuZXdJbmRleDtcbiAgICAgICAgaWYgKHByZXZDaGlsZC5rZXkgIT0gbnVsbCkge1xuICAgICAgICAgIG5ld0luZGV4ID0ga2V5VG9OZXdJbmRleE1hcC5nZXQocHJldkNoaWxkLmtleSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZm9yIChqID0gczI7IGogPD0gZTI7IGorKykge1xuICAgICAgICAgICAgaWYgKG5ld0luZGV4VG9PbGRJbmRleE1hcFtqIC0gczJdID09PSAwICYmIGlzU2FtZVZOb2RlVHlwZShwcmV2Q2hpbGQsIGMyW2pdKSkge1xuICAgICAgICAgICAgICBuZXdJbmRleCA9IGo7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobmV3SW5kZXggPT09IHZvaWQgMCkge1xuICAgICAgICAgIHVubW91bnQocHJldkNoaWxkLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCB0cnVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXdJbmRleFRvT2xkSW5kZXhNYXBbbmV3SW5kZXggLSBzMl0gPSBpICsgMTtcbiAgICAgICAgICBpZiAobmV3SW5kZXggPj0gbWF4TmV3SW5kZXhTb0Zhcikge1xuICAgICAgICAgICAgbWF4TmV3SW5kZXhTb0ZhciA9IG5ld0luZGV4O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtb3ZlZCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHBhdGNoKFxuICAgICAgICAgICAgcHJldkNoaWxkLFxuICAgICAgICAgICAgYzJbbmV3SW5kZXhdLFxuICAgICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgICAgaXNTVkcsXG4gICAgICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICAgICApO1xuICAgICAgICAgIHBhdGNoZWQrKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgaW5jcmVhc2luZ05ld0luZGV4U2VxdWVuY2UgPSBtb3ZlZCA/IGdldFNlcXVlbmNlKG5ld0luZGV4VG9PbGRJbmRleE1hcCkgOiBFTVBUWV9BUlI7XG4gICAgICBqID0gaW5jcmVhc2luZ05ld0luZGV4U2VxdWVuY2UubGVuZ3RoIC0gMTtcbiAgICAgIGZvciAoaSA9IHRvQmVQYXRjaGVkIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgY29uc3QgbmV4dEluZGV4ID0gczIgKyBpO1xuICAgICAgICBjb25zdCBuZXh0Q2hpbGQgPSBjMltuZXh0SW5kZXhdO1xuICAgICAgICBjb25zdCBhbmNob3IgPSBuZXh0SW5kZXggKyAxIDwgbDIgPyBjMltuZXh0SW5kZXggKyAxXS5lbCA6IHBhcmVudEFuY2hvcjtcbiAgICAgICAgaWYgKG5ld0luZGV4VG9PbGRJbmRleE1hcFtpXSA9PT0gMCkge1xuICAgICAgICAgIHBhdGNoKFxuICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgIG5leHRDaGlsZCxcbiAgICAgICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgICAgIGFuY2hvcixcbiAgICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgICAgaXNTVkcsXG4gICAgICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2UgaWYgKG1vdmVkKSB7XG4gICAgICAgICAgaWYgKGogPCAwIHx8IGkgIT09IGluY3JlYXNpbmdOZXdJbmRleFNlcXVlbmNlW2pdKSB7XG4gICAgICAgICAgICBtb3ZlKG5leHRDaGlsZCwgY29udGFpbmVyLCBhbmNob3IsIDIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBqLS07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBjb25zdCBtb3ZlID0gKHZub2RlLCBjb250YWluZXIsIGFuY2hvciwgbW92ZVR5cGUsIHBhcmVudFN1c3BlbnNlID0gbnVsbCkgPT4ge1xuICAgIGNvbnN0IHsgZWwsIHR5cGUsIHRyYW5zaXRpb24sIGNoaWxkcmVuLCBzaGFwZUZsYWcgfSA9IHZub2RlO1xuICAgIGlmIChzaGFwZUZsYWcgJiA2KSB7XG4gICAgICBtb3ZlKHZub2RlLmNvbXBvbmVudC5zdWJUcmVlLCBjb250YWluZXIsIGFuY2hvciwgbW92ZVR5cGUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoc2hhcGVGbGFnICYgMTI4KSB7XG4gICAgICB2bm9kZS5zdXNwZW5zZS5tb3ZlKGNvbnRhaW5lciwgYW5jaG9yLCBtb3ZlVHlwZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChzaGFwZUZsYWcgJiA2NCkge1xuICAgICAgdHlwZS5tb3ZlKHZub2RlLCBjb250YWluZXIsIGFuY2hvciwgaW50ZXJuYWxzKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHR5cGUgPT09IEZyYWdtZW50KSB7XG4gICAgICBob3N0SW5zZXJ0KGVsLCBjb250YWluZXIsIGFuY2hvcik7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG1vdmUoY2hpbGRyZW5baV0sIGNvbnRhaW5lciwgYW5jaG9yLCBtb3ZlVHlwZSk7XG4gICAgICB9XG4gICAgICBob3N0SW5zZXJ0KHZub2RlLmFuY2hvciwgY29udGFpbmVyLCBhbmNob3IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodHlwZSA9PT0gU3RhdGljKSB7XG4gICAgICBtb3ZlU3RhdGljTm9kZSh2bm9kZSwgY29udGFpbmVyLCBhbmNob3IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBuZWVkVHJhbnNpdGlvbiA9IG1vdmVUeXBlICE9PSAyICYmIHNoYXBlRmxhZyAmIDEgJiYgdHJhbnNpdGlvbjtcbiAgICBpZiAobmVlZFRyYW5zaXRpb24pIHtcbiAgICAgIGlmIChtb3ZlVHlwZSA9PT0gMCkge1xuICAgICAgICB0cmFuc2l0aW9uLmJlZm9yZUVudGVyKGVsKTtcbiAgICAgICAgaG9zdEluc2VydChlbCwgY29udGFpbmVyLCBhbmNob3IpO1xuICAgICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QoKCkgPT4gdHJhbnNpdGlvbi5lbnRlcihlbCksIHBhcmVudFN1c3BlbnNlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHsgbGVhdmUsIGRlbGF5TGVhdmUsIGFmdGVyTGVhdmUgfSA9IHRyYW5zaXRpb247XG4gICAgICAgIGNvbnN0IHJlbW92ZTIgPSAoKSA9PiBob3N0SW5zZXJ0KGVsLCBjb250YWluZXIsIGFuY2hvcik7XG4gICAgICAgIGNvbnN0IHBlcmZvcm1MZWF2ZSA9ICgpID0+IHtcbiAgICAgICAgICBsZWF2ZShlbCwgKCkgPT4ge1xuICAgICAgICAgICAgcmVtb3ZlMigpO1xuICAgICAgICAgICAgYWZ0ZXJMZWF2ZSAmJiBhZnRlckxlYXZlKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIGlmIChkZWxheUxlYXZlKSB7XG4gICAgICAgICAgZGVsYXlMZWF2ZShlbCwgcmVtb3ZlMiwgcGVyZm9ybUxlYXZlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwZXJmb3JtTGVhdmUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBob3N0SW5zZXJ0KGVsLCBjb250YWluZXIsIGFuY2hvcik7XG4gICAgfVxuICB9O1xuICBjb25zdCB1bm1vdW50ID0gKHZub2RlLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBkb1JlbW92ZSA9IGZhbHNlLCBvcHRpbWl6ZWQgPSBmYWxzZSkgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIHR5cGUsXG4gICAgICBwcm9wcyxcbiAgICAgIHJlZixcbiAgICAgIGNoaWxkcmVuLFxuICAgICAgZHluYW1pY0NoaWxkcmVuLFxuICAgICAgc2hhcGVGbGFnLFxuICAgICAgcGF0Y2hGbGFnLFxuICAgICAgZGlyc1xuICAgIH0gPSB2bm9kZTtcbiAgICBpZiAocmVmICE9IG51bGwpIHtcbiAgICAgIHNldFJlZihyZWYsIG51bGwsIHBhcmVudFN1c3BlbnNlLCB2bm9kZSwgdHJ1ZSk7XG4gICAgfVxuICAgIGlmIChzaGFwZUZsYWcgJiAyNTYpIHtcbiAgICAgIHBhcmVudENvbXBvbmVudC5jdHguZGVhY3RpdmF0ZSh2bm9kZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHNob3VsZEludm9rZURpcnMgPSBzaGFwZUZsYWcgJiAxICYmIGRpcnM7XG4gICAgY29uc3Qgc2hvdWxkSW52b2tlVm5vZGVIb29rID0gIWlzQXN5bmNXcmFwcGVyKHZub2RlKTtcbiAgICBsZXQgdm5vZGVIb29rO1xuICAgIGlmIChzaG91bGRJbnZva2VWbm9kZUhvb2sgJiYgKHZub2RlSG9vayA9IHByb3BzICYmIHByb3BzLm9uVm5vZGVCZWZvcmVVbm1vdW50KSkge1xuICAgICAgaW52b2tlVk5vZGVIb29rKHZub2RlSG9vaywgcGFyZW50Q29tcG9uZW50LCB2bm9kZSk7XG4gICAgfVxuICAgIGlmIChzaGFwZUZsYWcgJiA2KSB7XG4gICAgICB1bm1vdW50Q29tcG9uZW50KHZub2RlLmNvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGRvUmVtb3ZlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHNoYXBlRmxhZyAmIDEyOCkge1xuICAgICAgICB2bm9kZS5zdXNwZW5zZS51bm1vdW50KHBhcmVudFN1c3BlbnNlLCBkb1JlbW92ZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChzaG91bGRJbnZva2VEaXJzKSB7XG4gICAgICAgIGludm9rZURpcmVjdGl2ZUhvb2sodm5vZGUsIG51bGwsIHBhcmVudENvbXBvbmVudCwgXCJiZWZvcmVVbm1vdW50XCIpO1xuICAgICAgfVxuICAgICAgaWYgKHNoYXBlRmxhZyAmIDY0KSB7XG4gICAgICAgIHZub2RlLnR5cGUucmVtb3ZlKFxuICAgICAgICAgIHZub2RlLFxuICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICBvcHRpbWl6ZWQsXG4gICAgICAgICAgaW50ZXJuYWxzLFxuICAgICAgICAgIGRvUmVtb3ZlXG4gICAgICAgICk7XG4gICAgICB9IGVsc2UgaWYgKGR5bmFtaWNDaGlsZHJlbiAmJiAvLyAjMTE1MzogZmFzdCBwYXRoIHNob3VsZCBub3QgYmUgdGFrZW4gZm9yIG5vbi1zdGFibGUgKHYtZm9yKSBmcmFnbWVudHNcbiAgICAgICh0eXBlICE9PSBGcmFnbWVudCB8fCBwYXRjaEZsYWcgPiAwICYmIHBhdGNoRmxhZyAmIDY0KSkge1xuICAgICAgICB1bm1vdW50Q2hpbGRyZW4oXG4gICAgICAgICAgZHluYW1pY0NoaWxkcmVuLFxuICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICB0cnVlXG4gICAgICAgICk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IEZyYWdtZW50ICYmIHBhdGNoRmxhZyAmICgxMjggfCAyNTYpIHx8ICFvcHRpbWl6ZWQgJiYgc2hhcGVGbGFnICYgMTYpIHtcbiAgICAgICAgdW5tb3VudENoaWxkcmVuKGNoaWxkcmVuLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlKTtcbiAgICAgIH1cbiAgICAgIGlmIChkb1JlbW92ZSkge1xuICAgICAgICByZW1vdmUodm5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoc2hvdWxkSW52b2tlVm5vZGVIb29rICYmICh2bm9kZUhvb2sgPSBwcm9wcyAmJiBwcm9wcy5vblZub2RlVW5tb3VudGVkKSB8fCBzaG91bGRJbnZva2VEaXJzKSB7XG4gICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QoKCkgPT4ge1xuICAgICAgICB2bm9kZUhvb2sgJiYgaW52b2tlVk5vZGVIb29rKHZub2RlSG9vaywgcGFyZW50Q29tcG9uZW50LCB2bm9kZSk7XG4gICAgICAgIHNob3VsZEludm9rZURpcnMgJiYgaW52b2tlRGlyZWN0aXZlSG9vayh2bm9kZSwgbnVsbCwgcGFyZW50Q29tcG9uZW50LCBcInVubW91bnRlZFwiKTtcbiAgICAgIH0sIHBhcmVudFN1c3BlbnNlKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHJlbW92ZSA9ICh2bm9kZSkgPT4ge1xuICAgIGNvbnN0IHsgdHlwZSwgZWwsIGFuY2hvciwgdHJhbnNpdGlvbiB9ID0gdm5vZGU7XG4gICAgaWYgKHR5cGUgPT09IEZyYWdtZW50KSB7XG4gICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiB2bm9kZS5wYXRjaEZsYWcgPiAwICYmIHZub2RlLnBhdGNoRmxhZyAmIDIwNDggJiYgdHJhbnNpdGlvbiAmJiAhdHJhbnNpdGlvbi5wZXJzaXN0ZWQpIHtcbiAgICAgICAgdm5vZGUuY2hpbGRyZW4uZm9yRWFjaCgoY2hpbGQpID0+IHtcbiAgICAgICAgICBpZiAoY2hpbGQudHlwZSA9PT0gQ29tbWVudCkge1xuICAgICAgICAgICAgaG9zdFJlbW92ZShjaGlsZC5lbCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlbW92ZShjaGlsZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlbW92ZUZyYWdtZW50KGVsLCBhbmNob3IpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodHlwZSA9PT0gU3RhdGljKSB7XG4gICAgICByZW1vdmVTdGF0aWNOb2RlKHZub2RlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgcGVyZm9ybVJlbW92ZSA9ICgpID0+IHtcbiAgICAgIGhvc3RSZW1vdmUoZWwpO1xuICAgICAgaWYgKHRyYW5zaXRpb24gJiYgIXRyYW5zaXRpb24ucGVyc2lzdGVkICYmIHRyYW5zaXRpb24uYWZ0ZXJMZWF2ZSkge1xuICAgICAgICB0cmFuc2l0aW9uLmFmdGVyTGVhdmUoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGlmICh2bm9kZS5zaGFwZUZsYWcgJiAxICYmIHRyYW5zaXRpb24gJiYgIXRyYW5zaXRpb24ucGVyc2lzdGVkKSB7XG4gICAgICBjb25zdCB7IGxlYXZlLCBkZWxheUxlYXZlIH0gPSB0cmFuc2l0aW9uO1xuICAgICAgY29uc3QgcGVyZm9ybUxlYXZlID0gKCkgPT4gbGVhdmUoZWwsIHBlcmZvcm1SZW1vdmUpO1xuICAgICAgaWYgKGRlbGF5TGVhdmUpIHtcbiAgICAgICAgZGVsYXlMZWF2ZSh2bm9kZS5lbCwgcGVyZm9ybVJlbW92ZSwgcGVyZm9ybUxlYXZlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBlcmZvcm1MZWF2ZSgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwZXJmb3JtUmVtb3ZlKCk7XG4gICAgfVxuICB9O1xuICBjb25zdCByZW1vdmVGcmFnbWVudCA9IChjdXIsIGVuZCkgPT4ge1xuICAgIGxldCBuZXh0O1xuICAgIHdoaWxlIChjdXIgIT09IGVuZCkge1xuICAgICAgbmV4dCA9IGhvc3ROZXh0U2libGluZyhjdXIpO1xuICAgICAgaG9zdFJlbW92ZShjdXIpO1xuICAgICAgY3VyID0gbmV4dDtcbiAgICB9XG4gICAgaG9zdFJlbW92ZShlbmQpO1xuICB9O1xuICBjb25zdCB1bm1vdW50Q29tcG9uZW50ID0gKGluc3RhbmNlLCBwYXJlbnRTdXNwZW5zZSwgZG9SZW1vdmUpID0+IHtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBpbnN0YW5jZS50eXBlLl9faG1ySWQpIHtcbiAgICAgIHVucmVnaXN0ZXJITVIoaW5zdGFuY2UpO1xuICAgIH1cbiAgICBjb25zdCB7IGJ1bSwgc2NvcGUsIHVwZGF0ZSwgc3ViVHJlZSwgdW0gfSA9IGluc3RhbmNlO1xuICAgIGlmIChidW0pIHtcbiAgICAgIGludm9rZUFycmF5Rm5zKGJ1bSk7XG4gICAgfVxuICAgIHNjb3BlLnN0b3AoKTtcbiAgICBpZiAodXBkYXRlKSB7XG4gICAgICB1cGRhdGUuYWN0aXZlID0gZmFsc2U7XG4gICAgICB1bm1vdW50KHN1YlRyZWUsIGluc3RhbmNlLCBwYXJlbnRTdXNwZW5zZSwgZG9SZW1vdmUpO1xuICAgIH1cbiAgICBpZiAodW0pIHtcbiAgICAgIHF1ZXVlUG9zdFJlbmRlckVmZmVjdCh1bSwgcGFyZW50U3VzcGVuc2UpO1xuICAgIH1cbiAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QoKCkgPT4ge1xuICAgICAgaW5zdGFuY2UuaXNVbm1vdW50ZWQgPSB0cnVlO1xuICAgIH0sIHBhcmVudFN1c3BlbnNlKTtcbiAgICBpZiAocGFyZW50U3VzcGVuc2UgJiYgcGFyZW50U3VzcGVuc2UucGVuZGluZ0JyYW5jaCAmJiAhcGFyZW50U3VzcGVuc2UuaXNVbm1vdW50ZWQgJiYgaW5zdGFuY2UuYXN5bmNEZXAgJiYgIWluc3RhbmNlLmFzeW5jUmVzb2x2ZWQgJiYgaW5zdGFuY2Uuc3VzcGVuc2VJZCA9PT0gcGFyZW50U3VzcGVuc2UucGVuZGluZ0lkKSB7XG4gICAgICBwYXJlbnRTdXNwZW5zZS5kZXBzLS07XG4gICAgICBpZiAocGFyZW50U3VzcGVuc2UuZGVwcyA9PT0gMCkge1xuICAgICAgICBwYXJlbnRTdXNwZW5zZS5yZXNvbHZlKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykge1xuICAgICAgZGV2dG9vbHNDb21wb25lbnRSZW1vdmVkKGluc3RhbmNlKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHVubW91bnRDaGlsZHJlbiA9IChjaGlsZHJlbiwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgZG9SZW1vdmUgPSBmYWxzZSwgb3B0aW1pemVkID0gZmFsc2UsIHN0YXJ0ID0gMCkgPT4ge1xuICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICB1bm1vdW50KGNoaWxkcmVuW2ldLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBkb1JlbW92ZSwgb3B0aW1pemVkKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IGdldE5leHRIb3N0Tm9kZSA9ICh2bm9kZSkgPT4ge1xuICAgIGlmICh2bm9kZS5zaGFwZUZsYWcgJiA2KSB7XG4gICAgICByZXR1cm4gZ2V0TmV4dEhvc3ROb2RlKHZub2RlLmNvbXBvbmVudC5zdWJUcmVlKTtcbiAgICB9XG4gICAgaWYgKHZub2RlLnNoYXBlRmxhZyAmIDEyOCkge1xuICAgICAgcmV0dXJuIHZub2RlLnN1c3BlbnNlLm5leHQoKTtcbiAgICB9XG4gICAgcmV0dXJuIGhvc3ROZXh0U2libGluZyh2bm9kZS5hbmNob3IgfHwgdm5vZGUuZWwpO1xuICB9O1xuICBjb25zdCByZW5kZXIgPSAodm5vZGUsIGNvbnRhaW5lciwgaXNTVkcpID0+IHtcbiAgICBpZiAodm5vZGUgPT0gbnVsbCkge1xuICAgICAgaWYgKGNvbnRhaW5lci5fdm5vZGUpIHtcbiAgICAgICAgdW5tb3VudChjb250YWluZXIuX3Zub2RlLCBudWxsLCBudWxsLCB0cnVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcGF0Y2goY29udGFpbmVyLl92bm9kZSB8fCBudWxsLCB2bm9kZSwgY29udGFpbmVyLCBudWxsLCBudWxsLCBudWxsLCBpc1NWRyk7XG4gICAgfVxuICAgIGZsdXNoUHJlRmx1c2hDYnMoKTtcbiAgICBmbHVzaFBvc3RGbHVzaENicygpO1xuICAgIGNvbnRhaW5lci5fdm5vZGUgPSB2bm9kZTtcbiAgfTtcbiAgY29uc3QgaW50ZXJuYWxzID0ge1xuICAgIHA6IHBhdGNoLFxuICAgIHVtOiB1bm1vdW50LFxuICAgIG06IG1vdmUsXG4gICAgcjogcmVtb3ZlLFxuICAgIG10OiBtb3VudENvbXBvbmVudCxcbiAgICBtYzogbW91bnRDaGlsZHJlbixcbiAgICBwYzogcGF0Y2hDaGlsZHJlbixcbiAgICBwYmM6IHBhdGNoQmxvY2tDaGlsZHJlbixcbiAgICBuOiBnZXROZXh0SG9zdE5vZGUsXG4gICAgbzogb3B0aW9uc1xuICB9O1xuICBsZXQgaHlkcmF0ZTtcbiAgbGV0IGh5ZHJhdGVOb2RlO1xuICBpZiAoY3JlYXRlSHlkcmF0aW9uRm5zKSB7XG4gICAgW2h5ZHJhdGUsIGh5ZHJhdGVOb2RlXSA9IGNyZWF0ZUh5ZHJhdGlvbkZucyhcbiAgICAgIGludGVybmFsc1xuICAgICk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICByZW5kZXIsXG4gICAgaHlkcmF0ZSxcbiAgICBjcmVhdGVBcHA6IGNyZWF0ZUFwcEFQSShyZW5kZXIsIGh5ZHJhdGUpXG4gIH07XG59XG5mdW5jdGlvbiB0b2dnbGVSZWN1cnNlKHsgZWZmZWN0LCB1cGRhdGUgfSwgYWxsb3dlZCkge1xuICBlZmZlY3QuYWxsb3dSZWN1cnNlID0gdXBkYXRlLmFsbG93UmVjdXJzZSA9IGFsbG93ZWQ7XG59XG5mdW5jdGlvbiB0cmF2ZXJzZVN0YXRpY0NoaWxkcmVuKG4xLCBuMiwgc2hhbGxvdyA9IGZhbHNlKSB7XG4gIGNvbnN0IGNoMSA9IG4xLmNoaWxkcmVuO1xuICBjb25zdCBjaDIgPSBuMi5jaGlsZHJlbjtcbiAgaWYgKGlzQXJyYXkoY2gxKSAmJiBpc0FycmF5KGNoMikpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoMS5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgYzEgPSBjaDFbaV07XG4gICAgICBsZXQgYzIgPSBjaDJbaV07XG4gICAgICBpZiAoYzIuc2hhcGVGbGFnICYgMSAmJiAhYzIuZHluYW1pY0NoaWxkcmVuKSB7XG4gICAgICAgIGlmIChjMi5wYXRjaEZsYWcgPD0gMCB8fCBjMi5wYXRjaEZsYWcgPT09IDMyKSB7XG4gICAgICAgICAgYzIgPSBjaDJbaV0gPSBjbG9uZUlmTW91bnRlZChjaDJbaV0pO1xuICAgICAgICAgIGMyLmVsID0gYzEuZWw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFzaGFsbG93KVxuICAgICAgICAgIHRyYXZlcnNlU3RhdGljQ2hpbGRyZW4oYzEsIGMyKTtcbiAgICAgIH1cbiAgICAgIGlmIChjMi50eXBlID09PSBUZXh0KSB7XG4gICAgICAgIGMyLmVsID0gYzEuZWw7XG4gICAgICB9XG4gICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBjMi50eXBlID09PSBDb21tZW50ICYmICFjMi5lbCkge1xuICAgICAgICBjMi5lbCA9IGMxLmVsO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZ2V0U2VxdWVuY2UoYXJyKSB7XG4gIGNvbnN0IHAgPSBhcnIuc2xpY2UoKTtcbiAgY29uc3QgcmVzdWx0ID0gWzBdO1xuICBsZXQgaSwgaiwgdSwgdiwgYztcbiAgY29uc3QgbGVuID0gYXJyLmxlbmd0aDtcbiAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgY29uc3QgYXJySSA9IGFycltpXTtcbiAgICBpZiAoYXJySSAhPT0gMCkge1xuICAgICAgaiA9IHJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gMV07XG4gICAgICBpZiAoYXJyW2pdIDwgYXJySSkge1xuICAgICAgICBwW2ldID0gajtcbiAgICAgICAgcmVzdWx0LnB1c2goaSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdSA9IDA7XG4gICAgICB2ID0gcmVzdWx0Lmxlbmd0aCAtIDE7XG4gICAgICB3aGlsZSAodSA8IHYpIHtcbiAgICAgICAgYyA9IHUgKyB2ID4+IDE7XG4gICAgICAgIGlmIChhcnJbcmVzdWx0W2NdXSA8IGFyckkpIHtcbiAgICAgICAgICB1ID0gYyArIDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdiA9IGM7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChhcnJJIDwgYXJyW3Jlc3VsdFt1XV0pIHtcbiAgICAgICAgaWYgKHUgPiAwKSB7XG4gICAgICAgICAgcFtpXSA9IHJlc3VsdFt1IC0gMV07XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0W3VdID0gaTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgdSA9IHJlc3VsdC5sZW5ndGg7XG4gIHYgPSByZXN1bHRbdSAtIDFdO1xuICB3aGlsZSAodS0tID4gMCkge1xuICAgIHJlc3VsdFt1XSA9IHY7XG4gICAgdiA9IHBbdl07XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuY29uc3QgaXNUZWxlcG9ydCA9ICh0eXBlKSA9PiB0eXBlLl9faXNUZWxlcG9ydDtcbmNvbnN0IGlzVGVsZXBvcnREaXNhYmxlZCA9IChwcm9wcykgPT4gcHJvcHMgJiYgKHByb3BzLmRpc2FibGVkIHx8IHByb3BzLmRpc2FibGVkID09PSBcIlwiKTtcbmNvbnN0IGlzVGFyZ2V0U1ZHID0gKHRhcmdldCkgPT4gdHlwZW9mIFNWR0VsZW1lbnQgIT09IFwidW5kZWZpbmVkXCIgJiYgdGFyZ2V0IGluc3RhbmNlb2YgU1ZHRWxlbWVudDtcbmNvbnN0IHJlc29sdmVUYXJnZXQgPSAocHJvcHMsIHNlbGVjdCkgPT4ge1xuICBjb25zdCB0YXJnZXRTZWxlY3RvciA9IHByb3BzICYmIHByb3BzLnRvO1xuICBpZiAoaXNTdHJpbmcodGFyZ2V0U2VsZWN0b3IpKSB7XG4gICAgaWYgKCFzZWxlY3QpIHtcbiAgICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgd2FybihcbiAgICAgICAgYEN1cnJlbnQgcmVuZGVyZXIgZG9lcyBub3Qgc3VwcG9ydCBzdHJpbmcgdGFyZ2V0IGZvciBUZWxlcG9ydHMuIChtaXNzaW5nIHF1ZXJ5U2VsZWN0b3IgcmVuZGVyZXIgb3B0aW9uKWBcbiAgICAgICk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgdGFyZ2V0ID0gc2VsZWN0KHRhcmdldFNlbGVjdG9yKTtcbiAgICAgIGlmICghdGFyZ2V0KSB7XG4gICAgICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgd2FybihcbiAgICAgICAgICBgRmFpbGVkIHRvIGxvY2F0ZSBUZWxlcG9ydCB0YXJnZXQgd2l0aCBzZWxlY3RvciBcIiR7dGFyZ2V0U2VsZWN0b3J9XCIuIE5vdGUgdGhlIHRhcmdldCBlbGVtZW50IG11c3QgZXhpc3QgYmVmb3JlIHRoZSBjb21wb25lbnQgaXMgbW91bnRlZCAtIGkuZS4gdGhlIHRhcmdldCBjYW5ub3QgYmUgcmVuZGVyZWQgYnkgdGhlIGNvbXBvbmVudCBpdHNlbGYsIGFuZCBpZGVhbGx5IHNob3VsZCBiZSBvdXRzaWRlIG9mIHRoZSBlbnRpcmUgVnVlIGNvbXBvbmVudCB0cmVlLmBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICF0YXJnZXRTZWxlY3RvciAmJiAhaXNUZWxlcG9ydERpc2FibGVkKHByb3BzKSkge1xuICAgICAgd2FybihgSW52YWxpZCBUZWxlcG9ydCB0YXJnZXQ6ICR7dGFyZ2V0U2VsZWN0b3J9YCk7XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXRTZWxlY3RvcjtcbiAgfVxufTtcbmNvbnN0IFRlbGVwb3J0SW1wbCA9IHtcbiAgX19pc1RlbGVwb3J0OiB0cnVlLFxuICBwcm9jZXNzKG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCwgaW50ZXJuYWxzKSB7XG4gICAgY29uc3Qge1xuICAgICAgbWM6IG1vdW50Q2hpbGRyZW4sXG4gICAgICBwYzogcGF0Y2hDaGlsZHJlbixcbiAgICAgIHBiYzogcGF0Y2hCbG9ja0NoaWxkcmVuLFxuICAgICAgbzogeyBpbnNlcnQsIHF1ZXJ5U2VsZWN0b3IsIGNyZWF0ZVRleHQsIGNyZWF0ZUNvbW1lbnQgfVxuICAgIH0gPSBpbnRlcm5hbHM7XG4gICAgY29uc3QgZGlzYWJsZWQgPSBpc1RlbGVwb3J0RGlzYWJsZWQobjIucHJvcHMpO1xuICAgIGxldCB7IHNoYXBlRmxhZywgY2hpbGRyZW4sIGR5bmFtaWNDaGlsZHJlbiB9ID0gbjI7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgaXNIbXJVcGRhdGluZykge1xuICAgICAgb3B0aW1pemVkID0gZmFsc2U7XG4gICAgICBkeW5hbWljQ2hpbGRyZW4gPSBudWxsO1xuICAgIH1cbiAgICBpZiAobjEgPT0gbnVsbCkge1xuICAgICAgY29uc3QgcGxhY2Vob2xkZXIgPSBuMi5lbCA9ICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyBjcmVhdGVDb21tZW50KFwidGVsZXBvcnQgc3RhcnRcIikgOiBjcmVhdGVUZXh0KFwiXCIpO1xuICAgICAgY29uc3QgbWFpbkFuY2hvciA9IG4yLmFuY2hvciA9ICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyBjcmVhdGVDb21tZW50KFwidGVsZXBvcnQgZW5kXCIpIDogY3JlYXRlVGV4dChcIlwiKTtcbiAgICAgIGluc2VydChwbGFjZWhvbGRlciwgY29udGFpbmVyLCBhbmNob3IpO1xuICAgICAgaW5zZXJ0KG1haW5BbmNob3IsIGNvbnRhaW5lciwgYW5jaG9yKTtcbiAgICAgIGNvbnN0IHRhcmdldCA9IG4yLnRhcmdldCA9IHJlc29sdmVUYXJnZXQobjIucHJvcHMsIHF1ZXJ5U2VsZWN0b3IpO1xuICAgICAgY29uc3QgdGFyZ2V0QW5jaG9yID0gbjIudGFyZ2V0QW5jaG9yID0gY3JlYXRlVGV4dChcIlwiKTtcbiAgICAgIGlmICh0YXJnZXQpIHtcbiAgICAgICAgaW5zZXJ0KHRhcmdldEFuY2hvciwgdGFyZ2V0KTtcbiAgICAgICAgaXNTVkcgPSBpc1NWRyB8fCBpc1RhcmdldFNWRyh0YXJnZXQpO1xuICAgICAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICFkaXNhYmxlZCkge1xuICAgICAgICB3YXJuKFwiSW52YWxpZCBUZWxlcG9ydCB0YXJnZXQgb24gbW91bnQ6XCIsIHRhcmdldCwgYCgke3R5cGVvZiB0YXJnZXR9KWApO1xuICAgICAgfVxuICAgICAgY29uc3QgbW91bnQgPSAoY29udGFpbmVyMiwgYW5jaG9yMikgPT4ge1xuICAgICAgICBpZiAoc2hhcGVGbGFnICYgMTYpIHtcbiAgICAgICAgICBtb3VudENoaWxkcmVuKFxuICAgICAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgICAgICBjb250YWluZXIyLFxuICAgICAgICAgICAgYW5jaG9yMixcbiAgICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgICAgaXNTVkcsXG4gICAgICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgaWYgKGRpc2FibGVkKSB7XG4gICAgICAgIG1vdW50KGNvbnRhaW5lciwgbWFpbkFuY2hvcik7XG4gICAgICB9IGVsc2UgaWYgKHRhcmdldCkge1xuICAgICAgICBtb3VudCh0YXJnZXQsIHRhcmdldEFuY2hvcik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG4yLmVsID0gbjEuZWw7XG4gICAgICBjb25zdCBtYWluQW5jaG9yID0gbjIuYW5jaG9yID0gbjEuYW5jaG9yO1xuICAgICAgY29uc3QgdGFyZ2V0ID0gbjIudGFyZ2V0ID0gbjEudGFyZ2V0O1xuICAgICAgY29uc3QgdGFyZ2V0QW5jaG9yID0gbjIudGFyZ2V0QW5jaG9yID0gbjEudGFyZ2V0QW5jaG9yO1xuICAgICAgY29uc3Qgd2FzRGlzYWJsZWQgPSBpc1RlbGVwb3J0RGlzYWJsZWQobjEucHJvcHMpO1xuICAgICAgY29uc3QgY3VycmVudENvbnRhaW5lciA9IHdhc0Rpc2FibGVkID8gY29udGFpbmVyIDogdGFyZ2V0O1xuICAgICAgY29uc3QgY3VycmVudEFuY2hvciA9IHdhc0Rpc2FibGVkID8gbWFpbkFuY2hvciA6IHRhcmdldEFuY2hvcjtcbiAgICAgIGlzU1ZHID0gaXNTVkcgfHwgaXNUYXJnZXRTVkcodGFyZ2V0KTtcbiAgICAgIGlmIChkeW5hbWljQ2hpbGRyZW4pIHtcbiAgICAgICAgcGF0Y2hCbG9ja0NoaWxkcmVuKFxuICAgICAgICAgIG4xLmR5bmFtaWNDaGlsZHJlbixcbiAgICAgICAgICBkeW5hbWljQ2hpbGRyZW4sXG4gICAgICAgICAgY3VycmVudENvbnRhaW5lcixcbiAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgaXNTVkcsXG4gICAgICAgICAgc2xvdFNjb3BlSWRzXG4gICAgICAgICk7XG4gICAgICAgIHRyYXZlcnNlU3RhdGljQ2hpbGRyZW4objEsIG4yLCB0cnVlKTtcbiAgICAgIH0gZWxzZSBpZiAoIW9wdGltaXplZCkge1xuICAgICAgICBwYXRjaENoaWxkcmVuKFxuICAgICAgICAgIG4xLFxuICAgICAgICAgIG4yLFxuICAgICAgICAgIGN1cnJlbnRDb250YWluZXIsXG4gICAgICAgICAgY3VycmVudEFuY2hvcixcbiAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgaXNTVkcsXG4gICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgIGZhbHNlXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAoZGlzYWJsZWQpIHtcbiAgICAgICAgaWYgKCF3YXNEaXNhYmxlZCkge1xuICAgICAgICAgIG1vdmVUZWxlcG9ydChcbiAgICAgICAgICAgIG4yLFxuICAgICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgICAgbWFpbkFuY2hvcixcbiAgICAgICAgICAgIGludGVybmFscyxcbiAgICAgICAgICAgIDFcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoKG4yLnByb3BzICYmIG4yLnByb3BzLnRvKSAhPT0gKG4xLnByb3BzICYmIG4xLnByb3BzLnRvKSkge1xuICAgICAgICAgIGNvbnN0IG5leHRUYXJnZXQgPSBuMi50YXJnZXQgPSByZXNvbHZlVGFyZ2V0KFxuICAgICAgICAgICAgbjIucHJvcHMsXG4gICAgICAgICAgICBxdWVyeVNlbGVjdG9yXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpZiAobmV4dFRhcmdldCkge1xuICAgICAgICAgICAgbW92ZVRlbGVwb3J0KFxuICAgICAgICAgICAgICBuMixcbiAgICAgICAgICAgICAgbmV4dFRhcmdldCxcbiAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgaW50ZXJuYWxzLFxuICAgICAgICAgICAgICAwXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgICAgd2FybihcbiAgICAgICAgICAgICAgXCJJbnZhbGlkIFRlbGVwb3J0IHRhcmdldCBvbiB1cGRhdGU6XCIsXG4gICAgICAgICAgICAgIHRhcmdldCxcbiAgICAgICAgICAgICAgYCgke3R5cGVvZiB0YXJnZXR9KWBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHdhc0Rpc2FibGVkKSB7XG4gICAgICAgICAgbW92ZVRlbGVwb3J0KFxuICAgICAgICAgICAgbjIsXG4gICAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgICB0YXJnZXRBbmNob3IsXG4gICAgICAgICAgICBpbnRlcm5hbHMsXG4gICAgICAgICAgICAxXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB1cGRhdGVDc3NWYXJzKG4yKTtcbiAgfSxcbiAgcmVtb3ZlKHZub2RlLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBvcHRpbWl6ZWQsIHsgdW06IHVubW91bnQsIG86IHsgcmVtb3ZlOiBob3N0UmVtb3ZlIH0gfSwgZG9SZW1vdmUpIHtcbiAgICBjb25zdCB7IHNoYXBlRmxhZywgY2hpbGRyZW4sIGFuY2hvciwgdGFyZ2V0QW5jaG9yLCB0YXJnZXQsIHByb3BzIH0gPSB2bm9kZTtcbiAgICBpZiAodGFyZ2V0KSB7XG4gICAgICBob3N0UmVtb3ZlKHRhcmdldEFuY2hvcik7XG4gICAgfVxuICAgIGlmIChkb1JlbW92ZSB8fCAhaXNUZWxlcG9ydERpc2FibGVkKHByb3BzKSkge1xuICAgICAgaG9zdFJlbW92ZShhbmNob3IpO1xuICAgICAgaWYgKHNoYXBlRmxhZyAmIDE2KSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgICAgIHVubW91bnQoXG4gICAgICAgICAgICBjaGlsZCxcbiAgICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAgICEhY2hpbGQuZHluYW1pY0NoaWxkcmVuXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgbW92ZTogbW92ZVRlbGVwb3J0LFxuICBoeWRyYXRlOiBoeWRyYXRlVGVsZXBvcnRcbn07XG5mdW5jdGlvbiBtb3ZlVGVsZXBvcnQodm5vZGUsIGNvbnRhaW5lciwgcGFyZW50QW5jaG9yLCB7IG86IHsgaW5zZXJ0IH0sIG06IG1vdmUgfSwgbW92ZVR5cGUgPSAyKSB7XG4gIGlmIChtb3ZlVHlwZSA9PT0gMCkge1xuICAgIGluc2VydCh2bm9kZS50YXJnZXRBbmNob3IsIGNvbnRhaW5lciwgcGFyZW50QW5jaG9yKTtcbiAgfVxuICBjb25zdCB7IGVsLCBhbmNob3IsIHNoYXBlRmxhZywgY2hpbGRyZW4sIHByb3BzIH0gPSB2bm9kZTtcbiAgY29uc3QgaXNSZW9yZGVyID0gbW92ZVR5cGUgPT09IDI7XG4gIGlmIChpc1Jlb3JkZXIpIHtcbiAgICBpbnNlcnQoZWwsIGNvbnRhaW5lciwgcGFyZW50QW5jaG9yKTtcbiAgfVxuICBpZiAoIWlzUmVvcmRlciB8fCBpc1RlbGVwb3J0RGlzYWJsZWQocHJvcHMpKSB7XG4gICAgaWYgKHNoYXBlRmxhZyAmIDE2KSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG1vdmUoXG4gICAgICAgICAgY2hpbGRyZW5baV0sXG4gICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgIHBhcmVudEFuY2hvcixcbiAgICAgICAgICAyXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChpc1Jlb3JkZXIpIHtcbiAgICBpbnNlcnQoYW5jaG9yLCBjb250YWluZXIsIHBhcmVudEFuY2hvcik7XG4gIH1cbn1cbmZ1bmN0aW9uIGh5ZHJhdGVUZWxlcG9ydChub2RlLCB2bm9kZSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQsIHtcbiAgbzogeyBuZXh0U2libGluZywgcGFyZW50Tm9kZSwgcXVlcnlTZWxlY3RvciB9XG59LCBoeWRyYXRlQ2hpbGRyZW4pIHtcbiAgY29uc3QgdGFyZ2V0ID0gdm5vZGUudGFyZ2V0ID0gcmVzb2x2ZVRhcmdldChcbiAgICB2bm9kZS5wcm9wcyxcbiAgICBxdWVyeVNlbGVjdG9yXG4gICk7XG4gIGlmICh0YXJnZXQpIHtcbiAgICBjb25zdCB0YXJnZXROb2RlID0gdGFyZ2V0Ll9scGEgfHwgdGFyZ2V0LmZpcnN0Q2hpbGQ7XG4gICAgaWYgKHZub2RlLnNoYXBlRmxhZyAmIDE2KSB7XG4gICAgICBpZiAoaXNUZWxlcG9ydERpc2FibGVkKHZub2RlLnByb3BzKSkge1xuICAgICAgICB2bm9kZS5hbmNob3IgPSBoeWRyYXRlQ2hpbGRyZW4oXG4gICAgICAgICAgbmV4dFNpYmxpbmcobm9kZSksXG4gICAgICAgICAgdm5vZGUsXG4gICAgICAgICAgcGFyZW50Tm9kZShub2RlKSxcbiAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgIG9wdGltaXplZFxuICAgICAgICApO1xuICAgICAgICB2bm9kZS50YXJnZXRBbmNob3IgPSB0YXJnZXROb2RlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdm5vZGUuYW5jaG9yID0gbmV4dFNpYmxpbmcobm9kZSk7XG4gICAgICAgIGxldCB0YXJnZXRBbmNob3IgPSB0YXJnZXROb2RlO1xuICAgICAgICB3aGlsZSAodGFyZ2V0QW5jaG9yKSB7XG4gICAgICAgICAgdGFyZ2V0QW5jaG9yID0gbmV4dFNpYmxpbmcodGFyZ2V0QW5jaG9yKTtcbiAgICAgICAgICBpZiAodGFyZ2V0QW5jaG9yICYmIHRhcmdldEFuY2hvci5ub2RlVHlwZSA9PT0gOCAmJiB0YXJnZXRBbmNob3IuZGF0YSA9PT0gXCJ0ZWxlcG9ydCBhbmNob3JcIikge1xuICAgICAgICAgICAgdm5vZGUudGFyZ2V0QW5jaG9yID0gdGFyZ2V0QW5jaG9yO1xuICAgICAgICAgICAgdGFyZ2V0Ll9scGEgPSB2bm9kZS50YXJnZXRBbmNob3IgJiYgbmV4dFNpYmxpbmcodm5vZGUudGFyZ2V0QW5jaG9yKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBoeWRyYXRlQ2hpbGRyZW4oXG4gICAgICAgICAgdGFyZ2V0Tm9kZSxcbiAgICAgICAgICB2bm9kZSxcbiAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdXBkYXRlQ3NzVmFycyh2bm9kZSk7XG4gIH1cbiAgcmV0dXJuIHZub2RlLmFuY2hvciAmJiBuZXh0U2libGluZyh2bm9kZS5hbmNob3IpO1xufVxuY29uc3QgVGVsZXBvcnQgPSBUZWxlcG9ydEltcGw7XG5mdW5jdGlvbiB1cGRhdGVDc3NWYXJzKHZub2RlKSB7XG4gIGNvbnN0IGN0eCA9IHZub2RlLmN0eDtcbiAgaWYgKGN0eCAmJiBjdHgudXQpIHtcbiAgICBsZXQgbm9kZSA9IHZub2RlLmNoaWxkcmVuWzBdLmVsO1xuICAgIHdoaWxlIChub2RlICE9PSB2bm9kZS50YXJnZXRBbmNob3IpIHtcbiAgICAgIGlmIChub2RlLm5vZGVUeXBlID09PSAxKVxuICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShcImRhdGEtdi1vd25lclwiLCBjdHgudWlkKTtcbiAgICAgIG5vZGUgPSBub2RlLm5leHRTaWJsaW5nO1xuICAgIH1cbiAgICBjdHgudXQoKTtcbiAgfVxufVxuXG5jb25zdCBGcmFnbWVudCA9IFN5bWJvbC5mb3IoXCJ2LWZndFwiKTtcbmNvbnN0IFRleHQgPSBTeW1ib2wuZm9yKFwidi10eHRcIik7XG5jb25zdCBDb21tZW50ID0gU3ltYm9sLmZvcihcInYtY210XCIpO1xuY29uc3QgU3RhdGljID0gU3ltYm9sLmZvcihcInYtc3RjXCIpO1xuY29uc3QgYmxvY2tTdGFjayA9IFtdO1xubGV0IGN1cnJlbnRCbG9jayA9IG51bGw7XG5mdW5jdGlvbiBvcGVuQmxvY2soZGlzYWJsZVRyYWNraW5nID0gZmFsc2UpIHtcbiAgYmxvY2tTdGFjay5wdXNoKGN1cnJlbnRCbG9jayA9IGRpc2FibGVUcmFja2luZyA/IG51bGwgOiBbXSk7XG59XG5mdW5jdGlvbiBjbG9zZUJsb2NrKCkge1xuICBibG9ja1N0YWNrLnBvcCgpO1xuICBjdXJyZW50QmxvY2sgPSBibG9ja1N0YWNrW2Jsb2NrU3RhY2subGVuZ3RoIC0gMV0gfHwgbnVsbDtcbn1cbmxldCBpc0Jsb2NrVHJlZUVuYWJsZWQgPSAxO1xuZnVuY3Rpb24gc2V0QmxvY2tUcmFja2luZyh2YWx1ZSkge1xuICBpc0Jsb2NrVHJlZUVuYWJsZWQgKz0gdmFsdWU7XG59XG5mdW5jdGlvbiBzZXR1cEJsb2NrKHZub2RlKSB7XG4gIHZub2RlLmR5bmFtaWNDaGlsZHJlbiA9IGlzQmxvY2tUcmVlRW5hYmxlZCA+IDAgPyBjdXJyZW50QmxvY2sgfHwgRU1QVFlfQVJSIDogbnVsbDtcbiAgY2xvc2VCbG9jaygpO1xuICBpZiAoaXNCbG9ja1RyZWVFbmFibGVkID4gMCAmJiBjdXJyZW50QmxvY2spIHtcbiAgICBjdXJyZW50QmxvY2sucHVzaCh2bm9kZSk7XG4gIH1cbiAgcmV0dXJuIHZub2RlO1xufVxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudEJsb2NrKHR5cGUsIHByb3BzLCBjaGlsZHJlbiwgcGF0Y2hGbGFnLCBkeW5hbWljUHJvcHMsIHNoYXBlRmxhZykge1xuICByZXR1cm4gc2V0dXBCbG9jayhcbiAgICBjcmVhdGVCYXNlVk5vZGUoXG4gICAgICB0eXBlLFxuICAgICAgcHJvcHMsXG4gICAgICBjaGlsZHJlbixcbiAgICAgIHBhdGNoRmxhZyxcbiAgICAgIGR5bmFtaWNQcm9wcyxcbiAgICAgIHNoYXBlRmxhZyxcbiAgICAgIHRydWVcbiAgICAgIC8qIGlzQmxvY2sgKi9cbiAgICApXG4gICk7XG59XG5mdW5jdGlvbiBjcmVhdGVCbG9jayh0eXBlLCBwcm9wcywgY2hpbGRyZW4sIHBhdGNoRmxhZywgZHluYW1pY1Byb3BzKSB7XG4gIHJldHVybiBzZXR1cEJsb2NrKFxuICAgIGNyZWF0ZVZOb2RlKFxuICAgICAgdHlwZSxcbiAgICAgIHByb3BzLFxuICAgICAgY2hpbGRyZW4sXG4gICAgICBwYXRjaEZsYWcsXG4gICAgICBkeW5hbWljUHJvcHMsXG4gICAgICB0cnVlXG4gICAgICAvKiBpc0Jsb2NrOiBwcmV2ZW50IGEgYmxvY2sgZnJvbSB0cmFja2luZyBpdHNlbGYgKi9cbiAgICApXG4gICk7XG59XG5mdW5jdGlvbiBpc1ZOb2RlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA/IHZhbHVlLl9fdl9pc1ZOb2RlID09PSB0cnVlIDogZmFsc2U7XG59XG5mdW5jdGlvbiBpc1NhbWVWTm9kZVR5cGUobjEsIG4yKSB7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIG4yLnNoYXBlRmxhZyAmIDYgJiYgaG1yRGlydHlDb21wb25lbnRzLmhhcyhuMi50eXBlKSkge1xuICAgIG4xLnNoYXBlRmxhZyAmPSB+MjU2O1xuICAgIG4yLnNoYXBlRmxhZyAmPSB+NTEyO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gbjEudHlwZSA9PT0gbjIudHlwZSAmJiBuMS5rZXkgPT09IG4yLmtleTtcbn1cbmxldCB2bm9kZUFyZ3NUcmFuc2Zvcm1lcjtcbmZ1bmN0aW9uIHRyYW5zZm9ybVZOb2RlQXJncyh0cmFuc2Zvcm1lcikge1xuICB2bm9kZUFyZ3NUcmFuc2Zvcm1lciA9IHRyYW5zZm9ybWVyO1xufVxuY29uc3QgY3JlYXRlVk5vZGVXaXRoQXJnc1RyYW5zZm9ybSA9ICguLi5hcmdzKSA9PiB7XG4gIHJldHVybiBfY3JlYXRlVk5vZGUoXG4gICAgLi4udm5vZGVBcmdzVHJhbnNmb3JtZXIgPyB2bm9kZUFyZ3NUcmFuc2Zvcm1lcihhcmdzLCBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UpIDogYXJnc1xuICApO1xufTtcbmNvbnN0IEludGVybmFsT2JqZWN0S2V5ID0gYF9fdkludGVybmFsYDtcbmNvbnN0IG5vcm1hbGl6ZUtleSA9ICh7IGtleSB9KSA9PiBrZXkgIT0gbnVsbCA/IGtleSA6IG51bGw7XG5jb25zdCBub3JtYWxpemVSZWYgPSAoe1xuICByZWYsXG4gIHJlZl9rZXksXG4gIHJlZl9mb3Jcbn0pID0+IHtcbiAgaWYgKHR5cGVvZiByZWYgPT09IFwibnVtYmVyXCIpIHtcbiAgICByZWYgPSBcIlwiICsgcmVmO1xuICB9XG4gIHJldHVybiByZWYgIT0gbnVsbCA/IGlzU3RyaW5nKHJlZikgfHwgaXNSZWYocmVmKSB8fCBpc0Z1bmN0aW9uKHJlZikgPyB7IGk6IGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSwgcjogcmVmLCBrOiByZWZfa2V5LCBmOiAhIXJlZl9mb3IgfSA6IHJlZiA6IG51bGw7XG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZVZOb2RlKHR5cGUsIHByb3BzID0gbnVsbCwgY2hpbGRyZW4gPSBudWxsLCBwYXRjaEZsYWcgPSAwLCBkeW5hbWljUHJvcHMgPSBudWxsLCBzaGFwZUZsYWcgPSB0eXBlID09PSBGcmFnbWVudCA/IDAgOiAxLCBpc0Jsb2NrTm9kZSA9IGZhbHNlLCBuZWVkRnVsbENoaWxkcmVuTm9ybWFsaXphdGlvbiA9IGZhbHNlKSB7XG4gIGNvbnN0IHZub2RlID0ge1xuICAgIF9fdl9pc1ZOb2RlOiB0cnVlLFxuICAgIF9fdl9za2lwOiB0cnVlLFxuICAgIHR5cGUsXG4gICAgcHJvcHMsXG4gICAga2V5OiBwcm9wcyAmJiBub3JtYWxpemVLZXkocHJvcHMpLFxuICAgIHJlZjogcHJvcHMgJiYgbm9ybWFsaXplUmVmKHByb3BzKSxcbiAgICBzY29wZUlkOiBjdXJyZW50U2NvcGVJZCxcbiAgICBzbG90U2NvcGVJZHM6IG51bGwsXG4gICAgY2hpbGRyZW4sXG4gICAgY29tcG9uZW50OiBudWxsLFxuICAgIHN1c3BlbnNlOiBudWxsLFxuICAgIHNzQ29udGVudDogbnVsbCxcbiAgICBzc0ZhbGxiYWNrOiBudWxsLFxuICAgIGRpcnM6IG51bGwsXG4gICAgdHJhbnNpdGlvbjogbnVsbCxcbiAgICBlbDogbnVsbCxcbiAgICBhbmNob3I6IG51bGwsXG4gICAgdGFyZ2V0OiBudWxsLFxuICAgIHRhcmdldEFuY2hvcjogbnVsbCxcbiAgICBzdGF0aWNDb3VudDogMCxcbiAgICBzaGFwZUZsYWcsXG4gICAgcGF0Y2hGbGFnLFxuICAgIGR5bmFtaWNQcm9wcyxcbiAgICBkeW5hbWljQ2hpbGRyZW46IG51bGwsXG4gICAgYXBwQ29udGV4dDogbnVsbCxcbiAgICBjdHg6IGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZVxuICB9O1xuICBpZiAobmVlZEZ1bGxDaGlsZHJlbk5vcm1hbGl6YXRpb24pIHtcbiAgICBub3JtYWxpemVDaGlsZHJlbih2bm9kZSwgY2hpbGRyZW4pO1xuICAgIGlmIChzaGFwZUZsYWcgJiAxMjgpIHtcbiAgICAgIHR5cGUubm9ybWFsaXplKHZub2RlKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoY2hpbGRyZW4pIHtcbiAgICB2bm9kZS5zaGFwZUZsYWcgfD0gaXNTdHJpbmcoY2hpbGRyZW4pID8gOCA6IDE2O1xuICB9XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHZub2RlLmtleSAhPT0gdm5vZGUua2V5KSB7XG4gICAgd2FybihgVk5vZGUgY3JlYXRlZCB3aXRoIGludmFsaWQga2V5IChOYU4pLiBWTm9kZSB0eXBlOmAsIHZub2RlLnR5cGUpO1xuICB9XG4gIGlmIChpc0Jsb2NrVHJlZUVuYWJsZWQgPiAwICYmIC8vIGF2b2lkIGEgYmxvY2sgbm9kZSBmcm9tIHRyYWNraW5nIGl0c2VsZlxuICAhaXNCbG9ja05vZGUgJiYgLy8gaGFzIGN1cnJlbnQgcGFyZW50IGJsb2NrXG4gIGN1cnJlbnRCbG9jayAmJiAvLyBwcmVzZW5jZSBvZiBhIHBhdGNoIGZsYWcgaW5kaWNhdGVzIHRoaXMgbm9kZSBuZWVkcyBwYXRjaGluZyBvbiB1cGRhdGVzLlxuICAvLyBjb21wb25lbnQgbm9kZXMgYWxzbyBzaG91bGQgYWx3YXlzIGJlIHBhdGNoZWQsIGJlY2F1c2UgZXZlbiBpZiB0aGVcbiAgLy8gY29tcG9uZW50IGRvZXNuJ3QgbmVlZCB0byB1cGRhdGUsIGl0IG5lZWRzIHRvIHBlcnNpc3QgdGhlIGluc3RhbmNlIG9uIHRvXG4gIC8vIHRoZSBuZXh0IHZub2RlIHNvIHRoYXQgaXQgY2FuIGJlIHByb3Blcmx5IHVubW91bnRlZCBsYXRlci5cbiAgKHZub2RlLnBhdGNoRmxhZyA+IDAgfHwgc2hhcGVGbGFnICYgNikgJiYgLy8gdGhlIEVWRU5UUyBmbGFnIGlzIG9ubHkgZm9yIGh5ZHJhdGlvbiBhbmQgaWYgaXQgaXMgdGhlIG9ubHkgZmxhZywgdGhlXG4gIC8vIHZub2RlIHNob3VsZCBub3QgYmUgY29uc2lkZXJlZCBkeW5hbWljIGR1ZSB0byBoYW5kbGVyIGNhY2hpbmcuXG4gIHZub2RlLnBhdGNoRmxhZyAhPT0gMzIpIHtcbiAgICBjdXJyZW50QmxvY2sucHVzaCh2bm9kZSk7XG4gIH1cbiAgcmV0dXJuIHZub2RlO1xufVxuY29uc3QgY3JlYXRlVk5vZGUgPSAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gY3JlYXRlVk5vZGVXaXRoQXJnc1RyYW5zZm9ybSA6IF9jcmVhdGVWTm9kZTtcbmZ1bmN0aW9uIF9jcmVhdGVWTm9kZSh0eXBlLCBwcm9wcyA9IG51bGwsIGNoaWxkcmVuID0gbnVsbCwgcGF0Y2hGbGFnID0gMCwgZHluYW1pY1Byb3BzID0gbnVsbCwgaXNCbG9ja05vZGUgPSBmYWxzZSkge1xuICBpZiAoIXR5cGUgfHwgdHlwZSA9PT0gTlVMTF9EWU5BTUlDX0NPTVBPTkVOVCkge1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICF0eXBlKSB7XG4gICAgICB3YXJuKGBJbnZhbGlkIHZub2RlIHR5cGUgd2hlbiBjcmVhdGluZyB2bm9kZTogJHt0eXBlfS5gKTtcbiAgICB9XG4gICAgdHlwZSA9IENvbW1lbnQ7XG4gIH1cbiAgaWYgKGlzVk5vZGUodHlwZSkpIHtcbiAgICBjb25zdCBjbG9uZWQgPSBjbG9uZVZOb2RlKFxuICAgICAgdHlwZSxcbiAgICAgIHByb3BzLFxuICAgICAgdHJ1ZVxuICAgICAgLyogbWVyZ2VSZWY6IHRydWUgKi9cbiAgICApO1xuICAgIGlmIChjaGlsZHJlbikge1xuICAgICAgbm9ybWFsaXplQ2hpbGRyZW4oY2xvbmVkLCBjaGlsZHJlbik7XG4gICAgfVxuICAgIGlmIChpc0Jsb2NrVHJlZUVuYWJsZWQgPiAwICYmICFpc0Jsb2NrTm9kZSAmJiBjdXJyZW50QmxvY2spIHtcbiAgICAgIGlmIChjbG9uZWQuc2hhcGVGbGFnICYgNikge1xuICAgICAgICBjdXJyZW50QmxvY2tbY3VycmVudEJsb2NrLmluZGV4T2YodHlwZSldID0gY2xvbmVkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3VycmVudEJsb2NrLnB1c2goY2xvbmVkKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY2xvbmVkLnBhdGNoRmxhZyB8PSAtMjtcbiAgICByZXR1cm4gY2xvbmVkO1xuICB9XG4gIGlmIChpc0NsYXNzQ29tcG9uZW50KHR5cGUpKSB7XG4gICAgdHlwZSA9IHR5cGUuX192Y2NPcHRzO1xuICB9XG4gIGlmIChwcm9wcykge1xuICAgIHByb3BzID0gZ3VhcmRSZWFjdGl2ZVByb3BzKHByb3BzKTtcbiAgICBsZXQgeyBjbGFzczoga2xhc3MsIHN0eWxlIH0gPSBwcm9wcztcbiAgICBpZiAoa2xhc3MgJiYgIWlzU3RyaW5nKGtsYXNzKSkge1xuICAgICAgcHJvcHMuY2xhc3MgPSBub3JtYWxpemVDbGFzcyhrbGFzcyk7XG4gICAgfVxuICAgIGlmIChpc09iamVjdChzdHlsZSkpIHtcbiAgICAgIGlmIChpc1Byb3h5KHN0eWxlKSAmJiAhaXNBcnJheShzdHlsZSkpIHtcbiAgICAgICAgc3R5bGUgPSBleHRlbmQoe30sIHN0eWxlKTtcbiAgICAgIH1cbiAgICAgIHByb3BzLnN0eWxlID0gbm9ybWFsaXplU3R5bGUoc3R5bGUpO1xuICAgIH1cbiAgfVxuICBjb25zdCBzaGFwZUZsYWcgPSBpc1N0cmluZyh0eXBlKSA/IDEgOiBpc1N1c3BlbnNlKHR5cGUpID8gMTI4IDogaXNUZWxlcG9ydCh0eXBlKSA/IDY0IDogaXNPYmplY3QodHlwZSkgPyA0IDogaXNGdW5jdGlvbih0eXBlKSA/IDIgOiAwO1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBzaGFwZUZsYWcgJiA0ICYmIGlzUHJveHkodHlwZSkpIHtcbiAgICB0eXBlID0gdG9SYXcodHlwZSk7XG4gICAgd2FybihcbiAgICAgIGBWdWUgcmVjZWl2ZWQgYSBDb21wb25lbnQgd2hpY2ggd2FzIG1hZGUgYSByZWFjdGl2ZSBvYmplY3QuIFRoaXMgY2FuIGxlYWQgdG8gdW5uZWNlc3NhcnkgcGVyZm9ybWFuY2Ugb3ZlcmhlYWQsIGFuZCBzaG91bGQgYmUgYXZvaWRlZCBieSBtYXJraW5nIHRoZSBjb21wb25lbnQgd2l0aCBcXGBtYXJrUmF3XFxgIG9yIHVzaW5nIFxcYHNoYWxsb3dSZWZcXGAgaW5zdGVhZCBvZiBcXGByZWZcXGAuYCxcbiAgICAgIGBcbkNvbXBvbmVudCB0aGF0IHdhcyBtYWRlIHJlYWN0aXZlOiBgLFxuICAgICAgdHlwZVxuICAgICk7XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUJhc2VWTm9kZShcbiAgICB0eXBlLFxuICAgIHByb3BzLFxuICAgIGNoaWxkcmVuLFxuICAgIHBhdGNoRmxhZyxcbiAgICBkeW5hbWljUHJvcHMsXG4gICAgc2hhcGVGbGFnLFxuICAgIGlzQmxvY2tOb2RlLFxuICAgIHRydWVcbiAgKTtcbn1cbmZ1bmN0aW9uIGd1YXJkUmVhY3RpdmVQcm9wcyhwcm9wcykge1xuICBpZiAoIXByb3BzKVxuICAgIHJldHVybiBudWxsO1xuICByZXR1cm4gaXNQcm94eShwcm9wcykgfHwgSW50ZXJuYWxPYmplY3RLZXkgaW4gcHJvcHMgPyBleHRlbmQoe30sIHByb3BzKSA6IHByb3BzO1xufVxuZnVuY3Rpb24gY2xvbmVWTm9kZSh2bm9kZSwgZXh0cmFQcm9wcywgbWVyZ2VSZWYgPSBmYWxzZSkge1xuICBjb25zdCB7IHByb3BzLCByZWYsIHBhdGNoRmxhZywgY2hpbGRyZW4gfSA9IHZub2RlO1xuICBjb25zdCBtZXJnZWRQcm9wcyA9IGV4dHJhUHJvcHMgPyBtZXJnZVByb3BzKHByb3BzIHx8IHt9LCBleHRyYVByb3BzKSA6IHByb3BzO1xuICBjb25zdCBjbG9uZWQgPSB7XG4gICAgX192X2lzVk5vZGU6IHRydWUsXG4gICAgX192X3NraXA6IHRydWUsXG4gICAgdHlwZTogdm5vZGUudHlwZSxcbiAgICBwcm9wczogbWVyZ2VkUHJvcHMsXG4gICAga2V5OiBtZXJnZWRQcm9wcyAmJiBub3JtYWxpemVLZXkobWVyZ2VkUHJvcHMpLFxuICAgIHJlZjogZXh0cmFQcm9wcyAmJiBleHRyYVByb3BzLnJlZiA/IChcbiAgICAgIC8vICMyMDc4IGluIHRoZSBjYXNlIG9mIDxjb21wb25lbnQgOmlzPVwidm5vZGVcIiByZWY9XCJleHRyYVwiLz5cbiAgICAgIC8vIGlmIHRoZSB2bm9kZSBpdHNlbGYgYWxyZWFkeSBoYXMgYSByZWYsIGNsb25lVk5vZGUgd2lsbCBuZWVkIHRvIG1lcmdlXG4gICAgICAvLyB0aGUgcmVmcyBzbyB0aGUgc2luZ2xlIHZub2RlIGNhbiBiZSBzZXQgb24gbXVsdGlwbGUgcmVmc1xuICAgICAgbWVyZ2VSZWYgJiYgcmVmID8gaXNBcnJheShyZWYpID8gcmVmLmNvbmNhdChub3JtYWxpemVSZWYoZXh0cmFQcm9wcykpIDogW3JlZiwgbm9ybWFsaXplUmVmKGV4dHJhUHJvcHMpXSA6IG5vcm1hbGl6ZVJlZihleHRyYVByb3BzKVxuICAgICkgOiByZWYsXG4gICAgc2NvcGVJZDogdm5vZGUuc2NvcGVJZCxcbiAgICBzbG90U2NvcGVJZHM6IHZub2RlLnNsb3RTY29wZUlkcyxcbiAgICBjaGlsZHJlbjogISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBwYXRjaEZsYWcgPT09IC0xICYmIGlzQXJyYXkoY2hpbGRyZW4pID8gY2hpbGRyZW4ubWFwKGRlZXBDbG9uZVZOb2RlKSA6IGNoaWxkcmVuLFxuICAgIHRhcmdldDogdm5vZGUudGFyZ2V0LFxuICAgIHRhcmdldEFuY2hvcjogdm5vZGUudGFyZ2V0QW5jaG9yLFxuICAgIHN0YXRpY0NvdW50OiB2bm9kZS5zdGF0aWNDb3VudCxcbiAgICBzaGFwZUZsYWc6IHZub2RlLnNoYXBlRmxhZyxcbiAgICAvLyBpZiB0aGUgdm5vZGUgaXMgY2xvbmVkIHdpdGggZXh0cmEgcHJvcHMsIHdlIGNhbiBubyBsb25nZXIgYXNzdW1lIGl0c1xuICAgIC8vIGV4aXN0aW5nIHBhdGNoIGZsYWcgdG8gYmUgcmVsaWFibGUgYW5kIG5lZWQgdG8gYWRkIHRoZSBGVUxMX1BST1BTIGZsYWcuXG4gICAgLy8gbm90ZTogcHJlc2VydmUgZmxhZyBmb3IgZnJhZ21lbnRzIHNpbmNlIHRoZXkgdXNlIHRoZSBmbGFnIGZvciBjaGlsZHJlblxuICAgIC8vIGZhc3QgcGF0aHMgb25seS5cbiAgICBwYXRjaEZsYWc6IGV4dHJhUHJvcHMgJiYgdm5vZGUudHlwZSAhPT0gRnJhZ21lbnQgPyBwYXRjaEZsYWcgPT09IC0xID8gMTYgOiBwYXRjaEZsYWcgfCAxNiA6IHBhdGNoRmxhZyxcbiAgICBkeW5hbWljUHJvcHM6IHZub2RlLmR5bmFtaWNQcm9wcyxcbiAgICBkeW5hbWljQ2hpbGRyZW46IHZub2RlLmR5bmFtaWNDaGlsZHJlbixcbiAgICBhcHBDb250ZXh0OiB2bm9kZS5hcHBDb250ZXh0LFxuICAgIGRpcnM6IHZub2RlLmRpcnMsXG4gICAgdHJhbnNpdGlvbjogdm5vZGUudHJhbnNpdGlvbixcbiAgICAvLyBUaGVzZSBzaG91bGQgdGVjaG5pY2FsbHkgb25seSBiZSBub24tbnVsbCBvbiBtb3VudGVkIFZOb2Rlcy4gSG93ZXZlcixcbiAgICAvLyB0aGV5ICpzaG91bGQqIGJlIGNvcGllZCBmb3Iga2VwdC1hbGl2ZSB2bm9kZXMuIFNvIHdlIGp1c3QgYWx3YXlzIGNvcHlcbiAgICAvLyB0aGVtIHNpbmNlIHRoZW0gYmVpbmcgbm9uLW51bGwgZHVyaW5nIGEgbW91bnQgZG9lc24ndCBhZmZlY3QgdGhlIGxvZ2ljIGFzXG4gICAgLy8gdGhleSB3aWxsIHNpbXBseSBiZSBvdmVyd3JpdHRlbi5cbiAgICBjb21wb25lbnQ6IHZub2RlLmNvbXBvbmVudCxcbiAgICBzdXNwZW5zZTogdm5vZGUuc3VzcGVuc2UsXG4gICAgc3NDb250ZW50OiB2bm9kZS5zc0NvbnRlbnQgJiYgY2xvbmVWTm9kZSh2bm9kZS5zc0NvbnRlbnQpLFxuICAgIHNzRmFsbGJhY2s6IHZub2RlLnNzRmFsbGJhY2sgJiYgY2xvbmVWTm9kZSh2bm9kZS5zc0ZhbGxiYWNrKSxcbiAgICBlbDogdm5vZGUuZWwsXG4gICAgYW5jaG9yOiB2bm9kZS5hbmNob3IsXG4gICAgY3R4OiB2bm9kZS5jdHgsXG4gICAgY2U6IHZub2RlLmNlXG4gIH07XG4gIHJldHVybiBjbG9uZWQ7XG59XG5mdW5jdGlvbiBkZWVwQ2xvbmVWTm9kZSh2bm9kZSkge1xuICBjb25zdCBjbG9uZWQgPSBjbG9uZVZOb2RlKHZub2RlKTtcbiAgaWYgKGlzQXJyYXkodm5vZGUuY2hpbGRyZW4pKSB7XG4gICAgY2xvbmVkLmNoaWxkcmVuID0gdm5vZGUuY2hpbGRyZW4ubWFwKGRlZXBDbG9uZVZOb2RlKTtcbiAgfVxuICByZXR1cm4gY2xvbmVkO1xufVxuZnVuY3Rpb24gY3JlYXRlVGV4dFZOb2RlKHRleHQgPSBcIiBcIiwgZmxhZyA9IDApIHtcbiAgcmV0dXJuIGNyZWF0ZVZOb2RlKFRleHQsIG51bGwsIHRleHQsIGZsYWcpO1xufVxuZnVuY3Rpb24gY3JlYXRlU3RhdGljVk5vZGUoY29udGVudCwgbnVtYmVyT2ZOb2Rlcykge1xuICBjb25zdCB2bm9kZSA9IGNyZWF0ZVZOb2RlKFN0YXRpYywgbnVsbCwgY29udGVudCk7XG4gIHZub2RlLnN0YXRpY0NvdW50ID0gbnVtYmVyT2ZOb2RlcztcbiAgcmV0dXJuIHZub2RlO1xufVxuZnVuY3Rpb24gY3JlYXRlQ29tbWVudFZOb2RlKHRleHQgPSBcIlwiLCBhc0Jsb2NrID0gZmFsc2UpIHtcbiAgcmV0dXJuIGFzQmxvY2sgPyAob3BlbkJsb2NrKCksIGNyZWF0ZUJsb2NrKENvbW1lbnQsIG51bGwsIHRleHQpKSA6IGNyZWF0ZVZOb2RlKENvbW1lbnQsIG51bGwsIHRleHQpO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplVk5vZGUoY2hpbGQpIHtcbiAgaWYgKGNoaWxkID09IG51bGwgfHwgdHlwZW9mIGNoaWxkID09PSBcImJvb2xlYW5cIikge1xuICAgIHJldHVybiBjcmVhdGVWTm9kZShDb21tZW50KTtcbiAgfSBlbHNlIGlmIChpc0FycmF5KGNoaWxkKSkge1xuICAgIHJldHVybiBjcmVhdGVWTm9kZShcbiAgICAgIEZyYWdtZW50LFxuICAgICAgbnVsbCxcbiAgICAgIC8vICMzNjY2LCBhdm9pZCByZWZlcmVuY2UgcG9sbHV0aW9uIHdoZW4gcmV1c2luZyB2bm9kZVxuICAgICAgY2hpbGQuc2xpY2UoKVxuICAgICk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGNoaWxkID09PSBcIm9iamVjdFwiKSB7XG4gICAgcmV0dXJuIGNsb25lSWZNb3VudGVkKGNoaWxkKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gY3JlYXRlVk5vZGUoVGV4dCwgbnVsbCwgU3RyaW5nKGNoaWxkKSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGNsb25lSWZNb3VudGVkKGNoaWxkKSB7XG4gIHJldHVybiBjaGlsZC5lbCA9PT0gbnVsbCAmJiBjaGlsZC5wYXRjaEZsYWcgIT09IC0xIHx8IGNoaWxkLm1lbW8gPyBjaGlsZCA6IGNsb25lVk5vZGUoY2hpbGQpO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplQ2hpbGRyZW4odm5vZGUsIGNoaWxkcmVuKSB7XG4gIGxldCB0eXBlID0gMDtcbiAgY29uc3QgeyBzaGFwZUZsYWcgfSA9IHZub2RlO1xuICBpZiAoY2hpbGRyZW4gPT0gbnVsbCkge1xuICAgIGNoaWxkcmVuID0gbnVsbDtcbiAgfSBlbHNlIGlmIChpc0FycmF5KGNoaWxkcmVuKSkge1xuICAgIHR5cGUgPSAxNjtcbiAgfSBlbHNlIGlmICh0eXBlb2YgY2hpbGRyZW4gPT09IFwib2JqZWN0XCIpIHtcbiAgICBpZiAoc2hhcGVGbGFnICYgKDEgfCA2NCkpIHtcbiAgICAgIGNvbnN0IHNsb3QgPSBjaGlsZHJlbi5kZWZhdWx0O1xuICAgICAgaWYgKHNsb3QpIHtcbiAgICAgICAgc2xvdC5fYyAmJiAoc2xvdC5fZCA9IGZhbHNlKTtcbiAgICAgICAgbm9ybWFsaXplQ2hpbGRyZW4odm5vZGUsIHNsb3QoKSk7XG4gICAgICAgIHNsb3QuX2MgJiYgKHNsb3QuX2QgPSB0cnVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9IGVsc2Uge1xuICAgICAgdHlwZSA9IDMyO1xuICAgICAgY29uc3Qgc2xvdEZsYWcgPSBjaGlsZHJlbi5fO1xuICAgICAgaWYgKCFzbG90RmxhZyAmJiAhKEludGVybmFsT2JqZWN0S2V5IGluIGNoaWxkcmVuKSkge1xuICAgICAgICBjaGlsZHJlbi5fY3R4ID0gY3VycmVudFJlbmRlcmluZ0luc3RhbmNlO1xuICAgICAgfSBlbHNlIGlmIChzbG90RmxhZyA9PT0gMyAmJiBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UpIHtcbiAgICAgICAgaWYgKGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZS5zbG90cy5fID09PSAxKSB7XG4gICAgICAgICAgY2hpbGRyZW4uXyA9IDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2hpbGRyZW4uXyA9IDI7XG4gICAgICAgICAgdm5vZGUucGF0Y2hGbGFnIHw9IDEwMjQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNGdW5jdGlvbihjaGlsZHJlbikpIHtcbiAgICBjaGlsZHJlbiA9IHsgZGVmYXVsdDogY2hpbGRyZW4sIF9jdHg6IGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSB9O1xuICAgIHR5cGUgPSAzMjtcbiAgfSBlbHNlIHtcbiAgICBjaGlsZHJlbiA9IFN0cmluZyhjaGlsZHJlbik7XG4gICAgaWYgKHNoYXBlRmxhZyAmIDY0KSB7XG4gICAgICB0eXBlID0gMTY7XG4gICAgICBjaGlsZHJlbiA9IFtjcmVhdGVUZXh0Vk5vZGUoY2hpbGRyZW4pXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdHlwZSA9IDg7XG4gICAgfVxuICB9XG4gIHZub2RlLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gIHZub2RlLnNoYXBlRmxhZyB8PSB0eXBlO1xufVxuZnVuY3Rpb24gbWVyZ2VQcm9wcyguLi5hcmdzKSB7XG4gIGNvbnN0IHJldCA9IHt9O1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCB0b01lcmdlID0gYXJnc1tpXTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiB0b01lcmdlKSB7XG4gICAgICBpZiAoa2V5ID09PSBcImNsYXNzXCIpIHtcbiAgICAgICAgaWYgKHJldC5jbGFzcyAhPT0gdG9NZXJnZS5jbGFzcykge1xuICAgICAgICAgIHJldC5jbGFzcyA9IG5vcm1hbGl6ZUNsYXNzKFtyZXQuY2xhc3MsIHRvTWVyZ2UuY2xhc3NdKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChrZXkgPT09IFwic3R5bGVcIikge1xuICAgICAgICByZXQuc3R5bGUgPSBub3JtYWxpemVTdHlsZShbcmV0LnN0eWxlLCB0b01lcmdlLnN0eWxlXSk7XG4gICAgICB9IGVsc2UgaWYgKGlzT24oa2V5KSkge1xuICAgICAgICBjb25zdCBleGlzdGluZyA9IHJldFtrZXldO1xuICAgICAgICBjb25zdCBpbmNvbWluZyA9IHRvTWVyZ2Vba2V5XTtcbiAgICAgICAgaWYgKGluY29taW5nICYmIGV4aXN0aW5nICE9PSBpbmNvbWluZyAmJiAhKGlzQXJyYXkoZXhpc3RpbmcpICYmIGV4aXN0aW5nLmluY2x1ZGVzKGluY29taW5nKSkpIHtcbiAgICAgICAgICByZXRba2V5XSA9IGV4aXN0aW5nID8gW10uY29uY2F0KGV4aXN0aW5nLCBpbmNvbWluZykgOiBpbmNvbWluZztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChrZXkgIT09IFwiXCIpIHtcbiAgICAgICAgcmV0W2tleV0gPSB0b01lcmdlW2tleV07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiByZXQ7XG59XG5mdW5jdGlvbiBpbnZva2VWTm9kZUhvb2soaG9vaywgaW5zdGFuY2UsIHZub2RlLCBwcmV2Vk5vZGUgPSBudWxsKSB7XG4gIGNhbGxXaXRoQXN5bmNFcnJvckhhbmRsaW5nKGhvb2ssIGluc3RhbmNlLCA3LCBbXG4gICAgdm5vZGUsXG4gICAgcHJldlZOb2RlXG4gIF0pO1xufVxuXG5jb25zdCBlbXB0eUFwcENvbnRleHQgPSBjcmVhdGVBcHBDb250ZXh0KCk7XG5sZXQgdWlkID0gMDtcbmZ1bmN0aW9uIGNyZWF0ZUNvbXBvbmVudEluc3RhbmNlKHZub2RlLCBwYXJlbnQsIHN1c3BlbnNlKSB7XG4gIGNvbnN0IHR5cGUgPSB2bm9kZS50eXBlO1xuICBjb25zdCBhcHBDb250ZXh0ID0gKHBhcmVudCA/IHBhcmVudC5hcHBDb250ZXh0IDogdm5vZGUuYXBwQ29udGV4dCkgfHwgZW1wdHlBcHBDb250ZXh0O1xuICBjb25zdCBpbnN0YW5jZSA9IHtcbiAgICB1aWQ6IHVpZCsrLFxuICAgIHZub2RlLFxuICAgIHR5cGUsXG4gICAgcGFyZW50LFxuICAgIGFwcENvbnRleHQsXG4gICAgcm9vdDogbnVsbCxcbiAgICAvLyB0byBiZSBpbW1lZGlhdGVseSBzZXRcbiAgICBuZXh0OiBudWxsLFxuICAgIHN1YlRyZWU6IG51bGwsXG4gICAgLy8gd2lsbCBiZSBzZXQgc3luY2hyb25vdXNseSByaWdodCBhZnRlciBjcmVhdGlvblxuICAgIGVmZmVjdDogbnVsbCxcbiAgICB1cGRhdGU6IG51bGwsXG4gICAgLy8gd2lsbCBiZSBzZXQgc3luY2hyb25vdXNseSByaWdodCBhZnRlciBjcmVhdGlvblxuICAgIHNjb3BlOiBuZXcgRWZmZWN0U2NvcGUoXG4gICAgICB0cnVlXG4gICAgICAvKiBkZXRhY2hlZCAqL1xuICAgICksXG4gICAgcmVuZGVyOiBudWxsLFxuICAgIHByb3h5OiBudWxsLFxuICAgIGV4cG9zZWQ6IG51bGwsXG4gICAgZXhwb3NlUHJveHk6IG51bGwsXG4gICAgd2l0aFByb3h5OiBudWxsLFxuICAgIHByb3ZpZGVzOiBwYXJlbnQgPyBwYXJlbnQucHJvdmlkZXMgOiBPYmplY3QuY3JlYXRlKGFwcENvbnRleHQucHJvdmlkZXMpLFxuICAgIGFjY2Vzc0NhY2hlOiBudWxsLFxuICAgIHJlbmRlckNhY2hlOiBbXSxcbiAgICAvLyBsb2NhbCByZXNvbHZlZCBhc3NldHNcbiAgICBjb21wb25lbnRzOiBudWxsLFxuICAgIGRpcmVjdGl2ZXM6IG51bGwsXG4gICAgLy8gcmVzb2x2ZWQgcHJvcHMgYW5kIGVtaXRzIG9wdGlvbnNcbiAgICBwcm9wc09wdGlvbnM6IG5vcm1hbGl6ZVByb3BzT3B0aW9ucyh0eXBlLCBhcHBDb250ZXh0KSxcbiAgICBlbWl0c09wdGlvbnM6IG5vcm1hbGl6ZUVtaXRzT3B0aW9ucyh0eXBlLCBhcHBDb250ZXh0KSxcbiAgICAvLyBlbWl0XG4gICAgZW1pdDogbnVsbCxcbiAgICAvLyB0byBiZSBzZXQgaW1tZWRpYXRlbHlcbiAgICBlbWl0dGVkOiBudWxsLFxuICAgIC8vIHByb3BzIGRlZmF1bHQgdmFsdWVcbiAgICBwcm9wc0RlZmF1bHRzOiBFTVBUWV9PQkosXG4gICAgLy8gaW5oZXJpdEF0dHJzXG4gICAgaW5oZXJpdEF0dHJzOiB0eXBlLmluaGVyaXRBdHRycyxcbiAgICAvLyBzdGF0ZVxuICAgIGN0eDogRU1QVFlfT0JKLFxuICAgIGRhdGE6IEVNUFRZX09CSixcbiAgICBwcm9wczogRU1QVFlfT0JKLFxuICAgIGF0dHJzOiBFTVBUWV9PQkosXG4gICAgc2xvdHM6IEVNUFRZX09CSixcbiAgICByZWZzOiBFTVBUWV9PQkosXG4gICAgc2V0dXBTdGF0ZTogRU1QVFlfT0JKLFxuICAgIHNldHVwQ29udGV4dDogbnVsbCxcbiAgICBhdHRyc1Byb3h5OiBudWxsLFxuICAgIHNsb3RzUHJveHk6IG51bGwsXG4gICAgLy8gc3VzcGVuc2UgcmVsYXRlZFxuICAgIHN1c3BlbnNlLFxuICAgIHN1c3BlbnNlSWQ6IHN1c3BlbnNlID8gc3VzcGVuc2UucGVuZGluZ0lkIDogMCxcbiAgICBhc3luY0RlcDogbnVsbCxcbiAgICBhc3luY1Jlc29sdmVkOiBmYWxzZSxcbiAgICAvLyBsaWZlY3ljbGUgaG9va3NcbiAgICAvLyBub3QgdXNpbmcgZW51bXMgaGVyZSBiZWNhdXNlIGl0IHJlc3VsdHMgaW4gY29tcHV0ZWQgcHJvcGVydGllc1xuICAgIGlzTW91bnRlZDogZmFsc2UsXG4gICAgaXNVbm1vdW50ZWQ6IGZhbHNlLFxuICAgIGlzRGVhY3RpdmF0ZWQ6IGZhbHNlLFxuICAgIGJjOiBudWxsLFxuICAgIGM6IG51bGwsXG4gICAgYm06IG51bGwsXG4gICAgbTogbnVsbCxcbiAgICBidTogbnVsbCxcbiAgICB1OiBudWxsLFxuICAgIHVtOiBudWxsLFxuICAgIGJ1bTogbnVsbCxcbiAgICBkYTogbnVsbCxcbiAgICBhOiBudWxsLFxuICAgIHJ0ZzogbnVsbCxcbiAgICBydGM6IG51bGwsXG4gICAgZWM6IG51bGwsXG4gICAgc3A6IG51bGxcbiAgfTtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICBpbnN0YW5jZS5jdHggPSBjcmVhdGVEZXZSZW5kZXJDb250ZXh0KGluc3RhbmNlKTtcbiAgfSBlbHNlIHtcbiAgICBpbnN0YW5jZS5jdHggPSB7IF86IGluc3RhbmNlIH07XG4gIH1cbiAgaW5zdGFuY2Uucm9vdCA9IHBhcmVudCA/IHBhcmVudC5yb290IDogaW5zdGFuY2U7XG4gIGluc3RhbmNlLmVtaXQgPSBlbWl0LmJpbmQobnVsbCwgaW5zdGFuY2UpO1xuICBpZiAodm5vZGUuY2UpIHtcbiAgICB2bm9kZS5jZShpbnN0YW5jZSk7XG4gIH1cbiAgcmV0dXJuIGluc3RhbmNlO1xufVxubGV0IGN1cnJlbnRJbnN0YW5jZSA9IG51bGw7XG5jb25zdCBnZXRDdXJyZW50SW5zdGFuY2UgPSAoKSA9PiBjdXJyZW50SW5zdGFuY2UgfHwgY3VycmVudFJlbmRlcmluZ0luc3RhbmNlO1xubGV0IGludGVybmFsU2V0Q3VycmVudEluc3RhbmNlO1xubGV0IGdsb2JhbEN1cnJlbnRJbnN0YW5jZVNldHRlcnM7XG5sZXQgc2V0dGVyc0tleSA9IFwiX19WVUVfSU5TVEFOQ0VfU0VUVEVSU19fXCI7XG57XG4gIGlmICghKGdsb2JhbEN1cnJlbnRJbnN0YW5jZVNldHRlcnMgPSBnZXRHbG9iYWxUaGlzKClbc2V0dGVyc0tleV0pKSB7XG4gICAgZ2xvYmFsQ3VycmVudEluc3RhbmNlU2V0dGVycyA9IGdldEdsb2JhbFRoaXMoKVtzZXR0ZXJzS2V5XSA9IFtdO1xuICB9XG4gIGdsb2JhbEN1cnJlbnRJbnN0YW5jZVNldHRlcnMucHVzaCgoaSkgPT4gY3VycmVudEluc3RhbmNlID0gaSk7XG4gIGludGVybmFsU2V0Q3VycmVudEluc3RhbmNlID0gKGluc3RhbmNlKSA9PiB7XG4gICAgaWYgKGdsb2JhbEN1cnJlbnRJbnN0YW5jZVNldHRlcnMubGVuZ3RoID4gMSkge1xuICAgICAgZ2xvYmFsQ3VycmVudEluc3RhbmNlU2V0dGVycy5mb3JFYWNoKChzKSA9PiBzKGluc3RhbmNlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdsb2JhbEN1cnJlbnRJbnN0YW5jZVNldHRlcnNbMF0oaW5zdGFuY2UpO1xuICAgIH1cbiAgfTtcbn1cbmNvbnN0IHNldEN1cnJlbnRJbnN0YW5jZSA9IChpbnN0YW5jZSkgPT4ge1xuICBpbnRlcm5hbFNldEN1cnJlbnRJbnN0YW5jZShpbnN0YW5jZSk7XG4gIGluc3RhbmNlLnNjb3BlLm9uKCk7XG59O1xuY29uc3QgdW5zZXRDdXJyZW50SW5zdGFuY2UgPSAoKSA9PiB7XG4gIGN1cnJlbnRJbnN0YW5jZSAmJiBjdXJyZW50SW5zdGFuY2Uuc2NvcGUub2ZmKCk7XG4gIGludGVybmFsU2V0Q3VycmVudEluc3RhbmNlKG51bGwpO1xufTtcbmNvbnN0IGlzQnVpbHRJblRhZyA9IC8qIEBfX1BVUkVfXyAqLyBtYWtlTWFwKFwic2xvdCxjb21wb25lbnRcIik7XG5mdW5jdGlvbiB2YWxpZGF0ZUNvbXBvbmVudE5hbWUobmFtZSwgY29uZmlnKSB7XG4gIGNvbnN0IGFwcElzTmF0aXZlVGFnID0gY29uZmlnLmlzTmF0aXZlVGFnIHx8IE5PO1xuICBpZiAoaXNCdWlsdEluVGFnKG5hbWUpIHx8IGFwcElzTmF0aXZlVGFnKG5hbWUpKSB7XG4gICAgd2FybihcbiAgICAgIFwiRG8gbm90IHVzZSBidWlsdC1pbiBvciByZXNlcnZlZCBIVE1MIGVsZW1lbnRzIGFzIGNvbXBvbmVudCBpZDogXCIgKyBuYW1lXG4gICAgKTtcbiAgfVxufVxuZnVuY3Rpb24gaXNTdGF0ZWZ1bENvbXBvbmVudChpbnN0YW5jZSkge1xuICByZXR1cm4gaW5zdGFuY2Uudm5vZGUuc2hhcGVGbGFnICYgNDtcbn1cbmxldCBpc0luU1NSQ29tcG9uZW50U2V0dXAgPSBmYWxzZTtcbmZ1bmN0aW9uIHNldHVwQ29tcG9uZW50KGluc3RhbmNlLCBpc1NTUiA9IGZhbHNlKSB7XG4gIGlzSW5TU1JDb21wb25lbnRTZXR1cCA9IGlzU1NSO1xuICBjb25zdCB7IHByb3BzLCBjaGlsZHJlbiB9ID0gaW5zdGFuY2Uudm5vZGU7XG4gIGNvbnN0IGlzU3RhdGVmdWwgPSBpc1N0YXRlZnVsQ29tcG9uZW50KGluc3RhbmNlKTtcbiAgaW5pdFByb3BzKGluc3RhbmNlLCBwcm9wcywgaXNTdGF0ZWZ1bCwgaXNTU1IpO1xuICBpbml0U2xvdHMoaW5zdGFuY2UsIGNoaWxkcmVuKTtcbiAgY29uc3Qgc2V0dXBSZXN1bHQgPSBpc1N0YXRlZnVsID8gc2V0dXBTdGF0ZWZ1bENvbXBvbmVudChpbnN0YW5jZSwgaXNTU1IpIDogdm9pZCAwO1xuICBpc0luU1NSQ29tcG9uZW50U2V0dXAgPSBmYWxzZTtcbiAgcmV0dXJuIHNldHVwUmVzdWx0O1xufVxuZnVuY3Rpb24gc2V0dXBTdGF0ZWZ1bENvbXBvbmVudChpbnN0YW5jZSwgaXNTU1IpIHtcbiAgdmFyIF9hO1xuICBjb25zdCBDb21wb25lbnQgPSBpbnN0YW5jZS50eXBlO1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIGlmIChDb21wb25lbnQubmFtZSkge1xuICAgICAgdmFsaWRhdGVDb21wb25lbnROYW1lKENvbXBvbmVudC5uYW1lLCBpbnN0YW5jZS5hcHBDb250ZXh0LmNvbmZpZyk7XG4gICAgfVxuICAgIGlmIChDb21wb25lbnQuY29tcG9uZW50cykge1xuICAgICAgY29uc3QgbmFtZXMgPSBPYmplY3Qua2V5cyhDb21wb25lbnQuY29tcG9uZW50cyk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhbGlkYXRlQ29tcG9uZW50TmFtZShuYW1lc1tpXSwgaW5zdGFuY2UuYXBwQ29udGV4dC5jb25maWcpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoQ29tcG9uZW50LmRpcmVjdGl2ZXMpIHtcbiAgICAgIGNvbnN0IG5hbWVzID0gT2JqZWN0LmtleXMoQ29tcG9uZW50LmRpcmVjdGl2ZXMpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YWxpZGF0ZURpcmVjdGl2ZU5hbWUobmFtZXNbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoQ29tcG9uZW50LmNvbXBpbGVyT3B0aW9ucyAmJiBpc1J1bnRpbWVPbmx5KCkpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIGBcImNvbXBpbGVyT3B0aW9uc1wiIGlzIG9ubHkgc3VwcG9ydGVkIHdoZW4gdXNpbmcgYSBidWlsZCBvZiBWdWUgdGhhdCBpbmNsdWRlcyB0aGUgcnVudGltZSBjb21waWxlci4gU2luY2UgeW91IGFyZSB1c2luZyBhIHJ1bnRpbWUtb25seSBidWlsZCwgdGhlIG9wdGlvbnMgc2hvdWxkIGJlIHBhc3NlZCB2aWEgeW91ciBidWlsZCB0b29sIGNvbmZpZyBpbnN0ZWFkLmBcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIGluc3RhbmNlLmFjY2Vzc0NhY2hlID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGluc3RhbmNlLnByb3h5ID0gbWFya1JhdyhuZXcgUHJveHkoaW5zdGFuY2UuY3R4LCBQdWJsaWNJbnN0YW5jZVByb3h5SGFuZGxlcnMpKTtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICBleHBvc2VQcm9wc09uUmVuZGVyQ29udGV4dChpbnN0YW5jZSk7XG4gIH1cbiAgY29uc3QgeyBzZXR1cCB9ID0gQ29tcG9uZW50O1xuICBpZiAoc2V0dXApIHtcbiAgICBjb25zdCBzZXR1cENvbnRleHQgPSBpbnN0YW5jZS5zZXR1cENvbnRleHQgPSBzZXR1cC5sZW5ndGggPiAxID8gY3JlYXRlU2V0dXBDb250ZXh0KGluc3RhbmNlKSA6IG51bGw7XG4gICAgc2V0Q3VycmVudEluc3RhbmNlKGluc3RhbmNlKTtcbiAgICBwYXVzZVRyYWNraW5nKCk7XG4gICAgY29uc3Qgc2V0dXBSZXN1bHQgPSBjYWxsV2l0aEVycm9ySGFuZGxpbmcoXG4gICAgICBzZXR1cCxcbiAgICAgIGluc3RhbmNlLFxuICAgICAgMCxcbiAgICAgIFshIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gc2hhbGxvd1JlYWRvbmx5KGluc3RhbmNlLnByb3BzKSA6IGluc3RhbmNlLnByb3BzLCBzZXR1cENvbnRleHRdXG4gICAgKTtcbiAgICByZXNldFRyYWNraW5nKCk7XG4gICAgdW5zZXRDdXJyZW50SW5zdGFuY2UoKTtcbiAgICBpZiAoaXNQcm9taXNlKHNldHVwUmVzdWx0KSkge1xuICAgICAgc2V0dXBSZXN1bHQudGhlbih1bnNldEN1cnJlbnRJbnN0YW5jZSwgdW5zZXRDdXJyZW50SW5zdGFuY2UpO1xuICAgICAgaWYgKGlzU1NSKSB7XG4gICAgICAgIHJldHVybiBzZXR1cFJlc3VsdC50aGVuKChyZXNvbHZlZFJlc3VsdCkgPT4ge1xuICAgICAgICAgIGhhbmRsZVNldHVwUmVzdWx0KGluc3RhbmNlLCByZXNvbHZlZFJlc3VsdCwgaXNTU1IpO1xuICAgICAgICB9KS5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgIGhhbmRsZUVycm9yKGUsIGluc3RhbmNlLCAwKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbnN0YW5jZS5hc3luY0RlcCA9IHNldHVwUmVzdWx0O1xuICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhaW5zdGFuY2Uuc3VzcGVuc2UpIHtcbiAgICAgICAgICBjb25zdCBuYW1lID0gKF9hID0gQ29tcG9uZW50Lm5hbWUpICE9IG51bGwgPyBfYSA6IFwiQW5vbnltb3VzXCI7XG4gICAgICAgICAgd2FybihcbiAgICAgICAgICAgIGBDb21wb25lbnQgPCR7bmFtZX0+OiBzZXR1cCBmdW5jdGlvbiByZXR1cm5lZCBhIHByb21pc2UsIGJ1dCBubyA8U3VzcGVuc2U+IGJvdW5kYXJ5IHdhcyBmb3VuZCBpbiB0aGUgcGFyZW50IGNvbXBvbmVudCB0cmVlLiBBIGNvbXBvbmVudCB3aXRoIGFzeW5jIHNldHVwKCkgbXVzdCBiZSBuZXN0ZWQgaW4gYSA8U3VzcGVuc2U+IGluIG9yZGVyIHRvIGJlIHJlbmRlcmVkLmBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGhhbmRsZVNldHVwUmVzdWx0KGluc3RhbmNlLCBzZXR1cFJlc3VsdCwgaXNTU1IpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBmaW5pc2hDb21wb25lbnRTZXR1cChpbnN0YW5jZSwgaXNTU1IpO1xuICB9XG59XG5mdW5jdGlvbiBoYW5kbGVTZXR1cFJlc3VsdChpbnN0YW5jZSwgc2V0dXBSZXN1bHQsIGlzU1NSKSB7XG4gIGlmIChpc0Z1bmN0aW9uKHNldHVwUmVzdWx0KSkge1xuICAgIGlmIChpbnN0YW5jZS50eXBlLl9fc3NySW5saW5lUmVuZGVyKSB7XG4gICAgICBpbnN0YW5jZS5zc3JSZW5kZXIgPSBzZXR1cFJlc3VsdDtcbiAgICB9IGVsc2Uge1xuICAgICAgaW5zdGFuY2UucmVuZGVyID0gc2V0dXBSZXN1bHQ7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KHNldHVwUmVzdWx0KSkge1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGlzVk5vZGUoc2V0dXBSZXN1bHQpKSB7XG4gICAgICB3YXJuKFxuICAgICAgICBgc2V0dXAoKSBzaG91bGQgbm90IHJldHVybiBWTm9kZXMgZGlyZWN0bHkgLSByZXR1cm4gYSByZW5kZXIgZnVuY3Rpb24gaW5zdGVhZC5gXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcbiAgICAgIGluc3RhbmNlLmRldnRvb2xzUmF3U2V0dXBTdGF0ZSA9IHNldHVwUmVzdWx0O1xuICAgIH1cbiAgICBpbnN0YW5jZS5zZXR1cFN0YXRlID0gcHJveHlSZWZzKHNldHVwUmVzdWx0KTtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgZXhwb3NlU2V0dXBTdGF0ZU9uUmVuZGVyQ29udGV4dChpbnN0YW5jZSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgc2V0dXBSZXN1bHQgIT09IHZvaWQgMCkge1xuICAgIHdhcm4oXG4gICAgICBgc2V0dXAoKSBzaG91bGQgcmV0dXJuIGFuIG9iamVjdC4gUmVjZWl2ZWQ6ICR7c2V0dXBSZXN1bHQgPT09IG51bGwgPyBcIm51bGxcIiA6IHR5cGVvZiBzZXR1cFJlc3VsdH1gXG4gICAgKTtcbiAgfVxuICBmaW5pc2hDb21wb25lbnRTZXR1cChpbnN0YW5jZSwgaXNTU1IpO1xufVxubGV0IGNvbXBpbGU7XG5sZXQgaW5zdGFsbFdpdGhQcm94eTtcbmZ1bmN0aW9uIHJlZ2lzdGVyUnVudGltZUNvbXBpbGVyKF9jb21waWxlKSB7XG4gIGNvbXBpbGUgPSBfY29tcGlsZTtcbiAgaW5zdGFsbFdpdGhQcm94eSA9IChpKSA9PiB7XG4gICAgaWYgKGkucmVuZGVyLl9yYykge1xuICAgICAgaS53aXRoUHJveHkgPSBuZXcgUHJveHkoaS5jdHgsIFJ1bnRpbWVDb21waWxlZFB1YmxpY0luc3RhbmNlUHJveHlIYW5kbGVycyk7XG4gICAgfVxuICB9O1xufVxuY29uc3QgaXNSdW50aW1lT25seSA9ICgpID0+ICFjb21waWxlO1xuZnVuY3Rpb24gZmluaXNoQ29tcG9uZW50U2V0dXAoaW5zdGFuY2UsIGlzU1NSLCBza2lwT3B0aW9ucykge1xuICBjb25zdCBDb21wb25lbnQgPSBpbnN0YW5jZS50eXBlO1xuICBpZiAoIWluc3RhbmNlLnJlbmRlcikge1xuICAgIGlmICghaXNTU1IgJiYgY29tcGlsZSAmJiAhQ29tcG9uZW50LnJlbmRlcikge1xuICAgICAgY29uc3QgdGVtcGxhdGUgPSBDb21wb25lbnQudGVtcGxhdGUgfHwgcmVzb2x2ZU1lcmdlZE9wdGlvbnMoaW5zdGFuY2UpLnRlbXBsYXRlO1xuICAgICAgaWYgKHRlbXBsYXRlKSB7XG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgc3RhcnRNZWFzdXJlKGluc3RhbmNlLCBgY29tcGlsZWApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgaXNDdXN0b21FbGVtZW50LCBjb21waWxlck9wdGlvbnMgfSA9IGluc3RhbmNlLmFwcENvbnRleHQuY29uZmlnO1xuICAgICAgICBjb25zdCB7IGRlbGltaXRlcnMsIGNvbXBpbGVyT3B0aW9uczogY29tcG9uZW50Q29tcGlsZXJPcHRpb25zIH0gPSBDb21wb25lbnQ7XG4gICAgICAgIGNvbnN0IGZpbmFsQ29tcGlsZXJPcHRpb25zID0gZXh0ZW5kKFxuICAgICAgICAgIGV4dGVuZChcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgaXNDdXN0b21FbGVtZW50LFxuICAgICAgICAgICAgICBkZWxpbWl0ZXJzXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29tcGlsZXJPcHRpb25zXG4gICAgICAgICAgKSxcbiAgICAgICAgICBjb21wb25lbnRDb21waWxlck9wdGlvbnNcbiAgICAgICAgKTtcbiAgICAgICAgQ29tcG9uZW50LnJlbmRlciA9IGNvbXBpbGUodGVtcGxhdGUsIGZpbmFsQ29tcGlsZXJPcHRpb25zKTtcbiAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICBlbmRNZWFzdXJlKGluc3RhbmNlLCBgY29tcGlsZWApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGluc3RhbmNlLnJlbmRlciA9IENvbXBvbmVudC5yZW5kZXIgfHwgTk9PUDtcbiAgICBpZiAoaW5zdGFsbFdpdGhQcm94eSkge1xuICAgICAgaW5zdGFsbFdpdGhQcm94eShpbnN0YW5jZSk7XG4gICAgfVxuICB9XG4gIGlmIChfX1ZVRV9PUFRJT05TX0FQSV9fICYmIHRydWUpIHtcbiAgICBzZXRDdXJyZW50SW5zdGFuY2UoaW5zdGFuY2UpO1xuICAgIHBhdXNlVHJhY2tpbmcoKTtcbiAgICBhcHBseU9wdGlvbnMoaW5zdGFuY2UpO1xuICAgIHJlc2V0VHJhY2tpbmcoKTtcbiAgICB1bnNldEN1cnJlbnRJbnN0YW5jZSgpO1xuICB9XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICFDb21wb25lbnQucmVuZGVyICYmIGluc3RhbmNlLnJlbmRlciA9PT0gTk9PUCAmJiAhaXNTU1IpIHtcbiAgICBpZiAoIWNvbXBpbGUgJiYgQ29tcG9uZW50LnRlbXBsYXRlKSB7XG4gICAgICB3YXJuKFxuICAgICAgICBgQ29tcG9uZW50IHByb3ZpZGVkIHRlbXBsYXRlIG9wdGlvbiBidXQgcnVudGltZSBjb21waWxhdGlvbiBpcyBub3Qgc3VwcG9ydGVkIGluIHRoaXMgYnVpbGQgb2YgVnVlLmAgKyAoYCBDb25maWd1cmUgeW91ciBidW5kbGVyIHRvIGFsaWFzIFwidnVlXCIgdG8gXCJ2dWUvZGlzdC92dWUuZXNtLWJ1bmRsZXIuanNcIi5gIClcbiAgICAgICAgLyogc2hvdWxkIG5vdCBoYXBwZW4gKi9cbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdhcm4oYENvbXBvbmVudCBpcyBtaXNzaW5nIHRlbXBsYXRlIG9yIHJlbmRlciBmdW5jdGlvbi5gKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGdldEF0dHJzUHJveHkoaW5zdGFuY2UpIHtcbiAgcmV0dXJuIGluc3RhbmNlLmF0dHJzUHJveHkgfHwgKGluc3RhbmNlLmF0dHJzUHJveHkgPSBuZXcgUHJveHkoXG4gICAgaW5zdGFuY2UuYXR0cnMsXG4gICAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IHtcbiAgICAgIGdldCh0YXJnZXQsIGtleSkge1xuICAgICAgICBtYXJrQXR0cnNBY2Nlc3NlZCgpO1xuICAgICAgICB0cmFjayhpbnN0YW5jZSwgXCJnZXRcIiwgXCIkYXR0cnNcIik7XG4gICAgICAgIHJldHVybiB0YXJnZXRba2V5XTtcbiAgICAgIH0sXG4gICAgICBzZXQoKSB7XG4gICAgICAgIHdhcm4oYHNldHVwQ29udGV4dC5hdHRycyBpcyByZWFkb25seS5gKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSxcbiAgICAgIGRlbGV0ZVByb3BlcnR5KCkge1xuICAgICAgICB3YXJuKGBzZXR1cENvbnRleHQuYXR0cnMgaXMgcmVhZG9ubHkuYCk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9IDoge1xuICAgICAgZ2V0KHRhcmdldCwga2V5KSB7XG4gICAgICAgIHRyYWNrKGluc3RhbmNlLCBcImdldFwiLCBcIiRhdHRyc1wiKTtcbiAgICAgICAgcmV0dXJuIHRhcmdldFtrZXldO1xuICAgICAgfVxuICAgIH1cbiAgKSk7XG59XG5mdW5jdGlvbiBnZXRTbG90c1Byb3h5KGluc3RhbmNlKSB7XG4gIHJldHVybiBpbnN0YW5jZS5zbG90c1Byb3h5IHx8IChpbnN0YW5jZS5zbG90c1Byb3h5ID0gbmV3IFByb3h5KGluc3RhbmNlLnNsb3RzLCB7XG4gICAgZ2V0KHRhcmdldCwga2V5KSB7XG4gICAgICB0cmFjayhpbnN0YW5jZSwgXCJnZXRcIiwgXCIkc2xvdHNcIik7XG4gICAgICByZXR1cm4gdGFyZ2V0W2tleV07XG4gICAgfVxuICB9KSk7XG59XG5mdW5jdGlvbiBjcmVhdGVTZXR1cENvbnRleHQoaW5zdGFuY2UpIHtcbiAgY29uc3QgZXhwb3NlID0gKGV4cG9zZWQpID0+IHtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgaWYgKGluc3RhbmNlLmV4cG9zZWQpIHtcbiAgICAgICAgd2FybihgZXhwb3NlKCkgc2hvdWxkIGJlIGNhbGxlZCBvbmx5IG9uY2UgcGVyIHNldHVwKCkuYCk7XG4gICAgICB9XG4gICAgICBpZiAoZXhwb3NlZCAhPSBudWxsKSB7XG4gICAgICAgIGxldCBleHBvc2VkVHlwZSA9IHR5cGVvZiBleHBvc2VkO1xuICAgICAgICBpZiAoZXhwb3NlZFR5cGUgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICBpZiAoaXNBcnJheShleHBvc2VkKSkge1xuICAgICAgICAgICAgZXhwb3NlZFR5cGUgPSBcImFycmF5XCI7XG4gICAgICAgICAgfSBlbHNlIGlmIChpc1JlZihleHBvc2VkKSkge1xuICAgICAgICAgICAgZXhwb3NlZFR5cGUgPSBcInJlZlwiO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZXhwb3NlZFR5cGUgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgYGV4cG9zZSgpIHNob3VsZCBiZSBwYXNzZWQgYSBwbGFpbiBvYmplY3QsIHJlY2VpdmVkICR7ZXhwb3NlZFR5cGV9LmBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGluc3RhbmNlLmV4cG9zZWQgPSBleHBvc2VkIHx8IHt9O1xuICB9O1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIHJldHVybiBPYmplY3QuZnJlZXplKHtcbiAgICAgIGdldCBhdHRycygpIHtcbiAgICAgICAgcmV0dXJuIGdldEF0dHJzUHJveHkoaW5zdGFuY2UpO1xuICAgICAgfSxcbiAgICAgIGdldCBzbG90cygpIHtcbiAgICAgICAgcmV0dXJuIGdldFNsb3RzUHJveHkoaW5zdGFuY2UpO1xuICAgICAgfSxcbiAgICAgIGdldCBlbWl0KCkge1xuICAgICAgICByZXR1cm4gKGV2ZW50LCAuLi5hcmdzKSA9PiBpbnN0YW5jZS5lbWl0KGV2ZW50LCAuLi5hcmdzKTtcbiAgICAgIH0sXG4gICAgICBleHBvc2VcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4ge1xuICAgICAgZ2V0IGF0dHJzKCkge1xuICAgICAgICByZXR1cm4gZ2V0QXR0cnNQcm94eShpbnN0YW5jZSk7XG4gICAgICB9LFxuICAgICAgc2xvdHM6IGluc3RhbmNlLnNsb3RzLFxuICAgICAgZW1pdDogaW5zdGFuY2UuZW1pdCxcbiAgICAgIGV4cG9zZVxuICAgIH07XG4gIH1cbn1cbmZ1bmN0aW9uIGdldEV4cG9zZVByb3h5KGluc3RhbmNlKSB7XG4gIGlmIChpbnN0YW5jZS5leHBvc2VkKSB7XG4gICAgcmV0dXJuIGluc3RhbmNlLmV4cG9zZVByb3h5IHx8IChpbnN0YW5jZS5leHBvc2VQcm94eSA9IG5ldyBQcm94eShwcm94eVJlZnMobWFya1JhdyhpbnN0YW5jZS5leHBvc2VkKSksIHtcbiAgICAgIGdldCh0YXJnZXQsIGtleSkge1xuICAgICAgICBpZiAoa2V5IGluIHRhcmdldCkge1xuICAgICAgICAgIHJldHVybiB0YXJnZXRba2V5XTtcbiAgICAgICAgfSBlbHNlIGlmIChrZXkgaW4gcHVibGljUHJvcGVydGllc01hcCkge1xuICAgICAgICAgIHJldHVybiBwdWJsaWNQcm9wZXJ0aWVzTWFwW2tleV0oaW5zdGFuY2UpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgaGFzKHRhcmdldCwga2V5KSB7XG4gICAgICAgIHJldHVybiBrZXkgaW4gdGFyZ2V0IHx8IGtleSBpbiBwdWJsaWNQcm9wZXJ0aWVzTWFwO1xuICAgICAgfVxuICAgIH0pKTtcbiAgfVxufVxuY29uc3QgY2xhc3NpZnlSRSA9IC8oPzpefFstX10pKFxcdykvZztcbmNvbnN0IGNsYXNzaWZ5ID0gKHN0cikgPT4gc3RyLnJlcGxhY2UoY2xhc3NpZnlSRSwgKGMpID0+IGMudG9VcHBlckNhc2UoKSkucmVwbGFjZSgvWy1fXS9nLCBcIlwiKTtcbmZ1bmN0aW9uIGdldENvbXBvbmVudE5hbWUoQ29tcG9uZW50LCBpbmNsdWRlSW5mZXJyZWQgPSB0cnVlKSB7XG4gIHJldHVybiBpc0Z1bmN0aW9uKENvbXBvbmVudCkgPyBDb21wb25lbnQuZGlzcGxheU5hbWUgfHwgQ29tcG9uZW50Lm5hbWUgOiBDb21wb25lbnQubmFtZSB8fCBpbmNsdWRlSW5mZXJyZWQgJiYgQ29tcG9uZW50Ll9fbmFtZTtcbn1cbmZ1bmN0aW9uIGZvcm1hdENvbXBvbmVudE5hbWUoaW5zdGFuY2UsIENvbXBvbmVudCwgaXNSb290ID0gZmFsc2UpIHtcbiAgbGV0IG5hbWUgPSBnZXRDb21wb25lbnROYW1lKENvbXBvbmVudCk7XG4gIGlmICghbmFtZSAmJiBDb21wb25lbnQuX19maWxlKSB7XG4gICAgY29uc3QgbWF0Y2ggPSBDb21wb25lbnQuX19maWxlLm1hdGNoKC8oW14vXFxcXF0rKVxcLlxcdyskLyk7XG4gICAgaWYgKG1hdGNoKSB7XG4gICAgICBuYW1lID0gbWF0Y2hbMV07XG4gICAgfVxuICB9XG4gIGlmICghbmFtZSAmJiBpbnN0YW5jZSAmJiBpbnN0YW5jZS5wYXJlbnQpIHtcbiAgICBjb25zdCBpbmZlckZyb21SZWdpc3RyeSA9IChyZWdpc3RyeSkgPT4ge1xuICAgICAgZm9yIChjb25zdCBrZXkgaW4gcmVnaXN0cnkpIHtcbiAgICAgICAgaWYgKHJlZ2lzdHJ5W2tleV0gPT09IENvbXBvbmVudCkge1xuICAgICAgICAgIHJldHVybiBrZXk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIG5hbWUgPSBpbmZlckZyb21SZWdpc3RyeShcbiAgICAgIGluc3RhbmNlLmNvbXBvbmVudHMgfHwgaW5zdGFuY2UucGFyZW50LnR5cGUuY29tcG9uZW50c1xuICAgICkgfHwgaW5mZXJGcm9tUmVnaXN0cnkoaW5zdGFuY2UuYXBwQ29udGV4dC5jb21wb25lbnRzKTtcbiAgfVxuICByZXR1cm4gbmFtZSA/IGNsYXNzaWZ5KG5hbWUpIDogaXNSb290ID8gYEFwcGAgOiBgQW5vbnltb3VzYDtcbn1cbmZ1bmN0aW9uIGlzQ2xhc3NDb21wb25lbnQodmFsdWUpIHtcbiAgcmV0dXJuIGlzRnVuY3Rpb24odmFsdWUpICYmIFwiX192Y2NPcHRzXCIgaW4gdmFsdWU7XG59XG5cbmNvbnN0IGNvbXB1dGVkID0gKGdldHRlck9yT3B0aW9ucywgZGVidWdPcHRpb25zKSA9PiB7XG4gIHJldHVybiBjb21wdXRlZCQxKGdldHRlck9yT3B0aW9ucywgZGVidWdPcHRpb25zLCBpc0luU1NSQ29tcG9uZW50U2V0dXApO1xufTtcblxuZnVuY3Rpb24gaCh0eXBlLCBwcm9wc09yQ2hpbGRyZW4sIGNoaWxkcmVuKSB7XG4gIGNvbnN0IGwgPSBhcmd1bWVudHMubGVuZ3RoO1xuICBpZiAobCA9PT0gMikge1xuICAgIGlmIChpc09iamVjdChwcm9wc09yQ2hpbGRyZW4pICYmICFpc0FycmF5KHByb3BzT3JDaGlsZHJlbikpIHtcbiAgICAgIGlmIChpc1ZOb2RlKHByb3BzT3JDaGlsZHJlbikpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVZOb2RlKHR5cGUsIG51bGwsIFtwcm9wc09yQ2hpbGRyZW5dKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjcmVhdGVWTm9kZSh0eXBlLCBwcm9wc09yQ2hpbGRyZW4pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gY3JlYXRlVk5vZGUodHlwZSwgbnVsbCwgcHJvcHNPckNoaWxkcmVuKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGwgPiAzKSB7XG4gICAgICBjaGlsZHJlbiA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XG4gICAgfSBlbHNlIGlmIChsID09PSAzICYmIGlzVk5vZGUoY2hpbGRyZW4pKSB7XG4gICAgICBjaGlsZHJlbiA9IFtjaGlsZHJlbl07XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVWTm9kZSh0eXBlLCBwcm9wc09yQ2hpbGRyZW4sIGNoaWxkcmVuKTtcbiAgfVxufVxuXG5jb25zdCBzc3JDb250ZXh0S2V5ID0gU3ltYm9sLmZvcihcInYtc2N4XCIpO1xuY29uc3QgdXNlU1NSQ29udGV4dCA9ICgpID0+IHtcbiAge1xuICAgIGNvbnN0IGN0eCA9IGluamVjdChzc3JDb250ZXh0S2V5KTtcbiAgICBpZiAoIWN0eCkge1xuICAgICAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiB3YXJuKFxuICAgICAgICBgU2VydmVyIHJlbmRlcmluZyBjb250ZXh0IG5vdCBwcm92aWRlZC4gTWFrZSBzdXJlIHRvIG9ubHkgY2FsbCB1c2VTU1JDb250ZXh0KCkgY29uZGl0aW9uYWxseSBpbiB0aGUgc2VydmVyIGJ1aWxkLmBcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBjdHg7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGlzU2hhbGxvdyh2YWx1ZSkge1xuICByZXR1cm4gISEodmFsdWUgJiYgdmFsdWVbXCJfX3ZfaXNTaGFsbG93XCJdKTtcbn1cblxuZnVuY3Rpb24gaW5pdEN1c3RvbUZvcm1hdHRlcigpIHtcbiAgaWYgKCEhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHx8IHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgdnVlU3R5bGUgPSB7IHN0eWxlOiBcImNvbG9yOiMzYmE3NzZcIiB9O1xuICBjb25zdCBudW1iZXJTdHlsZSA9IHsgc3R5bGU6IFwiY29sb3I6IzBiMWJjOVwiIH07XG4gIGNvbnN0IHN0cmluZ1N0eWxlID0geyBzdHlsZTogXCJjb2xvcjojYjYyZTI0XCIgfTtcbiAgY29uc3Qga2V5d29yZFN0eWxlID0geyBzdHlsZTogXCJjb2xvcjojOWQyODhjXCIgfTtcbiAgY29uc3QgZm9ybWF0dGVyID0ge1xuICAgIGhlYWRlcihvYmopIHtcbiAgICAgIGlmICghaXNPYmplY3Qob2JqKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmIChvYmouX19pc1Z1ZSkge1xuICAgICAgICByZXR1cm4gW1wiZGl2XCIsIHZ1ZVN0eWxlLCBgVnVlSW5zdGFuY2VgXTtcbiAgICAgIH0gZWxzZSBpZiAoaXNSZWYob2JqKSkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgIFwiZGl2XCIsXG4gICAgICAgICAge30sXG4gICAgICAgICAgW1wic3BhblwiLCB2dWVTdHlsZSwgZ2VuUmVmRmxhZyhvYmopXSxcbiAgICAgICAgICBcIjxcIixcbiAgICAgICAgICBmb3JtYXRWYWx1ZShvYmoudmFsdWUpLFxuICAgICAgICAgIGA+YFxuICAgICAgICBdO1xuICAgICAgfSBlbHNlIGlmIChpc1JlYWN0aXZlKG9iaikpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICBcImRpdlwiLFxuICAgICAgICAgIHt9LFxuICAgICAgICAgIFtcInNwYW5cIiwgdnVlU3R5bGUsIGlzU2hhbGxvdyhvYmopID8gXCJTaGFsbG93UmVhY3RpdmVcIiA6IFwiUmVhY3RpdmVcIl0sXG4gICAgICAgICAgXCI8XCIsXG4gICAgICAgICAgZm9ybWF0VmFsdWUob2JqKSxcbiAgICAgICAgICBgPiR7aXNSZWFkb25seShvYmopID8gYCAocmVhZG9ubHkpYCA6IGBgfWBcbiAgICAgICAgXTtcbiAgICAgIH0gZWxzZSBpZiAoaXNSZWFkb25seShvYmopKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgXCJkaXZcIixcbiAgICAgICAgICB7fSxcbiAgICAgICAgICBbXCJzcGFuXCIsIHZ1ZVN0eWxlLCBpc1NoYWxsb3cob2JqKSA/IFwiU2hhbGxvd1JlYWRvbmx5XCIgOiBcIlJlYWRvbmx5XCJdLFxuICAgICAgICAgIFwiPFwiLFxuICAgICAgICAgIGZvcm1hdFZhbHVlKG9iaiksXG4gICAgICAgICAgXCI+XCJcbiAgICAgICAgXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG4gICAgaGFzQm9keShvYmopIHtcbiAgICAgIHJldHVybiBvYmogJiYgb2JqLl9faXNWdWU7XG4gICAgfSxcbiAgICBib2R5KG9iaikge1xuICAgICAgaWYgKG9iaiAmJiBvYmouX19pc1Z1ZSkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgIFwiZGl2XCIsXG4gICAgICAgICAge30sXG4gICAgICAgICAgLi4uZm9ybWF0SW5zdGFuY2Uob2JqLiQpXG4gICAgICAgIF07XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBmdW5jdGlvbiBmb3JtYXRJbnN0YW5jZShpbnN0YW5jZSkge1xuICAgIGNvbnN0IGJsb2NrcyA9IFtdO1xuICAgIGlmIChpbnN0YW5jZS50eXBlLnByb3BzICYmIGluc3RhbmNlLnByb3BzKSB7XG4gICAgICBibG9ja3MucHVzaChjcmVhdGVJbnN0YW5jZUJsb2NrKFwicHJvcHNcIiwgdG9SYXcoaW5zdGFuY2UucHJvcHMpKSk7XG4gICAgfVxuICAgIGlmIChpbnN0YW5jZS5zZXR1cFN0YXRlICE9PSBFTVBUWV9PQkopIHtcbiAgICAgIGJsb2Nrcy5wdXNoKGNyZWF0ZUluc3RhbmNlQmxvY2soXCJzZXR1cFwiLCBpbnN0YW5jZS5zZXR1cFN0YXRlKSk7XG4gICAgfVxuICAgIGlmIChpbnN0YW5jZS5kYXRhICE9PSBFTVBUWV9PQkopIHtcbiAgICAgIGJsb2Nrcy5wdXNoKGNyZWF0ZUluc3RhbmNlQmxvY2soXCJkYXRhXCIsIHRvUmF3KGluc3RhbmNlLmRhdGEpKSk7XG4gICAgfVxuICAgIGNvbnN0IGNvbXB1dGVkID0gZXh0cmFjdEtleXMoaW5zdGFuY2UsIFwiY29tcHV0ZWRcIik7XG4gICAgaWYgKGNvbXB1dGVkKSB7XG4gICAgICBibG9ja3MucHVzaChjcmVhdGVJbnN0YW5jZUJsb2NrKFwiY29tcHV0ZWRcIiwgY29tcHV0ZWQpKTtcbiAgICB9XG4gICAgY29uc3QgaW5qZWN0ZWQgPSBleHRyYWN0S2V5cyhpbnN0YW5jZSwgXCJpbmplY3RcIik7XG4gICAgaWYgKGluamVjdGVkKSB7XG4gICAgICBibG9ja3MucHVzaChjcmVhdGVJbnN0YW5jZUJsb2NrKFwiaW5qZWN0ZWRcIiwgaW5qZWN0ZWQpKTtcbiAgICB9XG4gICAgYmxvY2tzLnB1c2goW1xuICAgICAgXCJkaXZcIixcbiAgICAgIHt9LFxuICAgICAgW1xuICAgICAgICBcInNwYW5cIixcbiAgICAgICAge1xuICAgICAgICAgIHN0eWxlOiBrZXl3b3JkU3R5bGUuc3R5bGUgKyBcIjtvcGFjaXR5OjAuNjZcIlxuICAgICAgICB9LFxuICAgICAgICBcIiQgKGludGVybmFsKTogXCJcbiAgICAgIF0sXG4gICAgICBbXCJvYmplY3RcIiwgeyBvYmplY3Q6IGluc3RhbmNlIH1dXG4gICAgXSk7XG4gICAgcmV0dXJuIGJsb2NrcztcbiAgfVxuICBmdW5jdGlvbiBjcmVhdGVJbnN0YW5jZUJsb2NrKHR5cGUsIHRhcmdldCkge1xuICAgIHRhcmdldCA9IGV4dGVuZCh7fSwgdGFyZ2V0KTtcbiAgICBpZiAoIU9iamVjdC5rZXlzKHRhcmdldCkubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gW1wic3BhblwiLCB7fV07XG4gICAgfVxuICAgIHJldHVybiBbXG4gICAgICBcImRpdlwiLFxuICAgICAgeyBzdHlsZTogXCJsaW5lLWhlaWdodDoxLjI1ZW07bWFyZ2luLWJvdHRvbTowLjZlbVwiIH0sXG4gICAgICBbXG4gICAgICAgIFwiZGl2XCIsXG4gICAgICAgIHtcbiAgICAgICAgICBzdHlsZTogXCJjb2xvcjojNDc2NTgyXCJcbiAgICAgICAgfSxcbiAgICAgICAgdHlwZVxuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgXCJkaXZcIixcbiAgICAgICAge1xuICAgICAgICAgIHN0eWxlOiBcInBhZGRpbmctbGVmdDoxLjI1ZW1cIlxuICAgICAgICB9LFxuICAgICAgICAuLi5PYmplY3Qua2V5cyh0YXJnZXQpLm1hcCgoa2V5KSA9PiB7XG4gICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIFwiZGl2XCIsXG4gICAgICAgICAgICB7fSxcbiAgICAgICAgICAgIFtcInNwYW5cIiwga2V5d29yZFN0eWxlLCBrZXkgKyBcIjogXCJdLFxuICAgICAgICAgICAgZm9ybWF0VmFsdWUodGFyZ2V0W2tleV0sIGZhbHNlKVxuICAgICAgICAgIF07XG4gICAgICAgIH0pXG4gICAgICBdXG4gICAgXTtcbiAgfVxuICBmdW5jdGlvbiBmb3JtYXRWYWx1ZSh2LCBhc1JhdyA9IHRydWUpIHtcbiAgICBpZiAodHlwZW9mIHYgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHJldHVybiBbXCJzcGFuXCIsIG51bWJlclN0eWxlLCB2XTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB2ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICByZXR1cm4gW1wic3BhblwiLCBzdHJpbmdTdHlsZSwgSlNPTi5zdHJpbmdpZnkodildO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHYgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICByZXR1cm4gW1wic3BhblwiLCBrZXl3b3JkU3R5bGUsIHZdO1xuICAgIH0gZWxzZSBpZiAoaXNPYmplY3QodikpIHtcbiAgICAgIHJldHVybiBbXCJvYmplY3RcIiwgeyBvYmplY3Q6IGFzUmF3ID8gdG9SYXcodikgOiB2IH1dO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gW1wic3BhblwiLCBzdHJpbmdTdHlsZSwgU3RyaW5nKHYpXTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZXh0cmFjdEtleXMoaW5zdGFuY2UsIHR5cGUpIHtcbiAgICBjb25zdCBDb21wID0gaW5zdGFuY2UudHlwZTtcbiAgICBpZiAoaXNGdW5jdGlvbihDb21wKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBleHRyYWN0ZWQgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBpbnN0YW5jZS5jdHgpIHtcbiAgICAgIGlmIChpc0tleU9mVHlwZShDb21wLCBrZXksIHR5cGUpKSB7XG4gICAgICAgIGV4dHJhY3RlZFtrZXldID0gaW5zdGFuY2UuY3R4W2tleV07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBleHRyYWN0ZWQ7XG4gIH1cbiAgZnVuY3Rpb24gaXNLZXlPZlR5cGUoQ29tcCwga2V5LCB0eXBlKSB7XG4gICAgY29uc3Qgb3B0cyA9IENvbXBbdHlwZV07XG4gICAgaWYgKGlzQXJyYXkob3B0cykgJiYgb3B0cy5pbmNsdWRlcyhrZXkpIHx8IGlzT2JqZWN0KG9wdHMpICYmIGtleSBpbiBvcHRzKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKENvbXAuZXh0ZW5kcyAmJiBpc0tleU9mVHlwZShDb21wLmV4dGVuZHMsIGtleSwgdHlwZSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoQ29tcC5taXhpbnMgJiYgQ29tcC5taXhpbnMuc29tZSgobSkgPT4gaXNLZXlPZlR5cGUobSwga2V5LCB0eXBlKSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBnZW5SZWZGbGFnKHYpIHtcbiAgICBpZiAoaXNTaGFsbG93KHYpKSB7XG4gICAgICByZXR1cm4gYFNoYWxsb3dSZWZgO1xuICAgIH1cbiAgICBpZiAodi5lZmZlY3QpIHtcbiAgICAgIHJldHVybiBgQ29tcHV0ZWRSZWZgO1xuICAgIH1cbiAgICByZXR1cm4gYFJlZmA7XG4gIH1cbiAgaWYgKHdpbmRvdy5kZXZ0b29sc0Zvcm1hdHRlcnMpIHtcbiAgICB3aW5kb3cuZGV2dG9vbHNGb3JtYXR0ZXJzLnB1c2goZm9ybWF0dGVyKTtcbiAgfSBlbHNlIHtcbiAgICB3aW5kb3cuZGV2dG9vbHNGb3JtYXR0ZXJzID0gW2Zvcm1hdHRlcl07XG4gIH1cbn1cblxuZnVuY3Rpb24gd2l0aE1lbW8obWVtbywgcmVuZGVyLCBjYWNoZSwgaW5kZXgpIHtcbiAgY29uc3QgY2FjaGVkID0gY2FjaGVbaW5kZXhdO1xuICBpZiAoY2FjaGVkICYmIGlzTWVtb1NhbWUoY2FjaGVkLCBtZW1vKSkge1xuICAgIHJldHVybiBjYWNoZWQ7XG4gIH1cbiAgY29uc3QgcmV0ID0gcmVuZGVyKCk7XG4gIHJldC5tZW1vID0gbWVtby5zbGljZSgpO1xuICByZXR1cm4gY2FjaGVbaW5kZXhdID0gcmV0O1xufVxuZnVuY3Rpb24gaXNNZW1vU2FtZShjYWNoZWQsIG1lbW8pIHtcbiAgY29uc3QgcHJldiA9IGNhY2hlZC5tZW1vO1xuICBpZiAocHJldi5sZW5ndGggIT0gbWVtby5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcmV2Lmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGhhc0NoYW5nZWQocHJldltpXSwgbWVtb1tpXSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgaWYgKGlzQmxvY2tUcmVlRW5hYmxlZCA+IDAgJiYgY3VycmVudEJsb2NrKSB7XG4gICAgY3VycmVudEJsb2NrLnB1c2goY2FjaGVkKTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuY29uc3QgdmVyc2lvbiA9IFwiMy4zLjRcIjtcbmNvbnN0IF9zc3JVdGlscyA9IHtcbiAgY3JlYXRlQ29tcG9uZW50SW5zdGFuY2UsXG4gIHNldHVwQ29tcG9uZW50LFxuICByZW5kZXJDb21wb25lbnRSb290LFxuICBzZXRDdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UsXG4gIGlzVk5vZGU6IGlzVk5vZGUsXG4gIG5vcm1hbGl6ZVZOb2RlXG59O1xuY29uc3Qgc3NyVXRpbHMgPSBfc3NyVXRpbHMgO1xuY29uc3QgcmVzb2x2ZUZpbHRlciA9IG51bGw7XG5jb25zdCBjb21wYXRVdGlscyA9IG51bGw7XG5cbmV4cG9ydCB7IEJhc2VUcmFuc2l0aW9uLCBCYXNlVHJhbnNpdGlvblByb3BzVmFsaWRhdG9ycywgQ29tbWVudCwgRnJhZ21lbnQsIEtlZXBBbGl2ZSwgU3RhdGljLCBTdXNwZW5zZSwgVGVsZXBvcnQsIFRleHQsIGFzc2VydE51bWJlciwgY2FsbFdpdGhBc3luY0Vycm9ySGFuZGxpbmcsIGNhbGxXaXRoRXJyb3JIYW5kbGluZywgY2xvbmVWTm9kZSwgY29tcGF0VXRpbHMsIGNvbXB1dGVkLCBjcmVhdGVCbG9jaywgY3JlYXRlQ29tbWVudFZOb2RlLCBjcmVhdGVFbGVtZW50QmxvY2ssIGNyZWF0ZUJhc2VWTm9kZSBhcyBjcmVhdGVFbGVtZW50Vk5vZGUsIGNyZWF0ZUh5ZHJhdGlvblJlbmRlcmVyLCBjcmVhdGVQcm9wc1Jlc3RQcm94eSwgY3JlYXRlUmVuZGVyZXIsIGNyZWF0ZVNsb3RzLCBjcmVhdGVTdGF0aWNWTm9kZSwgY3JlYXRlVGV4dFZOb2RlLCBjcmVhdGVWTm9kZSwgZGVmaW5lQXN5bmNDb21wb25lbnQsIGRlZmluZUNvbXBvbmVudCwgZGVmaW5lRW1pdHMsIGRlZmluZUV4cG9zZSwgZGVmaW5lTW9kZWwsIGRlZmluZU9wdGlvbnMsIGRlZmluZVByb3BzLCBkZWZpbmVTbG90cywgZGV2dG9vbHMsIGdldEN1cnJlbnRJbnN0YW5jZSwgZ2V0VHJhbnNpdGlvblJhd0NoaWxkcmVuLCBndWFyZFJlYWN0aXZlUHJvcHMsIGgsIGhhbmRsZUVycm9yLCBoYXNJbmplY3Rpb25Db250ZXh0LCBpbml0Q3VzdG9tRm9ybWF0dGVyLCBpbmplY3QsIGlzTWVtb1NhbWUsIGlzUnVudGltZU9ubHksIGlzVk5vZGUsIG1lcmdlRGVmYXVsdHMsIG1lcmdlTW9kZWxzLCBtZXJnZVByb3BzLCBuZXh0VGljaywgb25BY3RpdmF0ZWQsIG9uQmVmb3JlTW91bnQsIG9uQmVmb3JlVW5tb3VudCwgb25CZWZvcmVVcGRhdGUsIG9uRGVhY3RpdmF0ZWQsIG9uRXJyb3JDYXB0dXJlZCwgb25Nb3VudGVkLCBvblJlbmRlclRyYWNrZWQsIG9uUmVuZGVyVHJpZ2dlcmVkLCBvblNlcnZlclByZWZldGNoLCBvblVubW91bnRlZCwgb25VcGRhdGVkLCBvcGVuQmxvY2ssIHBvcFNjb3BlSWQsIHByb3ZpZGUsIHB1c2hTY29wZUlkLCBxdWV1ZVBvc3RGbHVzaENiLCByZWdpc3RlclJ1bnRpbWVDb21waWxlciwgcmVuZGVyTGlzdCwgcmVuZGVyU2xvdCwgcmVzb2x2ZUNvbXBvbmVudCwgcmVzb2x2ZURpcmVjdGl2ZSwgcmVzb2x2ZUR5bmFtaWNDb21wb25lbnQsIHJlc29sdmVGaWx0ZXIsIHJlc29sdmVUcmFuc2l0aW9uSG9va3MsIHNldEJsb2NrVHJhY2tpbmcsIHNldERldnRvb2xzSG9vaywgc2V0VHJhbnNpdGlvbkhvb2tzLCBzc3JDb250ZXh0S2V5LCBzc3JVdGlscywgdG9IYW5kbGVycywgdHJhbnNmb3JtVk5vZGVBcmdzLCB1c2VBdHRycywgdXNlTW9kZWwsIHVzZVNTUkNvbnRleHQsIHVzZVNsb3RzLCB1c2VUcmFuc2l0aW9uU3RhdGUsIHZlcnNpb24sIHdhcm4sIHdhdGNoLCB3YXRjaEVmZmVjdCwgd2F0Y2hQb3N0RWZmZWN0LCB3YXRjaFN5bmNFZmZlY3QsIHdpdGhBc3luY0NvbnRleHQsIHdpdGhDdHgsIHdpdGhEZWZhdWx0cywgd2l0aERpcmVjdGl2ZXMsIHdpdGhNZW1vLCB3aXRoU2NvcGVJZCB9O1xuIiwiaW1wb3J0IHsgZXh0ZW5kLCBpc0FycmF5LCBpc01hcCwgaXNJbnRlZ2VyS2V5LCBoYXNPd24sIGlzU3ltYm9sLCBpc09iamVjdCwgaGFzQ2hhbmdlZCwgbWFrZU1hcCwgY2FwaXRhbGl6ZSwgdG9SYXdUeXBlLCBkZWYsIGlzRnVuY3Rpb24sIE5PT1AgfSBmcm9tICdAdnVlL3NoYXJlZCc7XG5cbmZ1bmN0aW9uIHdhcm4obXNnLCAuLi5hcmdzKSB7XG4gIGNvbnNvbGUud2FybihgW1Z1ZSB3YXJuXSAke21zZ31gLCAuLi5hcmdzKTtcbn1cblxubGV0IGFjdGl2ZUVmZmVjdFNjb3BlO1xuY2xhc3MgRWZmZWN0U2NvcGUge1xuICBjb25zdHJ1Y3RvcihkZXRhY2hlZCA9IGZhbHNlKSB7XG4gICAgdGhpcy5kZXRhY2hlZCA9IGRldGFjaGVkO1xuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHRoaXMuX2FjdGl2ZSA9IHRydWU7XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgdGhpcy5lZmZlY3RzID0gW107XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgdGhpcy5jbGVhbnVwcyA9IFtdO1xuICAgIHRoaXMucGFyZW50ID0gYWN0aXZlRWZmZWN0U2NvcGU7XG4gICAgaWYgKCFkZXRhY2hlZCAmJiBhY3RpdmVFZmZlY3RTY29wZSkge1xuICAgICAgdGhpcy5pbmRleCA9IChhY3RpdmVFZmZlY3RTY29wZS5zY29wZXMgfHwgKGFjdGl2ZUVmZmVjdFNjb3BlLnNjb3BlcyA9IFtdKSkucHVzaChcbiAgICAgICAgdGhpc1xuICAgICAgKSAtIDE7XG4gICAgfVxuICB9XG4gIGdldCBhY3RpdmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FjdGl2ZTtcbiAgfVxuICBydW4oZm4pIHtcbiAgICBpZiAodGhpcy5fYWN0aXZlKSB7XG4gICAgICBjb25zdCBjdXJyZW50RWZmZWN0U2NvcGUgPSBhY3RpdmVFZmZlY3RTY29wZTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGFjdGl2ZUVmZmVjdFNjb3BlID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGZuKCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBhY3RpdmVFZmZlY3RTY29wZSA9IGN1cnJlbnRFZmZlY3RTY29wZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgIHdhcm4oYGNhbm5vdCBydW4gYW4gaW5hY3RpdmUgZWZmZWN0IHNjb3BlLmApO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogVGhpcyBzaG91bGQgb25seSBiZSBjYWxsZWQgb24gbm9uLWRldGFjaGVkIHNjb3Blc1xuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIG9uKCkge1xuICAgIGFjdGl2ZUVmZmVjdFNjb3BlID0gdGhpcztcbiAgfVxuICAvKipcbiAgICogVGhpcyBzaG91bGQgb25seSBiZSBjYWxsZWQgb24gbm9uLWRldGFjaGVkIHNjb3Blc1xuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIG9mZigpIHtcbiAgICBhY3RpdmVFZmZlY3RTY29wZSA9IHRoaXMucGFyZW50O1xuICB9XG4gIHN0b3AoZnJvbVBhcmVudCkge1xuICAgIGlmICh0aGlzLl9hY3RpdmUpIHtcbiAgICAgIGxldCBpLCBsO1xuICAgICAgZm9yIChpID0gMCwgbCA9IHRoaXMuZWZmZWN0cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdGhpcy5lZmZlY3RzW2ldLnN0b3AoKTtcbiAgICAgIH1cbiAgICAgIGZvciAoaSA9IDAsIGwgPSB0aGlzLmNsZWFudXBzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB0aGlzLmNsZWFudXBzW2ldKCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5zY29wZXMpIHtcbiAgICAgICAgZm9yIChpID0gMCwgbCA9IHRoaXMuc2NvcGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIHRoaXMuc2NvcGVzW2ldLnN0b3AodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5kZXRhY2hlZCAmJiB0aGlzLnBhcmVudCAmJiAhZnJvbVBhcmVudCkge1xuICAgICAgICBjb25zdCBsYXN0ID0gdGhpcy5wYXJlbnQuc2NvcGVzLnBvcCgpO1xuICAgICAgICBpZiAobGFzdCAmJiBsYXN0ICE9PSB0aGlzKSB7XG4gICAgICAgICAgdGhpcy5wYXJlbnQuc2NvcGVzW3RoaXMuaW5kZXhdID0gbGFzdDtcbiAgICAgICAgICBsYXN0LmluZGV4ID0gdGhpcy5pbmRleDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5wYXJlbnQgPSB2b2lkIDA7XG4gICAgICB0aGlzLl9hY3RpdmUgPSBmYWxzZTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGVmZmVjdFNjb3BlKGRldGFjaGVkKSB7XG4gIHJldHVybiBuZXcgRWZmZWN0U2NvcGUoZGV0YWNoZWQpO1xufVxuZnVuY3Rpb24gcmVjb3JkRWZmZWN0U2NvcGUoZWZmZWN0LCBzY29wZSA9IGFjdGl2ZUVmZmVjdFNjb3BlKSB7XG4gIGlmIChzY29wZSAmJiBzY29wZS5hY3RpdmUpIHtcbiAgICBzY29wZS5lZmZlY3RzLnB1c2goZWZmZWN0KTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0Q3VycmVudFNjb3BlKCkge1xuICByZXR1cm4gYWN0aXZlRWZmZWN0U2NvcGU7XG59XG5mdW5jdGlvbiBvblNjb3BlRGlzcG9zZShmbikge1xuICBpZiAoYWN0aXZlRWZmZWN0U2NvcGUpIHtcbiAgICBhY3RpdmVFZmZlY3RTY29wZS5jbGVhbnVwcy5wdXNoKGZuKTtcbiAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgd2FybihcbiAgICAgIGBvblNjb3BlRGlzcG9zZSgpIGlzIGNhbGxlZCB3aGVuIHRoZXJlIGlzIG5vIGFjdGl2ZSBlZmZlY3Qgc2NvcGUgdG8gYmUgYXNzb2NpYXRlZCB3aXRoLmBcbiAgICApO1xuICB9XG59XG5cbmNvbnN0IGNyZWF0ZURlcCA9IChlZmZlY3RzKSA9PiB7XG4gIGNvbnN0IGRlcCA9IG5ldyBTZXQoZWZmZWN0cyk7XG4gIGRlcC53ID0gMDtcbiAgZGVwLm4gPSAwO1xuICByZXR1cm4gZGVwO1xufTtcbmNvbnN0IHdhc1RyYWNrZWQgPSAoZGVwKSA9PiAoZGVwLncgJiB0cmFja09wQml0KSA+IDA7XG5jb25zdCBuZXdUcmFja2VkID0gKGRlcCkgPT4gKGRlcC5uICYgdHJhY2tPcEJpdCkgPiAwO1xuY29uc3QgaW5pdERlcE1hcmtlcnMgPSAoeyBkZXBzIH0pID0+IHtcbiAgaWYgKGRlcHMubGVuZ3RoKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkZXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBkZXBzW2ldLncgfD0gdHJhY2tPcEJpdDtcbiAgICB9XG4gIH1cbn07XG5jb25zdCBmaW5hbGl6ZURlcE1hcmtlcnMgPSAoZWZmZWN0KSA9PiB7XG4gIGNvbnN0IHsgZGVwcyB9ID0gZWZmZWN0O1xuICBpZiAoZGVwcy5sZW5ndGgpIHtcbiAgICBsZXQgcHRyID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRlcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGRlcCA9IGRlcHNbaV07XG4gICAgICBpZiAod2FzVHJhY2tlZChkZXApICYmICFuZXdUcmFja2VkKGRlcCkpIHtcbiAgICAgICAgZGVwLmRlbGV0ZShlZmZlY3QpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVwc1twdHIrK10gPSBkZXA7XG4gICAgICB9XG4gICAgICBkZXAudyAmPSB+dHJhY2tPcEJpdDtcbiAgICAgIGRlcC5uICY9IH50cmFja09wQml0O1xuICAgIH1cbiAgICBkZXBzLmxlbmd0aCA9IHB0cjtcbiAgfVxufTtcblxuY29uc3QgdGFyZ2V0TWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG5sZXQgZWZmZWN0VHJhY2tEZXB0aCA9IDA7XG5sZXQgdHJhY2tPcEJpdCA9IDE7XG5jb25zdCBtYXhNYXJrZXJCaXRzID0gMzA7XG5sZXQgYWN0aXZlRWZmZWN0O1xuY29uc3QgSVRFUkFURV9LRVkgPSBTeW1ib2woISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IFwiaXRlcmF0ZVwiIDogXCJcIik7XG5jb25zdCBNQVBfS0VZX0lURVJBVEVfS0VZID0gU3ltYm9sKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyBcIk1hcCBrZXkgaXRlcmF0ZVwiIDogXCJcIik7XG5jbGFzcyBSZWFjdGl2ZUVmZmVjdCB7XG4gIGNvbnN0cnVjdG9yKGZuLCBzY2hlZHVsZXIgPSBudWxsLCBzY29wZSkge1xuICAgIHRoaXMuZm4gPSBmbjtcbiAgICB0aGlzLnNjaGVkdWxlciA9IHNjaGVkdWxlcjtcbiAgICB0aGlzLmFjdGl2ZSA9IHRydWU7XG4gICAgdGhpcy5kZXBzID0gW107XG4gICAgdGhpcy5wYXJlbnQgPSB2b2lkIDA7XG4gICAgcmVjb3JkRWZmZWN0U2NvcGUodGhpcywgc2NvcGUpO1xuICB9XG4gIHJ1bigpIHtcbiAgICBpZiAoIXRoaXMuYWN0aXZlKSB7XG4gICAgICByZXR1cm4gdGhpcy5mbigpO1xuICAgIH1cbiAgICBsZXQgcGFyZW50ID0gYWN0aXZlRWZmZWN0O1xuICAgIGxldCBsYXN0U2hvdWxkVHJhY2sgPSBzaG91bGRUcmFjaztcbiAgICB3aGlsZSAocGFyZW50KSB7XG4gICAgICBpZiAocGFyZW50ID09PSB0aGlzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICB0aGlzLnBhcmVudCA9IGFjdGl2ZUVmZmVjdDtcbiAgICAgIGFjdGl2ZUVmZmVjdCA9IHRoaXM7XG4gICAgICBzaG91bGRUcmFjayA9IHRydWU7XG4gICAgICB0cmFja09wQml0ID0gMSA8PCArK2VmZmVjdFRyYWNrRGVwdGg7XG4gICAgICBpZiAoZWZmZWN0VHJhY2tEZXB0aCA8PSBtYXhNYXJrZXJCaXRzKSB7XG4gICAgICAgIGluaXREZXBNYXJrZXJzKHRoaXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2xlYW51cEVmZmVjdCh0aGlzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmZuKCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmIChlZmZlY3RUcmFja0RlcHRoIDw9IG1heE1hcmtlckJpdHMpIHtcbiAgICAgICAgZmluYWxpemVEZXBNYXJrZXJzKHRoaXMpO1xuICAgICAgfVxuICAgICAgdHJhY2tPcEJpdCA9IDEgPDwgLS1lZmZlY3RUcmFja0RlcHRoO1xuICAgICAgYWN0aXZlRWZmZWN0ID0gdGhpcy5wYXJlbnQ7XG4gICAgICBzaG91bGRUcmFjayA9IGxhc3RTaG91bGRUcmFjaztcbiAgICAgIHRoaXMucGFyZW50ID0gdm9pZCAwO1xuICAgICAgaWYgKHRoaXMuZGVmZXJTdG9wKSB7XG4gICAgICAgIHRoaXMuc3RvcCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBzdG9wKCkge1xuICAgIGlmIChhY3RpdmVFZmZlY3QgPT09IHRoaXMpIHtcbiAgICAgIHRoaXMuZGVmZXJTdG9wID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuYWN0aXZlKSB7XG4gICAgICBjbGVhbnVwRWZmZWN0KHRoaXMpO1xuICAgICAgaWYgKHRoaXMub25TdG9wKSB7XG4gICAgICAgIHRoaXMub25TdG9wKCk7XG4gICAgICB9XG4gICAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gY2xlYW51cEVmZmVjdChlZmZlY3QyKSB7XG4gIGNvbnN0IHsgZGVwcyB9ID0gZWZmZWN0MjtcbiAgaWYgKGRlcHMubGVuZ3RoKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkZXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBkZXBzW2ldLmRlbGV0ZShlZmZlY3QyKTtcbiAgICB9XG4gICAgZGVwcy5sZW5ndGggPSAwO1xuICB9XG59XG5mdW5jdGlvbiBlZmZlY3QoZm4sIG9wdGlvbnMpIHtcbiAgaWYgKGZuLmVmZmVjdCkge1xuICAgIGZuID0gZm4uZWZmZWN0LmZuO1xuICB9XG4gIGNvbnN0IF9lZmZlY3QgPSBuZXcgUmVhY3RpdmVFZmZlY3QoZm4pO1xuICBpZiAob3B0aW9ucykge1xuICAgIGV4dGVuZChfZWZmZWN0LCBvcHRpb25zKTtcbiAgICBpZiAob3B0aW9ucy5zY29wZSlcbiAgICAgIHJlY29yZEVmZmVjdFNjb3BlKF9lZmZlY3QsIG9wdGlvbnMuc2NvcGUpO1xuICB9XG4gIGlmICghb3B0aW9ucyB8fCAhb3B0aW9ucy5sYXp5KSB7XG4gICAgX2VmZmVjdC5ydW4oKTtcbiAgfVxuICBjb25zdCBydW5uZXIgPSBfZWZmZWN0LnJ1bi5iaW5kKF9lZmZlY3QpO1xuICBydW5uZXIuZWZmZWN0ID0gX2VmZmVjdDtcbiAgcmV0dXJuIHJ1bm5lcjtcbn1cbmZ1bmN0aW9uIHN0b3AocnVubmVyKSB7XG4gIHJ1bm5lci5lZmZlY3Quc3RvcCgpO1xufVxubGV0IHNob3VsZFRyYWNrID0gdHJ1ZTtcbmNvbnN0IHRyYWNrU3RhY2sgPSBbXTtcbmZ1bmN0aW9uIHBhdXNlVHJhY2tpbmcoKSB7XG4gIHRyYWNrU3RhY2sucHVzaChzaG91bGRUcmFjayk7XG4gIHNob3VsZFRyYWNrID0gZmFsc2U7XG59XG5mdW5jdGlvbiBlbmFibGVUcmFja2luZygpIHtcbiAgdHJhY2tTdGFjay5wdXNoKHNob3VsZFRyYWNrKTtcbiAgc2hvdWxkVHJhY2sgPSB0cnVlO1xufVxuZnVuY3Rpb24gcmVzZXRUcmFja2luZygpIHtcbiAgY29uc3QgbGFzdCA9IHRyYWNrU3RhY2sucG9wKCk7XG4gIHNob3VsZFRyYWNrID0gbGFzdCA9PT0gdm9pZCAwID8gdHJ1ZSA6IGxhc3Q7XG59XG5mdW5jdGlvbiB0cmFjayh0YXJnZXQsIHR5cGUsIGtleSkge1xuICBpZiAoc2hvdWxkVHJhY2sgJiYgYWN0aXZlRWZmZWN0KSB7XG4gICAgbGV0IGRlcHNNYXAgPSB0YXJnZXRNYXAuZ2V0KHRhcmdldCk7XG4gICAgaWYgKCFkZXBzTWFwKSB7XG4gICAgICB0YXJnZXRNYXAuc2V0KHRhcmdldCwgZGVwc01hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCkpO1xuICAgIH1cbiAgICBsZXQgZGVwID0gZGVwc01hcC5nZXQoa2V5KTtcbiAgICBpZiAoIWRlcCkge1xuICAgICAgZGVwc01hcC5zZXQoa2V5LCBkZXAgPSBjcmVhdGVEZXAoKSk7XG4gICAgfVxuICAgIGNvbnN0IGV2ZW50SW5mbyA9ICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyB7IGVmZmVjdDogYWN0aXZlRWZmZWN0LCB0YXJnZXQsIHR5cGUsIGtleSB9IDogdm9pZCAwO1xuICAgIHRyYWNrRWZmZWN0cyhkZXAsIGV2ZW50SW5mbyk7XG4gIH1cbn1cbmZ1bmN0aW9uIHRyYWNrRWZmZWN0cyhkZXAsIGRlYnVnZ2VyRXZlbnRFeHRyYUluZm8pIHtcbiAgbGV0IHNob3VsZFRyYWNrMiA9IGZhbHNlO1xuICBpZiAoZWZmZWN0VHJhY2tEZXB0aCA8PSBtYXhNYXJrZXJCaXRzKSB7XG4gICAgaWYgKCFuZXdUcmFja2VkKGRlcCkpIHtcbiAgICAgIGRlcC5uIHw9IHRyYWNrT3BCaXQ7XG4gICAgICBzaG91bGRUcmFjazIgPSAhd2FzVHJhY2tlZChkZXApO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBzaG91bGRUcmFjazIgPSAhZGVwLmhhcyhhY3RpdmVFZmZlY3QpO1xuICB9XG4gIGlmIChzaG91bGRUcmFjazIpIHtcbiAgICBkZXAuYWRkKGFjdGl2ZUVmZmVjdCk7XG4gICAgYWN0aXZlRWZmZWN0LmRlcHMucHVzaChkZXApO1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGFjdGl2ZUVmZmVjdC5vblRyYWNrKSB7XG4gICAgICBhY3RpdmVFZmZlY3Qub25UcmFjayhcbiAgICAgICAgZXh0ZW5kKFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGVmZmVjdDogYWN0aXZlRWZmZWN0XG4gICAgICAgICAgfSxcbiAgICAgICAgICBkZWJ1Z2dlckV2ZW50RXh0cmFJbmZvXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiB0cmlnZ2VyKHRhcmdldCwgdHlwZSwga2V5LCBuZXdWYWx1ZSwgb2xkVmFsdWUsIG9sZFRhcmdldCkge1xuICBjb25zdCBkZXBzTWFwID0gdGFyZ2V0TWFwLmdldCh0YXJnZXQpO1xuICBpZiAoIWRlcHNNYXApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgbGV0IGRlcHMgPSBbXTtcbiAgaWYgKHR5cGUgPT09IFwiY2xlYXJcIikge1xuICAgIGRlcHMgPSBbLi4uZGVwc01hcC52YWx1ZXMoKV07XG4gIH0gZWxzZSBpZiAoa2V5ID09PSBcImxlbmd0aFwiICYmIGlzQXJyYXkodGFyZ2V0KSkge1xuICAgIGNvbnN0IG5ld0xlbmd0aCA9IE51bWJlcihuZXdWYWx1ZSk7XG4gICAgZGVwc01hcC5mb3JFYWNoKChkZXAsIGtleTIpID0+IHtcbiAgICAgIGlmIChrZXkyID09PSBcImxlbmd0aFwiIHx8IGtleTIgPj0gbmV3TGVuZ3RoKSB7XG4gICAgICAgIGRlcHMucHVzaChkZXApO1xuICAgICAgfVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGlmIChrZXkgIT09IHZvaWQgMCkge1xuICAgICAgZGVwcy5wdXNoKGRlcHNNYXAuZ2V0KGtleSkpO1xuICAgIH1cbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgXCJhZGRcIjpcbiAgICAgICAgaWYgKCFpc0FycmF5KHRhcmdldCkpIHtcbiAgICAgICAgICBkZXBzLnB1c2goZGVwc01hcC5nZXQoSVRFUkFURV9LRVkpKTtcbiAgICAgICAgICBpZiAoaXNNYXAodGFyZ2V0KSkge1xuICAgICAgICAgICAgZGVwcy5wdXNoKGRlcHNNYXAuZ2V0KE1BUF9LRVlfSVRFUkFURV9LRVkpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoaXNJbnRlZ2VyS2V5KGtleSkpIHtcbiAgICAgICAgICBkZXBzLnB1c2goZGVwc01hcC5nZXQoXCJsZW5ndGhcIikpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImRlbGV0ZVwiOlxuICAgICAgICBpZiAoIWlzQXJyYXkodGFyZ2V0KSkge1xuICAgICAgICAgIGRlcHMucHVzaChkZXBzTWFwLmdldChJVEVSQVRFX0tFWSkpO1xuICAgICAgICAgIGlmIChpc01hcCh0YXJnZXQpKSB7XG4gICAgICAgICAgICBkZXBzLnB1c2goZGVwc01hcC5nZXQoTUFQX0tFWV9JVEVSQVRFX0tFWSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJzZXRcIjpcbiAgICAgICAgaWYgKGlzTWFwKHRhcmdldCkpIHtcbiAgICAgICAgICBkZXBzLnB1c2goZGVwc01hcC5nZXQoSVRFUkFURV9LRVkpKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgY29uc3QgZXZlbnRJbmZvID0gISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IHsgdGFyZ2V0LCB0eXBlLCBrZXksIG5ld1ZhbHVlLCBvbGRWYWx1ZSwgb2xkVGFyZ2V0IH0gOiB2b2lkIDA7XG4gIGlmIChkZXBzLmxlbmd0aCA9PT0gMSkge1xuICAgIGlmIChkZXBzWzBdKSB7XG4gICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICB0cmlnZ2VyRWZmZWN0cyhkZXBzWzBdLCBldmVudEluZm8pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHJpZ2dlckVmZmVjdHMoZGVwc1swXSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGNvbnN0IGVmZmVjdHMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGRlcCBvZiBkZXBzKSB7XG4gICAgICBpZiAoZGVwKSB7XG4gICAgICAgIGVmZmVjdHMucHVzaCguLi5kZXApO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgdHJpZ2dlckVmZmVjdHMoY3JlYXRlRGVwKGVmZmVjdHMpLCBldmVudEluZm8pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0cmlnZ2VyRWZmZWN0cyhjcmVhdGVEZXAoZWZmZWN0cykpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gdHJpZ2dlckVmZmVjdHMoZGVwLCBkZWJ1Z2dlckV2ZW50RXh0cmFJbmZvKSB7XG4gIGNvbnN0IGVmZmVjdHMgPSBpc0FycmF5KGRlcCkgPyBkZXAgOiBbLi4uZGVwXTtcbiAgZm9yIChjb25zdCBlZmZlY3QyIG9mIGVmZmVjdHMpIHtcbiAgICBpZiAoZWZmZWN0Mi5jb21wdXRlZCkge1xuICAgICAgdHJpZ2dlckVmZmVjdChlZmZlY3QyLCBkZWJ1Z2dlckV2ZW50RXh0cmFJbmZvKTtcbiAgICB9XG4gIH1cbiAgZm9yIChjb25zdCBlZmZlY3QyIG9mIGVmZmVjdHMpIHtcbiAgICBpZiAoIWVmZmVjdDIuY29tcHV0ZWQpIHtcbiAgICAgIHRyaWdnZXJFZmZlY3QoZWZmZWN0MiwgZGVidWdnZXJFdmVudEV4dHJhSW5mbyk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiB0cmlnZ2VyRWZmZWN0KGVmZmVjdDIsIGRlYnVnZ2VyRXZlbnRFeHRyYUluZm8pIHtcbiAgaWYgKGVmZmVjdDIgIT09IGFjdGl2ZUVmZmVjdCB8fCBlZmZlY3QyLmFsbG93UmVjdXJzZSkge1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGVmZmVjdDIub25UcmlnZ2VyKSB7XG4gICAgICBlZmZlY3QyLm9uVHJpZ2dlcihleHRlbmQoeyBlZmZlY3Q6IGVmZmVjdDIgfSwgZGVidWdnZXJFdmVudEV4dHJhSW5mbykpO1xuICAgIH1cbiAgICBpZiAoZWZmZWN0Mi5zY2hlZHVsZXIpIHtcbiAgICAgIGVmZmVjdDIuc2NoZWR1bGVyKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVmZmVjdDIucnVuKCk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBnZXREZXBGcm9tUmVhY3RpdmUob2JqZWN0LCBrZXkpIHtcbiAgdmFyIF9hO1xuICByZXR1cm4gKF9hID0gdGFyZ2V0TWFwLmdldChvYmplY3QpKSA9PSBudWxsID8gdm9pZCAwIDogX2EuZ2V0KGtleSk7XG59XG5cbmNvbnN0IGlzTm9uVHJhY2thYmxlS2V5cyA9IC8qIEBfX1BVUkVfXyAqLyBtYWtlTWFwKGBfX3Byb3RvX18sX192X2lzUmVmLF9faXNWdWVgKTtcbmNvbnN0IGJ1aWx0SW5TeW1ib2xzID0gbmV3IFNldChcbiAgLyogQF9fUFVSRV9fICovIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKFN5bWJvbCkuZmlsdGVyKChrZXkpID0+IGtleSAhPT0gXCJhcmd1bWVudHNcIiAmJiBrZXkgIT09IFwiY2FsbGVyXCIpLm1hcCgoa2V5KSA9PiBTeW1ib2xba2V5XSkuZmlsdGVyKGlzU3ltYm9sKVxuKTtcbmNvbnN0IGdldCQxID0gLyogQF9fUFVSRV9fICovIGNyZWF0ZUdldHRlcigpO1xuY29uc3Qgc2hhbGxvd0dldCA9IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVHZXR0ZXIoZmFsc2UsIHRydWUpO1xuY29uc3QgcmVhZG9ubHlHZXQgPSAvKiBAX19QVVJFX18gKi8gY3JlYXRlR2V0dGVyKHRydWUpO1xuY29uc3Qgc2hhbGxvd1JlYWRvbmx5R2V0ID0gLyogQF9fUFVSRV9fICovIGNyZWF0ZUdldHRlcih0cnVlLCB0cnVlKTtcbmNvbnN0IGFycmF5SW5zdHJ1bWVudGF0aW9ucyA9IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVBcnJheUluc3RydW1lbnRhdGlvbnMoKTtcbmZ1bmN0aW9uIGNyZWF0ZUFycmF5SW5zdHJ1bWVudGF0aW9ucygpIHtcbiAgY29uc3QgaW5zdHJ1bWVudGF0aW9ucyA9IHt9O1xuICBbXCJpbmNsdWRlc1wiLCBcImluZGV4T2ZcIiwgXCJsYXN0SW5kZXhPZlwiXS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICBpbnN0cnVtZW50YXRpb25zW2tleV0gPSBmdW5jdGlvbiguLi5hcmdzKSB7XG4gICAgICBjb25zdCBhcnIgPSB0b1Jhdyh0aGlzKTtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gdGhpcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdHJhY2soYXJyLCBcImdldFwiLCBpICsgXCJcIik7XG4gICAgICB9XG4gICAgICBjb25zdCByZXMgPSBhcnJba2V5XSguLi5hcmdzKTtcbiAgICAgIGlmIChyZXMgPT09IC0xIHx8IHJlcyA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIGFycltrZXldKC4uLmFyZ3MubWFwKHRvUmF3KSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgfVxuICAgIH07XG4gIH0pO1xuICBbXCJwdXNoXCIsIFwicG9wXCIsIFwic2hpZnRcIiwgXCJ1bnNoaWZ0XCIsIFwic3BsaWNlXCJdLmZvckVhY2goKGtleSkgPT4ge1xuICAgIGluc3RydW1lbnRhdGlvbnNba2V5XSA9IGZ1bmN0aW9uKC4uLmFyZ3MpIHtcbiAgICAgIHBhdXNlVHJhY2tpbmcoKTtcbiAgICAgIGNvbnN0IHJlcyA9IHRvUmF3KHRoaXMpW2tleV0uYXBwbHkodGhpcywgYXJncyk7XG4gICAgICByZXNldFRyYWNraW5nKCk7XG4gICAgICByZXR1cm4gcmVzO1xuICAgIH07XG4gIH0pO1xuICByZXR1cm4gaW5zdHJ1bWVudGF0aW9ucztcbn1cbmZ1bmN0aW9uIGhhc093blByb3BlcnR5KGtleSkge1xuICBjb25zdCBvYmogPSB0b1Jhdyh0aGlzKTtcbiAgdHJhY2sob2JqLCBcImhhc1wiLCBrZXkpO1xuICByZXR1cm4gb2JqLmhhc093blByb3BlcnR5KGtleSk7XG59XG5mdW5jdGlvbiBjcmVhdGVHZXR0ZXIoaXNSZWFkb25seTIgPSBmYWxzZSwgc2hhbGxvdyA9IGZhbHNlKSB7XG4gIHJldHVybiBmdW5jdGlvbiBnZXQyKHRhcmdldCwga2V5LCByZWNlaXZlcikge1xuICAgIGlmIChrZXkgPT09IFwiX192X2lzUmVhY3RpdmVcIikge1xuICAgICAgcmV0dXJuICFpc1JlYWRvbmx5MjtcbiAgICB9IGVsc2UgaWYgKGtleSA9PT0gXCJfX3ZfaXNSZWFkb25seVwiKSB7XG4gICAgICByZXR1cm4gaXNSZWFkb25seTI7XG4gICAgfSBlbHNlIGlmIChrZXkgPT09IFwiX192X2lzU2hhbGxvd1wiKSB7XG4gICAgICByZXR1cm4gc2hhbGxvdztcbiAgICB9IGVsc2UgaWYgKGtleSA9PT0gXCJfX3ZfcmF3XCIgJiYgcmVjZWl2ZXIgPT09IChpc1JlYWRvbmx5MiA/IHNoYWxsb3cgPyBzaGFsbG93UmVhZG9ubHlNYXAgOiByZWFkb25seU1hcCA6IHNoYWxsb3cgPyBzaGFsbG93UmVhY3RpdmVNYXAgOiByZWFjdGl2ZU1hcCkuZ2V0KHRhcmdldCkpIHtcbiAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuICAgIGNvbnN0IHRhcmdldElzQXJyYXkgPSBpc0FycmF5KHRhcmdldCk7XG4gICAgaWYgKCFpc1JlYWRvbmx5Mikge1xuICAgICAgaWYgKHRhcmdldElzQXJyYXkgJiYgaGFzT3duKGFycmF5SW5zdHJ1bWVudGF0aW9ucywga2V5KSkge1xuICAgICAgICByZXR1cm4gUmVmbGVjdC5nZXQoYXJyYXlJbnN0cnVtZW50YXRpb25zLCBrZXksIHJlY2VpdmVyKTtcbiAgICAgIH1cbiAgICAgIGlmIChrZXkgPT09IFwiaGFzT3duUHJvcGVydHlcIikge1xuICAgICAgICByZXR1cm4gaGFzT3duUHJvcGVydHk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHJlcyA9IFJlZmxlY3QuZ2V0KHRhcmdldCwga2V5LCByZWNlaXZlcik7XG4gICAgaWYgKGlzU3ltYm9sKGtleSkgPyBidWlsdEluU3ltYm9scy5oYXMoa2V5KSA6IGlzTm9uVHJhY2thYmxlS2V5cyhrZXkpKSB7XG4gICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgICBpZiAoIWlzUmVhZG9ubHkyKSB7XG4gICAgICB0cmFjayh0YXJnZXQsIFwiZ2V0XCIsIGtleSk7XG4gICAgfVxuICAgIGlmIChzaGFsbG93KSB7XG4gICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgICBpZiAoaXNSZWYocmVzKSkge1xuICAgICAgcmV0dXJuIHRhcmdldElzQXJyYXkgJiYgaXNJbnRlZ2VyS2V5KGtleSkgPyByZXMgOiByZXMudmFsdWU7XG4gICAgfVxuICAgIGlmIChpc09iamVjdChyZXMpKSB7XG4gICAgICByZXR1cm4gaXNSZWFkb25seTIgPyByZWFkb25seShyZXMpIDogcmVhY3RpdmUocmVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbiAgfTtcbn1cbmNvbnN0IHNldCQxID0gLyogQF9fUFVSRV9fICovIGNyZWF0ZVNldHRlcigpO1xuY29uc3Qgc2hhbGxvd1NldCA9IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVTZXR0ZXIodHJ1ZSk7XG5mdW5jdGlvbiBjcmVhdGVTZXR0ZXIoc2hhbGxvdyA9IGZhbHNlKSB7XG4gIHJldHVybiBmdW5jdGlvbiBzZXQyKHRhcmdldCwga2V5LCB2YWx1ZSwgcmVjZWl2ZXIpIHtcbiAgICBsZXQgb2xkVmFsdWUgPSB0YXJnZXRba2V5XTtcbiAgICBpZiAoaXNSZWFkb25seShvbGRWYWx1ZSkgJiYgaXNSZWYob2xkVmFsdWUpICYmICFpc1JlZih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCFzaGFsbG93KSB7XG4gICAgICBpZiAoIWlzU2hhbGxvdyh2YWx1ZSkgJiYgIWlzUmVhZG9ubHkodmFsdWUpKSB7XG4gICAgICAgIG9sZFZhbHVlID0gdG9SYXcob2xkVmFsdWUpO1xuICAgICAgICB2YWx1ZSA9IHRvUmF3KHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGlmICghaXNBcnJheSh0YXJnZXQpICYmIGlzUmVmKG9sZFZhbHVlKSAmJiAhaXNSZWYodmFsdWUpKSB7XG4gICAgICAgIG9sZFZhbHVlLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBoYWRLZXkgPSBpc0FycmF5KHRhcmdldCkgJiYgaXNJbnRlZ2VyS2V5KGtleSkgPyBOdW1iZXIoa2V5KSA8IHRhcmdldC5sZW5ndGggOiBoYXNPd24odGFyZ2V0LCBrZXkpO1xuICAgIGNvbnN0IHJlc3VsdCA9IFJlZmxlY3Quc2V0KHRhcmdldCwga2V5LCB2YWx1ZSwgcmVjZWl2ZXIpO1xuICAgIGlmICh0YXJnZXQgPT09IHRvUmF3KHJlY2VpdmVyKSkge1xuICAgICAgaWYgKCFoYWRLZXkpIHtcbiAgICAgICAgdHJpZ2dlcih0YXJnZXQsIFwiYWRkXCIsIGtleSwgdmFsdWUpO1xuICAgICAgfSBlbHNlIGlmIChoYXNDaGFuZ2VkKHZhbHVlLCBvbGRWYWx1ZSkpIHtcbiAgICAgICAgdHJpZ2dlcih0YXJnZXQsIFwic2V0XCIsIGtleSwgdmFsdWUsIG9sZFZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbn1cbmZ1bmN0aW9uIGRlbGV0ZVByb3BlcnR5KHRhcmdldCwga2V5KSB7XG4gIGNvbnN0IGhhZEtleSA9IGhhc093bih0YXJnZXQsIGtleSk7XG4gIGNvbnN0IG9sZFZhbHVlID0gdGFyZ2V0W2tleV07XG4gIGNvbnN0IHJlc3VsdCA9IFJlZmxlY3QuZGVsZXRlUHJvcGVydHkodGFyZ2V0LCBrZXkpO1xuICBpZiAocmVzdWx0ICYmIGhhZEtleSkge1xuICAgIHRyaWdnZXIodGFyZ2V0LCBcImRlbGV0ZVwiLCBrZXksIHZvaWQgMCwgb2xkVmFsdWUpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBoYXMkMSh0YXJnZXQsIGtleSkge1xuICBjb25zdCByZXN1bHQgPSBSZWZsZWN0Lmhhcyh0YXJnZXQsIGtleSk7XG4gIGlmICghaXNTeW1ib2woa2V5KSB8fCAhYnVpbHRJblN5bWJvbHMuaGFzKGtleSkpIHtcbiAgICB0cmFjayh0YXJnZXQsIFwiaGFzXCIsIGtleSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIG93bktleXModGFyZ2V0KSB7XG4gIHRyYWNrKHRhcmdldCwgXCJpdGVyYXRlXCIsIGlzQXJyYXkodGFyZ2V0KSA/IFwibGVuZ3RoXCIgOiBJVEVSQVRFX0tFWSk7XG4gIHJldHVybiBSZWZsZWN0Lm93bktleXModGFyZ2V0KTtcbn1cbmNvbnN0IG11dGFibGVIYW5kbGVycyA9IHtcbiAgZ2V0OiBnZXQkMSxcbiAgc2V0OiBzZXQkMSxcbiAgZGVsZXRlUHJvcGVydHksXG4gIGhhczogaGFzJDEsXG4gIG93bktleXNcbn07XG5jb25zdCByZWFkb25seUhhbmRsZXJzID0ge1xuICBnZXQ6IHJlYWRvbmx5R2V0LFxuICBzZXQodGFyZ2V0LCBrZXkpIHtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgd2FybihcbiAgICAgICAgYFNldCBvcGVyYXRpb24gb24ga2V5IFwiJHtTdHJpbmcoa2V5KX1cIiBmYWlsZWQ6IHRhcmdldCBpcyByZWFkb25seS5gLFxuICAgICAgICB0YXJnZXRcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9LFxuICBkZWxldGVQcm9wZXJ0eSh0YXJnZXQsIGtleSkge1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICB3YXJuKFxuICAgICAgICBgRGVsZXRlIG9wZXJhdGlvbiBvbiBrZXkgXCIke1N0cmluZyhrZXkpfVwiIGZhaWxlZDogdGFyZ2V0IGlzIHJlYWRvbmx5LmAsXG4gICAgICAgIHRhcmdldFxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn07XG5jb25zdCBzaGFsbG93UmVhY3RpdmVIYW5kbGVycyA9IC8qIEBfX1BVUkVfXyAqLyBleHRlbmQoXG4gIHt9LFxuICBtdXRhYmxlSGFuZGxlcnMsXG4gIHtcbiAgICBnZXQ6IHNoYWxsb3dHZXQsXG4gICAgc2V0OiBzaGFsbG93U2V0XG4gIH1cbik7XG5jb25zdCBzaGFsbG93UmVhZG9ubHlIYW5kbGVycyA9IC8qIEBfX1BVUkVfXyAqLyBleHRlbmQoXG4gIHt9LFxuICByZWFkb25seUhhbmRsZXJzLFxuICB7XG4gICAgZ2V0OiBzaGFsbG93UmVhZG9ubHlHZXRcbiAgfVxuKTtcblxuY29uc3QgdG9TaGFsbG93ID0gKHZhbHVlKSA9PiB2YWx1ZTtcbmNvbnN0IGdldFByb3RvID0gKHYpID0+IFJlZmxlY3QuZ2V0UHJvdG90eXBlT2Yodik7XG5mdW5jdGlvbiBnZXQodGFyZ2V0LCBrZXksIGlzUmVhZG9ubHkgPSBmYWxzZSwgaXNTaGFsbG93ID0gZmFsc2UpIHtcbiAgdGFyZ2V0ID0gdGFyZ2V0W1wiX192X3Jhd1wiXTtcbiAgY29uc3QgcmF3VGFyZ2V0ID0gdG9SYXcodGFyZ2V0KTtcbiAgY29uc3QgcmF3S2V5ID0gdG9SYXcoa2V5KTtcbiAgaWYgKCFpc1JlYWRvbmx5KSB7XG4gICAgaWYgKGtleSAhPT0gcmF3S2V5KSB7XG4gICAgICB0cmFjayhyYXdUYXJnZXQsIFwiZ2V0XCIsIGtleSk7XG4gICAgfVxuICAgIHRyYWNrKHJhd1RhcmdldCwgXCJnZXRcIiwgcmF3S2V5KTtcbiAgfVxuICBjb25zdCB7IGhhczogaGFzMiB9ID0gZ2V0UHJvdG8ocmF3VGFyZ2V0KTtcbiAgY29uc3Qgd3JhcCA9IGlzU2hhbGxvdyA/IHRvU2hhbGxvdyA6IGlzUmVhZG9ubHkgPyB0b1JlYWRvbmx5IDogdG9SZWFjdGl2ZTtcbiAgaWYgKGhhczIuY2FsbChyYXdUYXJnZXQsIGtleSkpIHtcbiAgICByZXR1cm4gd3JhcCh0YXJnZXQuZ2V0KGtleSkpO1xuICB9IGVsc2UgaWYgKGhhczIuY2FsbChyYXdUYXJnZXQsIHJhd0tleSkpIHtcbiAgICByZXR1cm4gd3JhcCh0YXJnZXQuZ2V0KHJhd0tleSkpO1xuICB9IGVsc2UgaWYgKHRhcmdldCAhPT0gcmF3VGFyZ2V0KSB7XG4gICAgdGFyZ2V0LmdldChrZXkpO1xuICB9XG59XG5mdW5jdGlvbiBoYXMoa2V5LCBpc1JlYWRvbmx5ID0gZmFsc2UpIHtcbiAgY29uc3QgdGFyZ2V0ID0gdGhpc1tcIl9fdl9yYXdcIl07XG4gIGNvbnN0IHJhd1RhcmdldCA9IHRvUmF3KHRhcmdldCk7XG4gIGNvbnN0IHJhd0tleSA9IHRvUmF3KGtleSk7XG4gIGlmICghaXNSZWFkb25seSkge1xuICAgIGlmIChrZXkgIT09IHJhd0tleSkge1xuICAgICAgdHJhY2socmF3VGFyZ2V0LCBcImhhc1wiLCBrZXkpO1xuICAgIH1cbiAgICB0cmFjayhyYXdUYXJnZXQsIFwiaGFzXCIsIHJhd0tleSk7XG4gIH1cbiAgcmV0dXJuIGtleSA9PT0gcmF3S2V5ID8gdGFyZ2V0LmhhcyhrZXkpIDogdGFyZ2V0LmhhcyhrZXkpIHx8IHRhcmdldC5oYXMocmF3S2V5KTtcbn1cbmZ1bmN0aW9uIHNpemUodGFyZ2V0LCBpc1JlYWRvbmx5ID0gZmFsc2UpIHtcbiAgdGFyZ2V0ID0gdGFyZ2V0W1wiX192X3Jhd1wiXTtcbiAgIWlzUmVhZG9ubHkgJiYgdHJhY2sodG9SYXcodGFyZ2V0KSwgXCJpdGVyYXRlXCIsIElURVJBVEVfS0VZKTtcbiAgcmV0dXJuIFJlZmxlY3QuZ2V0KHRhcmdldCwgXCJzaXplXCIsIHRhcmdldCk7XG59XG5mdW5jdGlvbiBhZGQodmFsdWUpIHtcbiAgdmFsdWUgPSB0b1Jhdyh2YWx1ZSk7XG4gIGNvbnN0IHRhcmdldCA9IHRvUmF3KHRoaXMpO1xuICBjb25zdCBwcm90byA9IGdldFByb3RvKHRhcmdldCk7XG4gIGNvbnN0IGhhZEtleSA9IHByb3RvLmhhcy5jYWxsKHRhcmdldCwgdmFsdWUpO1xuICBpZiAoIWhhZEtleSkge1xuICAgIHRhcmdldC5hZGQodmFsdWUpO1xuICAgIHRyaWdnZXIodGFyZ2V0LCBcImFkZFwiLCB2YWx1ZSwgdmFsdWUpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufVxuZnVuY3Rpb24gc2V0KGtleSwgdmFsdWUpIHtcbiAgdmFsdWUgPSB0b1Jhdyh2YWx1ZSk7XG4gIGNvbnN0IHRhcmdldCA9IHRvUmF3KHRoaXMpO1xuICBjb25zdCB7IGhhczogaGFzMiwgZ2V0OiBnZXQyIH0gPSBnZXRQcm90byh0YXJnZXQpO1xuICBsZXQgaGFkS2V5ID0gaGFzMi5jYWxsKHRhcmdldCwga2V5KTtcbiAgaWYgKCFoYWRLZXkpIHtcbiAgICBrZXkgPSB0b1JhdyhrZXkpO1xuICAgIGhhZEtleSA9IGhhczIuY2FsbCh0YXJnZXQsIGtleSk7XG4gIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIGNoZWNrSWRlbnRpdHlLZXlzKHRhcmdldCwgaGFzMiwga2V5KTtcbiAgfVxuICBjb25zdCBvbGRWYWx1ZSA9IGdldDIuY2FsbCh0YXJnZXQsIGtleSk7XG4gIHRhcmdldC5zZXQoa2V5LCB2YWx1ZSk7XG4gIGlmICghaGFkS2V5KSB7XG4gICAgdHJpZ2dlcih0YXJnZXQsIFwiYWRkXCIsIGtleSwgdmFsdWUpO1xuICB9IGVsc2UgaWYgKGhhc0NoYW5nZWQodmFsdWUsIG9sZFZhbHVlKSkge1xuICAgIHRyaWdnZXIodGFyZ2V0LCBcInNldFwiLCBrZXksIHZhbHVlLCBvbGRWYWx1ZSk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59XG5mdW5jdGlvbiBkZWxldGVFbnRyeShrZXkpIHtcbiAgY29uc3QgdGFyZ2V0ID0gdG9SYXcodGhpcyk7XG4gIGNvbnN0IHsgaGFzOiBoYXMyLCBnZXQ6IGdldDIgfSA9IGdldFByb3RvKHRhcmdldCk7XG4gIGxldCBoYWRLZXkgPSBoYXMyLmNhbGwodGFyZ2V0LCBrZXkpO1xuICBpZiAoIWhhZEtleSkge1xuICAgIGtleSA9IHRvUmF3KGtleSk7XG4gICAgaGFkS2V5ID0gaGFzMi5jYWxsKHRhcmdldCwga2V5KTtcbiAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgY2hlY2tJZGVudGl0eUtleXModGFyZ2V0LCBoYXMyLCBrZXkpO1xuICB9XG4gIGNvbnN0IG9sZFZhbHVlID0gZ2V0MiA/IGdldDIuY2FsbCh0YXJnZXQsIGtleSkgOiB2b2lkIDA7XG4gIGNvbnN0IHJlc3VsdCA9IHRhcmdldC5kZWxldGUoa2V5KTtcbiAgaWYgKGhhZEtleSkge1xuICAgIHRyaWdnZXIodGFyZ2V0LCBcImRlbGV0ZVwiLCBrZXksIHZvaWQgMCwgb2xkVmFsdWUpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBjbGVhcigpIHtcbiAgY29uc3QgdGFyZ2V0ID0gdG9SYXcodGhpcyk7XG4gIGNvbnN0IGhhZEl0ZW1zID0gdGFyZ2V0LnNpemUgIT09IDA7XG4gIGNvbnN0IG9sZFRhcmdldCA9ICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyBpc01hcCh0YXJnZXQpID8gbmV3IE1hcCh0YXJnZXQpIDogbmV3IFNldCh0YXJnZXQpIDogdm9pZCAwO1xuICBjb25zdCByZXN1bHQgPSB0YXJnZXQuY2xlYXIoKTtcbiAgaWYgKGhhZEl0ZW1zKSB7XG4gICAgdHJpZ2dlcih0YXJnZXQsIFwiY2xlYXJcIiwgdm9pZCAwLCB2b2lkIDAsIG9sZFRhcmdldCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUZvckVhY2goaXNSZWFkb25seSwgaXNTaGFsbG93KSB7XG4gIHJldHVybiBmdW5jdGlvbiBmb3JFYWNoKGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgY29uc3Qgb2JzZXJ2ZWQgPSB0aGlzO1xuICAgIGNvbnN0IHRhcmdldCA9IG9ic2VydmVkW1wiX192X3Jhd1wiXTtcbiAgICBjb25zdCByYXdUYXJnZXQgPSB0b1Jhdyh0YXJnZXQpO1xuICAgIGNvbnN0IHdyYXAgPSBpc1NoYWxsb3cgPyB0b1NoYWxsb3cgOiBpc1JlYWRvbmx5ID8gdG9SZWFkb25seSA6IHRvUmVhY3RpdmU7XG4gICAgIWlzUmVhZG9ubHkgJiYgdHJhY2socmF3VGFyZ2V0LCBcIml0ZXJhdGVcIiwgSVRFUkFURV9LRVkpO1xuICAgIHJldHVybiB0YXJnZXQuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrLmNhbGwodGhpc0FyZywgd3JhcCh2YWx1ZSksIHdyYXAoa2V5KSwgb2JzZXJ2ZWQpO1xuICAgIH0pO1xuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlSXRlcmFibGVNZXRob2QobWV0aG9kLCBpc1JlYWRvbmx5LCBpc1NoYWxsb3cpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKC4uLmFyZ3MpIHtcbiAgICBjb25zdCB0YXJnZXQgPSB0aGlzW1wiX192X3Jhd1wiXTtcbiAgICBjb25zdCByYXdUYXJnZXQgPSB0b1Jhdyh0YXJnZXQpO1xuICAgIGNvbnN0IHRhcmdldElzTWFwID0gaXNNYXAocmF3VGFyZ2V0KTtcbiAgICBjb25zdCBpc1BhaXIgPSBtZXRob2QgPT09IFwiZW50cmllc1wiIHx8IG1ldGhvZCA9PT0gU3ltYm9sLml0ZXJhdG9yICYmIHRhcmdldElzTWFwO1xuICAgIGNvbnN0IGlzS2V5T25seSA9IG1ldGhvZCA9PT0gXCJrZXlzXCIgJiYgdGFyZ2V0SXNNYXA7XG4gICAgY29uc3QgaW5uZXJJdGVyYXRvciA9IHRhcmdldFttZXRob2RdKC4uLmFyZ3MpO1xuICAgIGNvbnN0IHdyYXAgPSBpc1NoYWxsb3cgPyB0b1NoYWxsb3cgOiBpc1JlYWRvbmx5ID8gdG9SZWFkb25seSA6IHRvUmVhY3RpdmU7XG4gICAgIWlzUmVhZG9ubHkgJiYgdHJhY2soXG4gICAgICByYXdUYXJnZXQsXG4gICAgICBcIml0ZXJhdGVcIixcbiAgICAgIGlzS2V5T25seSA/IE1BUF9LRVlfSVRFUkFURV9LRVkgOiBJVEVSQVRFX0tFWVxuICAgICk7XG4gICAgcmV0dXJuIHtcbiAgICAgIC8vIGl0ZXJhdG9yIHByb3RvY29sXG4gICAgICBuZXh0KCkge1xuICAgICAgICBjb25zdCB7IHZhbHVlLCBkb25lIH0gPSBpbm5lckl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgcmV0dXJuIGRvbmUgPyB7IHZhbHVlLCBkb25lIH0gOiB7XG4gICAgICAgICAgdmFsdWU6IGlzUGFpciA/IFt3cmFwKHZhbHVlWzBdKSwgd3JhcCh2YWx1ZVsxXSldIDogd3JhcCh2YWx1ZSksXG4gICAgICAgICAgZG9uZVxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIC8vIGl0ZXJhYmxlIHByb3RvY29sXG4gICAgICBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgfTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVJlYWRvbmx5TWV0aG9kKHR5cGUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKC4uLmFyZ3MpIHtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgY29uc3Qga2V5ID0gYXJnc1swXSA/IGBvbiBrZXkgXCIke2FyZ3NbMF19XCIgYCA6IGBgO1xuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICBgJHtjYXBpdGFsaXplKHR5cGUpfSBvcGVyYXRpb24gJHtrZXl9ZmFpbGVkOiB0YXJnZXQgaXMgcmVhZG9ubHkuYCxcbiAgICAgICAgdG9SYXcodGhpcylcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB0eXBlID09PSBcImRlbGV0ZVwiID8gZmFsc2UgOiB0aGlzO1xuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlSW5zdHJ1bWVudGF0aW9ucygpIHtcbiAgY29uc3QgbXV0YWJsZUluc3RydW1lbnRhdGlvbnMyID0ge1xuICAgIGdldChrZXkpIHtcbiAgICAgIHJldHVybiBnZXQodGhpcywga2V5KTtcbiAgICB9LFxuICAgIGdldCBzaXplKCkge1xuICAgICAgcmV0dXJuIHNpemUodGhpcyk7XG4gICAgfSxcbiAgICBoYXMsXG4gICAgYWRkLFxuICAgIHNldCxcbiAgICBkZWxldGU6IGRlbGV0ZUVudHJ5LFxuICAgIGNsZWFyLFxuICAgIGZvckVhY2g6IGNyZWF0ZUZvckVhY2goZmFsc2UsIGZhbHNlKVxuICB9O1xuICBjb25zdCBzaGFsbG93SW5zdHJ1bWVudGF0aW9uczIgPSB7XG4gICAgZ2V0KGtleSkge1xuICAgICAgcmV0dXJuIGdldCh0aGlzLCBrZXksIGZhbHNlLCB0cnVlKTtcbiAgICB9LFxuICAgIGdldCBzaXplKCkge1xuICAgICAgcmV0dXJuIHNpemUodGhpcyk7XG4gICAgfSxcbiAgICBoYXMsXG4gICAgYWRkLFxuICAgIHNldCxcbiAgICBkZWxldGU6IGRlbGV0ZUVudHJ5LFxuICAgIGNsZWFyLFxuICAgIGZvckVhY2g6IGNyZWF0ZUZvckVhY2goZmFsc2UsIHRydWUpXG4gIH07XG4gIGNvbnN0IHJlYWRvbmx5SW5zdHJ1bWVudGF0aW9uczIgPSB7XG4gICAgZ2V0KGtleSkge1xuICAgICAgcmV0dXJuIGdldCh0aGlzLCBrZXksIHRydWUpO1xuICAgIH0sXG4gICAgZ2V0IHNpemUoKSB7XG4gICAgICByZXR1cm4gc2l6ZSh0aGlzLCB0cnVlKTtcbiAgICB9LFxuICAgIGhhcyhrZXkpIHtcbiAgICAgIHJldHVybiBoYXMuY2FsbCh0aGlzLCBrZXksIHRydWUpO1xuICAgIH0sXG4gICAgYWRkOiBjcmVhdGVSZWFkb25seU1ldGhvZChcImFkZFwiKSxcbiAgICBzZXQ6IGNyZWF0ZVJlYWRvbmx5TWV0aG9kKFwic2V0XCIpLFxuICAgIGRlbGV0ZTogY3JlYXRlUmVhZG9ubHlNZXRob2QoXCJkZWxldGVcIiksXG4gICAgY2xlYXI6IGNyZWF0ZVJlYWRvbmx5TWV0aG9kKFwiY2xlYXJcIiksXG4gICAgZm9yRWFjaDogY3JlYXRlRm9yRWFjaCh0cnVlLCBmYWxzZSlcbiAgfTtcbiAgY29uc3Qgc2hhbGxvd1JlYWRvbmx5SW5zdHJ1bWVudGF0aW9uczIgPSB7XG4gICAgZ2V0KGtleSkge1xuICAgICAgcmV0dXJuIGdldCh0aGlzLCBrZXksIHRydWUsIHRydWUpO1xuICAgIH0sXG4gICAgZ2V0IHNpemUoKSB7XG4gICAgICByZXR1cm4gc2l6ZSh0aGlzLCB0cnVlKTtcbiAgICB9LFxuICAgIGhhcyhrZXkpIHtcbiAgICAgIHJldHVybiBoYXMuY2FsbCh0aGlzLCBrZXksIHRydWUpO1xuICAgIH0sXG4gICAgYWRkOiBjcmVhdGVSZWFkb25seU1ldGhvZChcImFkZFwiKSxcbiAgICBzZXQ6IGNyZWF0ZVJlYWRvbmx5TWV0aG9kKFwic2V0XCIpLFxuICAgIGRlbGV0ZTogY3JlYXRlUmVhZG9ubHlNZXRob2QoXCJkZWxldGVcIiksXG4gICAgY2xlYXI6IGNyZWF0ZVJlYWRvbmx5TWV0aG9kKFwiY2xlYXJcIiksXG4gICAgZm9yRWFjaDogY3JlYXRlRm9yRWFjaCh0cnVlLCB0cnVlKVxuICB9O1xuICBjb25zdCBpdGVyYXRvck1ldGhvZHMgPSBbXCJrZXlzXCIsIFwidmFsdWVzXCIsIFwiZW50cmllc1wiLCBTeW1ib2wuaXRlcmF0b3JdO1xuICBpdGVyYXRvck1ldGhvZHMuZm9yRWFjaCgobWV0aG9kKSA9PiB7XG4gICAgbXV0YWJsZUluc3RydW1lbnRhdGlvbnMyW21ldGhvZF0gPSBjcmVhdGVJdGVyYWJsZU1ldGhvZChcbiAgICAgIG1ldGhvZCxcbiAgICAgIGZhbHNlLFxuICAgICAgZmFsc2VcbiAgICApO1xuICAgIHJlYWRvbmx5SW5zdHJ1bWVudGF0aW9uczJbbWV0aG9kXSA9IGNyZWF0ZUl0ZXJhYmxlTWV0aG9kKFxuICAgICAgbWV0aG9kLFxuICAgICAgdHJ1ZSxcbiAgICAgIGZhbHNlXG4gICAgKTtcbiAgICBzaGFsbG93SW5zdHJ1bWVudGF0aW9uczJbbWV0aG9kXSA9IGNyZWF0ZUl0ZXJhYmxlTWV0aG9kKFxuICAgICAgbWV0aG9kLFxuICAgICAgZmFsc2UsXG4gICAgICB0cnVlXG4gICAgKTtcbiAgICBzaGFsbG93UmVhZG9ubHlJbnN0cnVtZW50YXRpb25zMlttZXRob2RdID0gY3JlYXRlSXRlcmFibGVNZXRob2QoXG4gICAgICBtZXRob2QsXG4gICAgICB0cnVlLFxuICAgICAgdHJ1ZVxuICAgICk7XG4gIH0pO1xuICByZXR1cm4gW1xuICAgIG11dGFibGVJbnN0cnVtZW50YXRpb25zMixcbiAgICByZWFkb25seUluc3RydW1lbnRhdGlvbnMyLFxuICAgIHNoYWxsb3dJbnN0cnVtZW50YXRpb25zMixcbiAgICBzaGFsbG93UmVhZG9ubHlJbnN0cnVtZW50YXRpb25zMlxuICBdO1xufVxuY29uc3QgW1xuICBtdXRhYmxlSW5zdHJ1bWVudGF0aW9ucyxcbiAgcmVhZG9ubHlJbnN0cnVtZW50YXRpb25zLFxuICBzaGFsbG93SW5zdHJ1bWVudGF0aW9ucyxcbiAgc2hhbGxvd1JlYWRvbmx5SW5zdHJ1bWVudGF0aW9uc1xuXSA9IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVJbnN0cnVtZW50YXRpb25zKCk7XG5mdW5jdGlvbiBjcmVhdGVJbnN0cnVtZW50YXRpb25HZXR0ZXIoaXNSZWFkb25seSwgc2hhbGxvdykge1xuICBjb25zdCBpbnN0cnVtZW50YXRpb25zID0gc2hhbGxvdyA/IGlzUmVhZG9ubHkgPyBzaGFsbG93UmVhZG9ubHlJbnN0cnVtZW50YXRpb25zIDogc2hhbGxvd0luc3RydW1lbnRhdGlvbnMgOiBpc1JlYWRvbmx5ID8gcmVhZG9ubHlJbnN0cnVtZW50YXRpb25zIDogbXV0YWJsZUluc3RydW1lbnRhdGlvbnM7XG4gIHJldHVybiAodGFyZ2V0LCBrZXksIHJlY2VpdmVyKSA9PiB7XG4gICAgaWYgKGtleSA9PT0gXCJfX3ZfaXNSZWFjdGl2ZVwiKSB7XG4gICAgICByZXR1cm4gIWlzUmVhZG9ubHk7XG4gICAgfSBlbHNlIGlmIChrZXkgPT09IFwiX192X2lzUmVhZG9ubHlcIikge1xuICAgICAgcmV0dXJuIGlzUmVhZG9ubHk7XG4gICAgfSBlbHNlIGlmIChrZXkgPT09IFwiX192X3Jhd1wiKSB7XG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cbiAgICByZXR1cm4gUmVmbGVjdC5nZXQoXG4gICAgICBoYXNPd24oaW5zdHJ1bWVudGF0aW9ucywga2V5KSAmJiBrZXkgaW4gdGFyZ2V0ID8gaW5zdHJ1bWVudGF0aW9ucyA6IHRhcmdldCxcbiAgICAgIGtleSxcbiAgICAgIHJlY2VpdmVyXG4gICAgKTtcbiAgfTtcbn1cbmNvbnN0IG11dGFibGVDb2xsZWN0aW9uSGFuZGxlcnMgPSB7XG4gIGdldDogLyogQF9fUFVSRV9fICovIGNyZWF0ZUluc3RydW1lbnRhdGlvbkdldHRlcihmYWxzZSwgZmFsc2UpXG59O1xuY29uc3Qgc2hhbGxvd0NvbGxlY3Rpb25IYW5kbGVycyA9IHtcbiAgZ2V0OiAvKiBAX19QVVJFX18gKi8gY3JlYXRlSW5zdHJ1bWVudGF0aW9uR2V0dGVyKGZhbHNlLCB0cnVlKVxufTtcbmNvbnN0IHJlYWRvbmx5Q29sbGVjdGlvbkhhbmRsZXJzID0ge1xuICBnZXQ6IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVJbnN0cnVtZW50YXRpb25HZXR0ZXIodHJ1ZSwgZmFsc2UpXG59O1xuY29uc3Qgc2hhbGxvd1JlYWRvbmx5Q29sbGVjdGlvbkhhbmRsZXJzID0ge1xuICBnZXQ6IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVJbnN0cnVtZW50YXRpb25HZXR0ZXIodHJ1ZSwgdHJ1ZSlcbn07XG5mdW5jdGlvbiBjaGVja0lkZW50aXR5S2V5cyh0YXJnZXQsIGhhczIsIGtleSkge1xuICBjb25zdCByYXdLZXkgPSB0b1JhdyhrZXkpO1xuICBpZiAocmF3S2V5ICE9PSBrZXkgJiYgaGFzMi5jYWxsKHRhcmdldCwgcmF3S2V5KSkge1xuICAgIGNvbnN0IHR5cGUgPSB0b1Jhd1R5cGUodGFyZ2V0KTtcbiAgICBjb25zb2xlLndhcm4oXG4gICAgICBgUmVhY3RpdmUgJHt0eXBlfSBjb250YWlucyBib3RoIHRoZSByYXcgYW5kIHJlYWN0aXZlIHZlcnNpb25zIG9mIHRoZSBzYW1lIG9iamVjdCR7dHlwZSA9PT0gYE1hcGAgPyBgIGFzIGtleXNgIDogYGB9LCB3aGljaCBjYW4gbGVhZCB0byBpbmNvbnNpc3RlbmNpZXMuIEF2b2lkIGRpZmZlcmVudGlhdGluZyBiZXR3ZWVuIHRoZSByYXcgYW5kIHJlYWN0aXZlIHZlcnNpb25zIG9mIGFuIG9iamVjdCBhbmQgb25seSB1c2UgdGhlIHJlYWN0aXZlIHZlcnNpb24gaWYgcG9zc2libGUuYFxuICAgICk7XG4gIH1cbn1cblxuY29uc3QgcmVhY3RpdmVNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbmNvbnN0IHNoYWxsb3dSZWFjdGl2ZU1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuY29uc3QgcmVhZG9ubHlNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbmNvbnN0IHNoYWxsb3dSZWFkb25seU1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuZnVuY3Rpb24gdGFyZ2V0VHlwZU1hcChyYXdUeXBlKSB7XG4gIHN3aXRjaCAocmF3VHlwZSkge1xuICAgIGNhc2UgXCJPYmplY3RcIjpcbiAgICBjYXNlIFwiQXJyYXlcIjpcbiAgICAgIHJldHVybiAxIC8qIENPTU1PTiAqLztcbiAgICBjYXNlIFwiTWFwXCI6XG4gICAgY2FzZSBcIlNldFwiOlxuICAgIGNhc2UgXCJXZWFrTWFwXCI6XG4gICAgY2FzZSBcIldlYWtTZXRcIjpcbiAgICAgIHJldHVybiAyIC8qIENPTExFQ1RJT04gKi87XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiAwIC8qIElOVkFMSUQgKi87XG4gIH1cbn1cbmZ1bmN0aW9uIGdldFRhcmdldFR5cGUodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlW1wiX192X3NraXBcIl0gfHwgIU9iamVjdC5pc0V4dGVuc2libGUodmFsdWUpID8gMCAvKiBJTlZBTElEICovIDogdGFyZ2V0VHlwZU1hcCh0b1Jhd1R5cGUodmFsdWUpKTtcbn1cbmZ1bmN0aW9uIHJlYWN0aXZlKHRhcmdldCkge1xuICBpZiAoaXNSZWFkb25seSh0YXJnZXQpKSB7XG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfVxuICByZXR1cm4gY3JlYXRlUmVhY3RpdmVPYmplY3QoXG4gICAgdGFyZ2V0LFxuICAgIGZhbHNlLFxuICAgIG11dGFibGVIYW5kbGVycyxcbiAgICBtdXRhYmxlQ29sbGVjdGlvbkhhbmRsZXJzLFxuICAgIHJlYWN0aXZlTWFwXG4gICk7XG59XG5mdW5jdGlvbiBzaGFsbG93UmVhY3RpdmUodGFyZ2V0KSB7XG4gIHJldHVybiBjcmVhdGVSZWFjdGl2ZU9iamVjdChcbiAgICB0YXJnZXQsXG4gICAgZmFsc2UsXG4gICAgc2hhbGxvd1JlYWN0aXZlSGFuZGxlcnMsXG4gICAgc2hhbGxvd0NvbGxlY3Rpb25IYW5kbGVycyxcbiAgICBzaGFsbG93UmVhY3RpdmVNYXBcbiAgKTtcbn1cbmZ1bmN0aW9uIHJlYWRvbmx5KHRhcmdldCkge1xuICByZXR1cm4gY3JlYXRlUmVhY3RpdmVPYmplY3QoXG4gICAgdGFyZ2V0LFxuICAgIHRydWUsXG4gICAgcmVhZG9ubHlIYW5kbGVycyxcbiAgICByZWFkb25seUNvbGxlY3Rpb25IYW5kbGVycyxcbiAgICByZWFkb25seU1hcFxuICApO1xufVxuZnVuY3Rpb24gc2hhbGxvd1JlYWRvbmx5KHRhcmdldCkge1xuICByZXR1cm4gY3JlYXRlUmVhY3RpdmVPYmplY3QoXG4gICAgdGFyZ2V0LFxuICAgIHRydWUsXG4gICAgc2hhbGxvd1JlYWRvbmx5SGFuZGxlcnMsXG4gICAgc2hhbGxvd1JlYWRvbmx5Q29sbGVjdGlvbkhhbmRsZXJzLFxuICAgIHNoYWxsb3dSZWFkb25seU1hcFxuICApO1xufVxuZnVuY3Rpb24gY3JlYXRlUmVhY3RpdmVPYmplY3QodGFyZ2V0LCBpc1JlYWRvbmx5MiwgYmFzZUhhbmRsZXJzLCBjb2xsZWN0aW9uSGFuZGxlcnMsIHByb3h5TWFwKSB7XG4gIGlmICghaXNPYmplY3QodGFyZ2V0KSkge1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICBjb25zb2xlLndhcm4oYHZhbHVlIGNhbm5vdCBiZSBtYWRlIHJlYWN0aXZlOiAke1N0cmluZyh0YXJnZXQpfWApO1xuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9XG4gIGlmICh0YXJnZXRbXCJfX3ZfcmF3XCJdICYmICEoaXNSZWFkb25seTIgJiYgdGFyZ2V0W1wiX192X2lzUmVhY3RpdmVcIl0pKSB7XG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfVxuICBjb25zdCBleGlzdGluZ1Byb3h5ID0gcHJveHlNYXAuZ2V0KHRhcmdldCk7XG4gIGlmIChleGlzdGluZ1Byb3h5KSB7XG4gICAgcmV0dXJuIGV4aXN0aW5nUHJveHk7XG4gIH1cbiAgY29uc3QgdGFyZ2V0VHlwZSA9IGdldFRhcmdldFR5cGUodGFyZ2V0KTtcbiAgaWYgKHRhcmdldFR5cGUgPT09IDAgLyogSU5WQUxJRCAqLykge1xuICAgIHJldHVybiB0YXJnZXQ7XG4gIH1cbiAgY29uc3QgcHJveHkgPSBuZXcgUHJveHkoXG4gICAgdGFyZ2V0LFxuICAgIHRhcmdldFR5cGUgPT09IDIgLyogQ09MTEVDVElPTiAqLyA/IGNvbGxlY3Rpb25IYW5kbGVycyA6IGJhc2VIYW5kbGVyc1xuICApO1xuICBwcm94eU1hcC5zZXQodGFyZ2V0LCBwcm94eSk7XG4gIHJldHVybiBwcm94eTtcbn1cbmZ1bmN0aW9uIGlzUmVhY3RpdmUodmFsdWUpIHtcbiAgaWYgKGlzUmVhZG9ubHkodmFsdWUpKSB7XG4gICAgcmV0dXJuIGlzUmVhY3RpdmUodmFsdWVbXCJfX3ZfcmF3XCJdKTtcbiAgfVxuICByZXR1cm4gISEodmFsdWUgJiYgdmFsdWVbXCJfX3ZfaXNSZWFjdGl2ZVwiXSk7XG59XG5mdW5jdGlvbiBpc1JlYWRvbmx5KHZhbHVlKSB7XG4gIHJldHVybiAhISh2YWx1ZSAmJiB2YWx1ZVtcIl9fdl9pc1JlYWRvbmx5XCJdKTtcbn1cbmZ1bmN0aW9uIGlzU2hhbGxvdyh2YWx1ZSkge1xuICByZXR1cm4gISEodmFsdWUgJiYgdmFsdWVbXCJfX3ZfaXNTaGFsbG93XCJdKTtcbn1cbmZ1bmN0aW9uIGlzUHJveHkodmFsdWUpIHtcbiAgcmV0dXJuIGlzUmVhY3RpdmUodmFsdWUpIHx8IGlzUmVhZG9ubHkodmFsdWUpO1xufVxuZnVuY3Rpb24gdG9SYXcob2JzZXJ2ZWQpIHtcbiAgY29uc3QgcmF3ID0gb2JzZXJ2ZWQgJiYgb2JzZXJ2ZWRbXCJfX3ZfcmF3XCJdO1xuICByZXR1cm4gcmF3ID8gdG9SYXcocmF3KSA6IG9ic2VydmVkO1xufVxuZnVuY3Rpb24gbWFya1Jhdyh2YWx1ZSkge1xuICBkZWYodmFsdWUsIFwiX192X3NraXBcIiwgdHJ1ZSk7XG4gIHJldHVybiB2YWx1ZTtcbn1cbmNvbnN0IHRvUmVhY3RpdmUgPSAodmFsdWUpID0+IGlzT2JqZWN0KHZhbHVlKSA/IHJlYWN0aXZlKHZhbHVlKSA6IHZhbHVlO1xuY29uc3QgdG9SZWFkb25seSA9ICh2YWx1ZSkgPT4gaXNPYmplY3QodmFsdWUpID8gcmVhZG9ubHkodmFsdWUpIDogdmFsdWU7XG5cbmZ1bmN0aW9uIHRyYWNrUmVmVmFsdWUocmVmMikge1xuICBpZiAoc2hvdWxkVHJhY2sgJiYgYWN0aXZlRWZmZWN0KSB7XG4gICAgcmVmMiA9IHRvUmF3KHJlZjIpO1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICB0cmFja0VmZmVjdHMocmVmMi5kZXAgfHwgKHJlZjIuZGVwID0gY3JlYXRlRGVwKCkpLCB7XG4gICAgICAgIHRhcmdldDogcmVmMixcbiAgICAgICAgdHlwZTogXCJnZXRcIixcbiAgICAgICAga2V5OiBcInZhbHVlXCJcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0cmFja0VmZmVjdHMocmVmMi5kZXAgfHwgKHJlZjIuZGVwID0gY3JlYXRlRGVwKCkpKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHRyaWdnZXJSZWZWYWx1ZShyZWYyLCBuZXdWYWwpIHtcbiAgcmVmMiA9IHRvUmF3KHJlZjIpO1xuICBjb25zdCBkZXAgPSByZWYyLmRlcDtcbiAgaWYgKGRlcCkge1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICB0cmlnZ2VyRWZmZWN0cyhkZXAsIHtcbiAgICAgICAgdGFyZ2V0OiByZWYyLFxuICAgICAgICB0eXBlOiBcInNldFwiLFxuICAgICAgICBrZXk6IFwidmFsdWVcIixcbiAgICAgICAgbmV3VmFsdWU6IG5ld1ZhbFxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyaWdnZXJFZmZlY3RzKGRlcCk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBpc1JlZihyKSB7XG4gIHJldHVybiAhIShyICYmIHIuX192X2lzUmVmID09PSB0cnVlKTtcbn1cbmZ1bmN0aW9uIHJlZih2YWx1ZSkge1xuICByZXR1cm4gY3JlYXRlUmVmKHZhbHVlLCBmYWxzZSk7XG59XG5mdW5jdGlvbiBzaGFsbG93UmVmKHZhbHVlKSB7XG4gIHJldHVybiBjcmVhdGVSZWYodmFsdWUsIHRydWUpO1xufVxuZnVuY3Rpb24gY3JlYXRlUmVmKHJhd1ZhbHVlLCBzaGFsbG93KSB7XG4gIGlmIChpc1JlZihyYXdWYWx1ZSkpIHtcbiAgICByZXR1cm4gcmF3VmFsdWU7XG4gIH1cbiAgcmV0dXJuIG5ldyBSZWZJbXBsKHJhd1ZhbHVlLCBzaGFsbG93KTtcbn1cbmNsYXNzIFJlZkltcGwge1xuICBjb25zdHJ1Y3Rvcih2YWx1ZSwgX192X2lzU2hhbGxvdykge1xuICAgIHRoaXMuX192X2lzU2hhbGxvdyA9IF9fdl9pc1NoYWxsb3c7XG4gICAgdGhpcy5kZXAgPSB2b2lkIDA7XG4gICAgdGhpcy5fX3ZfaXNSZWYgPSB0cnVlO1xuICAgIHRoaXMuX3Jhd1ZhbHVlID0gX192X2lzU2hhbGxvdyA/IHZhbHVlIDogdG9SYXcodmFsdWUpO1xuICAgIHRoaXMuX3ZhbHVlID0gX192X2lzU2hhbGxvdyA/IHZhbHVlIDogdG9SZWFjdGl2ZSh2YWx1ZSk7XG4gIH1cbiAgZ2V0IHZhbHVlKCkge1xuICAgIHRyYWNrUmVmVmFsdWUodGhpcyk7XG4gICAgcmV0dXJuIHRoaXMuX3ZhbHVlO1xuICB9XG4gIHNldCB2YWx1ZShuZXdWYWwpIHtcbiAgICBjb25zdCB1c2VEaXJlY3RWYWx1ZSA9IHRoaXMuX192X2lzU2hhbGxvdyB8fCBpc1NoYWxsb3cobmV3VmFsKSB8fCBpc1JlYWRvbmx5KG5ld1ZhbCk7XG4gICAgbmV3VmFsID0gdXNlRGlyZWN0VmFsdWUgPyBuZXdWYWwgOiB0b1JhdyhuZXdWYWwpO1xuICAgIGlmIChoYXNDaGFuZ2VkKG5ld1ZhbCwgdGhpcy5fcmF3VmFsdWUpKSB7XG4gICAgICB0aGlzLl9yYXdWYWx1ZSA9IG5ld1ZhbDtcbiAgICAgIHRoaXMuX3ZhbHVlID0gdXNlRGlyZWN0VmFsdWUgPyBuZXdWYWwgOiB0b1JlYWN0aXZlKG5ld1ZhbCk7XG4gICAgICB0cmlnZ2VyUmVmVmFsdWUodGhpcywgbmV3VmFsKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHRyaWdnZXJSZWYocmVmMikge1xuICB0cmlnZ2VyUmVmVmFsdWUocmVmMiwgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IHJlZjIudmFsdWUgOiB2b2lkIDApO1xufVxuZnVuY3Rpb24gdW5yZWYocmVmMikge1xuICByZXR1cm4gaXNSZWYocmVmMikgPyByZWYyLnZhbHVlIDogcmVmMjtcbn1cbmZ1bmN0aW9uIHRvVmFsdWUoc291cmNlKSB7XG4gIHJldHVybiBpc0Z1bmN0aW9uKHNvdXJjZSkgPyBzb3VyY2UoKSA6IHVucmVmKHNvdXJjZSk7XG59XG5jb25zdCBzaGFsbG93VW53cmFwSGFuZGxlcnMgPSB7XG4gIGdldDogKHRhcmdldCwga2V5LCByZWNlaXZlcikgPT4gdW5yZWYoUmVmbGVjdC5nZXQodGFyZ2V0LCBrZXksIHJlY2VpdmVyKSksXG4gIHNldDogKHRhcmdldCwga2V5LCB2YWx1ZSwgcmVjZWl2ZXIpID0+IHtcbiAgICBjb25zdCBvbGRWYWx1ZSA9IHRhcmdldFtrZXldO1xuICAgIGlmIChpc1JlZihvbGRWYWx1ZSkgJiYgIWlzUmVmKHZhbHVlKSkge1xuICAgICAgb2xkVmFsdWUudmFsdWUgPSB2YWx1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gUmVmbGVjdC5zZXQodGFyZ2V0LCBrZXksIHZhbHVlLCByZWNlaXZlcik7XG4gICAgfVxuICB9XG59O1xuZnVuY3Rpb24gcHJveHlSZWZzKG9iamVjdFdpdGhSZWZzKSB7XG4gIHJldHVybiBpc1JlYWN0aXZlKG9iamVjdFdpdGhSZWZzKSA/IG9iamVjdFdpdGhSZWZzIDogbmV3IFByb3h5KG9iamVjdFdpdGhSZWZzLCBzaGFsbG93VW53cmFwSGFuZGxlcnMpO1xufVxuY2xhc3MgQ3VzdG9tUmVmSW1wbCB7XG4gIGNvbnN0cnVjdG9yKGZhY3RvcnkpIHtcbiAgICB0aGlzLmRlcCA9IHZvaWQgMDtcbiAgICB0aGlzLl9fdl9pc1JlZiA9IHRydWU7XG4gICAgY29uc3QgeyBnZXQsIHNldCB9ID0gZmFjdG9yeShcbiAgICAgICgpID0+IHRyYWNrUmVmVmFsdWUodGhpcyksXG4gICAgICAoKSA9PiB0cmlnZ2VyUmVmVmFsdWUodGhpcylcbiAgICApO1xuICAgIHRoaXMuX2dldCA9IGdldDtcbiAgICB0aGlzLl9zZXQgPSBzZXQ7XG4gIH1cbiAgZ2V0IHZhbHVlKCkge1xuICAgIHJldHVybiB0aGlzLl9nZXQoKTtcbiAgfVxuICBzZXQgdmFsdWUobmV3VmFsKSB7XG4gICAgdGhpcy5fc2V0KG5ld1ZhbCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGN1c3RvbVJlZihmYWN0b3J5KSB7XG4gIHJldHVybiBuZXcgQ3VzdG9tUmVmSW1wbChmYWN0b3J5KTtcbn1cbmZ1bmN0aW9uIHRvUmVmcyhvYmplY3QpIHtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgIWlzUHJveHkob2JqZWN0KSkge1xuICAgIGNvbnNvbGUud2FybihgdG9SZWZzKCkgZXhwZWN0cyBhIHJlYWN0aXZlIG9iamVjdCBidXQgcmVjZWl2ZWQgYSBwbGFpbiBvbmUuYCk7XG4gIH1cbiAgY29uc3QgcmV0ID0gaXNBcnJheShvYmplY3QpID8gbmV3IEFycmF5KG9iamVjdC5sZW5ndGgpIDoge307XG4gIGZvciAoY29uc3Qga2V5IGluIG9iamVjdCkge1xuICAgIHJldFtrZXldID0gcHJvcGVydHlUb1JlZihvYmplY3QsIGtleSk7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cbmNsYXNzIE9iamVjdFJlZkltcGwge1xuICBjb25zdHJ1Y3Rvcihfb2JqZWN0LCBfa2V5LCBfZGVmYXVsdFZhbHVlKSB7XG4gICAgdGhpcy5fb2JqZWN0ID0gX29iamVjdDtcbiAgICB0aGlzLl9rZXkgPSBfa2V5O1xuICAgIHRoaXMuX2RlZmF1bHRWYWx1ZSA9IF9kZWZhdWx0VmFsdWU7XG4gICAgdGhpcy5fX3ZfaXNSZWYgPSB0cnVlO1xuICB9XG4gIGdldCB2YWx1ZSgpIHtcbiAgICBjb25zdCB2YWwgPSB0aGlzLl9vYmplY3RbdGhpcy5fa2V5XTtcbiAgICByZXR1cm4gdmFsID09PSB2b2lkIDAgPyB0aGlzLl9kZWZhdWx0VmFsdWUgOiB2YWw7XG4gIH1cbiAgc2V0IHZhbHVlKG5ld1ZhbCkge1xuICAgIHRoaXMuX29iamVjdFt0aGlzLl9rZXldID0gbmV3VmFsO1xuICB9XG4gIGdldCBkZXAoKSB7XG4gICAgcmV0dXJuIGdldERlcEZyb21SZWFjdGl2ZSh0b1Jhdyh0aGlzLl9vYmplY3QpLCB0aGlzLl9rZXkpO1xuICB9XG59XG5jbGFzcyBHZXR0ZXJSZWZJbXBsIHtcbiAgY29uc3RydWN0b3IoX2dldHRlcikge1xuICAgIHRoaXMuX2dldHRlciA9IF9nZXR0ZXI7XG4gICAgdGhpcy5fX3ZfaXNSZWYgPSB0cnVlO1xuICAgIHRoaXMuX192X2lzUmVhZG9ubHkgPSB0cnVlO1xuICB9XG4gIGdldCB2YWx1ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0dGVyKCk7XG4gIH1cbn1cbmZ1bmN0aW9uIHRvUmVmKHNvdXJjZSwga2V5LCBkZWZhdWx0VmFsdWUpIHtcbiAgaWYgKGlzUmVmKHNvdXJjZSkpIHtcbiAgICByZXR1cm4gc291cmNlO1xuICB9IGVsc2UgaWYgKGlzRnVuY3Rpb24oc291cmNlKSkge1xuICAgIHJldHVybiBuZXcgR2V0dGVyUmVmSW1wbChzb3VyY2UpO1xuICB9IGVsc2UgaWYgKGlzT2JqZWN0KHNvdXJjZSkgJiYgYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICByZXR1cm4gcHJvcGVydHlUb1JlZihzb3VyY2UsIGtleSwgZGVmYXVsdFZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcmVmKHNvdXJjZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHByb3BlcnR5VG9SZWYoc291cmNlLCBrZXksIGRlZmF1bHRWYWx1ZSkge1xuICBjb25zdCB2YWwgPSBzb3VyY2Vba2V5XTtcbiAgcmV0dXJuIGlzUmVmKHZhbCkgPyB2YWwgOiBuZXcgT2JqZWN0UmVmSW1wbChcbiAgICBzb3VyY2UsXG4gICAga2V5LFxuICAgIGRlZmF1bHRWYWx1ZVxuICApO1xufVxuXG5jbGFzcyBDb21wdXRlZFJlZkltcGwge1xuICBjb25zdHJ1Y3RvcihnZXR0ZXIsIF9zZXR0ZXIsIGlzUmVhZG9ubHksIGlzU1NSKSB7XG4gICAgdGhpcy5fc2V0dGVyID0gX3NldHRlcjtcbiAgICB0aGlzLmRlcCA9IHZvaWQgMDtcbiAgICB0aGlzLl9fdl9pc1JlZiA9IHRydWU7XG4gICAgdGhpc1tcIl9fdl9pc1JlYWRvbmx5XCJdID0gZmFsc2U7XG4gICAgdGhpcy5fZGlydHkgPSB0cnVlO1xuICAgIHRoaXMuZWZmZWN0ID0gbmV3IFJlYWN0aXZlRWZmZWN0KGdldHRlciwgKCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLl9kaXJ0eSkge1xuICAgICAgICB0aGlzLl9kaXJ0eSA9IHRydWU7XG4gICAgICAgIHRyaWdnZXJSZWZWYWx1ZSh0aGlzKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLmVmZmVjdC5jb21wdXRlZCA9IHRoaXM7XG4gICAgdGhpcy5lZmZlY3QuYWN0aXZlID0gdGhpcy5fY2FjaGVhYmxlID0gIWlzU1NSO1xuICAgIHRoaXNbXCJfX3ZfaXNSZWFkb25seVwiXSA9IGlzUmVhZG9ubHk7XG4gIH1cbiAgZ2V0IHZhbHVlKCkge1xuICAgIGNvbnN0IHNlbGYgPSB0b1Jhdyh0aGlzKTtcbiAgICB0cmFja1JlZlZhbHVlKHNlbGYpO1xuICAgIGlmIChzZWxmLl9kaXJ0eSB8fCAhc2VsZi5fY2FjaGVhYmxlKSB7XG4gICAgICBzZWxmLl9kaXJ0eSA9IGZhbHNlO1xuICAgICAgc2VsZi5fdmFsdWUgPSBzZWxmLmVmZmVjdC5ydW4oKTtcbiAgICB9XG4gICAgcmV0dXJuIHNlbGYuX3ZhbHVlO1xuICB9XG4gIHNldCB2YWx1ZShuZXdWYWx1ZSkge1xuICAgIHRoaXMuX3NldHRlcihuZXdWYWx1ZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGNvbXB1dGVkKGdldHRlck9yT3B0aW9ucywgZGVidWdPcHRpb25zLCBpc1NTUiA9IGZhbHNlKSB7XG4gIGxldCBnZXR0ZXI7XG4gIGxldCBzZXR0ZXI7XG4gIGNvbnN0IG9ubHlHZXR0ZXIgPSBpc0Z1bmN0aW9uKGdldHRlck9yT3B0aW9ucyk7XG4gIGlmIChvbmx5R2V0dGVyKSB7XG4gICAgZ2V0dGVyID0gZ2V0dGVyT3JPcHRpb25zO1xuICAgIHNldHRlciA9ICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyAoKSA9PiB7XG4gICAgICBjb25zb2xlLndhcm4oXCJXcml0ZSBvcGVyYXRpb24gZmFpbGVkOiBjb21wdXRlZCB2YWx1ZSBpcyByZWFkb25seVwiKTtcbiAgICB9IDogTk9PUDtcbiAgfSBlbHNlIHtcbiAgICBnZXR0ZXIgPSBnZXR0ZXJPck9wdGlvbnMuZ2V0O1xuICAgIHNldHRlciA9IGdldHRlck9yT3B0aW9ucy5zZXQ7XG4gIH1cbiAgY29uc3QgY1JlZiA9IG5ldyBDb21wdXRlZFJlZkltcGwoZ2V0dGVyLCBzZXR0ZXIsIG9ubHlHZXR0ZXIgfHwgIXNldHRlciwgaXNTU1IpO1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBkZWJ1Z09wdGlvbnMgJiYgIWlzU1NSKSB7XG4gICAgY1JlZi5lZmZlY3Qub25UcmFjayA9IGRlYnVnT3B0aW9ucy5vblRyYWNrO1xuICAgIGNSZWYuZWZmZWN0Lm9uVHJpZ2dlciA9IGRlYnVnT3B0aW9ucy5vblRyaWdnZXI7XG4gIH1cbiAgcmV0dXJuIGNSZWY7XG59XG5cbmNvbnN0IHRpY2sgPSAvKiBAX19QVVJFX18gKi8gUHJvbWlzZS5yZXNvbHZlKCk7XG5jb25zdCBxdWV1ZSA9IFtdO1xubGV0IHF1ZXVlZCA9IGZhbHNlO1xuY29uc3Qgc2NoZWR1bGVyID0gKGZuKSA9PiB7XG4gIHF1ZXVlLnB1c2goZm4pO1xuICBpZiAoIXF1ZXVlZCkge1xuICAgIHF1ZXVlZCA9IHRydWU7XG4gICAgdGljay50aGVuKGZsdXNoKTtcbiAgfVxufTtcbmNvbnN0IGZsdXNoID0gKCkgPT4ge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDsgaSsrKSB7XG4gICAgcXVldWVbaV0oKTtcbiAgfVxuICBxdWV1ZS5sZW5ndGggPSAwO1xuICBxdWV1ZWQgPSBmYWxzZTtcbn07XG5jbGFzcyBEZWZlcnJlZENvbXB1dGVkUmVmSW1wbCB7XG4gIGNvbnN0cnVjdG9yKGdldHRlcikge1xuICAgIHRoaXMuZGVwID0gdm9pZCAwO1xuICAgIHRoaXMuX2RpcnR5ID0gdHJ1ZTtcbiAgICB0aGlzLl9fdl9pc1JlZiA9IHRydWU7XG4gICAgdGhpc1tcIl9fdl9pc1JlYWRvbmx5XCJdID0gdHJ1ZTtcbiAgICBsZXQgY29tcGFyZVRhcmdldDtcbiAgICBsZXQgaGFzQ29tcGFyZVRhcmdldCA9IGZhbHNlO1xuICAgIGxldCBzY2hlZHVsZWQgPSBmYWxzZTtcbiAgICB0aGlzLmVmZmVjdCA9IG5ldyBSZWFjdGl2ZUVmZmVjdChnZXR0ZXIsIChjb21wdXRlZFRyaWdnZXIpID0+IHtcbiAgICAgIGlmICh0aGlzLmRlcCkge1xuICAgICAgICBpZiAoY29tcHV0ZWRUcmlnZ2VyKSB7XG4gICAgICAgICAgY29tcGFyZVRhcmdldCA9IHRoaXMuX3ZhbHVlO1xuICAgICAgICAgIGhhc0NvbXBhcmVUYXJnZXQgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKCFzY2hlZHVsZWQpIHtcbiAgICAgICAgICBjb25zdCB2YWx1ZVRvQ29tcGFyZSA9IGhhc0NvbXBhcmVUYXJnZXQgPyBjb21wYXJlVGFyZ2V0IDogdGhpcy5fdmFsdWU7XG4gICAgICAgICAgc2NoZWR1bGVkID0gdHJ1ZTtcbiAgICAgICAgICBoYXNDb21wYXJlVGFyZ2V0ID0gZmFsc2U7XG4gICAgICAgICAgc2NoZWR1bGVyKCgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmVmZmVjdC5hY3RpdmUgJiYgdGhpcy5fZ2V0KCkgIT09IHZhbHVlVG9Db21wYXJlKSB7XG4gICAgICAgICAgICAgIHRyaWdnZXJSZWZWYWx1ZSh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNjaGVkdWxlZCA9IGZhbHNlO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgZSBvZiB0aGlzLmRlcCkge1xuICAgICAgICAgIGlmIChlLmNvbXB1dGVkIGluc3RhbmNlb2YgRGVmZXJyZWRDb21wdXRlZFJlZkltcGwpIHtcbiAgICAgICAgICAgIGUuc2NoZWR1bGVyKFxuICAgICAgICAgICAgICB0cnVlXG4gICAgICAgICAgICAgIC8qIGNvbXB1dGVkVHJpZ2dlciAqL1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuX2RpcnR5ID0gdHJ1ZTtcbiAgICB9KTtcbiAgICB0aGlzLmVmZmVjdC5jb21wdXRlZCA9IHRoaXM7XG4gIH1cbiAgX2dldCgpIHtcbiAgICBpZiAodGhpcy5fZGlydHkpIHtcbiAgICAgIHRoaXMuX2RpcnR5ID0gZmFsc2U7XG4gICAgICByZXR1cm4gdGhpcy5fdmFsdWUgPSB0aGlzLmVmZmVjdC5ydW4oKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3ZhbHVlO1xuICB9XG4gIGdldCB2YWx1ZSgpIHtcbiAgICB0cmFja1JlZlZhbHVlKHRoaXMpO1xuICAgIHJldHVybiB0b1Jhdyh0aGlzKS5fZ2V0KCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGRlZmVycmVkQ29tcHV0ZWQoZ2V0dGVyKSB7XG4gIHJldHVybiBuZXcgRGVmZXJyZWRDb21wdXRlZFJlZkltcGwoZ2V0dGVyKTtcbn1cblxuZXhwb3J0IHsgRWZmZWN0U2NvcGUsIElURVJBVEVfS0VZLCBSZWFjdGl2ZUVmZmVjdCwgY29tcHV0ZWQsIGN1c3RvbVJlZiwgZGVmZXJyZWRDb21wdXRlZCwgZWZmZWN0LCBlZmZlY3RTY29wZSwgZW5hYmxlVHJhY2tpbmcsIGdldEN1cnJlbnRTY29wZSwgaXNQcm94eSwgaXNSZWFjdGl2ZSwgaXNSZWFkb25seSwgaXNSZWYsIGlzU2hhbGxvdywgbWFya1Jhdywgb25TY29wZURpc3Bvc2UsIHBhdXNlVHJhY2tpbmcsIHByb3h5UmVmcywgcmVhY3RpdmUsIHJlYWRvbmx5LCByZWYsIHJlc2V0VHJhY2tpbmcsIHNoYWxsb3dSZWFjdGl2ZSwgc2hhbGxvd1JlYWRvbmx5LCBzaGFsbG93UmVmLCBzdG9wLCB0b1JhdywgdG9SZWYsIHRvUmVmcywgdG9WYWx1ZSwgdHJhY2ssIHRyaWdnZXIsIHRyaWdnZXJSZWYsIHVucmVmIH07XG4iLCJmdW5jdGlvbiBtYWtlTWFwKHN0ciwgZXhwZWN0c0xvd2VyQ2FzZSkge1xuICBjb25zdCBtYXAgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgY29uc3QgbGlzdCA9IHN0ci5zcGxpdChcIixcIik7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIG1hcFtsaXN0W2ldXSA9IHRydWU7XG4gIH1cbiAgcmV0dXJuIGV4cGVjdHNMb3dlckNhc2UgPyAodmFsKSA9PiAhIW1hcFt2YWwudG9Mb3dlckNhc2UoKV0gOiAodmFsKSA9PiAhIW1hcFt2YWxdO1xufVxuXG5jb25zdCBFTVBUWV9PQkogPSAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gT2JqZWN0LmZyZWV6ZSh7fSkgOiB7fTtcbmNvbnN0IEVNUFRZX0FSUiA9ICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyBPYmplY3QuZnJlZXplKFtdKSA6IFtdO1xuY29uc3QgTk9PUCA9ICgpID0+IHtcbn07XG5jb25zdCBOTyA9ICgpID0+IGZhbHNlO1xuY29uc3Qgb25SRSA9IC9eb25bXmEtel0vO1xuY29uc3QgaXNPbiA9IChrZXkpID0+IG9uUkUudGVzdChrZXkpO1xuY29uc3QgaXNNb2RlbExpc3RlbmVyID0gKGtleSkgPT4ga2V5LnN0YXJ0c1dpdGgoXCJvblVwZGF0ZTpcIik7XG5jb25zdCBleHRlbmQgPSBPYmplY3QuYXNzaWduO1xuY29uc3QgcmVtb3ZlID0gKGFyciwgZWwpID0+IHtcbiAgY29uc3QgaSA9IGFyci5pbmRleE9mKGVsKTtcbiAgaWYgKGkgPiAtMSkge1xuICAgIGFyci5zcGxpY2UoaSwgMSk7XG4gIH1cbn07XG5jb25zdCBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5jb25zdCBoYXNPd24gPSAodmFsLCBrZXkpID0+IGhhc093blByb3BlcnR5LmNhbGwodmFsLCBrZXkpO1xuY29uc3QgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5jb25zdCBpc01hcCA9ICh2YWwpID0+IHRvVHlwZVN0cmluZyh2YWwpID09PSBcIltvYmplY3QgTWFwXVwiO1xuY29uc3QgaXNTZXQgPSAodmFsKSA9PiB0b1R5cGVTdHJpbmcodmFsKSA9PT0gXCJbb2JqZWN0IFNldF1cIjtcbmNvbnN0IGlzRGF0ZSA9ICh2YWwpID0+IHRvVHlwZVN0cmluZyh2YWwpID09PSBcIltvYmplY3QgRGF0ZV1cIjtcbmNvbnN0IGlzUmVnRXhwID0gKHZhbCkgPT4gdG9UeXBlU3RyaW5nKHZhbCkgPT09IFwiW29iamVjdCBSZWdFeHBdXCI7XG5jb25zdCBpc0Z1bmN0aW9uID0gKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gXCJmdW5jdGlvblwiO1xuY29uc3QgaXNTdHJpbmcgPSAodmFsKSA9PiB0eXBlb2YgdmFsID09PSBcInN0cmluZ1wiO1xuY29uc3QgaXNTeW1ib2wgPSAodmFsKSA9PiB0eXBlb2YgdmFsID09PSBcInN5bWJvbFwiO1xuY29uc3QgaXNPYmplY3QgPSAodmFsKSA9PiB2YWwgIT09IG51bGwgJiYgdHlwZW9mIHZhbCA9PT0gXCJvYmplY3RcIjtcbmNvbnN0IGlzUHJvbWlzZSA9ICh2YWwpID0+IHtcbiAgcmV0dXJuIGlzT2JqZWN0KHZhbCkgJiYgaXNGdW5jdGlvbih2YWwudGhlbikgJiYgaXNGdW5jdGlvbih2YWwuY2F0Y2gpO1xufTtcbmNvbnN0IG9iamVjdFRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbmNvbnN0IHRvVHlwZVN0cmluZyA9ICh2YWx1ZSkgPT4gb2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG5jb25zdCB0b1Jhd1R5cGUgPSAodmFsdWUpID0+IHtcbiAgcmV0dXJuIHRvVHlwZVN0cmluZyh2YWx1ZSkuc2xpY2UoOCwgLTEpO1xufTtcbmNvbnN0IGlzUGxhaW5PYmplY3QgPSAodmFsKSA9PiB0b1R5cGVTdHJpbmcodmFsKSA9PT0gXCJbb2JqZWN0IE9iamVjdF1cIjtcbmNvbnN0IGlzSW50ZWdlcktleSA9IChrZXkpID0+IGlzU3RyaW5nKGtleSkgJiYga2V5ICE9PSBcIk5hTlwiICYmIGtleVswXSAhPT0gXCItXCIgJiYgXCJcIiArIHBhcnNlSW50KGtleSwgMTApID09PSBrZXk7XG5jb25zdCBpc1Jlc2VydmVkUHJvcCA9IC8qIEBfX1BVUkVfXyAqLyBtYWtlTWFwKFxuICAvLyB0aGUgbGVhZGluZyBjb21tYSBpcyBpbnRlbnRpb25hbCBzbyBlbXB0eSBzdHJpbmcgXCJcIiBpcyBhbHNvIGluY2x1ZGVkXG4gIFwiLGtleSxyZWYscmVmX2ZvcixyZWZfa2V5LG9uVm5vZGVCZWZvcmVNb3VudCxvblZub2RlTW91bnRlZCxvblZub2RlQmVmb3JlVXBkYXRlLG9uVm5vZGVVcGRhdGVkLG9uVm5vZGVCZWZvcmVVbm1vdW50LG9uVm5vZGVVbm1vdW50ZWRcIlxuKTtcbmNvbnN0IGlzQnVpbHRJbkRpcmVjdGl2ZSA9IC8qIEBfX1BVUkVfXyAqLyBtYWtlTWFwKFxuICBcImJpbmQsY2xvYWssZWxzZS1pZixlbHNlLGZvcixodG1sLGlmLG1vZGVsLG9uLG9uY2UscHJlLHNob3csc2xvdCx0ZXh0LG1lbW9cIlxuKTtcbmNvbnN0IGNhY2hlU3RyaW5nRnVuY3Rpb24gPSAoZm4pID0+IHtcbiAgY29uc3QgY2FjaGUgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgcmV0dXJuIChzdHIpID0+IHtcbiAgICBjb25zdCBoaXQgPSBjYWNoZVtzdHJdO1xuICAgIHJldHVybiBoaXQgfHwgKGNhY2hlW3N0cl0gPSBmbihzdHIpKTtcbiAgfTtcbn07XG5jb25zdCBjYW1lbGl6ZVJFID0gLy0oXFx3KS9nO1xuY29uc3QgY2FtZWxpemUgPSBjYWNoZVN0cmluZ0Z1bmN0aW9uKChzdHIpID0+IHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKGNhbWVsaXplUkUsIChfLCBjKSA9PiBjID8gYy50b1VwcGVyQ2FzZSgpIDogXCJcIik7XG59KTtcbmNvbnN0IGh5cGhlbmF0ZVJFID0gL1xcQihbQS1aXSkvZztcbmNvbnN0IGh5cGhlbmF0ZSA9IGNhY2hlU3RyaW5nRnVuY3Rpb24oXG4gIChzdHIpID0+IHN0ci5yZXBsYWNlKGh5cGhlbmF0ZVJFLCBcIi0kMVwiKS50b0xvd2VyQ2FzZSgpXG4pO1xuY29uc3QgY2FwaXRhbGl6ZSA9IGNhY2hlU3RyaW5nRnVuY3Rpb24oXG4gIChzdHIpID0+IHN0ci5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0ci5zbGljZSgxKVxuKTtcbmNvbnN0IHRvSGFuZGxlcktleSA9IGNhY2hlU3RyaW5nRnVuY3Rpb24oXG4gIChzdHIpID0+IHN0ciA/IGBvbiR7Y2FwaXRhbGl6ZShzdHIpfWAgOiBgYFxuKTtcbmNvbnN0IGhhc0NoYW5nZWQgPSAodmFsdWUsIG9sZFZhbHVlKSA9PiAhT2JqZWN0LmlzKHZhbHVlLCBvbGRWYWx1ZSk7XG5jb25zdCBpbnZva2VBcnJheUZucyA9IChmbnMsIGFyZykgPT4ge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGZucy5sZW5ndGg7IGkrKykge1xuICAgIGZuc1tpXShhcmcpO1xuICB9XG59O1xuY29uc3QgZGVmID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgdmFsdWVcbiAgfSk7XG59O1xuY29uc3QgbG9vc2VUb051bWJlciA9ICh2YWwpID0+IHtcbiAgY29uc3QgbiA9IHBhcnNlRmxvYXQodmFsKTtcbiAgcmV0dXJuIGlzTmFOKG4pID8gdmFsIDogbjtcbn07XG5jb25zdCB0b051bWJlciA9ICh2YWwpID0+IHtcbiAgY29uc3QgbiA9IGlzU3RyaW5nKHZhbCkgPyBOdW1iZXIodmFsKSA6IE5hTjtcbiAgcmV0dXJuIGlzTmFOKG4pID8gdmFsIDogbjtcbn07XG5sZXQgX2dsb2JhbFRoaXM7XG5jb25zdCBnZXRHbG9iYWxUaGlzID0gKCkgPT4ge1xuICByZXR1cm4gX2dsb2JhbFRoaXMgfHwgKF9nbG9iYWxUaGlzID0gdHlwZW9mIGdsb2JhbFRoaXMgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWxUaGlzIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB7fSk7XG59O1xuY29uc3QgaWRlbnRSRSA9IC9eW18kYS16QS1aXFx4QTAtXFx1RkZGRl1bXyRhLXpBLVowLTlcXHhBMC1cXHVGRkZGXSokLztcbmZ1bmN0aW9uIGdlblByb3BzQWNjZXNzRXhwKG5hbWUpIHtcbiAgcmV0dXJuIGlkZW50UkUudGVzdChuYW1lKSA/IGBfX3Byb3BzLiR7bmFtZX1gIDogYF9fcHJvcHNbJHtKU09OLnN0cmluZ2lmeShuYW1lKX1dYDtcbn1cblxuY29uc3QgUGF0Y2hGbGFnTmFtZXMgPSB7XG4gIFsxXTogYFRFWFRgLFxuICBbMl06IGBDTEFTU2AsXG4gIFs0XTogYFNUWUxFYCxcbiAgWzhdOiBgUFJPUFNgLFxuICBbMTZdOiBgRlVMTF9QUk9QU2AsXG4gIFszMl06IGBIWURSQVRFX0VWRU5UU2AsXG4gIFs2NF06IGBTVEFCTEVfRlJBR01FTlRgLFxuICBbMTI4XTogYEtFWUVEX0ZSQUdNRU5UYCxcbiAgWzI1Nl06IGBVTktFWUVEX0ZSQUdNRU5UYCxcbiAgWzUxMl06IGBORUVEX1BBVENIYCxcbiAgWzEwMjRdOiBgRFlOQU1JQ19TTE9UU2AsXG4gIFsyMDQ4XTogYERFVl9ST09UX0ZSQUdNRU5UYCxcbiAgWy0xXTogYEhPSVNURURgLFxuICBbLTJdOiBgQkFJTGBcbn07XG5cbmNvbnN0IHNsb3RGbGFnc1RleHQgPSB7XG4gIFsxXTogXCJTVEFCTEVcIixcbiAgWzJdOiBcIkRZTkFNSUNcIixcbiAgWzNdOiBcIkZPUldBUkRFRFwiXG59O1xuXG5jb25zdCBHTE9CQUxTX1dISVRFX0xJU1RFRCA9IFwiSW5maW5pdHksdW5kZWZpbmVkLE5hTixpc0Zpbml0ZSxpc05hTixwYXJzZUZsb2F0LHBhcnNlSW50LGRlY29kZVVSSSxkZWNvZGVVUklDb21wb25lbnQsZW5jb2RlVVJJLGVuY29kZVVSSUNvbXBvbmVudCxNYXRoLE51bWJlcixEYXRlLEFycmF5LE9iamVjdCxCb29sZWFuLFN0cmluZyxSZWdFeHAsTWFwLFNldCxKU09OLEludGwsQmlnSW50LGNvbnNvbGVcIjtcbmNvbnN0IGlzR2xvYmFsbHlXaGl0ZWxpc3RlZCA9IC8qIEBfX1BVUkVfXyAqLyBtYWtlTWFwKEdMT0JBTFNfV0hJVEVfTElTVEVEKTtcblxuY29uc3QgcmFuZ2UgPSAyO1xuZnVuY3Rpb24gZ2VuZXJhdGVDb2RlRnJhbWUoc291cmNlLCBzdGFydCA9IDAsIGVuZCA9IHNvdXJjZS5sZW5ndGgpIHtcbiAgbGV0IGxpbmVzID0gc291cmNlLnNwbGl0KC8oXFxyP1xcbikvKTtcbiAgY29uc3QgbmV3bGluZVNlcXVlbmNlcyA9IGxpbmVzLmZpbHRlcigoXywgaWR4KSA9PiBpZHggJSAyID09PSAxKTtcbiAgbGluZXMgPSBsaW5lcy5maWx0ZXIoKF8sIGlkeCkgPT4gaWR4ICUgMiA9PT0gMCk7XG4gIGxldCBjb3VudCA9IDA7XG4gIGNvbnN0IHJlcyA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgY291bnQgKz0gbGluZXNbaV0ubGVuZ3RoICsgKG5ld2xpbmVTZXF1ZW5jZXNbaV0gJiYgbmV3bGluZVNlcXVlbmNlc1tpXS5sZW5ndGggfHwgMCk7XG4gICAgaWYgKGNvdW50ID49IHN0YXJ0KSB7XG4gICAgICBmb3IgKGxldCBqID0gaSAtIHJhbmdlOyBqIDw9IGkgKyByYW5nZSB8fCBlbmQgPiBjb3VudDsgaisrKSB7XG4gICAgICAgIGlmIChqIDwgMCB8fCBqID49IGxpbmVzLmxlbmd0aClcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgY29uc3QgbGluZSA9IGogKyAxO1xuICAgICAgICByZXMucHVzaChcbiAgICAgICAgICBgJHtsaW5lfSR7XCIgXCIucmVwZWF0KE1hdGgubWF4KDMgLSBTdHJpbmcobGluZSkubGVuZ3RoLCAwKSl9fCAgJHtsaW5lc1tqXX1gXG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IGxpbmVMZW5ndGggPSBsaW5lc1tqXS5sZW5ndGg7XG4gICAgICAgIGNvbnN0IG5ld0xpbmVTZXFMZW5ndGggPSBuZXdsaW5lU2VxdWVuY2VzW2pdICYmIG5ld2xpbmVTZXF1ZW5jZXNbal0ubGVuZ3RoIHx8IDA7XG4gICAgICAgIGlmIChqID09PSBpKSB7XG4gICAgICAgICAgY29uc3QgcGFkID0gc3RhcnQgLSAoY291bnQgLSAobGluZUxlbmd0aCArIG5ld0xpbmVTZXFMZW5ndGgpKTtcbiAgICAgICAgICBjb25zdCBsZW5ndGggPSBNYXRoLm1heChcbiAgICAgICAgICAgIDEsXG4gICAgICAgICAgICBlbmQgPiBjb3VudCA/IGxpbmVMZW5ndGggLSBwYWQgOiBlbmQgLSBzdGFydFxuICAgICAgICAgICk7XG4gICAgICAgICAgcmVzLnB1c2goYCAgIHwgIGAgKyBcIiBcIi5yZXBlYXQocGFkKSArIFwiXlwiLnJlcGVhdChsZW5ndGgpKTtcbiAgICAgICAgfSBlbHNlIGlmIChqID4gaSkge1xuICAgICAgICAgIGlmIChlbmQgPiBjb3VudCkge1xuICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0gTWF0aC5tYXgoTWF0aC5taW4oZW5kIC0gY291bnQsIGxpbmVMZW5ndGgpLCAxKTtcbiAgICAgICAgICAgIHJlcy5wdXNoKGAgICB8ICBgICsgXCJeXCIucmVwZWF0KGxlbmd0aCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb3VudCArPSBsaW5lTGVuZ3RoICsgbmV3TGluZVNlcUxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXMuam9pbihcIlxcblwiKTtcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplU3R5bGUodmFsdWUpIHtcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgY29uc3QgcmVzID0ge307XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgaXRlbSA9IHZhbHVlW2ldO1xuICAgICAgY29uc3Qgbm9ybWFsaXplZCA9IGlzU3RyaW5nKGl0ZW0pID8gcGFyc2VTdHJpbmdTdHlsZShpdGVtKSA6IG5vcm1hbGl6ZVN0eWxlKGl0ZW0pO1xuICAgICAgaWYgKG5vcm1hbGl6ZWQpIHtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gbm9ybWFsaXplZCkge1xuICAgICAgICAgIHJlc1trZXldID0gbm9ybWFsaXplZFtrZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXM7XG4gIH0gZWxzZSBpZiAoaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9IGVsc2UgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxufVxuY29uc3QgbGlzdERlbGltaXRlclJFID0gLzsoPyFbXihdKlxcKSkvZztcbmNvbnN0IHByb3BlcnR5RGVsaW1pdGVyUkUgPSAvOihbXl0rKS87XG5jb25zdCBzdHlsZUNvbW1lbnRSRSA9IC9cXC9cXCpbXl0qP1xcKlxcLy9nO1xuZnVuY3Rpb24gcGFyc2VTdHJpbmdTdHlsZShjc3NUZXh0KSB7XG4gIGNvbnN0IHJldCA9IHt9O1xuICBjc3NUZXh0LnJlcGxhY2Uoc3R5bGVDb21tZW50UkUsIFwiXCIpLnNwbGl0KGxpc3REZWxpbWl0ZXJSRSkuZm9yRWFjaCgoaXRlbSkgPT4ge1xuICAgIGlmIChpdGVtKSB7XG4gICAgICBjb25zdCB0bXAgPSBpdGVtLnNwbGl0KHByb3BlcnR5RGVsaW1pdGVyUkUpO1xuICAgICAgdG1wLmxlbmd0aCA+IDEgJiYgKHJldFt0bXBbMF0udHJpbSgpXSA9IHRtcFsxXS50cmltKCkpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiByZXQ7XG59XG5mdW5jdGlvbiBzdHJpbmdpZnlTdHlsZShzdHlsZXMpIHtcbiAgbGV0IHJldCA9IFwiXCI7XG4gIGlmICghc3R5bGVzIHx8IGlzU3RyaW5nKHN0eWxlcykpIHtcbiAgICByZXR1cm4gcmV0O1xuICB9XG4gIGZvciAoY29uc3Qga2V5IGluIHN0eWxlcykge1xuICAgIGNvbnN0IHZhbHVlID0gc3R5bGVzW2tleV07XG4gICAgY29uc3Qgbm9ybWFsaXplZEtleSA9IGtleS5zdGFydHNXaXRoKGAtLWApID8ga2V5IDogaHlwaGVuYXRlKGtleSk7XG4gICAgaWYgKGlzU3RyaW5nKHZhbHVlKSB8fCB0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHJldCArPSBgJHtub3JtYWxpemVkS2V5fToke3ZhbHVlfTtgO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmV0O1xufVxuZnVuY3Rpb24gbm9ybWFsaXplQ2xhc3ModmFsdWUpIHtcbiAgbGV0IHJlcyA9IFwiXCI7XG4gIGlmIChpc1N0cmluZyh2YWx1ZSkpIHtcbiAgICByZXMgPSB2YWx1ZTtcbiAgfSBlbHNlIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSBub3JtYWxpemVDbGFzcyh2YWx1ZVtpXSk7XG4gICAgICBpZiAobm9ybWFsaXplZCkge1xuICAgICAgICByZXMgKz0gbm9ybWFsaXplZCArIFwiIFwiO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICBmb3IgKGNvbnN0IG5hbWUgaW4gdmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZVtuYW1lXSkge1xuICAgICAgICByZXMgKz0gbmFtZSArIFwiIFwiO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzLnRyaW0oKTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZVByb3BzKHByb3BzKSB7XG4gIGlmICghcHJvcHMpXG4gICAgcmV0dXJuIG51bGw7XG4gIGxldCB7IGNsYXNzOiBrbGFzcywgc3R5bGUgfSA9IHByb3BzO1xuICBpZiAoa2xhc3MgJiYgIWlzU3RyaW5nKGtsYXNzKSkge1xuICAgIHByb3BzLmNsYXNzID0gbm9ybWFsaXplQ2xhc3Moa2xhc3MpO1xuICB9XG4gIGlmIChzdHlsZSkge1xuICAgIHByb3BzLnN0eWxlID0gbm9ybWFsaXplU3R5bGUoc3R5bGUpO1xuICB9XG4gIHJldHVybiBwcm9wcztcbn1cblxuY29uc3QgSFRNTF9UQUdTID0gXCJodG1sLGJvZHksYmFzZSxoZWFkLGxpbmssbWV0YSxzdHlsZSx0aXRsZSxhZGRyZXNzLGFydGljbGUsYXNpZGUsZm9vdGVyLGhlYWRlcixoZ3JvdXAsaDEsaDIsaDMsaDQsaDUsaDYsbmF2LHNlY3Rpb24sZGl2LGRkLGRsLGR0LGZpZ2NhcHRpb24sZmlndXJlLHBpY3R1cmUsaHIsaW1nLGxpLG1haW4sb2wscCxwcmUsdWwsYSxiLGFiYnIsYmRpLGJkbyxicixjaXRlLGNvZGUsZGF0YSxkZm4sZW0saSxrYmQsbWFyayxxLHJwLHJ0LHJ1YnkscyxzYW1wLHNtYWxsLHNwYW4sc3Ryb25nLHN1YixzdXAsdGltZSx1LHZhcix3YnIsYXJlYSxhdWRpbyxtYXAsdHJhY2ssdmlkZW8sZW1iZWQsb2JqZWN0LHBhcmFtLHNvdXJjZSxjYW52YXMsc2NyaXB0LG5vc2NyaXB0LGRlbCxpbnMsY2FwdGlvbixjb2wsY29sZ3JvdXAsdGFibGUsdGhlYWQsdGJvZHksdGQsdGgsdHIsYnV0dG9uLGRhdGFsaXN0LGZpZWxkc2V0LGZvcm0saW5wdXQsbGFiZWwsbGVnZW5kLG1ldGVyLG9wdGdyb3VwLG9wdGlvbixvdXRwdXQscHJvZ3Jlc3Msc2VsZWN0LHRleHRhcmVhLGRldGFpbHMsZGlhbG9nLG1lbnUsc3VtbWFyeSx0ZW1wbGF0ZSxibG9ja3F1b3RlLGlmcmFtZSx0Zm9vdFwiO1xuY29uc3QgU1ZHX1RBR1MgPSBcInN2ZyxhbmltYXRlLGFuaW1hdGVNb3Rpb24sYW5pbWF0ZVRyYW5zZm9ybSxjaXJjbGUsY2xpcFBhdGgsY29sb3ItcHJvZmlsZSxkZWZzLGRlc2MsZGlzY2FyZCxlbGxpcHNlLGZlQmxlbmQsZmVDb2xvck1hdHJpeCxmZUNvbXBvbmVudFRyYW5zZmVyLGZlQ29tcG9zaXRlLGZlQ29udm9sdmVNYXRyaXgsZmVEaWZmdXNlTGlnaHRpbmcsZmVEaXNwbGFjZW1lbnRNYXAsZmVEaXN0YW50TGlnaHQsZmVEcm9wU2hhZG93LGZlRmxvb2QsZmVGdW5jQSxmZUZ1bmNCLGZlRnVuY0csZmVGdW5jUixmZUdhdXNzaWFuQmx1cixmZUltYWdlLGZlTWVyZ2UsZmVNZXJnZU5vZGUsZmVNb3JwaG9sb2d5LGZlT2Zmc2V0LGZlUG9pbnRMaWdodCxmZVNwZWN1bGFyTGlnaHRpbmcsZmVTcG90TGlnaHQsZmVUaWxlLGZlVHVyYnVsZW5jZSxmaWx0ZXIsZm9yZWlnbk9iamVjdCxnLGhhdGNoLGhhdGNocGF0aCxpbWFnZSxsaW5lLGxpbmVhckdyYWRpZW50LG1hcmtlcixtYXNrLG1lc2gsbWVzaGdyYWRpZW50LG1lc2hwYXRjaCxtZXNocm93LG1ldGFkYXRhLG1wYXRoLHBhdGgscGF0dGVybixwb2x5Z29uLHBvbHlsaW5lLHJhZGlhbEdyYWRpZW50LHJlY3Qsc2V0LHNvbGlkY29sb3Isc3RvcCxzd2l0Y2gsc3ltYm9sLHRleHQsdGV4dFBhdGgsdGl0bGUsdHNwYW4sdW5rbm93bix1c2Usdmlld1wiO1xuY29uc3QgVk9JRF9UQUdTID0gXCJhcmVhLGJhc2UsYnIsY29sLGVtYmVkLGhyLGltZyxpbnB1dCxsaW5rLG1ldGEscGFyYW0sc291cmNlLHRyYWNrLHdiclwiO1xuY29uc3QgaXNIVE1MVGFnID0gLyogQF9fUFVSRV9fICovIG1ha2VNYXAoSFRNTF9UQUdTKTtcbmNvbnN0IGlzU1ZHVGFnID0gLyogQF9fUFVSRV9fICovIG1ha2VNYXAoU1ZHX1RBR1MpO1xuY29uc3QgaXNWb2lkVGFnID0gLyogQF9fUFVSRV9fICovIG1ha2VNYXAoVk9JRF9UQUdTKTtcblxuY29uc3Qgc3BlY2lhbEJvb2xlYW5BdHRycyA9IGBpdGVtc2NvcGUsYWxsb3dmdWxsc2NyZWVuLGZvcm1ub3ZhbGlkYXRlLGlzbWFwLG5vbW9kdWxlLG5vdmFsaWRhdGUscmVhZG9ubHlgO1xuY29uc3QgaXNTcGVjaWFsQm9vbGVhbkF0dHIgPSAvKiBAX19QVVJFX18gKi8gbWFrZU1hcChzcGVjaWFsQm9vbGVhbkF0dHJzKTtcbmNvbnN0IGlzQm9vbGVhbkF0dHIgPSAvKiBAX19QVVJFX18gKi8gbWFrZU1hcChcbiAgc3BlY2lhbEJvb2xlYW5BdHRycyArIGAsYXN5bmMsYXV0b2ZvY3VzLGF1dG9wbGF5LGNvbnRyb2xzLGRlZmF1bHQsZGVmZXIsZGlzYWJsZWQsaGlkZGVuLGluZXJ0LGxvb3Asb3BlbixyZXF1aXJlZCxyZXZlcnNlZCxzY29wZWQsc2VhbWxlc3MsY2hlY2tlZCxtdXRlZCxtdWx0aXBsZSxzZWxlY3RlZGBcbik7XG5mdW5jdGlvbiBpbmNsdWRlQm9vbGVhbkF0dHIodmFsdWUpIHtcbiAgcmV0dXJuICEhdmFsdWUgfHwgdmFsdWUgPT09IFwiXCI7XG59XG5jb25zdCB1bnNhZmVBdHRyQ2hhclJFID0gL1s+Lz1cIidcXHUwMDA5XFx1MDAwYVxcdTAwMGNcXHUwMDIwXS87XG5jb25zdCBhdHRyVmFsaWRhdGlvbkNhY2hlID0ge307XG5mdW5jdGlvbiBpc1NTUlNhZmVBdHRyTmFtZShuYW1lKSB7XG4gIGlmIChhdHRyVmFsaWRhdGlvbkNhY2hlLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgcmV0dXJuIGF0dHJWYWxpZGF0aW9uQ2FjaGVbbmFtZV07XG4gIH1cbiAgY29uc3QgaXNVbnNhZmUgPSB1bnNhZmVBdHRyQ2hhclJFLnRlc3QobmFtZSk7XG4gIGlmIChpc1Vuc2FmZSkge1xuICAgIGNvbnNvbGUuZXJyb3IoYHVuc2FmZSBhdHRyaWJ1dGUgbmFtZTogJHtuYW1lfWApO1xuICB9XG4gIHJldHVybiBhdHRyVmFsaWRhdGlvbkNhY2hlW25hbWVdID0gIWlzVW5zYWZlO1xufVxuY29uc3QgcHJvcHNUb0F0dHJNYXAgPSB7XG4gIGFjY2VwdENoYXJzZXQ6IFwiYWNjZXB0LWNoYXJzZXRcIixcbiAgY2xhc3NOYW1lOiBcImNsYXNzXCIsXG4gIGh0bWxGb3I6IFwiZm9yXCIsXG4gIGh0dHBFcXVpdjogXCJodHRwLWVxdWl2XCJcbn07XG5jb25zdCBpc0tub3duSHRtbEF0dHIgPSAvKiBAX19QVVJFX18gKi8gbWFrZU1hcChcbiAgYGFjY2VwdCxhY2NlcHQtY2hhcnNldCxhY2Nlc3NrZXksYWN0aW9uLGFsaWduLGFsbG93LGFsdCxhc3luYyxhdXRvY2FwaXRhbGl6ZSxhdXRvY29tcGxldGUsYXV0b2ZvY3VzLGF1dG9wbGF5LGJhY2tncm91bmQsYmdjb2xvcixib3JkZXIsYnVmZmVyZWQsY2FwdHVyZSxjaGFsbGVuZ2UsY2hhcnNldCxjaGVja2VkLGNpdGUsY2xhc3MsY29kZSxjb2RlYmFzZSxjb2xvcixjb2xzLGNvbHNwYW4sY29udGVudCxjb250ZW50ZWRpdGFibGUsY29udGV4dG1lbnUsY29udHJvbHMsY29vcmRzLGNyb3Nzb3JpZ2luLGNzcCxkYXRhLGRhdGV0aW1lLGRlY29kaW5nLGRlZmF1bHQsZGVmZXIsZGlyLGRpcm5hbWUsZGlzYWJsZWQsZG93bmxvYWQsZHJhZ2dhYmxlLGRyb3B6b25lLGVuY3R5cGUsZW50ZXJrZXloaW50LGZvcixmb3JtLGZvcm1hY3Rpb24sZm9ybWVuY3R5cGUsZm9ybW1ldGhvZCxmb3Jtbm92YWxpZGF0ZSxmb3JtdGFyZ2V0LGhlYWRlcnMsaGVpZ2h0LGhpZGRlbixoaWdoLGhyZWYsaHJlZmxhbmcsaHR0cC1lcXVpdixpY29uLGlkLGltcG9ydGFuY2UsaW5lcnQsaW50ZWdyaXR5LGlzbWFwLGl0ZW1wcm9wLGtleXR5cGUsa2luZCxsYWJlbCxsYW5nLGxhbmd1YWdlLGxvYWRpbmcsbGlzdCxsb29wLGxvdyxtYW5pZmVzdCxtYXgsbWF4bGVuZ3RoLG1pbmxlbmd0aCxtZWRpYSxtaW4sbXVsdGlwbGUsbXV0ZWQsbmFtZSxub3ZhbGlkYXRlLG9wZW4sb3B0aW11bSxwYXR0ZXJuLHBpbmcscGxhY2Vob2xkZXIscG9zdGVyLHByZWxvYWQscmFkaW9ncm91cCxyZWFkb25seSxyZWZlcnJlcnBvbGljeSxyZWwscmVxdWlyZWQscmV2ZXJzZWQscm93cyxyb3dzcGFuLHNhbmRib3gsc2NvcGUsc2NvcGVkLHNlbGVjdGVkLHNoYXBlLHNpemUsc2l6ZXMsc2xvdCxzcGFuLHNwZWxsY2hlY2ssc3JjLHNyY2RvYyxzcmNsYW5nLHNyY3NldCxzdGFydCxzdGVwLHN0eWxlLHN1bW1hcnksdGFiaW5kZXgsdGFyZ2V0LHRpdGxlLHRyYW5zbGF0ZSx0eXBlLHVzZW1hcCx2YWx1ZSx3aWR0aCx3cmFwYFxuKTtcbmNvbnN0IGlzS25vd25TdmdBdHRyID0gLyogQF9fUFVSRV9fICovIG1ha2VNYXAoXG4gIGB4bWxucyxhY2NlbnQtaGVpZ2h0LGFjY3VtdWxhdGUsYWRkaXRpdmUsYWxpZ25tZW50LWJhc2VsaW5lLGFscGhhYmV0aWMsYW1wbGl0dWRlLGFyYWJpYy1mb3JtLGFzY2VudCxhdHRyaWJ1dGVOYW1lLGF0dHJpYnV0ZVR5cGUsYXppbXV0aCxiYXNlRnJlcXVlbmN5LGJhc2VsaW5lLXNoaWZ0LGJhc2VQcm9maWxlLGJib3gsYmVnaW4sYmlhcyxieSxjYWxjTW9kZSxjYXAtaGVpZ2h0LGNsYXNzLGNsaXAsY2xpcFBhdGhVbml0cyxjbGlwLXBhdGgsY2xpcC1ydWxlLGNvbG9yLGNvbG9yLWludGVycG9sYXRpb24sY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzLGNvbG9yLXByb2ZpbGUsY29sb3ItcmVuZGVyaW5nLGNvbnRlbnRTY3JpcHRUeXBlLGNvbnRlbnRTdHlsZVR5cGUsY3Jvc3NvcmlnaW4sY3Vyc29yLGN4LGN5LGQsZGVjZWxlcmF0ZSxkZXNjZW50LGRpZmZ1c2VDb25zdGFudCxkaXJlY3Rpb24sZGlzcGxheSxkaXZpc29yLGRvbWluYW50LWJhc2VsaW5lLGR1cixkeCxkeSxlZGdlTW9kZSxlbGV2YXRpb24sZW5hYmxlLWJhY2tncm91bmQsZW5kLGV4cG9uZW50LGZpbGwsZmlsbC1vcGFjaXR5LGZpbGwtcnVsZSxmaWx0ZXIsZmlsdGVyUmVzLGZpbHRlclVuaXRzLGZsb29kLWNvbG9yLGZsb29kLW9wYWNpdHksZm9udC1mYW1pbHksZm9udC1zaXplLGZvbnQtc2l6ZS1hZGp1c3QsZm9udC1zdHJldGNoLGZvbnQtc3R5bGUsZm9udC12YXJpYW50LGZvbnQtd2VpZ2h0LGZvcm1hdCxmcm9tLGZyLGZ4LGZ5LGcxLGcyLGdseXBoLW5hbWUsZ2x5cGgtb3JpZW50YXRpb24taG9yaXpvbnRhbCxnbHlwaC1vcmllbnRhdGlvbi12ZXJ0aWNhbCxnbHlwaFJlZixncmFkaWVudFRyYW5zZm9ybSxncmFkaWVudFVuaXRzLGhhbmdpbmcsaGVpZ2h0LGhyZWYsaHJlZmxhbmcsaG9yaXotYWR2LXgsaG9yaXotb3JpZ2luLXgsaWQsaWRlb2dyYXBoaWMsaW1hZ2UtcmVuZGVyaW5nLGluLGluMixpbnRlcmNlcHQsayxrMSxrMixrMyxrNCxrZXJuZWxNYXRyaXgsa2VybmVsVW5pdExlbmd0aCxrZXJuaW5nLGtleVBvaW50cyxrZXlTcGxpbmVzLGtleVRpbWVzLGxhbmcsbGVuZ3RoQWRqdXN0LGxldHRlci1zcGFjaW5nLGxpZ2h0aW5nLWNvbG9yLGxpbWl0aW5nQ29uZUFuZ2xlLGxvY2FsLG1hcmtlci1lbmQsbWFya2VyLW1pZCxtYXJrZXItc3RhcnQsbWFya2VySGVpZ2h0LG1hcmtlclVuaXRzLG1hcmtlcldpZHRoLG1hc2ssbWFza0NvbnRlbnRVbml0cyxtYXNrVW5pdHMsbWF0aGVtYXRpY2FsLG1heCxtZWRpYSxtZXRob2QsbWluLG1vZGUsbmFtZSxudW1PY3RhdmVzLG9mZnNldCxvcGFjaXR5LG9wZXJhdG9yLG9yZGVyLG9yaWVudCxvcmllbnRhdGlvbixvcmlnaW4sb3ZlcmZsb3csb3ZlcmxpbmUtcG9zaXRpb24sb3ZlcmxpbmUtdGhpY2tuZXNzLHBhbm9zZS0xLHBhaW50LW9yZGVyLHBhdGgscGF0aExlbmd0aCxwYXR0ZXJuQ29udGVudFVuaXRzLHBhdHRlcm5UcmFuc2Zvcm0scGF0dGVyblVuaXRzLHBpbmcscG9pbnRlci1ldmVudHMscG9pbnRzLHBvaW50c0F0WCxwb2ludHNBdFkscG9pbnRzQXRaLHByZXNlcnZlQWxwaGEscHJlc2VydmVBc3BlY3RSYXRpbyxwcmltaXRpdmVVbml0cyxyLHJhZGl1cyxyZWZlcnJlclBvbGljeSxyZWZYLHJlZlkscmVsLHJlbmRlcmluZy1pbnRlbnQscmVwZWF0Q291bnQscmVwZWF0RHVyLHJlcXVpcmVkRXh0ZW5zaW9ucyxyZXF1aXJlZEZlYXR1cmVzLHJlc3RhcnQscmVzdWx0LHJvdGF0ZSxyeCxyeSxzY2FsZSxzZWVkLHNoYXBlLXJlbmRlcmluZyxzbG9wZSxzcGFjaW5nLHNwZWN1bGFyQ29uc3RhbnQsc3BlY3VsYXJFeHBvbmVudCxzcGVlZCxzcHJlYWRNZXRob2Qsc3RhcnRPZmZzZXQsc3RkRGV2aWF0aW9uLHN0ZW1oLHN0ZW12LHN0aXRjaFRpbGVzLHN0b3AtY29sb3Isc3RvcC1vcGFjaXR5LHN0cmlrZXRocm91Z2gtcG9zaXRpb24sc3RyaWtldGhyb3VnaC10aGlja25lc3Msc3RyaW5nLHN0cm9rZSxzdHJva2UtZGFzaGFycmF5LHN0cm9rZS1kYXNob2Zmc2V0LHN0cm9rZS1saW5lY2FwLHN0cm9rZS1saW5lam9pbixzdHJva2UtbWl0ZXJsaW1pdCxzdHJva2Utb3BhY2l0eSxzdHJva2Utd2lkdGgsc3R5bGUsc3VyZmFjZVNjYWxlLHN5c3RlbUxhbmd1YWdlLHRhYmluZGV4LHRhYmxlVmFsdWVzLHRhcmdldCx0YXJnZXRYLHRhcmdldFksdGV4dC1hbmNob3IsdGV4dC1kZWNvcmF0aW9uLHRleHQtcmVuZGVyaW5nLHRleHRMZW5ndGgsdG8sdHJhbnNmb3JtLHRyYW5zZm9ybS1vcmlnaW4sdHlwZSx1MSx1Mix1bmRlcmxpbmUtcG9zaXRpb24sdW5kZXJsaW5lLXRoaWNrbmVzcyx1bmljb2RlLHVuaWNvZGUtYmlkaSx1bmljb2RlLXJhbmdlLHVuaXRzLXBlci1lbSx2LWFscGhhYmV0aWMsdi1oYW5naW5nLHYtaWRlb2dyYXBoaWMsdi1tYXRoZW1hdGljYWwsdmFsdWVzLHZlY3Rvci1lZmZlY3QsdmVyc2lvbix2ZXJ0LWFkdi15LHZlcnQtb3JpZ2luLXgsdmVydC1vcmlnaW4teSx2aWV3Qm94LHZpZXdUYXJnZXQsdmlzaWJpbGl0eSx3aWR0aCx3aWR0aHMsd29yZC1zcGFjaW5nLHdyaXRpbmctbW9kZSx4LHgtaGVpZ2h0LHgxLHgyLHhDaGFubmVsU2VsZWN0b3IseGxpbms6YWN0dWF0ZSx4bGluazphcmNyb2xlLHhsaW5rOmhyZWYseGxpbms6cm9sZSx4bGluazpzaG93LHhsaW5rOnRpdGxlLHhsaW5rOnR5cGUseG1sOmJhc2UseG1sOmxhbmcseG1sOnNwYWNlLHkseTEseTIseUNoYW5uZWxTZWxlY3Rvcix6LHpvb21BbmRQYW5gXG4pO1xuXG5jb25zdCBlc2NhcGVSRSA9IC9bXCInJjw+XS87XG5mdW5jdGlvbiBlc2NhcGVIdG1sKHN0cmluZykge1xuICBjb25zdCBzdHIgPSBcIlwiICsgc3RyaW5nO1xuICBjb25zdCBtYXRjaCA9IGVzY2FwZVJFLmV4ZWMoc3RyKTtcbiAgaWYgKCFtYXRjaCkge1xuICAgIHJldHVybiBzdHI7XG4gIH1cbiAgbGV0IGh0bWwgPSBcIlwiO1xuICBsZXQgZXNjYXBlZDtcbiAgbGV0IGluZGV4O1xuICBsZXQgbGFzdEluZGV4ID0gMDtcbiAgZm9yIChpbmRleCA9IG1hdGNoLmluZGV4OyBpbmRleCA8IHN0ci5sZW5ndGg7IGluZGV4KyspIHtcbiAgICBzd2l0Y2ggKHN0ci5jaGFyQ29kZUF0KGluZGV4KSkge1xuICAgICAgY2FzZSAzNDpcbiAgICAgICAgZXNjYXBlZCA9IFwiJnF1b3Q7XCI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzODpcbiAgICAgICAgZXNjYXBlZCA9IFwiJmFtcDtcIjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDM5OlxuICAgICAgICBlc2NhcGVkID0gXCImIzM5O1wiO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgNjA6XG4gICAgICAgIGVzY2FwZWQgPSBcIiZsdDtcIjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDYyOlxuICAgICAgICBlc2NhcGVkID0gXCImZ3Q7XCI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChsYXN0SW5kZXggIT09IGluZGV4KSB7XG4gICAgICBodG1sICs9IHN0ci5zbGljZShsYXN0SW5kZXgsIGluZGV4KTtcbiAgICB9XG4gICAgbGFzdEluZGV4ID0gaW5kZXggKyAxO1xuICAgIGh0bWwgKz0gZXNjYXBlZDtcbiAgfVxuICByZXR1cm4gbGFzdEluZGV4ICE9PSBpbmRleCA/IGh0bWwgKyBzdHIuc2xpY2UobGFzdEluZGV4LCBpbmRleCkgOiBodG1sO1xufVxuY29uc3QgY29tbWVudFN0cmlwUkUgPSAvXi0/Pnw8IS0tfC0tPnwtLSE+fDwhLSQvZztcbmZ1bmN0aW9uIGVzY2FwZUh0bWxDb21tZW50KHNyYykge1xuICByZXR1cm4gc3JjLnJlcGxhY2UoY29tbWVudFN0cmlwUkUsIFwiXCIpO1xufVxuXG5mdW5jdGlvbiBsb29zZUNvbXBhcmVBcnJheXMoYSwgYikge1xuICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKVxuICAgIHJldHVybiBmYWxzZTtcbiAgbGV0IGVxdWFsID0gdHJ1ZTtcbiAgZm9yIChsZXQgaSA9IDA7IGVxdWFsICYmIGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgZXF1YWwgPSBsb29zZUVxdWFsKGFbaV0sIGJbaV0pO1xuICB9XG4gIHJldHVybiBlcXVhbDtcbn1cbmZ1bmN0aW9uIGxvb3NlRXF1YWwoYSwgYikge1xuICBpZiAoYSA9PT0gYilcbiAgICByZXR1cm4gdHJ1ZTtcbiAgbGV0IGFWYWxpZFR5cGUgPSBpc0RhdGUoYSk7XG4gIGxldCBiVmFsaWRUeXBlID0gaXNEYXRlKGIpO1xuICBpZiAoYVZhbGlkVHlwZSB8fCBiVmFsaWRUeXBlKSB7XG4gICAgcmV0dXJuIGFWYWxpZFR5cGUgJiYgYlZhbGlkVHlwZSA/IGEuZ2V0VGltZSgpID09PSBiLmdldFRpbWUoKSA6IGZhbHNlO1xuICB9XG4gIGFWYWxpZFR5cGUgPSBpc1N5bWJvbChhKTtcbiAgYlZhbGlkVHlwZSA9IGlzU3ltYm9sKGIpO1xuICBpZiAoYVZhbGlkVHlwZSB8fCBiVmFsaWRUeXBlKSB7XG4gICAgcmV0dXJuIGEgPT09IGI7XG4gIH1cbiAgYVZhbGlkVHlwZSA9IGlzQXJyYXkoYSk7XG4gIGJWYWxpZFR5cGUgPSBpc0FycmF5KGIpO1xuICBpZiAoYVZhbGlkVHlwZSB8fCBiVmFsaWRUeXBlKSB7XG4gICAgcmV0dXJuIGFWYWxpZFR5cGUgJiYgYlZhbGlkVHlwZSA/IGxvb3NlQ29tcGFyZUFycmF5cyhhLCBiKSA6IGZhbHNlO1xuICB9XG4gIGFWYWxpZFR5cGUgPSBpc09iamVjdChhKTtcbiAgYlZhbGlkVHlwZSA9IGlzT2JqZWN0KGIpO1xuICBpZiAoYVZhbGlkVHlwZSB8fCBiVmFsaWRUeXBlKSB7XG4gICAgaWYgKCFhVmFsaWRUeXBlIHx8ICFiVmFsaWRUeXBlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGFLZXlzQ291bnQgPSBPYmplY3Qua2V5cyhhKS5sZW5ndGg7XG4gICAgY29uc3QgYktleXNDb3VudCA9IE9iamVjdC5rZXlzKGIpLmxlbmd0aDtcbiAgICBpZiAoYUtleXNDb3VudCAhPT0gYktleXNDb3VudCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGtleSBpbiBhKSB7XG4gICAgICBjb25zdCBhSGFzS2V5ID0gYS5oYXNPd25Qcm9wZXJ0eShrZXkpO1xuICAgICAgY29uc3QgYkhhc0tleSA9IGIuaGFzT3duUHJvcGVydHkoa2V5KTtcbiAgICAgIGlmIChhSGFzS2V5ICYmICFiSGFzS2V5IHx8ICFhSGFzS2V5ICYmIGJIYXNLZXkgfHwgIWxvb3NlRXF1YWwoYVtrZXldLCBiW2tleV0pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIFN0cmluZyhhKSA9PT0gU3RyaW5nKGIpO1xufVxuZnVuY3Rpb24gbG9vc2VJbmRleE9mKGFyciwgdmFsKSB7XG4gIHJldHVybiBhcnIuZmluZEluZGV4KChpdGVtKSA9PiBsb29zZUVxdWFsKGl0ZW0sIHZhbCkpO1xufVxuXG5jb25zdCB0b0Rpc3BsYXlTdHJpbmcgPSAodmFsKSA9PiB7XG4gIHJldHVybiBpc1N0cmluZyh2YWwpID8gdmFsIDogdmFsID09IG51bGwgPyBcIlwiIDogaXNBcnJheSh2YWwpIHx8IGlzT2JqZWN0KHZhbCkgJiYgKHZhbC50b1N0cmluZyA9PT0gb2JqZWN0VG9TdHJpbmcgfHwgIWlzRnVuY3Rpb24odmFsLnRvU3RyaW5nKSkgPyBKU09OLnN0cmluZ2lmeSh2YWwsIHJlcGxhY2VyLCAyKSA6IFN0cmluZyh2YWwpO1xufTtcbmNvbnN0IHJlcGxhY2VyID0gKF9rZXksIHZhbCkgPT4ge1xuICBpZiAodmFsICYmIHZhbC5fX3ZfaXNSZWYpIHtcbiAgICByZXR1cm4gcmVwbGFjZXIoX2tleSwgdmFsLnZhbHVlKTtcbiAgfSBlbHNlIGlmIChpc01hcCh2YWwpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIFtgTWFwKCR7dmFsLnNpemV9KWBdOiBbLi4udmFsLmVudHJpZXMoKV0ucmVkdWNlKChlbnRyaWVzLCBba2V5LCB2YWwyXSkgPT4ge1xuICAgICAgICBlbnRyaWVzW2Ake2tleX0gPT5gXSA9IHZhbDI7XG4gICAgICAgIHJldHVybiBlbnRyaWVzO1xuICAgICAgfSwge30pXG4gICAgfTtcbiAgfSBlbHNlIGlmIChpc1NldCh2YWwpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIFtgU2V0KCR7dmFsLnNpemV9KWBdOiBbLi4udmFsLnZhbHVlcygpXVxuICAgIH07XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QodmFsKSAmJiAhaXNBcnJheSh2YWwpICYmICFpc1BsYWluT2JqZWN0KHZhbCkpIHtcbiAgICByZXR1cm4gU3RyaW5nKHZhbCk7XG4gIH1cbiAgcmV0dXJuIHZhbDtcbn07XG5cbmV4cG9ydCB7IEVNUFRZX0FSUiwgRU1QVFlfT0JKLCBOTywgTk9PUCwgUGF0Y2hGbGFnTmFtZXMsIGNhbWVsaXplLCBjYXBpdGFsaXplLCBkZWYsIGVzY2FwZUh0bWwsIGVzY2FwZUh0bWxDb21tZW50LCBleHRlbmQsIGdlblByb3BzQWNjZXNzRXhwLCBnZW5lcmF0ZUNvZGVGcmFtZSwgZ2V0R2xvYmFsVGhpcywgaGFzQ2hhbmdlZCwgaGFzT3duLCBoeXBoZW5hdGUsIGluY2x1ZGVCb29sZWFuQXR0ciwgaW52b2tlQXJyYXlGbnMsIGlzQXJyYXksIGlzQm9vbGVhbkF0dHIsIGlzQnVpbHRJbkRpcmVjdGl2ZSwgaXNEYXRlLCBpc0Z1bmN0aW9uLCBpc0dsb2JhbGx5V2hpdGVsaXN0ZWQsIGlzSFRNTFRhZywgaXNJbnRlZ2VyS2V5LCBpc0tub3duSHRtbEF0dHIsIGlzS25vd25TdmdBdHRyLCBpc01hcCwgaXNNb2RlbExpc3RlbmVyLCBpc09iamVjdCwgaXNPbiwgaXNQbGFpbk9iamVjdCwgaXNQcm9taXNlLCBpc1JlZ0V4cCwgaXNSZXNlcnZlZFByb3AsIGlzU1NSU2FmZUF0dHJOYW1lLCBpc1NWR1RhZywgaXNTZXQsIGlzU3BlY2lhbEJvb2xlYW5BdHRyLCBpc1N0cmluZywgaXNTeW1ib2wsIGlzVm9pZFRhZywgbG9vc2VFcXVhbCwgbG9vc2VJbmRleE9mLCBsb29zZVRvTnVtYmVyLCBtYWtlTWFwLCBub3JtYWxpemVDbGFzcywgbm9ybWFsaXplUHJvcHMsIG5vcm1hbGl6ZVN0eWxlLCBvYmplY3RUb1N0cmluZywgcGFyc2VTdHJpbmdTdHlsZSwgcHJvcHNUb0F0dHJNYXAsIHJlbW92ZSwgc2xvdEZsYWdzVGV4dCwgc3RyaW5naWZ5U3R5bGUsIHRvRGlzcGxheVN0cmluZywgdG9IYW5kbGVyS2V5LCB0b051bWJlciwgdG9SYXdUeXBlLCB0b1R5cGVTdHJpbmcgfTtcbiIsImV4cG9ydHMuaW50ZXJvcERlZmF1bHQgPSBmdW5jdGlvbiAoYSkge1xuICByZXR1cm4gYSAmJiBhLl9fZXNNb2R1bGUgPyBhIDoge2RlZmF1bHQ6IGF9O1xufTtcblxuZXhwb3J0cy5kZWZpbmVJbnRlcm9wRmxhZyA9IGZ1bmN0aW9uIChhKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhLCAnX19lc01vZHVsZScsIHt2YWx1ZTogdHJ1ZX0pO1xufTtcblxuZXhwb3J0cy5leHBvcnRBbGwgPSBmdW5jdGlvbiAoc291cmNlLCBkZXN0KSB7XG4gIE9iamVjdC5rZXlzKHNvdXJjZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgaWYgKGtleSA9PT0gJ2RlZmF1bHQnIHx8IGtleSA9PT0gJ19fZXNNb2R1bGUnIHx8IGRlc3QuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShkZXN0LCBrZXksIHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZVtrZXldO1xuICAgICAgfSxcbiAgICB9KTtcbiAgfSk7XG5cbiAgcmV0dXJuIGRlc3Q7XG59O1xuXG5leHBvcnRzLmV4cG9ydCA9IGZ1bmN0aW9uIChkZXN0LCBkZXN0TmFtZSwgZ2V0KSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShkZXN0LCBkZXN0TmFtZSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBnZXQsXG4gIH0pO1xufTtcbiIsIjx0ZW1wbGF0ZT5cbiAgPGRpdj5cbiAgICA8QXBwV2lkZ2V0PjwvQXBwV2lkZ2V0PlxuICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzdHlsZT5cbjpyb290IHtcbiAgZm9udC1mYW1pbHk6IEludGVyLCBzeXN0ZW0tdWksIEF2ZW5pciwgSGVsdmV0aWNhLCBBcmlhbCwgc2Fucy1zZXJpZjtcbiAgbGluZS1oZWlnaHQ6IDEuNTtcbiAgZm9udC13ZWlnaHQ6IDQwMDtcblxuICBjb2xvci1zY2hlbWU6IGxpZ2h0IGRhcms7XG4gIGNvbG9yOiByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuODcpO1xuICBiYWNrZ3JvdW5kLWNvbG9yOiAjMjQyNDI0O1xuXG4gIGZvbnQtc3ludGhlc2lzOiBub25lO1xuICB0ZXh0LXJlbmRlcmluZzogb3B0aW1pemVMZWdpYmlsaXR5O1xuICAtd2Via2l0LWZvbnQtc21vb3RoaW5nOiBhbnRpYWxpYXNlZDtcbiAgLW1vei1vc3gtZm9udC1zbW9vdGhpbmc6IGdyYXlzY2FsZTtcbiAgLXdlYmtpdC10ZXh0LXNpemUtYWRqdXN0OiAxMDAlO1xufVxuXG5hIHtcbiAgZm9udC13ZWlnaHQ6IDUwMDtcbiAgY29sb3I6ICM2NDZjZmY7XG4gIHRleHQtZGVjb3JhdGlvbjogaW5oZXJpdDtcbn1cbmE6aG92ZXIge1xuICBjb2xvcjogIzUzNWJmMjtcbn1cblxuLmJvZHkge1xuICBtYXJnaW46IDA7XG4gIGRpc3BsYXk6IGZsZXg7XG4gIHBsYWNlLWl0ZW1zOiBjZW50ZXI7XG4gIG1pbi13aWR0aDogMzIwcHg7XG4gIG1pbi1oZWlnaHQ6IDEwMHZoO1xufVxuXG5oMSB7XG4gIGZvbnQtc2l6ZTogMy4yZW07XG4gIGxpbmUtaGVpZ2h0OiAxLjE7XG59XG5cbmJ1dHRvbiB7XG4gIGJvcmRlci1yYWRpdXM6IDhweDtcbiAgYm9yZGVyOiAxcHggc29saWQgdHJhbnNwYXJlbnQ7XG4gIHBhZGRpbmc6IDAuNmVtIDEuMmVtO1xuICBmb250LXNpemU6IDFlbTtcbiAgZm9udC13ZWlnaHQ6IDUwMDtcbiAgZm9udC1mYW1pbHk6IGluaGVyaXQ7XG4gIGJhY2tncm91bmQtY29sb3I6ICMxYTFhMWE7XG4gIGN1cnNvcjogcG9pbnRlcjtcbiAgdHJhbnNpdGlvbjogYm9yZGVyLWNvbG9yIDAuMjVzO1xufVxuYnV0dG9uOmhvdmVyIHtcbiAgYm9yZGVyLWNvbG9yOiAjNjQ2Y2ZmO1xufVxuYnV0dG9uOmZvY3VzLFxuYnV0dG9uOmZvY3VzLXZpc2libGUge1xuICBvdXRsaW5lOiA0cHggYXV0byAtd2Via2l0LWZvY3VzLXJpbmctY29sb3I7XG59XG5cbi5jYXJkIHtcbiAgcGFkZGluZzogMmVtO1xufVxuXG4jYXBwIHtcbiAgbWF4LXdpZHRoOiAxMjgwcHg7XG4gIG1hcmdpbjogMCBhdXRvO1xuICBwYWRkaW5nOiAycmVtO1xuICB0ZXh0LWFsaWduOiBjZW50ZXI7XG59XG5cbkBtZWRpYSAocHJlZmVycy1jb2xvci1zY2hlbWU6IGxpZ2h0KSB7XG4gIDpyb290IHtcbiAgICBjb2xvcjogIzIxMzU0NztcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjZmZmZmZmO1xuICB9XG4gIGE6aG92ZXIge1xuICAgIGNvbG9yOiAjNzQ3YmZmO1xuICB9XG4gIGJ1dHRvbiB7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogI2Y5ZjlmOTtcbiAgfVxufVxuXG48L3N0eWxlPlxuXG48c2NyaXB0IHNldHVwIGxhbmc9XCJ0c1wiPlxuaW1wb3J0IEFwcFdpZGdldCBmcm9tIFwiLi9BcHAudnVlXCI7XG5cbmRlZmluZU9wdGlvbnMoe1xuICAvLyBwcmVwYXJlKGFwcDogQXBwKSB7XG4gIC8vICAgLy8gVXNlIGFueSBwbHVnaW5zIGhlcmU6XG4gIC8vICAgLy8gYXBwLnVzZVxuICAvLyB9LFxufSk7XG48L3NjcmlwdD5cbiIsIjxzY3JpcHQgc2V0dXAgbGFuZz1cInRzXCI+XG5pbXBvcnQgSGVsbG9Xb3JsZCBmcm9tICcuL2NvbXBvbmVudHMvSGVsbG9Xb3JsZC52dWUnXG48L3NjcmlwdD5cblxuPHRlbXBsYXRlPlxuICA8ZGl2IGNsYXNzPVwiYm9keVwiPlxuICAgIDxhIGhyZWY9XCJodHRwczovL3ZpdGVqcy5kZXZcIiB0YXJnZXQ9XCJfYmxhbmtcIj5cbiAgICAgIDxpbWcgc3JjPVwiL3ZpdGUuc3ZnXCIgY2xhc3M9XCJsb2dvXCIgYWx0PVwiVml0ZSBsb2dvXCIgLz5cbiAgICA8L2E+XG4gICAgPGEgaHJlZj1cImh0dHBzOi8vdnVlanMub3JnL1wiIHRhcmdldD1cIl9ibGFua1wiPlxuICAgICAgPGltZyBzcmM9XCIuL2Fzc2V0cy92dWUuc3ZnXCIgY2xhc3M9XCJsb2dvIHZ1ZVwiIGFsdD1cIlZ1ZSBsb2dvXCIgLz5cbiAgICA8L2E+XG4gIDwvZGl2PlxuICA8SGVsbG9Xb3JsZCBtc2c9XCJWaXRlICsgVnVlXCIgLz5cbjwvdGVtcGxhdGU+XG5cbjxzdHlsZSBzY29wZWQ+XG4ubG9nbyB7XG4gIGhlaWdodDogNmVtO1xuICBwYWRkaW5nOiAxLjVlbTtcbiAgd2lsbC1jaGFuZ2U6IGZpbHRlcjtcbiAgdHJhbnNpdGlvbjogZmlsdGVyIDMwMG1zO1xufVxuLmxvZ286aG92ZXIge1xuICBmaWx0ZXI6IGRyb3Atc2hhZG93KDAgMCAyZW0gIzY0NmNmZmFhKTtcbn1cbi5sb2dvLnZ1ZTpob3ZlciB7XG4gIGZpbHRlcjogZHJvcC1zaGFkb3coMCAwIDJlbSAjNDJiODgzYWEpO1xufVxuPC9zdHlsZT5cbiIsIjxzY3JpcHQgc2V0dXAgbGFuZz1cInRzXCI+XG5pbXBvcnQgeyByZWYgfSBmcm9tICd2dWUnXG5cbmRlZmluZVByb3BzPHsgbXNnOiBzdHJpbmcgfT4oKVxuXG5jb25zdCBjb3VudCA9IHJlZigwKVxuPC9zY3JpcHQ+XG5cbjx0ZW1wbGF0ZT5cbiAgPGgxPnt7IG1zZyB9fTwvaDE+XG5cbiAgPGRpdiBjbGFzcz1cImNhcmRcIj5cbiAgICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBAY2xpY2s9XCJjb3VudCsrXCI+Y291bnQgaXMge3sgY291bnQgfX08L2J1dHRvbj5cbiAgICA8cD5cbiAgICAgIEVkaXRcbiAgICAgIDxjb2RlPmNvbXBvbmVudHMvSGVsbG9Xb3JsZC52dWU8L2NvZGU+IHRvIHRlc3QgSE1SXG4gICAgPC9wPlxuICA8L2Rpdj5cblxuICA8cD5cbiAgICBDaGVjayBvdXRcbiAgICA8YSBocmVmPVwiaHR0cHM6Ly92dWVqcy5vcmcvZ3VpZGUvcXVpY2stc3RhcnQuaHRtbCNsb2NhbFwiIHRhcmdldD1cIl9ibGFua1wiXG4gICAgICA+Y3JlYXRlLXZ1ZTwvYVxuICAgID4sIHRoZSBvZmZpY2lhbCBWdWUgKyBWaXRlIHN0YXJ0ZXJcbiAgPC9wPlxuICA8cD5cbiAgICBJbnN0YWxsXG4gICAgPGEgaHJlZj1cImh0dHBzOi8vZ2l0aHViLmNvbS92dWVqcy9sYW5ndWFnZS10b29sc1wiIHRhcmdldD1cIl9ibGFua1wiPlZvbGFyPC9hPlxuICAgIGluIHlvdXIgSURFIGZvciBhIGJldHRlciBEWFxuICA8L3A+XG4gIDxwIGNsYXNzPVwicmVhZC10aGUtZG9jc1wiPkNsaWNrIG9uIHRoZSBWaXRlIGFuZCBWdWUgbG9nb3MgdG8gbGVhcm4gbW9yZTwvcD5cbjwvdGVtcGxhdGU+XG5cbjxzdHlsZSBzY29wZWQ+XG4ucmVhZC10aGUtZG9jcyB7XG4gIGNvbG9yOiAjODg4O1xufVxuPC9zdHlsZT5cbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9oZWxwZXJzL2J1bmRsZS11cmwnKS5nZXRCdW5kbGVVUkwoJ2NlU2RkJykgKyBcInZ1ZS5hM2NlMGI2OC5zdmdcIiArIFwiP1wiICsgRGF0ZS5ub3coKTsiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIGJ1bmRsZVVSTCA9IHt9O1xuZnVuY3Rpb24gZ2V0QnVuZGxlVVJMQ2FjaGVkKGlkKSB7XG4gIHZhciB2YWx1ZSA9IGJ1bmRsZVVSTFtpZF07XG4gIGlmICghdmFsdWUpIHtcbiAgICB2YWx1ZSA9IGdldEJ1bmRsZVVSTCgpO1xuICAgIGJ1bmRsZVVSTFtpZF0gPSB2YWx1ZTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiBnZXRCdW5kbGVVUkwoKSB7XG4gIHRyeSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHZhciBtYXRjaGVzID0gKCcnICsgZXJyLnN0YWNrKS5tYXRjaCgvKGh0dHBzP3xmaWxlfGZ0cHwoY2hyb21lfG1venxzYWZhcmktd2ViKS1leHRlbnNpb24pOlxcL1xcL1teKVxcbl0rL2cpO1xuICAgIGlmIChtYXRjaGVzKSB7XG4gICAgICAvLyBUaGUgZmlyc3QgdHdvIHN0YWNrIGZyYW1lcyB3aWxsIGJlIHRoaXMgZnVuY3Rpb24gYW5kIGdldEJ1bmRsZVVSTENhY2hlZC5cbiAgICAgIC8vIFVzZSB0aGUgM3JkIG9uZSwgd2hpY2ggd2lsbCBiZSBhIHJ1bnRpbWUgaW4gdGhlIG9yaWdpbmFsIGJ1bmRsZS5cbiAgICAgIHJldHVybiBnZXRCYXNlVVJMKG1hdGNoZXNbMl0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gJy8nO1xufVxuZnVuY3Rpb24gZ2V0QmFzZVVSTCh1cmwpIHtcbiAgcmV0dXJuICgnJyArIHVybCkucmVwbGFjZSgvXigoPzpodHRwcz98ZmlsZXxmdHB8KGNocm9tZXxtb3p8c2FmYXJpLXdlYiktZXh0ZW5zaW9uKTpcXC9cXC8uKylcXC9bXi9dKyQvLCAnJDEnKSArICcvJztcbn1cblxuLy8gVE9ETzogUmVwbGFjZSB1c2VzIHdpdGggYG5ldyBVUkwodXJsKS5vcmlnaW5gIHdoZW4gaWUxMSBpcyBubyBsb25nZXIgc3VwcG9ydGVkLlxuZnVuY3Rpb24gZ2V0T3JpZ2luKHVybCkge1xuICB2YXIgbWF0Y2hlcyA9ICgnJyArIHVybCkubWF0Y2goLyhodHRwcz98ZmlsZXxmdHB8KGNocm9tZXxtb3p8c2FmYXJpLXdlYiktZXh0ZW5zaW9uKTpcXC9cXC9bXi9dKy8pO1xuICBpZiAoIW1hdGNoZXMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ09yaWdpbiBub3QgZm91bmQnKTtcbiAgfVxuICByZXR1cm4gbWF0Y2hlc1swXTtcbn1cbmV4cG9ydHMuZ2V0QnVuZGxlVVJMID0gZ2V0QnVuZGxlVVJMQ2FjaGVkO1xuZXhwb3J0cy5nZXRCYXNlVVJMID0gZ2V0QmFzZVVSTDtcbmV4cG9ydHMuZ2V0T3JpZ2luID0gZ2V0T3JpZ2luOyIsImdsb2JhbFRoaXMuX19WVUVfT1BUSU9OU19BUElfXyA9IHRydWVcbmdsb2JhbFRoaXMuX19WVUVfUFJPRF9ERVZUT09MU19fID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiXG4iXSwibmFtZXMiOltdLCJ2ZXJzaW9uIjozLCJmaWxlIjoicG9wdXAuN2UzOTRjOGIuanMubWFwIn0=
 globalThis.define=__define;  })(globalThis.define);