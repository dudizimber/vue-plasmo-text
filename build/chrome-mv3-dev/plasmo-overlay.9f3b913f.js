(function(define){var __define; typeof define === "function" && (__define=define,define=null);
// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles

(function (modules, entry, mainEntry, parcelRequireName, globalName) {
  /* eslint-disable no-undef */
  var globalObject =
    typeof globalThis !== 'undefined'
      ? globalThis
      : typeof self !== 'undefined'
      ? self
      : typeof window !== 'undefined'
      ? window
      : typeof global !== 'undefined'
      ? global
      : {};
  /* eslint-enable no-undef */

  // Save the require from previous bundle to this closure if any
  var previousRequire =
    typeof globalObject[parcelRequireName] === 'function' &&
    globalObject[parcelRequireName];

  var cache = previousRequire.cache || {};
  // Do not use `require` to prevent Webpack from trying to bundle this call
  var nodeRequire =
    typeof module !== 'undefined' &&
    typeof module.require === 'function' &&
    module.require.bind(module);

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire =
          typeof globalObject[parcelRequireName] === 'function' &&
          globalObject[parcelRequireName];
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error("Cannot find module '" + name + "'");
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = (cache[name] = new newRequire.Module(name));

      modules[name][0].call(
        module.exports,
        localRequire,
        module,
        module.exports,
        this
      );
    }

    return cache[name].exports;

    function localRequire(x) {
      var res = localRequire.resolve(x);
      return res === false ? {} : newRequire(res);
    }

    function resolve(x) {
      var id = modules[name][1][x];
      return id != null ? id : x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.register = function (id, exports) {
    modules[id] = [
      function (require, module) {
        module.exports = exports;
      },
      {},
    ];
  };

  Object.defineProperty(newRequire, 'root', {
    get: function () {
      return globalObject[parcelRequireName];
    },
  });

  globalObject[parcelRequireName] = newRequire;

  for (var i = 0; i < entry.length; i++) {
    newRequire(entry[i]);
  }

  if (mainEntry) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(mainEntry);

    // CommonJS
    if (typeof exports === 'object' && typeof module !== 'undefined') {
      module.exports = mainExports;

      // RequireJS
    } else if (typeof define === 'function' && define.amd) {
      define(function () {
        return mainExports;
      });

      // <script>
    } else if (globalName) {
      this[globalName] = mainExports;
    }
  }
})({"V8rbn":[function(require,module,exports) {
var p = typeof globalThis.process < "u" ? globalThis.process.argv : [];
var y = ()=>typeof globalThis.process < "u" ? globalThis.process.env : {};
var M = new Set(p), _ = (e)=>M.has(e), z = p.filter((e)=>e.startsWith("--") && e.includes("=")).map((e)=>e.split("=")).reduce((e, [t, o])=>(e[t] = o, e), {});
var X = _("--dry-run"), d = ()=>_("--verbose") || y().VERBOSE === "true", G = d();
var u = (e = "", ...t)=>console.log(e.padEnd(9), "|", ...t);
var v = (...e)=>console.error("\uD83D\uDD34 ERROR".padEnd(9), "|", ...e), x = (...e)=>u("\uD83D\uDD35 INFO", ...e), g = (...e)=>u("\uD83D\uDFE0 WARN", ...e), D = 0, c = (...e)=>d() && u(`\u{1F7E1} ${D++}`, ...e);
var s = {
    "isContentScript": true,
    "isBackground": false,
    "isReact": false,
    "runtimes": [
        "script-runtime"
    ],
    "host": "localhost",
    "port": 1815,
    "entryFilePath": "/Users/davidzimberknopf/Documents/Apps/vue-plasmo-text/.plasmo/static/contents/plasmo-overlay.ts",
    "bundleId": "62bf693c9f3b913f",
    "envHash": "e792fbbdaa78ee84",
    "verbose": "false",
    "secure": false,
    "serverPort": 52712
};
module.bundle.HMR_BUNDLE_ID = s.bundleId;
globalThis.process = {
    argv: [],
    env: {
        VERBOSE: s.verbose
    }
};
var H = module.bundle.Module;
function I(e) {
    H.call(this, e), this.hot = {
        data: module.bundle.hotData[e],
        _acceptCallbacks: [],
        _disposeCallbacks: [],
        accept: function(t) {
            this._acceptCallbacks.push(t || function() {});
        },
        dispose: function(t) {
            this._disposeCallbacks.push(t);
        }
    }, module.bundle.hotData[e] = void 0;
}
module.bundle.Module = I;
module.bundle.hotData = {};
var l = globalThis.browser || globalThis.chrome || null;
function b() {
    return !s.host || s.host === "0.0.0.0" ? location.protocol.indexOf("http") === 0 ? location.hostname : "localhost" : s.host;
}
function C() {
    return s.port || location.port;
}
var E = "__plasmo_runtime_script_";
function L(e, t) {
    let { modules: o } = e;
    return o ? !!o[t] : !1;
}
function S(e = C()) {
    let t = b();
    return `${s.secure || location.protocol === "https:" && !/localhost|127.0.0.1|0.0.0.0/.test(t) ? "wss" : "ws"}://${t}:${e}/`;
}
function O(e) {
    typeof e.message == "string" && v("[plasmo/parcel-runtime]: " + e.message);
}
function P(e) {
    if (typeof globalThis.WebSocket > "u") return;
    let t = new WebSocket(S());
    return t.addEventListener("message", async function(o) {
        let r = JSON.parse(o.data);
        if (r.type === "update" && await e(r.assets), r.type === "error") for (let i of r.diagnostics.ansi){
            let w = i.codeframe || i.stack;
            g("[plasmo/parcel-runtime]: " + i.message + `
` + w + `

` + i.hints.join(`
`));
        }
    }), t.addEventListener("error", O), t.addEventListener("open", ()=>{
        x(`[plasmo/parcel-runtime]: Connected to HMR server for ${s.entryFilePath}`);
    }), t.addEventListener("close", ()=>{
        g(`[plasmo/parcel-runtime]: Connection to the HMR server is closed for ${s.entryFilePath}`);
    }), t;
}
var n = "__plasmo-loading__";
function m() {
    return document.getElementById(n);
}
function f() {
    return !m();
}
function B() {
    let e = document.createElement("div");
    return e.id = n, e.innerHTML = `
  <style>
    #${n} {
      background: #f3f3f3;
      color: #333;
      border: 1px solid #333;
      box-shadow: #333 4.7px 4.7px;
    }

    #${n}:hover {
      background: #e3e3e3;
      color: #444;
    }

    @keyframes plasmo-loading-animate-svg-fill {
      0% {
        fill: transparent;
      }
    
      100% {
        fill: #333;
      }
    }

    #${n} .svg-elem-1 {
      animation: plasmo-loading-animate-svg-fill 1.47s cubic-bezier(0.47, 0, 0.745, 0.715) 0.8s both infinite;
    }

    #${n} .svg-elem-2 {
      animation: plasmo-loading-animate-svg-fill 1.47s cubic-bezier(0.47, 0, 0.745, 0.715) 0.9s both infinite;
    }
    
    #${n} .svg-elem-3 {
      animation: plasmo-loading-animate-svg-fill 1.47s cubic-bezier(0.47, 0, 0.745, 0.715) 1s both infinite;
    }

    #${n} .hidden {
      display: none;
    }

  </style>
  
  <svg height="32" width="32" viewBox="0 0 264 354" fill="none" xmlns="http://www.w3.org/2000/svg">
    <path d="M139.221 282.243C154.252 282.243 166.903 294.849 161.338 308.812C159.489 313.454 157.15 317.913 154.347 322.109C146.464 333.909 135.26 343.107 122.151 348.538C109.043 353.969 94.6182 355.39 80.7022 352.621C66.7861 349.852 54.0034 343.018 43.9705 332.983C33.9375 322.947 27.105 310.162 24.3369 296.242C21.5689 282.323 22.9895 267.895 28.4193 254.783C33.8491 241.671 43.0441 230.464 54.8416 222.579C59.0353 219.777 63.4908 217.438 68.1295 215.588C82.0915 210.021 94.6978 222.671 94.6978 237.703L94.6978 255.027C94.6978 270.058 106.883 282.243 121.914 282.243H139.221Z" fill="#333" class="svg-elem-1" ></path>
    <path d="M192.261 142.028C192.261 126.996 204.867 114.346 218.829 119.913C223.468 121.763 227.923 124.102 232.117 126.904C243.915 134.789 253.11 145.996 258.539 159.108C263.969 172.22 265.39 186.648 262.622 200.567C259.854 214.487 253.021 227.272 242.988 237.308C232.955 247.343 220.173 254.177 206.256 256.946C192.34 259.715 177.916 258.294 164.807 252.863C151.699 247.432 140.495 238.234 132.612 226.434C129.808 222.238 127.47 217.779 125.62 213.137C120.056 199.174 132.707 186.568 147.738 186.568L165.044 186.568C180.076 186.568 192.261 174.383 192.261 159.352L192.261 142.028Z" fill="#333" class="svg-elem-2" ></path>
    <path d="M95.6522 164.135C95.6522 179.167 83.2279 191.725 68.8013 187.505C59.5145 184.788 50.6432 180.663 42.5106 175.227C26.7806 164.714 14.5206 149.772 7.28089 132.289C0.041183 114.807 -1.85305 95.5697 1.83772 77.0104C5.52849 58.4511 14.6385 41.4033 28.0157 28.0228C41.393 14.6423 58.4366 5.53006 76.9914 1.83839C95.5461 -1.85329 114.779 0.0414162 132.257 7.2829C149.735 14.5244 164.674 26.7874 175.184 42.5212C180.62 50.6576 184.744 59.5332 187.46 68.8245C191.678 83.2519 179.119 95.6759 164.088 95.6759L122.869 95.6759C107.837 95.6759 95.6522 107.861 95.6522 122.892L95.6522 164.135Z" fill="#333" class="svg-elem-3"></path>
  </svg>
  <span class="hidden">Context Invalidated, Press to Reload</span>
  `, e.style.pointerEvents = "none", e.style.position = "fixed", e.style.bottom = "14.7px", e.style.right = "14.7px", e.style.fontFamily = "sans-serif", e.style.display = "flex", e.style.justifyContent = "center", e.style.alignItems = "center", e.style.padding = "14.7px", e.style.gap = "14.7px", e.style.borderRadius = "4.7px", e.style.zIndex = "2147483647", e.style.opacity = "0", e.style.transition = "all 0.47s ease-in-out", e;
}
function $(e) {
    return new Promise((t)=>{
        document.documentElement ? (f() && (document.documentElement.appendChild(e), t()), t()) : globalThis.addEventListener("DOMContentLoaded", ()=>{
            f() && document.documentElement.appendChild(e), t();
        });
    });
}
var R = ()=>{
    let e;
    if (f()) {
        let t = B();
        e = $(t);
    }
    return {
        show: async ({ reloadButton: t = !1 } = {})=>{
            await e;
            let o = m();
            o.style.opacity = "1", t && (o.onclick = (r)=>{
                r.stopPropagation(), globalThis.location.reload();
            }, o.querySelector("span").classList.remove("hidden"), o.style.cursor = "pointer", o.style.pointerEvents = "all");
        },
        hide: async ()=>{
            await e;
            let t = m();
            t.style.opacity = "0";
        }
    };
};
var F = `${E}${module.id}__`, a, T = !1, A = R();
async function h() {
    c("Script Runtime - reloading"), T ? globalThis.location?.reload?.() : A.show({
        reloadButton: !0
    });
}
function k() {
    a?.disconnect(), a = l?.runtime.connect({
        name: F
    }), a.onDisconnect.addListener(()=>{
        h();
    }), a.onMessage.addListener((e)=>{
        e.__plasmo_cs_reload__ && h(), e.__plasmo_cs_active_tab__ && (T = !0);
    });
}
function N() {
    if (l?.runtime) try {
        k(), setInterval(k, 24e3);
    } catch  {
        return;
    }
}
N();
P(async (e)=>{
    c("Script runtime - on updated assets"), e.filter((o)=>o.envHash === s.envHash).some((o)=>L(module.bundle, o.id)) && (A.show(), l?.runtime ? a.postMessage({
        __plasmo_cs_changed__: !0
    }) : setTimeout(()=>{
        h();
    }, 4700));
});

},{}],"keCgq":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
var _vue = require("vue");
var _csui = require("@plasmo-static-common/csui");
var _csuiContainerVanilla = require("@plasmo-static-common/csui-container-vanilla");
var _vue1 = require("@plasmo-static-common/vue");
// @ts-ignore
var _plasmoOverlay = require("~contents/plasmo-overlay");
var _plasmoOverlayDefault = parcelHelpers.interopDefault(_plasmoOverlay);
// @ts-ignore
var _plasmoOverlay1 = require("style-raw:~contents/plasmo-overlay");
var _plasmoOverlayDefault1 = parcelHelpers.interopDefault(_plasmoOverlay1);
// Escape parcel's static analyzer
const Mount = (0, _plasmoOverlayDefault.default).plasmo || {};
if (typeof (0, _plasmoOverlayDefault1.default) === "string") {
    Mount.getSfcStyleContent = ()=>(0, _plasmoOverlayDefault1.default);
    if (typeof Mount.getStyle !== "function") Mount.getStyle = ({ sfcStyleContent })=>{
        const element = document.createElement("style");
        element.textContent = sfcStyleContent;
        return element;
    };
}
const observer = (0, _csui.createAnchorObserver)(Mount);
const render = (0, _csui.createRender)(Mount, [
    (0, _csuiContainerVanilla.createInlineCSUIContainer),
    (0, _csuiContainerVanilla.createOverlayCSUIContainer)
], observer?.mountState, async (anchor, rootContainer)=>{
    switch(anchor.type){
        case "inline":
            {
                const mountPoint = (0, _csuiContainerVanilla.createInlineCSUIContainer)({
                    anchor
                });
                rootContainer.appendChild(mountPoint);
                const app = (0, _vue.createApp)((0, _plasmoOverlayDefault.default));
                app.config.globalProperties.$anchor = anchor;
                app.mount(mountPoint);
                break;
            }
        case "overlay":
            {
                const targetList = observer?.mountState.overlayTargetList || [
                    anchor.element
                ];
                targetList.forEach((target, i)=>{
                    const id = `plasmo-overlay-${i}`;
                    const innerAnchor = {
                        element: target,
                        type: "overlay"
                    };
                    const mountPoint = (0, _csuiContainerVanilla.createOverlayCSUIContainer)({
                        id,
                        anchor: innerAnchor,
                        watchOverlayAnchor: Mount.watchOverlayAnchor
                    });
                    rootContainer.appendChild(mountPoint);
                    const app = (0, _vue.createApp)((0, _plasmoOverlayDefault.default));
                    app.config.globalProperties.$anchor = innerAnchor;
                    app.mount(mountPoint);
                });
                break;
            }
    }
});
if (!!observer) observer.start(render);
else render({
    element: document.documentElement,
    type: "overlay"
});
if (typeof Mount.watch === "function") Mount.watch({
    observer,
    render
});

},{"vue":"dmrjI","@plasmo-static-common/csui":"b2Mq6","@plasmo-static-common/csui-container-vanilla":"7z4EY","@plasmo-static-common/vue":"4j7Mh","~contents/plasmo-overlay":"lmDTV","style-raw:~contents/plasmo-overlay":"Lil6q","@parcel/transformer-js/src/esmodule-helpers.js":"boKlo"}],"dmrjI":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "compile", ()=>compile);
var _runtimeDom = require("@vue/runtime-dom");
parcelHelpers.exportAll(_runtimeDom, exports);
function initDev() {
    (0, _runtimeDom.initCustomFormatter)();
}
initDev();
const compile = ()=>{
    (0, _runtimeDom.warn)(`Runtime compilation is not supported in this build of Vue.` + ` Configure your bundler to alias "vue" to "vue/dist/vue.esm-bundler.js".`);
};

},{"@vue/runtime-dom":"illZR","@parcel/transformer-js/src/esmodule-helpers.js":"boKlo"}],"illZR":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Transition", ()=>Transition);
parcelHelpers.export(exports, "TransitionGroup", ()=>TransitionGroup);
parcelHelpers.export(exports, "VueElement", ()=>VueElement);
parcelHelpers.export(exports, "createApp", ()=>createApp);
parcelHelpers.export(exports, "createSSRApp", ()=>createSSRApp);
parcelHelpers.export(exports, "defineCustomElement", ()=>defineCustomElement);
parcelHelpers.export(exports, "defineSSRCustomElement", ()=>defineSSRCustomElement);
parcelHelpers.export(exports, "hydrate", ()=>hydrate);
parcelHelpers.export(exports, "initDirectivesForSSR", ()=>initDirectivesForSSR);
parcelHelpers.export(exports, "render", ()=>render);
parcelHelpers.export(exports, "useCssModule", ()=>useCssModule);
parcelHelpers.export(exports, "useCssVars", ()=>useCssVars);
parcelHelpers.export(exports, "vModelCheckbox", ()=>vModelCheckbox);
parcelHelpers.export(exports, "vModelDynamic", ()=>vModelDynamic);
parcelHelpers.export(exports, "vModelRadio", ()=>vModelRadio);
parcelHelpers.export(exports, "vModelSelect", ()=>vModelSelect);
parcelHelpers.export(exports, "vModelText", ()=>vModelText);
parcelHelpers.export(exports, "vShow", ()=>vShow);
parcelHelpers.export(exports, "withKeys", ()=>withKeys);
parcelHelpers.export(exports, "withModifiers", ()=>withModifiers);
var _runtimeCore = require("@vue/runtime-core");
parcelHelpers.exportAll(_runtimeCore, exports);
var _shared = require("@vue/shared");
const svgNS = "http://www.w3.org/2000/svg";
const doc = typeof document !== "undefined" ? document : null;
const templateContainer = doc && /* @__PURE__ */ doc.createElement("template");
const nodeOps = {
    insert: (child, parent, anchor)=>{
        parent.insertBefore(child, anchor || null);
    },
    remove: (child)=>{
        const parent = child.parentNode;
        if (parent) parent.removeChild(child);
    },
    createElement: (tag, isSVG, is, props)=>{
        const el = isSVG ? doc.createElementNS(svgNS, tag) : doc.createElement(tag, is ? {
            is
        } : void 0);
        if (tag === "select" && props && props.multiple != null) el.setAttribute("multiple", props.multiple);
        return el;
    },
    createText: (text)=>doc.createTextNode(text),
    createComment: (text)=>doc.createComment(text),
    setText: (node, text)=>{
        node.nodeValue = text;
    },
    setElementText: (el, text)=>{
        el.textContent = text;
    },
    parentNode: (node)=>node.parentNode,
    nextSibling: (node)=>node.nextSibling,
    querySelector: (selector)=>doc.querySelector(selector),
    setScopeId (el, id) {
        el.setAttribute(id, "");
    },
    // __UNSAFE__
    // Reason: innerHTML.
    // Static content here can only come from compiled templates.
    // As long as the user only uses trusted templates, this is safe.
    insertStaticContent (content, parent, anchor, isSVG, start, end) {
        const before = anchor ? anchor.previousSibling : parent.lastChild;
        if (start && (start === end || start.nextSibling)) while(true){
            parent.insertBefore(start.cloneNode(true), anchor);
            if (start === end || !(start = start.nextSibling)) break;
        }
        else {
            templateContainer.innerHTML = isSVG ? `<svg>${content}</svg>` : content;
            const template = templateContainer.content;
            if (isSVG) {
                const wrapper = template.firstChild;
                while(wrapper.firstChild)template.appendChild(wrapper.firstChild);
                template.removeChild(wrapper);
            }
            parent.insertBefore(template, anchor);
        }
        return [
            // first
            before ? before.nextSibling : parent.firstChild,
            // last
            anchor ? anchor.previousSibling : parent.lastChild
        ];
    }
};
function patchClass(el, value, isSVG) {
    const transitionClasses = el._vtc;
    if (transitionClasses) value = (value ? [
        value,
        ...transitionClasses
    ] : [
        ...transitionClasses
    ]).join(" ");
    if (value == null) el.removeAttribute("class");
    else if (isSVG) el.setAttribute("class", value);
    else el.className = value;
}
function patchStyle(el, prev, next) {
    const style = el.style;
    const isCssString = (0, _shared.isString)(next);
    if (next && !isCssString) {
        if (prev && !(0, _shared.isString)(prev)) {
            for(const key in prev)if (next[key] == null) setStyle(style, key, "");
        }
        for(const key in next)setStyle(style, key, next[key]);
    } else {
        const currentDisplay = style.display;
        if (isCssString) {
            if (prev !== next) style.cssText = next;
        } else if (prev) el.removeAttribute("style");
        if ("_vod" in el) style.display = currentDisplay;
    }
}
const semicolonRE = /[^\\];\s*$/;
const importantRE = /\s*!important$/;
function setStyle(style, name, val) {
    if ((0, _shared.isArray)(val)) val.forEach((v)=>setStyle(style, name, v));
    else {
        if (val == null) val = "";
        if (semicolonRE.test(val)) (0, _runtimeCore.warn)(`Unexpected semicolon at the end of '${name}' style value: '${val}'`);
        if (name.startsWith("--")) style.setProperty(name, val);
        else {
            const prefixed = autoPrefix(style, name);
            if (importantRE.test(val)) style.setProperty((0, _shared.hyphenate)(prefixed), val.replace(importantRE, ""), "important");
            else style[prefixed] = val;
        }
    }
}
const prefixes = [
    "Webkit",
    "Moz",
    "ms"
];
const prefixCache = {};
function autoPrefix(style, rawName) {
    const cached = prefixCache[rawName];
    if (cached) return cached;
    let name = (0, _runtimeCore.camelize)(rawName);
    if (name !== "filter" && name in style) return prefixCache[rawName] = name;
    name = (0, _shared.capitalize)(name);
    for(let i = 0; i < prefixes.length; i++){
        const prefixed = prefixes[i] + name;
        if (prefixed in style) return prefixCache[rawName] = prefixed;
    }
    return rawName;
}
const xlinkNS = "http://www.w3.org/1999/xlink";
function patchAttr(el, key, value, isSVG, instance) {
    if (isSVG && key.startsWith("xlink:")) {
        if (value == null) el.removeAttributeNS(xlinkNS, key.slice(6, key.length));
        else el.setAttributeNS(xlinkNS, key, value);
    } else {
        const isBoolean = (0, _shared.isSpecialBooleanAttr)(key);
        if (value == null || isBoolean && !(0, _shared.includeBooleanAttr)(value)) el.removeAttribute(key);
        else el.setAttribute(key, isBoolean ? "" : value);
    }
}
function patchDOMProp(el, key, value, prevChildren, parentComponent, parentSuspense, unmountChildren) {
    if (key === "innerHTML" || key === "textContent") {
        if (prevChildren) unmountChildren(prevChildren, parentComponent, parentSuspense);
        el[key] = value == null ? "" : value;
        return;
    }
    const tag = el.tagName;
    if (key === "value" && tag !== "PROGRESS" && // custom elements may use _value internally
    !tag.includes("-")) {
        el._value = value;
        const oldValue = tag === "OPTION" ? el.getAttribute("value") : el.value;
        const newValue = value == null ? "" : value;
        if (oldValue !== newValue) el.value = newValue;
        if (value == null) el.removeAttribute(key);
        return;
    }
    let needRemove = false;
    if (value === "" || value == null) {
        const type = typeof el[key];
        if (type === "boolean") value = (0, _shared.includeBooleanAttr)(value);
        else if (value == null && type === "string") {
            value = "";
            needRemove = true;
        } else if (type === "number") {
            value = 0;
            needRemove = true;
        }
    }
    try {
        el[key] = value;
    } catch (e) {
        if (!needRemove) (0, _runtimeCore.warn)(`Failed setting prop "${key}" on <${tag.toLowerCase()}>: value ${value} is invalid.`, e);
    }
    needRemove && el.removeAttribute(key);
}
function addEventListener(el, event, handler, options) {
    el.addEventListener(event, handler, options);
}
function removeEventListener(el, event, handler, options) {
    el.removeEventListener(event, handler, options);
}
function patchEvent(el, rawName, prevValue, nextValue, instance = null) {
    const invokers = el._vei || (el._vei = {});
    const existingInvoker = invokers[rawName];
    if (nextValue && existingInvoker) existingInvoker.value = nextValue;
    else {
        const [name, options] = parseName(rawName);
        if (nextValue) {
            const invoker = invokers[rawName] = createInvoker(nextValue, instance);
            addEventListener(el, name, invoker, options);
        } else if (existingInvoker) {
            removeEventListener(el, name, existingInvoker, options);
            invokers[rawName] = void 0;
        }
    }
}
const optionsModifierRE = /(?:Once|Passive|Capture)$/;
function parseName(name) {
    let options;
    if (optionsModifierRE.test(name)) {
        options = {};
        let m;
        while(m = name.match(optionsModifierRE)){
            name = name.slice(0, name.length - m[0].length);
            options[m[0].toLowerCase()] = true;
        }
    }
    const event = name[2] === ":" ? name.slice(3) : (0, _shared.hyphenate)(name.slice(2));
    return [
        event,
        options
    ];
}
let cachedNow = 0;
const p = /* @__PURE__ */ Promise.resolve();
const getNow = ()=>cachedNow || (p.then(()=>cachedNow = 0), cachedNow = Date.now());
function createInvoker(initialValue, instance) {
    const invoker = (e)=>{
        if (!e._vts) e._vts = Date.now();
        else if (e._vts <= invoker.attached) return;
        (0, _runtimeCore.callWithAsyncErrorHandling)(patchStopImmediatePropagation(e, invoker.value), instance, 5, [
            e
        ]);
    };
    invoker.value = initialValue;
    invoker.attached = getNow();
    return invoker;
}
function patchStopImmediatePropagation(e, value) {
    if ((0, _shared.isArray)(value)) {
        const originalStop = e.stopImmediatePropagation;
        e.stopImmediatePropagation = ()=>{
            originalStop.call(e);
            e._stopped = true;
        };
        return value.map((fn)=>(e2)=>!e2._stopped && fn && fn(e2));
    } else return value;
}
const nativeOnRE = /^on[a-z]/;
const patchProp = (el, key, prevValue, nextValue, isSVG = false, prevChildren, parentComponent, parentSuspense, unmountChildren)=>{
    if (key === "class") patchClass(el, nextValue, isSVG);
    else if (key === "style") patchStyle(el, prevValue, nextValue);
    else if ((0, _shared.isOn)(key)) {
        if (!(0, _shared.isModelListener)(key)) patchEvent(el, key, prevValue, nextValue, parentComponent);
    } else if (key[0] === "." ? (key = key.slice(1), true) : key[0] === "^" ? (key = key.slice(1), false) : shouldSetAsProp(el, key, nextValue, isSVG)) patchDOMProp(el, key, nextValue, prevChildren, parentComponent, parentSuspense, unmountChildren);
    else {
        if (key === "true-value") el._trueValue = nextValue;
        else if (key === "false-value") el._falseValue = nextValue;
        patchAttr(el, key, nextValue, isSVG);
    }
};
function shouldSetAsProp(el, key, value, isSVG) {
    if (isSVG) {
        if (key === "innerHTML" || key === "textContent") return true;
        if (key in el && nativeOnRE.test(key) && (0, _shared.isFunction)(value)) return true;
        return false;
    }
    if (key === "spellcheck" || key === "draggable" || key === "translate") return false;
    if (key === "form") return false;
    if (key === "list" && el.tagName === "INPUT") return false;
    if (key === "type" && el.tagName === "TEXTAREA") return false;
    if (nativeOnRE.test(key) && (0, _shared.isString)(value)) return false;
    return key in el;
}
function defineCustomElement(options, hydrate2) {
    const Comp = (0, _runtimeCore.defineComponent)(options);
    class VueCustomElement extends VueElement {
        constructor(initialProps){
            super(Comp, initialProps, hydrate2);
        }
    }
    VueCustomElement.def = Comp;
    return VueCustomElement;
}
const defineSSRCustomElement = (options)=>{
    return defineCustomElement(options, hydrate);
};
const BaseClass = typeof HTMLElement !== "undefined" ? HTMLElement : class {
};
class VueElement extends BaseClass {
    constructor(_def, _props = {}, hydrate2){
        super();
        this._def = _def;
        this._props = _props;
        /**
     * @internal
     */ this._instance = null;
        this._connected = false;
        this._resolved = false;
        this._numberProps = null;
        if (this.shadowRoot && hydrate2) hydrate2(this._createVNode(), this.shadowRoot);
        else {
            if (0, this.shadowRoot) (0, _runtimeCore.warn)(`Custom element has pre-rendered declarative shadow root but is not defined as hydratable. Use \`defineSSRCustomElement\`.`);
            this.attachShadow({
                mode: "open"
            });
            if (!this._def.__asyncLoader) this._resolveProps(this._def);
        }
    }
    connectedCallback() {
        this._connected = true;
        if (!this._instance) {
            if (this._resolved) this._update();
            else this._resolveDef();
        }
    }
    disconnectedCallback() {
        this._connected = false;
        (0, _runtimeCore.nextTick)(()=>{
            if (!this._connected) {
                render(null, this.shadowRoot);
                this._instance = null;
            }
        });
    }
    /**
   * resolve inner component definition (handle possible async component)
   */ _resolveDef() {
        this._resolved = true;
        for(let i = 0; i < this.attributes.length; i++)this._setAttr(this.attributes[i].name);
        new MutationObserver((mutations)=>{
            for (const m of mutations)this._setAttr(m.attributeName);
        }).observe(this, {
            attributes: true
        });
        const resolve = (def, isAsync = false)=>{
            const { props, styles } = def;
            let numberProps;
            if (props && !(0, _shared.isArray)(props)) for(const key in props){
                const opt = props[key];
                if (opt === Number || opt && opt.type === Number) {
                    if (key in this._props) this._props[key] = (0, _shared.toNumber)(this._props[key]);
                    (numberProps || (numberProps = /* @__PURE__ */ Object.create(null)))[(0, _shared.camelize)(key)] = true;
                }
            }
            this._numberProps = numberProps;
            if (isAsync) this._resolveProps(def);
            this._applyStyles(styles);
            this._update();
        };
        const asyncDef = this._def.__asyncLoader;
        if (asyncDef) asyncDef().then((def)=>resolve(def, true));
        else resolve(this._def);
    }
    _resolveProps(def) {
        const { props } = def;
        const declaredPropKeys = (0, _shared.isArray)(props) ? props : Object.keys(props || {});
        for (const key of Object.keys(this))if (key[0] !== "_" && declaredPropKeys.includes(key)) this._setProp(key, this[key], true, false);
        for (const key of declaredPropKeys.map((0, _shared.camelize)))Object.defineProperty(this, key, {
            get () {
                return this._getProp(key);
            },
            set (val) {
                this._setProp(key, val);
            }
        });
    }
    _setAttr(key) {
        let value = this.getAttribute(key);
        const camelKey = (0, _shared.camelize)(key);
        if (this._numberProps && this._numberProps[camelKey]) value = (0, _shared.toNumber)(value);
        this._setProp(camelKey, value, false);
    }
    /**
   * @internal
   */ _getProp(key) {
        return this._props[key];
    }
    /**
   * @internal
   */ _setProp(key, val, shouldReflect = true, shouldUpdate = true) {
        if (val !== this._props[key]) {
            this._props[key] = val;
            if (shouldUpdate && this._instance) this._update();
            if (shouldReflect) {
                if (val === true) this.setAttribute((0, _shared.hyphenate)(key), "");
                else if (typeof val === "string" || typeof val === "number") this.setAttribute((0, _shared.hyphenate)(key), val + "");
                else if (!val) this.removeAttribute((0, _shared.hyphenate)(key));
            }
        }
    }
    _update() {
        render(this._createVNode(), this.shadowRoot);
    }
    _createVNode() {
        const vnode = (0, _runtimeCore.createVNode)(this._def, (0, _shared.extend)({}, this._props));
        if (!this._instance) vnode.ce = (instance)=>{
            this._instance = instance;
            instance.isCE = true;
            instance.ceReload = (newStyles)=>{
                if (this._styles) {
                    this._styles.forEach((s)=>this.shadowRoot.removeChild(s));
                    this._styles.length = 0;
                }
                this._applyStyles(newStyles);
                this._instance = null;
                this._update();
            };
            const dispatch = (event, args)=>{
                this.dispatchEvent(new CustomEvent(event, {
                    detail: args
                }));
            };
            instance.emit = (event, ...args)=>{
                dispatch(event, args);
                if ((0, _shared.hyphenate)(event) !== event) dispatch((0, _shared.hyphenate)(event), args);
            };
            let parent = this;
            while(parent = parent && (parent.parentNode || parent.host))if (parent instanceof VueElement) {
                instance.parent = parent._instance;
                instance.provides = parent._instance.provides;
                break;
            }
        };
        return vnode;
    }
    _applyStyles(styles) {
        if (styles) styles.forEach((css)=>{
            const s = document.createElement("style");
            s.textContent = css;
            this.shadowRoot.appendChild(s);
            (this._styles || (this._styles = [])).push(s);
        });
    }
}
function useCssModule(name = "$style") {
    {
        const instance = (0, _runtimeCore.getCurrentInstance)();
        if (!instance) {
            (0, _runtimeCore.warn)(`useCssModule must be called inside setup()`);
            return 0, _shared.EMPTY_OBJ;
        }
        const modules = instance.type.__cssModules;
        if (!modules) {
            (0, _runtimeCore.warn)(`Current instance does not have CSS modules injected.`);
            return 0, _shared.EMPTY_OBJ;
        }
        const mod = modules[name];
        if (!mod) {
            (0, _runtimeCore.warn)(`Current instance does not have CSS module named "${name}".`);
            return 0, _shared.EMPTY_OBJ;
        }
        return mod;
    }
}
function useCssVars(getter) {
    const instance = (0, _runtimeCore.getCurrentInstance)();
    if (!instance) {
        (0, _runtimeCore.warn)(`useCssVars is called without current active component instance.`);
        return;
    }
    const updateTeleports = instance.ut = (vars = getter(instance.proxy))=>{
        Array.from(document.querySelectorAll(`[data-v-owner="${instance.uid}"]`)).forEach((node)=>setVarsOnNode(node, vars));
    };
    const setVars = ()=>{
        const vars = getter(instance.proxy);
        setVarsOnVNode(instance.subTree, vars);
        updateTeleports(vars);
    };
    (0, _runtimeCore.watchPostEffect)(setVars);
    (0, _runtimeCore.onMounted)(()=>{
        const ob = new MutationObserver(setVars);
        ob.observe(instance.subTree.el.parentNode, {
            childList: true
        });
        (0, _runtimeCore.onUnmounted)(()=>ob.disconnect());
    });
}
function setVarsOnVNode(vnode, vars) {
    if (vnode.shapeFlag & 128) {
        const suspense = vnode.suspense;
        vnode = suspense.activeBranch;
        if (suspense.pendingBranch && !suspense.isHydrating) suspense.effects.push(()=>{
            setVarsOnVNode(suspense.activeBranch, vars);
        });
    }
    while(vnode.component)vnode = vnode.component.subTree;
    if (vnode.shapeFlag & 1 && vnode.el) setVarsOnNode(vnode.el, vars);
    else if (vnode.type === (0, _runtimeCore.Fragment)) vnode.children.forEach((c)=>setVarsOnVNode(c, vars));
    else if (vnode.type === (0, _runtimeCore.Static)) {
        let { el, anchor } = vnode;
        while(el){
            setVarsOnNode(el, vars);
            if (el === anchor) break;
            el = el.nextSibling;
        }
    }
}
function setVarsOnNode(el, vars) {
    if (el.nodeType === 1) {
        const style = el.style;
        for(const key in vars)style.setProperty(`--${key}`, vars[key]);
    }
}
const TRANSITION = "transition";
const ANIMATION = "animation";
const Transition = (props, { slots })=>(0, _runtimeCore.h)((0, _runtimeCore.BaseTransition), resolveTransitionProps(props), slots);
Transition.displayName = "Transition";
const DOMTransitionPropsValidators = {
    name: String,
    type: String,
    css: {
        type: Boolean,
        default: true
    },
    duration: [
        String,
        Number,
        Object
    ],
    enterFromClass: String,
    enterActiveClass: String,
    enterToClass: String,
    appearFromClass: String,
    appearActiveClass: String,
    appearToClass: String,
    leaveFromClass: String,
    leaveActiveClass: String,
    leaveToClass: String
};
const TransitionPropsValidators = Transition.props = /* @__PURE__ */ (0, _shared.extend)({}, (0, _runtimeCore.BaseTransitionPropsValidators), DOMTransitionPropsValidators);
const callHook = (hook, args = [])=>{
    if ((0, _shared.isArray)(hook)) hook.forEach((h2)=>h2(...args));
    else if (hook) hook(...args);
};
const hasExplicitCallback = (hook)=>{
    return hook ? (0, _shared.isArray)(hook) ? hook.some((h2)=>h2.length > 1) : hook.length > 1 : false;
};
function resolveTransitionProps(rawProps) {
    const baseProps = {};
    for(const key in rawProps)if (!(key in DOMTransitionPropsValidators)) baseProps[key] = rawProps[key];
    if (rawProps.css === false) return baseProps;
    const { name = "v", type, duration, enterFromClass = `${name}-enter-from`, enterActiveClass = `${name}-enter-active`, enterToClass = `${name}-enter-to`, appearFromClass = enterFromClass, appearActiveClass = enterActiveClass, appearToClass = enterToClass, leaveFromClass = `${name}-leave-from`, leaveActiveClass = `${name}-leave-active`, leaveToClass = `${name}-leave-to` } = rawProps;
    const durations = normalizeDuration(duration);
    const enterDuration = durations && durations[0];
    const leaveDuration = durations && durations[1];
    const { onBeforeEnter, onEnter, onEnterCancelled, onLeave, onLeaveCancelled, onBeforeAppear = onBeforeEnter, onAppear = onEnter, onAppearCancelled = onEnterCancelled } = baseProps;
    const finishEnter = (el, isAppear, done)=>{
        removeTransitionClass(el, isAppear ? appearToClass : enterToClass);
        removeTransitionClass(el, isAppear ? appearActiveClass : enterActiveClass);
        done && done();
    };
    const finishLeave = (el, done)=>{
        el._isLeaving = false;
        removeTransitionClass(el, leaveFromClass);
        removeTransitionClass(el, leaveToClass);
        removeTransitionClass(el, leaveActiveClass);
        done && done();
    };
    const makeEnterHook = (isAppear)=>{
        return (el, done)=>{
            const hook = isAppear ? onAppear : onEnter;
            const resolve = ()=>finishEnter(el, isAppear, done);
            callHook(hook, [
                el,
                resolve
            ]);
            nextFrame(()=>{
                removeTransitionClass(el, isAppear ? appearFromClass : enterFromClass);
                addTransitionClass(el, isAppear ? appearToClass : enterToClass);
                if (!hasExplicitCallback(hook)) whenTransitionEnds(el, type, enterDuration, resolve);
            });
        };
    };
    return (0, _shared.extend)(baseProps, {
        onBeforeEnter (el) {
            callHook(onBeforeEnter, [
                el
            ]);
            addTransitionClass(el, enterFromClass);
            addTransitionClass(el, enterActiveClass);
        },
        onBeforeAppear (el) {
            callHook(onBeforeAppear, [
                el
            ]);
            addTransitionClass(el, appearFromClass);
            addTransitionClass(el, appearActiveClass);
        },
        onEnter: makeEnterHook(false),
        onAppear: makeEnterHook(true),
        onLeave (el, done) {
            el._isLeaving = true;
            const resolve = ()=>finishLeave(el, done);
            addTransitionClass(el, leaveFromClass);
            forceReflow();
            addTransitionClass(el, leaveActiveClass);
            nextFrame(()=>{
                if (!el._isLeaving) return;
                removeTransitionClass(el, leaveFromClass);
                addTransitionClass(el, leaveToClass);
                if (!hasExplicitCallback(onLeave)) whenTransitionEnds(el, type, leaveDuration, resolve);
            });
            callHook(onLeave, [
                el,
                resolve
            ]);
        },
        onEnterCancelled (el) {
            finishEnter(el, false);
            callHook(onEnterCancelled, [
                el
            ]);
        },
        onAppearCancelled (el) {
            finishEnter(el, true);
            callHook(onAppearCancelled, [
                el
            ]);
        },
        onLeaveCancelled (el) {
            finishLeave(el);
            callHook(onLeaveCancelled, [
                el
            ]);
        }
    });
}
function normalizeDuration(duration) {
    if (duration == null) return null;
    else if ((0, _shared.isObject)(duration)) return [
        NumberOf(duration.enter),
        NumberOf(duration.leave)
    ];
    else {
        const n = NumberOf(duration);
        return [
            n,
            n
        ];
    }
}
function NumberOf(val) {
    const res = (0, _shared.toNumber)(val);
    (0, _runtimeCore.assertNumber)(res, "<transition> explicit duration");
    return res;
}
function addTransitionClass(el, cls) {
    cls.split(/\s+/).forEach((c)=>c && el.classList.add(c));
    (el._vtc || (el._vtc = /* @__PURE__ */ new Set())).add(cls);
}
function removeTransitionClass(el, cls) {
    cls.split(/\s+/).forEach((c)=>c && el.classList.remove(c));
    const { _vtc } = el;
    if (_vtc) {
        _vtc.delete(cls);
        if (!_vtc.size) el._vtc = void 0;
    }
}
function nextFrame(cb) {
    requestAnimationFrame(()=>{
        requestAnimationFrame(cb);
    });
}
let endId = 0;
function whenTransitionEnds(el, expectedType, explicitTimeout, resolve) {
    const id = el._endId = ++endId;
    const resolveIfNotStale = ()=>{
        if (id === el._endId) resolve();
    };
    if (explicitTimeout) return setTimeout(resolveIfNotStale, explicitTimeout);
    const { type, timeout, propCount } = getTransitionInfo(el, expectedType);
    if (!type) return resolve();
    const endEvent = type + "end";
    let ended = 0;
    const end = ()=>{
        el.removeEventListener(endEvent, onEnd);
        resolveIfNotStale();
    };
    const onEnd = (e)=>{
        if (e.target === el && ++ended >= propCount) end();
    };
    setTimeout(()=>{
        if (ended < propCount) end();
    }, timeout + 1);
    el.addEventListener(endEvent, onEnd);
}
function getTransitionInfo(el, expectedType) {
    const styles = window.getComputedStyle(el);
    const getStyleProperties = (key)=>(styles[key] || "").split(", ");
    const transitionDelays = getStyleProperties(`${TRANSITION}Delay`);
    const transitionDurations = getStyleProperties(`${TRANSITION}Duration`);
    const transitionTimeout = getTimeout(transitionDelays, transitionDurations);
    const animationDelays = getStyleProperties(`${ANIMATION}Delay`);
    const animationDurations = getStyleProperties(`${ANIMATION}Duration`);
    const animationTimeout = getTimeout(animationDelays, animationDurations);
    let type = null;
    let timeout = 0;
    let propCount = 0;
    if (expectedType === TRANSITION) {
        if (transitionTimeout > 0) {
            type = TRANSITION;
            timeout = transitionTimeout;
            propCount = transitionDurations.length;
        }
    } else if (expectedType === ANIMATION) {
        if (animationTimeout > 0) {
            type = ANIMATION;
            timeout = animationTimeout;
            propCount = animationDurations.length;
        }
    } else {
        timeout = Math.max(transitionTimeout, animationTimeout);
        type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;
        propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;
    }
    const hasTransform = type === TRANSITION && /\b(transform|all)(,|$)/.test(getStyleProperties(`${TRANSITION}Property`).toString());
    return {
        type,
        timeout,
        propCount,
        hasTransform
    };
}
function getTimeout(delays, durations) {
    while(delays.length < durations.length)delays = delays.concat(delays);
    return Math.max(...durations.map((d, i)=>toMs(d) + toMs(delays[i])));
}
function toMs(s) {
    return Number(s.slice(0, -1).replace(",", ".")) * 1e3;
}
function forceReflow() {
    return document.body.offsetHeight;
}
const positionMap = /* @__PURE__ */ new WeakMap();
const newPositionMap = /* @__PURE__ */ new WeakMap();
const TransitionGroupImpl = {
    name: "TransitionGroup",
    props: /* @__PURE__ */ (0, _shared.extend)({}, TransitionPropsValidators, {
        tag: String,
        moveClass: String
    }),
    setup (props, { slots }) {
        const instance = (0, _runtimeCore.getCurrentInstance)();
        const state = (0, _runtimeCore.useTransitionState)();
        let prevChildren;
        let children;
        (0, _runtimeCore.onUpdated)(()=>{
            if (!prevChildren.length) return;
            const moveClass = props.moveClass || `${props.name || "v"}-move`;
            if (!hasCSSTransform(prevChildren[0].el, instance.vnode.el, moveClass)) return;
            prevChildren.forEach(callPendingCbs);
            prevChildren.forEach(recordPosition);
            const movedChildren = prevChildren.filter(applyTranslation);
            forceReflow();
            movedChildren.forEach((c)=>{
                const el = c.el;
                const style = el.style;
                addTransitionClass(el, moveClass);
                style.transform = style.webkitTransform = style.transitionDuration = "";
                const cb = el._moveCb = (e)=>{
                    if (e && e.target !== el) return;
                    if (!e || /transform$/.test(e.propertyName)) {
                        el.removeEventListener("transitionend", cb);
                        el._moveCb = null;
                        removeTransitionClass(el, moveClass);
                    }
                };
                el.addEventListener("transitionend", cb);
            });
        });
        return ()=>{
            const rawProps = (0, _runtimeCore.toRaw)(props);
            const cssTransitionProps = resolveTransitionProps(rawProps);
            let tag = rawProps.tag || (0, _runtimeCore.Fragment);
            prevChildren = children;
            children = slots.default ? (0, _runtimeCore.getTransitionRawChildren)(slots.default()) : [];
            for(let i = 0; i < children.length; i++){
                const child = children[i];
                if (child.key != null) (0, _runtimeCore.setTransitionHooks)(child, (0, _runtimeCore.resolveTransitionHooks)(child, cssTransitionProps, state, instance));
                else (0, _runtimeCore.warn)(`<TransitionGroup> children must be keyed.`);
            }
            if (prevChildren) for(let i = 0; i < prevChildren.length; i++){
                const child = prevChildren[i];
                (0, _runtimeCore.setTransitionHooks)(child, (0, _runtimeCore.resolveTransitionHooks)(child, cssTransitionProps, state, instance));
                positionMap.set(child, child.el.getBoundingClientRect());
            }
            return (0, _runtimeCore.createVNode)(tag, null, children);
        };
    }
};
const removeMode = (props)=>delete props.mode;
/* @__PURE__ */ removeMode(TransitionGroupImpl.props);
const TransitionGroup = TransitionGroupImpl;
function callPendingCbs(c) {
    const el = c.el;
    if (el._moveCb) el._moveCb();
    if (el._enterCb) el._enterCb();
}
function recordPosition(c) {
    newPositionMap.set(c, c.el.getBoundingClientRect());
}
function applyTranslation(c) {
    const oldPos = positionMap.get(c);
    const newPos = newPositionMap.get(c);
    const dx = oldPos.left - newPos.left;
    const dy = oldPos.top - newPos.top;
    if (dx || dy) {
        const s = c.el.style;
        s.transform = s.webkitTransform = `translate(${dx}px,${dy}px)`;
        s.transitionDuration = "0s";
        return c;
    }
}
function hasCSSTransform(el, root, moveClass) {
    const clone = el.cloneNode();
    if (el._vtc) el._vtc.forEach((cls)=>{
        cls.split(/\s+/).forEach((c)=>c && clone.classList.remove(c));
    });
    moveClass.split(/\s+/).forEach((c)=>c && clone.classList.add(c));
    clone.style.display = "none";
    const container = root.nodeType === 1 ? root : root.parentNode;
    container.appendChild(clone);
    const { hasTransform } = getTransitionInfo(clone);
    container.removeChild(clone);
    return hasTransform;
}
const getModelAssigner = (vnode)=>{
    const fn = vnode.props["onUpdate:modelValue"] || false;
    return (0, _shared.isArray)(fn) ? (value)=>(0, _shared.invokeArrayFns)(fn, value) : fn;
};
function onCompositionStart(e) {
    e.target.composing = true;
}
function onCompositionEnd(e) {
    const target = e.target;
    if (target.composing) {
        target.composing = false;
        target.dispatchEvent(new Event("input"));
    }
}
const vModelText = {
    created (el, { modifiers: { lazy, trim, number } }, vnode) {
        el._assign = getModelAssigner(vnode);
        const castToNumber = number || vnode.props && vnode.props.type === "number";
        addEventListener(el, lazy ? "change" : "input", (e)=>{
            if (e.target.composing) return;
            let domValue = el.value;
            if (trim) domValue = domValue.trim();
            if (castToNumber) domValue = (0, _shared.looseToNumber)(domValue);
            el._assign(domValue);
        });
        if (trim) addEventListener(el, "change", ()=>{
            el.value = el.value.trim();
        });
        if (!lazy) {
            addEventListener(el, "compositionstart", onCompositionStart);
            addEventListener(el, "compositionend", onCompositionEnd);
            addEventListener(el, "change", onCompositionEnd);
        }
    },
    // set value on mounted so it's after min/max for type="range"
    mounted (el, { value }) {
        el.value = value == null ? "" : value;
    },
    beforeUpdate (el, { value, modifiers: { lazy, trim, number } }, vnode) {
        el._assign = getModelAssigner(vnode);
        if (el.composing) return;
        if (document.activeElement === el && el.type !== "range") {
            if (lazy) return;
            if (trim && el.value.trim() === value) return;
            if ((number || el.type === "number") && (0, _shared.looseToNumber)(el.value) === value) return;
        }
        const newValue = value == null ? "" : value;
        if (el.value !== newValue) el.value = newValue;
    }
};
const vModelCheckbox = {
    // #4096 array checkboxes need to be deep traversed
    deep: true,
    created (el, _, vnode) {
        el._assign = getModelAssigner(vnode);
        addEventListener(el, "change", ()=>{
            const modelValue = el._modelValue;
            const elementValue = getValue(el);
            const checked = el.checked;
            const assign = el._assign;
            if ((0, _shared.isArray)(modelValue)) {
                const index = (0, _shared.looseIndexOf)(modelValue, elementValue);
                const found = index !== -1;
                if (checked && !found) assign(modelValue.concat(elementValue));
                else if (!checked && found) {
                    const filtered = [
                        ...modelValue
                    ];
                    filtered.splice(index, 1);
                    assign(filtered);
                }
            } else if ((0, _shared.isSet)(modelValue)) {
                const cloned = new Set(modelValue);
                if (checked) cloned.add(elementValue);
                else cloned.delete(elementValue);
                assign(cloned);
            } else assign(getCheckboxValue(el, checked));
        });
    },
    // set initial checked on mount to wait for true-value/false-value
    mounted: setChecked,
    beforeUpdate (el, binding, vnode) {
        el._assign = getModelAssigner(vnode);
        setChecked(el, binding, vnode);
    }
};
function setChecked(el, { value, oldValue }, vnode) {
    el._modelValue = value;
    if ((0, _shared.isArray)(value)) el.checked = (0, _shared.looseIndexOf)(value, vnode.props.value) > -1;
    else if ((0, _shared.isSet)(value)) el.checked = value.has(vnode.props.value);
    else if (value !== oldValue) el.checked = (0, _shared.looseEqual)(value, getCheckboxValue(el, true));
}
const vModelRadio = {
    created (el, { value }, vnode) {
        el.checked = (0, _shared.looseEqual)(value, vnode.props.value);
        el._assign = getModelAssigner(vnode);
        addEventListener(el, "change", ()=>{
            el._assign(getValue(el));
        });
    },
    beforeUpdate (el, { value, oldValue }, vnode) {
        el._assign = getModelAssigner(vnode);
        if (value !== oldValue) el.checked = (0, _shared.looseEqual)(value, vnode.props.value);
    }
};
const vModelSelect = {
    // <select multiple> value need to be deep traversed
    deep: true,
    created (el, { value, modifiers: { number } }, vnode) {
        const isSetModel = (0, _shared.isSet)(value);
        addEventListener(el, "change", ()=>{
            const selectedVal = Array.prototype.filter.call(el.options, (o)=>o.selected).map((o)=>number ? (0, _shared.looseToNumber)(getValue(o)) : getValue(o));
            el._assign(el.multiple ? isSetModel ? new Set(selectedVal) : selectedVal : selectedVal[0]);
        });
        el._assign = getModelAssigner(vnode);
    },
    // set value in mounted & updated because <select> relies on its children
    // <option>s.
    mounted (el, { value }) {
        setSelected(el, value);
    },
    beforeUpdate (el, _binding, vnode) {
        el._assign = getModelAssigner(vnode);
    },
    updated (el, { value }) {
        setSelected(el, value);
    }
};
function setSelected(el, value) {
    const isMultiple = el.multiple;
    if (isMultiple && !(0, _shared.isArray)(value) && !(0, _shared.isSet)(value)) {
        (0, _runtimeCore.warn)(`<select multiple v-model> expects an Array or Set value for its binding, but got ${Object.prototype.toString.call(value).slice(8, -1)}.`);
        return;
    }
    for(let i = 0, l = el.options.length; i < l; i++){
        const option = el.options[i];
        const optionValue = getValue(option);
        if (isMultiple) {
            if ((0, _shared.isArray)(value)) option.selected = (0, _shared.looseIndexOf)(value, optionValue) > -1;
            else option.selected = value.has(optionValue);
        } else if ((0, _shared.looseEqual)(getValue(option), value)) {
            if (el.selectedIndex !== i) el.selectedIndex = i;
            return;
        }
    }
    if (!isMultiple && el.selectedIndex !== -1) el.selectedIndex = -1;
}
function getValue(el) {
    return "_value" in el ? el._value : el.value;
}
function getCheckboxValue(el, checked) {
    const key = checked ? "_trueValue" : "_falseValue";
    return key in el ? el[key] : checked;
}
const vModelDynamic = {
    created (el, binding, vnode) {
        callModelHook(el, binding, vnode, null, "created");
    },
    mounted (el, binding, vnode) {
        callModelHook(el, binding, vnode, null, "mounted");
    },
    beforeUpdate (el, binding, vnode, prevVNode) {
        callModelHook(el, binding, vnode, prevVNode, "beforeUpdate");
    },
    updated (el, binding, vnode, prevVNode) {
        callModelHook(el, binding, vnode, prevVNode, "updated");
    }
};
function resolveDynamicModel(tagName, type) {
    switch(tagName){
        case "SELECT":
            return vModelSelect;
        case "TEXTAREA":
            return vModelText;
        default:
            switch(type){
                case "checkbox":
                    return vModelCheckbox;
                case "radio":
                    return vModelRadio;
                default:
                    return vModelText;
            }
    }
}
function callModelHook(el, binding, vnode, prevVNode, hook) {
    const modelToUse = resolveDynamicModel(el.tagName, vnode.props && vnode.props.type);
    const fn = modelToUse[hook];
    fn && fn(el, binding, vnode, prevVNode);
}
function initVModelForSSR() {
    vModelText.getSSRProps = ({ value })=>({
            value
        });
    vModelRadio.getSSRProps = ({ value }, vnode)=>{
        if (vnode.props && (0, _shared.looseEqual)(vnode.props.value, value)) return {
            checked: true
        };
    };
    vModelCheckbox.getSSRProps = ({ value }, vnode)=>{
        if ((0, _shared.isArray)(value)) {
            if (vnode.props && (0, _shared.looseIndexOf)(value, vnode.props.value) > -1) return {
                checked: true
            };
        } else if ((0, _shared.isSet)(value)) {
            if (vnode.props && value.has(vnode.props.value)) return {
                checked: true
            };
        } else if (value) return {
            checked: true
        };
    };
    vModelDynamic.getSSRProps = (binding, vnode)=>{
        if (typeof vnode.type !== "string") return;
        const modelToUse = resolveDynamicModel(// resolveDynamicModel expects an uppercase tag name, but vnode.type is lowercase
        vnode.type.toUpperCase(), vnode.props && vnode.props.type);
        if (modelToUse.getSSRProps) return modelToUse.getSSRProps(binding, vnode);
    };
}
const systemModifiers = [
    "ctrl",
    "shift",
    "alt",
    "meta"
];
const modifierGuards = {
    stop: (e)=>e.stopPropagation(),
    prevent: (e)=>e.preventDefault(),
    self: (e)=>e.target !== e.currentTarget,
    ctrl: (e)=>!e.ctrlKey,
    shift: (e)=>!e.shiftKey,
    alt: (e)=>!e.altKey,
    meta: (e)=>!e.metaKey,
    left: (e)=>"button" in e && e.button !== 0,
    middle: (e)=>"button" in e && e.button !== 1,
    right: (e)=>"button" in e && e.button !== 2,
    exact: (e, modifiers)=>systemModifiers.some((m)=>e[`${m}Key`] && !modifiers.includes(m))
};
const withModifiers = (fn, modifiers)=>{
    return (event, ...args)=>{
        for(let i = 0; i < modifiers.length; i++){
            const guard = modifierGuards[modifiers[i]];
            if (guard && guard(event, modifiers)) return;
        }
        return fn(event, ...args);
    };
};
const keyNames = {
    esc: "escape",
    space: " ",
    up: "arrow-up",
    left: "arrow-left",
    right: "arrow-right",
    down: "arrow-down",
    delete: "backspace"
};
const withKeys = (fn, modifiers)=>{
    return (event)=>{
        if (!("key" in event)) return;
        const eventKey = (0, _shared.hyphenate)(event.key);
        if (modifiers.some((k)=>k === eventKey || keyNames[k] === eventKey)) return fn(event);
    };
};
const vShow = {
    beforeMount (el, { value }, { transition }) {
        el._vod = el.style.display === "none" ? "" : el.style.display;
        if (transition && value) transition.beforeEnter(el);
        else setDisplay(el, value);
    },
    mounted (el, { value }, { transition }) {
        if (transition && value) transition.enter(el);
    },
    updated (el, { value, oldValue }, { transition }) {
        if (!value === !oldValue) return;
        if (transition) {
            if (value) {
                transition.beforeEnter(el);
                setDisplay(el, true);
                transition.enter(el);
            } else transition.leave(el, ()=>{
                setDisplay(el, false);
            });
        } else setDisplay(el, value);
    },
    beforeUnmount (el, { value }) {
        setDisplay(el, value);
    }
};
function setDisplay(el, value) {
    el.style.display = value ? el._vod : "none";
}
function initVShowForSSR() {
    vShow.getSSRProps = ({ value })=>{
        if (!value) return {
            style: {
                display: "none"
            }
        };
    };
}
const rendererOptions = /* @__PURE__ */ (0, _shared.extend)({
    patchProp
}, nodeOps);
let renderer;
let enabledHydration = false;
function ensureRenderer() {
    return renderer || (renderer = (0, _runtimeCore.createRenderer)(rendererOptions));
}
function ensureHydrationRenderer() {
    renderer = enabledHydration ? renderer : (0, _runtimeCore.createHydrationRenderer)(rendererOptions);
    enabledHydration = true;
    return renderer;
}
const render = (...args)=>{
    ensureRenderer().render(...args);
};
const hydrate = (...args)=>{
    ensureHydrationRenderer().hydrate(...args);
};
const createApp = (...args)=>{
    const app = ensureRenderer().createApp(...args);
    injectNativeTagCheck(app);
    injectCompilerOptionsCheck(app);
    const { mount } = app;
    app.mount = (containerOrSelector)=>{
        const container = normalizeContainer(containerOrSelector);
        if (!container) return;
        const component = app._component;
        if (!(0, _shared.isFunction)(component) && !component.render && !component.template) component.template = container.innerHTML;
        container.innerHTML = "";
        const proxy = mount(container, false, container instanceof SVGElement);
        if (container instanceof Element) {
            container.removeAttribute("v-cloak");
            container.setAttribute("data-v-app", "");
        }
        return proxy;
    };
    return app;
};
const createSSRApp = (...args)=>{
    const app = ensureHydrationRenderer().createApp(...args);
    injectNativeTagCheck(app);
    injectCompilerOptionsCheck(app);
    const { mount } = app;
    app.mount = (containerOrSelector)=>{
        const container = normalizeContainer(containerOrSelector);
        if (container) return mount(container, true, container instanceof SVGElement);
    };
    return app;
};
function injectNativeTagCheck(app) {
    Object.defineProperty(app.config, "isNativeTag", {
        value: (tag)=>(0, _shared.isHTMLTag)(tag) || (0, _shared.isSVGTag)(tag),
        writable: false
    });
}
function injectCompilerOptionsCheck(app) {
    if ((0, _runtimeCore.isRuntimeOnly)()) {
        const isCustomElement = app.config.isCustomElement;
        Object.defineProperty(app.config, "isCustomElement", {
            get () {
                return isCustomElement;
            },
            set () {
                (0, _runtimeCore.warn)(`The \`isCustomElement\` config option is deprecated. Use \`compilerOptions.isCustomElement\` instead.`);
            }
        });
        const compilerOptions = app.config.compilerOptions;
        const msg = `The \`compilerOptions\` config option is only respected when using a build of Vue.js that includes the runtime compiler (aka "full build"). Since you are using the runtime-only build, \`compilerOptions\` must be passed to \`@vue/compiler-dom\` in the build setup instead.
- For vue-loader: pass it via vue-loader's \`compilerOptions\` loader option.
- For vue-cli: see https://cli.vuejs.org/guide/webpack.html#modifying-options-of-a-loader
- For vite: pass it via @vitejs/plugin-vue options. See https://github.com/vitejs/vite-plugin-vue/tree/main/packages/plugin-vue#example-for-passing-options-to-vuecompiler-sfc`;
        Object.defineProperty(app.config, "compilerOptions", {
            get () {
                (0, _runtimeCore.warn)(msg);
                return compilerOptions;
            },
            set () {
                (0, _runtimeCore.warn)(msg);
            }
        });
    }
}
function normalizeContainer(container) {
    if ((0, _shared.isString)(container)) {
        const res = document.querySelector(container);
        if (!res) (0, _runtimeCore.warn)(`Failed to mount app: mount target selector "${container}" returned null.`);
        return res;
    }
    if ((0, window.ShadowRoot) && container instanceof window.ShadowRoot && container.mode === "closed") (0, _runtimeCore.warn)(`mounting on a ShadowRoot with \`{mode: "closed"}\` may lead to unpredictable bugs`);
    return container;
}
let ssrDirectiveInitialized = false;
const initDirectivesForSSR = ()=>{
    if (!ssrDirectiveInitialized) {
        ssrDirectiveInitialized = true;
        initVModelForSSR();
        initVShowForSSR();
    }
};

},{"@vue/runtime-core":"6EA3u","@vue/shared":"5YL8y","@parcel/transformer-js/src/esmodule-helpers.js":"boKlo"}],"6EA3u":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "EffectScope", ()=>(0, _reactivity.EffectScope));
parcelHelpers.export(exports, "ReactiveEffect", ()=>(0, _reactivity.ReactiveEffect));
parcelHelpers.export(exports, "customRef", ()=>(0, _reactivity.customRef));
parcelHelpers.export(exports, "effect", ()=>(0, _reactivity.effect));
parcelHelpers.export(exports, "effectScope", ()=>(0, _reactivity.effectScope));
parcelHelpers.export(exports, "getCurrentScope", ()=>(0, _reactivity.getCurrentScope));
parcelHelpers.export(exports, "isProxy", ()=>(0, _reactivity.isProxy));
parcelHelpers.export(exports, "isReactive", ()=>(0, _reactivity.isReactive));
parcelHelpers.export(exports, "isReadonly", ()=>(0, _reactivity.isReadonly));
parcelHelpers.export(exports, "isRef", ()=>(0, _reactivity.isRef));
parcelHelpers.export(exports, "isShallow", ()=>(0, _reactivity.isShallow));
parcelHelpers.export(exports, "markRaw", ()=>(0, _reactivity.markRaw));
parcelHelpers.export(exports, "onScopeDispose", ()=>(0, _reactivity.onScopeDispose));
parcelHelpers.export(exports, "proxyRefs", ()=>(0, _reactivity.proxyRefs));
parcelHelpers.export(exports, "reactive", ()=>(0, _reactivity.reactive));
parcelHelpers.export(exports, "readonly", ()=>(0, _reactivity.readonly));
parcelHelpers.export(exports, "ref", ()=>(0, _reactivity.ref));
parcelHelpers.export(exports, "shallowReactive", ()=>(0, _reactivity.shallowReactive));
parcelHelpers.export(exports, "shallowReadonly", ()=>(0, _reactivity.shallowReadonly));
parcelHelpers.export(exports, "shallowRef", ()=>(0, _reactivity.shallowRef));
parcelHelpers.export(exports, "stop", ()=>(0, _reactivity.stop));
parcelHelpers.export(exports, "toRaw", ()=>(0, _reactivity.toRaw));
parcelHelpers.export(exports, "toRef", ()=>(0, _reactivity.toRef));
parcelHelpers.export(exports, "toRefs", ()=>(0, _reactivity.toRefs));
parcelHelpers.export(exports, "toValue", ()=>(0, _reactivity.toValue));
parcelHelpers.export(exports, "triggerRef", ()=>(0, _reactivity.triggerRef));
parcelHelpers.export(exports, "unref", ()=>(0, _reactivity.unref));
parcelHelpers.export(exports, "camelize", ()=>(0, _shared.camelize));
parcelHelpers.export(exports, "capitalize", ()=>(0, _shared.capitalize));
parcelHelpers.export(exports, "normalizeClass", ()=>(0, _shared.normalizeClass));
parcelHelpers.export(exports, "normalizeProps", ()=>(0, _shared.normalizeProps));
parcelHelpers.export(exports, "normalizeStyle", ()=>(0, _shared.normalizeStyle));
parcelHelpers.export(exports, "toDisplayString", ()=>(0, _shared.toDisplayString));
parcelHelpers.export(exports, "toHandlerKey", ()=>(0, _shared.toHandlerKey));
parcelHelpers.export(exports, "BaseTransition", ()=>BaseTransition);
parcelHelpers.export(exports, "BaseTransitionPropsValidators", ()=>BaseTransitionPropsValidators);
parcelHelpers.export(exports, "Comment", ()=>Comment);
parcelHelpers.export(exports, "Fragment", ()=>Fragment);
parcelHelpers.export(exports, "KeepAlive", ()=>KeepAlive);
parcelHelpers.export(exports, "Static", ()=>Static);
parcelHelpers.export(exports, "Suspense", ()=>Suspense);
parcelHelpers.export(exports, "Teleport", ()=>Teleport);
parcelHelpers.export(exports, "Text", ()=>Text);
parcelHelpers.export(exports, "assertNumber", ()=>assertNumber);
parcelHelpers.export(exports, "callWithAsyncErrorHandling", ()=>callWithAsyncErrorHandling);
parcelHelpers.export(exports, "callWithErrorHandling", ()=>callWithErrorHandling);
parcelHelpers.export(exports, "cloneVNode", ()=>cloneVNode);
parcelHelpers.export(exports, "compatUtils", ()=>compatUtils);
parcelHelpers.export(exports, "computed", ()=>computed);
parcelHelpers.export(exports, "createBlock", ()=>createBlock);
parcelHelpers.export(exports, "createCommentVNode", ()=>createCommentVNode);
parcelHelpers.export(exports, "createElementBlock", ()=>createElementBlock);
parcelHelpers.export(exports, "createElementVNode", ()=>createBaseVNode);
parcelHelpers.export(exports, "createHydrationRenderer", ()=>createHydrationRenderer);
parcelHelpers.export(exports, "createPropsRestProxy", ()=>createPropsRestProxy);
parcelHelpers.export(exports, "createRenderer", ()=>createRenderer);
parcelHelpers.export(exports, "createSlots", ()=>createSlots);
parcelHelpers.export(exports, "createStaticVNode", ()=>createStaticVNode);
parcelHelpers.export(exports, "createTextVNode", ()=>createTextVNode);
parcelHelpers.export(exports, "createVNode", ()=>createVNode);
parcelHelpers.export(exports, "defineAsyncComponent", ()=>defineAsyncComponent);
parcelHelpers.export(exports, "defineComponent", ()=>defineComponent);
parcelHelpers.export(exports, "defineEmits", ()=>defineEmits);
parcelHelpers.export(exports, "defineExpose", ()=>defineExpose);
parcelHelpers.export(exports, "defineModel", ()=>defineModel);
parcelHelpers.export(exports, "defineOptions", ()=>defineOptions);
parcelHelpers.export(exports, "defineProps", ()=>defineProps);
parcelHelpers.export(exports, "defineSlots", ()=>defineSlots);
parcelHelpers.export(exports, "devtools", ()=>devtools);
parcelHelpers.export(exports, "getCurrentInstance", ()=>getCurrentInstance);
parcelHelpers.export(exports, "getTransitionRawChildren", ()=>getTransitionRawChildren);
parcelHelpers.export(exports, "guardReactiveProps", ()=>guardReactiveProps);
parcelHelpers.export(exports, "h", ()=>h);
parcelHelpers.export(exports, "handleError", ()=>handleError);
parcelHelpers.export(exports, "hasInjectionContext", ()=>hasInjectionContext);
parcelHelpers.export(exports, "initCustomFormatter", ()=>initCustomFormatter);
parcelHelpers.export(exports, "inject", ()=>inject);
parcelHelpers.export(exports, "isMemoSame", ()=>isMemoSame);
parcelHelpers.export(exports, "isRuntimeOnly", ()=>isRuntimeOnly);
parcelHelpers.export(exports, "isVNode", ()=>isVNode);
parcelHelpers.export(exports, "mergeDefaults", ()=>mergeDefaults);
parcelHelpers.export(exports, "mergeModels", ()=>mergeModels);
parcelHelpers.export(exports, "mergeProps", ()=>mergeProps);
parcelHelpers.export(exports, "nextTick", ()=>nextTick);
parcelHelpers.export(exports, "onActivated", ()=>onActivated);
parcelHelpers.export(exports, "onBeforeMount", ()=>onBeforeMount);
parcelHelpers.export(exports, "onBeforeUnmount", ()=>onBeforeUnmount);
parcelHelpers.export(exports, "onBeforeUpdate", ()=>onBeforeUpdate);
parcelHelpers.export(exports, "onDeactivated", ()=>onDeactivated);
parcelHelpers.export(exports, "onErrorCaptured", ()=>onErrorCaptured);
parcelHelpers.export(exports, "onMounted", ()=>onMounted);
parcelHelpers.export(exports, "onRenderTracked", ()=>onRenderTracked);
parcelHelpers.export(exports, "onRenderTriggered", ()=>onRenderTriggered);
parcelHelpers.export(exports, "onServerPrefetch", ()=>onServerPrefetch);
parcelHelpers.export(exports, "onUnmounted", ()=>onUnmounted);
parcelHelpers.export(exports, "onUpdated", ()=>onUpdated);
parcelHelpers.export(exports, "openBlock", ()=>openBlock);
parcelHelpers.export(exports, "popScopeId", ()=>popScopeId);
parcelHelpers.export(exports, "provide", ()=>provide);
parcelHelpers.export(exports, "pushScopeId", ()=>pushScopeId);
parcelHelpers.export(exports, "queuePostFlushCb", ()=>queuePostFlushCb);
parcelHelpers.export(exports, "registerRuntimeCompiler", ()=>registerRuntimeCompiler);
parcelHelpers.export(exports, "renderList", ()=>renderList);
parcelHelpers.export(exports, "renderSlot", ()=>renderSlot);
parcelHelpers.export(exports, "resolveComponent", ()=>resolveComponent);
parcelHelpers.export(exports, "resolveDirective", ()=>resolveDirective);
parcelHelpers.export(exports, "resolveDynamicComponent", ()=>resolveDynamicComponent);
parcelHelpers.export(exports, "resolveFilter", ()=>resolveFilter);
parcelHelpers.export(exports, "resolveTransitionHooks", ()=>resolveTransitionHooks);
parcelHelpers.export(exports, "setBlockTracking", ()=>setBlockTracking);
parcelHelpers.export(exports, "setDevtoolsHook", ()=>setDevtoolsHook);
parcelHelpers.export(exports, "setTransitionHooks", ()=>setTransitionHooks);
parcelHelpers.export(exports, "ssrContextKey", ()=>ssrContextKey);
parcelHelpers.export(exports, "ssrUtils", ()=>ssrUtils);
parcelHelpers.export(exports, "toHandlers", ()=>toHandlers);
parcelHelpers.export(exports, "transformVNodeArgs", ()=>transformVNodeArgs);
parcelHelpers.export(exports, "useAttrs", ()=>useAttrs);
parcelHelpers.export(exports, "useModel", ()=>useModel);
parcelHelpers.export(exports, "useSSRContext", ()=>useSSRContext);
parcelHelpers.export(exports, "useSlots", ()=>useSlots);
parcelHelpers.export(exports, "useTransitionState", ()=>useTransitionState);
parcelHelpers.export(exports, "version", ()=>version);
parcelHelpers.export(exports, "warn", ()=>warn);
parcelHelpers.export(exports, "watch", ()=>watch);
parcelHelpers.export(exports, "watchEffect", ()=>watchEffect);
parcelHelpers.export(exports, "watchPostEffect", ()=>watchPostEffect);
parcelHelpers.export(exports, "watchSyncEffect", ()=>watchSyncEffect);
parcelHelpers.export(exports, "withAsyncContext", ()=>withAsyncContext);
parcelHelpers.export(exports, "withCtx", ()=>withCtx);
parcelHelpers.export(exports, "withDefaults", ()=>withDefaults);
parcelHelpers.export(exports, "withDirectives", ()=>withDirectives);
parcelHelpers.export(exports, "withMemo", ()=>withMemo);
parcelHelpers.export(exports, "withScopeId", ()=>withScopeId);
var _reactivity = require("@vue/reactivity");
var _shared = require("@vue/shared");
const stack = [];
function pushWarningContext(vnode) {
    stack.push(vnode);
}
function popWarningContext() {
    stack.pop();
}
function warn(msg, ...args) {
    (0, _reactivity.pauseTracking)();
    const instance = stack.length ? stack[stack.length - 1].component : null;
    const appWarnHandler = instance && instance.appContext.config.warnHandler;
    const trace = getComponentTrace();
    if (appWarnHandler) callWithErrorHandling(appWarnHandler, instance, 11, [
        msg + args.join(""),
        instance && instance.proxy,
        trace.map(({ vnode })=>`at <${formatComponentName(instance, vnode.type)}>`).join("\n"),
        trace
    ]);
    else {
        const warnArgs = [
            `[Vue warn]: ${msg}`,
            ...args
        ];
        if (trace.length && // avoid spamming console during tests
        true) warnArgs.push(`
`, ...formatTrace(trace));
        console.warn(...warnArgs);
    }
    (0, _reactivity.resetTracking)();
}
function getComponentTrace() {
    let currentVNode = stack[stack.length - 1];
    if (!currentVNode) return [];
    const normalizedStack = [];
    while(currentVNode){
        const last = normalizedStack[0];
        if (last && last.vnode === currentVNode) last.recurseCount++;
        else normalizedStack.push({
            vnode: currentVNode,
            recurseCount: 0
        });
        const parentInstance = currentVNode.component && currentVNode.component.parent;
        currentVNode = parentInstance && parentInstance.vnode;
    }
    return normalizedStack;
}
function formatTrace(trace) {
    const logs = [];
    trace.forEach((entry, i)=>{
        logs.push(...i === 0 ? [] : [
            `
`
        ], ...formatTraceEntry(entry));
    });
    return logs;
}
function formatTraceEntry({ vnode, recurseCount }) {
    const postfix = recurseCount > 0 ? `... (${recurseCount} recursive calls)` : ``;
    const isRoot = vnode.component ? vnode.component.parent == null : false;
    const open = ` at <${formatComponentName(vnode.component, vnode.type, isRoot)}`;
    const close = `>` + postfix;
    return vnode.props ? [
        open,
        ...formatProps(vnode.props),
        close
    ] : [
        open + close
    ];
}
function formatProps(props) {
    const res = [];
    const keys = Object.keys(props);
    keys.slice(0, 3).forEach((key)=>{
        res.push(...formatProp(key, props[key]));
    });
    if (keys.length > 3) res.push(` ...`);
    return res;
}
function formatProp(key, value1, raw) {
    if ((0, _shared.isString)(value1)) {
        value1 = JSON.stringify(value1);
        return raw ? value1 : [
            `${key}=${value1}`
        ];
    } else if (typeof value1 === "number" || typeof value1 === "boolean" || value1 == null) return raw ? value1 : [
        `${key}=${value1}`
    ];
    else if ((0, _reactivity.isRef)(value1)) {
        value1 = formatProp(key, (0, _reactivity.toRaw)(value1.value), true);
        return raw ? value1 : [
            `${key}=Ref<`,
            value1,
            `>`
        ];
    } else if ((0, _shared.isFunction)(value1)) return [
        `${key}=fn${value1.name ? `<${value1.name}>` : ``}`
    ];
    else {
        value1 = (0, _reactivity.toRaw)(value1);
        return raw ? value1 : [
            `${key}=`,
            value1
        ];
    }
}
function assertNumber(val, type) {
    if (val === void 0) return;
    else if (typeof val !== "number") warn(`${type} is not a valid number - got ${JSON.stringify(val)}.`);
    else if (isNaN(val)) warn(`${type} is NaN - the duration expression might be incorrect.`);
}
const ErrorTypeStrings = {
    ["sp"]: "serverPrefetch hook",
    ["bc"]: "beforeCreate hook",
    ["c"]: "created hook",
    ["bm"]: "beforeMount hook",
    ["m"]: "mounted hook",
    ["bu"]: "beforeUpdate hook",
    ["u"]: "updated",
    ["bum"]: "beforeUnmount hook",
    ["um"]: "unmounted hook",
    ["a"]: "activated hook",
    ["da"]: "deactivated hook",
    ["ec"]: "errorCaptured hook",
    ["rtc"]: "renderTracked hook",
    ["rtg"]: "renderTriggered hook",
    [0]: "setup function",
    [1]: "render function",
    [2]: "watcher getter",
    [3]: "watcher callback",
    [4]: "watcher cleanup function",
    [5]: "native event handler",
    [6]: "component event handler",
    [7]: "vnode hook",
    [8]: "directive hook",
    [9]: "transition hook",
    [10]: "app errorHandler",
    [11]: "app warnHandler",
    [12]: "ref function",
    [13]: "async component loader",
    [14]: "scheduler flush. This is likely a Vue internals bug. Please open an issue at https://new-issue.vuejs.org/?repo=vuejs/core"
};
function callWithErrorHandling(fn, instance, type, args) {
    let res;
    try {
        res = args ? fn(...args) : fn();
    } catch (err) {
        handleError(err, instance, type);
    }
    return res;
}
function callWithAsyncErrorHandling(fn, instance, type, args) {
    if ((0, _shared.isFunction)(fn)) {
        const res = callWithErrorHandling(fn, instance, type, args);
        if (res && (0, _shared.isPromise)(res)) res.catch((err)=>{
            handleError(err, instance, type);
        });
        return res;
    }
    const values = [];
    for(let i = 0; i < fn.length; i++)values.push(callWithAsyncErrorHandling(fn[i], instance, type, args));
    return values;
}
function handleError(err, instance, type, throwInDev = true) {
    const contextVNode = instance ? instance.vnode : null;
    if (instance) {
        let cur = instance.parent;
        const exposedInstance = instance.proxy;
        const errorInfo = (0, ErrorTypeStrings[type]);
        while(cur){
            const errorCapturedHooks = cur.ec;
            if (errorCapturedHooks) for(let i = 0; i < errorCapturedHooks.length; i++){
                if (errorCapturedHooks[i](err, exposedInstance, errorInfo) === false) return;
            }
            cur = cur.parent;
        }
        const appErrorHandler = instance.appContext.config.errorHandler;
        if (appErrorHandler) {
            callWithErrorHandling(appErrorHandler, null, 10, [
                err,
                exposedInstance,
                errorInfo
            ]);
            return;
        }
    }
    logError(err, type, contextVNode, throwInDev);
}
function logError(err, type, contextVNode, throwInDev = true) {
    {
        const info = ErrorTypeStrings[type];
        if (contextVNode) pushWarningContext(contextVNode);
        warn(`Unhandled error${info ? ` during execution of ${info}` : ``}`);
        if (contextVNode) popWarningContext();
        if (throwInDev) throw err;
        else console.error(err);
    }
}
let isFlushing = false;
let isFlushPending = false;
const queue = [];
let flushIndex = 0;
const pendingPostFlushCbs = [];
let activePostFlushCbs = null;
let postFlushIndex = 0;
const resolvedPromise = /* @__PURE__ */ Promise.resolve();
let currentFlushPromise = null;
const RECURSION_LIMIT = 100;
function nextTick(fn) {
    const p = currentFlushPromise || resolvedPromise;
    return fn ? p.then(this ? fn.bind(this) : fn) : p;
}
function findInsertionIndex(id) {
    let start = flushIndex + 1;
    let end = queue.length;
    while(start < end){
        const middle = start + end >>> 1;
        const middleJobId = getId(queue[middle]);
        middleJobId < id ? start = middle + 1 : end = middle;
    }
    return start;
}
function queueJob(job) {
    if (!queue.length || !queue.includes(job, isFlushing && job.allowRecurse ? flushIndex + 1 : flushIndex)) {
        if (job.id == null) queue.push(job);
        else queue.splice(findInsertionIndex(job.id), 0, job);
        queueFlush();
    }
}
function queueFlush() {
    if (!isFlushing && !isFlushPending) {
        isFlushPending = true;
        currentFlushPromise = resolvedPromise.then(flushJobs);
    }
}
function invalidateJob(job) {
    const i = queue.indexOf(job);
    if (i > flushIndex) queue.splice(i, 1);
}
function queuePostFlushCb(cb) {
    if (!(0, _shared.isArray)(cb)) {
        if (!activePostFlushCbs || !activePostFlushCbs.includes(cb, cb.allowRecurse ? postFlushIndex + 1 : postFlushIndex)) pendingPostFlushCbs.push(cb);
    } else pendingPostFlushCbs.push(...cb);
    queueFlush();
}
function flushPreFlushCbs(seen, i = isFlushing ? flushIndex + 1 : 0) {
    seen = seen || /* @__PURE__ */ new Map();
    for(; i < queue.length; i++){
        const cb = queue[i];
        if (cb && cb.pre) {
            if (checkRecursiveUpdates(seen, cb)) continue;
            queue.splice(i, 1);
            i--;
            cb();
        }
    }
}
function flushPostFlushCbs(seen) {
    if (pendingPostFlushCbs.length) {
        const deduped = [
            ...new Set(pendingPostFlushCbs)
        ];
        pendingPostFlushCbs.length = 0;
        if (activePostFlushCbs) {
            activePostFlushCbs.push(...deduped);
            return;
        }
        activePostFlushCbs = deduped;
        seen = seen || /* @__PURE__ */ new Map();
        activePostFlushCbs.sort((a, b)=>getId(a) - getId(b));
        for(postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++){
            if (checkRecursiveUpdates(seen, activePostFlushCbs[postFlushIndex])) continue;
            activePostFlushCbs[postFlushIndex]();
        }
        activePostFlushCbs = null;
        postFlushIndex = 0;
    }
}
const getId = (job)=>job.id == null ? Infinity : job.id;
const comparator = (a, b)=>{
    const diff = getId(a) - getId(b);
    if (diff === 0) {
        if (a.pre && !b.pre) return -1;
        if (b.pre && !a.pre) return 1;
    }
    return diff;
};
function flushJobs(seen) {
    isFlushPending = false;
    isFlushing = true;
    seen = seen || /* @__PURE__ */ new Map();
    queue.sort(comparator);
    const check = (job)=>checkRecursiveUpdates(seen, job);
    try {
        for(flushIndex = 0; flushIndex < queue.length; flushIndex++){
            const job = queue[flushIndex];
            if (job && job.active !== false) {
                if (check(job)) continue;
                callWithErrorHandling(job, null, 14);
            }
        }
    } finally{
        flushIndex = 0;
        queue.length = 0;
        flushPostFlushCbs(seen);
        isFlushing = false;
        currentFlushPromise = null;
        if (queue.length || pendingPostFlushCbs.length) flushJobs(seen);
    }
}
function checkRecursiveUpdates(seen, fn) {
    if (!seen.has(fn)) seen.set(fn, 1);
    else {
        const count = seen.get(fn);
        if (count > RECURSION_LIMIT) {
            const instance = fn.ownerInstance;
            const componentName = instance && getComponentName(instance.type);
            warn(`Maximum recursive updates exceeded${componentName ? ` in component <${componentName}>` : ``}. This means you have a reactive effect that is mutating its own dependencies and thus recursively triggering itself. Possible sources include component template, render function, updated hook or watcher source function.`);
            return true;
        } else seen.set(fn, count + 1);
    }
}
let isHmrUpdating = false;
const hmrDirtyComponents = /* @__PURE__ */ new Set();
(0, _shared.getGlobalThis)().__VUE_HMR_RUNTIME__ = {
    createRecord: tryWrap(createRecord),
    rerender: tryWrap(rerender),
    reload: tryWrap(reload)
};
const map = /* @__PURE__ */ new Map();
function registerHMR(instance) {
    const id = instance.type.__hmrId;
    let record = map.get(id);
    if (!record) {
        createRecord(id, instance.type);
        record = map.get(id);
    }
    record.instances.add(instance);
}
function unregisterHMR(instance) {
    map.get(instance.type.__hmrId).instances.delete(instance);
}
function createRecord(id, initialDef) {
    if (map.has(id)) return false;
    map.set(id, {
        initialDef: normalizeClassComponent(initialDef),
        instances: /* @__PURE__ */ new Set()
    });
    return true;
}
function normalizeClassComponent(component) {
    return isClassComponent(component) ? component.__vccOpts : component;
}
function rerender(id, newRender) {
    const record = map.get(id);
    if (!record) return;
    record.initialDef.render = newRender;
    [
        ...record.instances
    ].forEach((instance)=>{
        if (newRender) {
            instance.render = newRender;
            normalizeClassComponent(instance.type).render = newRender;
        }
        instance.renderCache = [];
        isHmrUpdating = true;
        instance.update();
        isHmrUpdating = false;
    });
}
function reload(id, newComp) {
    const record = map.get(id);
    if (!record) return;
    newComp = normalizeClassComponent(newComp);
    updateComponentDef(record.initialDef, newComp);
    const instances = [
        ...record.instances
    ];
    for (const instance of instances){
        const oldComp = normalizeClassComponent(instance.type);
        if (!hmrDirtyComponents.has(oldComp)) {
            if (oldComp !== record.initialDef) updateComponentDef(oldComp, newComp);
            hmrDirtyComponents.add(oldComp);
        }
        instance.appContext.propsCache.delete(instance.type);
        instance.appContext.emitsCache.delete(instance.type);
        instance.appContext.optionsCache.delete(instance.type);
        if (instance.ceReload) {
            hmrDirtyComponents.add(oldComp);
            instance.ceReload(newComp.styles);
            hmrDirtyComponents.delete(oldComp);
        } else if (instance.parent) queueJob(instance.parent.update);
        else if (instance.appContext.reload) instance.appContext.reload();
        else if (typeof window !== "undefined") window.location.reload();
        else console.warn("[HMR] Root or manually mounted instance modified. Full reload required.");
    }
    queuePostFlushCb(()=>{
        for (const instance of instances)hmrDirtyComponents.delete(normalizeClassComponent(instance.type));
    });
}
function updateComponentDef(oldComp, newComp) {
    (0, _shared.extend)(oldComp, newComp);
    for(const key in oldComp)if (key !== "__file" && !(key in newComp)) delete oldComp[key];
}
function tryWrap(fn) {
    return (id, arg)=>{
        try {
            return fn(id, arg);
        } catch (e) {
            console.error(e);
            console.warn(`[HMR] Something went wrong during Vue component hot-reload. Full reload required.`);
        }
    };
}
let devtools;
let buffer = [];
let devtoolsNotInstalled = false;
function emit$1(event, ...args) {
    if (devtools) devtools.emit(event, ...args);
    else if (!devtoolsNotInstalled) buffer.push({
        event,
        args
    });
}
function setDevtoolsHook(hook, target) {
    var _a, _b;
    devtools = hook;
    if (devtools) {
        devtools.enabled = true;
        buffer.forEach(({ event, args })=>devtools.emit(event, ...args));
        buffer = [];
    } else if (// handle late devtools injection - only do this if we are in an actual
    // browser environment to avoid the timer handle stalling test runner exit
    // (#4815)
    typeof window !== "undefined" && // some envs mock window but not fully
    window.HTMLElement && // also exclude jsdom
    !((_b = (_a = window.navigator) == null ? void 0 : _a.userAgent) == null ? void 0 : _b.includes("jsdom"))) {
        const replay = target.__VUE_DEVTOOLS_HOOK_REPLAY__ = target.__VUE_DEVTOOLS_HOOK_REPLAY__ || [];
        replay.push((newHook)=>{
            setDevtoolsHook(newHook, target);
        });
        setTimeout(()=>{
            if (!devtools) {
                target.__VUE_DEVTOOLS_HOOK_REPLAY__ = null;
                devtoolsNotInstalled = true;
                buffer = [];
            }
        }, 3e3);
    } else {
        devtoolsNotInstalled = true;
        buffer = [];
    }
}
function devtoolsInitApp(app, version) {
    emit$1("app:init" /* APP_INIT */ , app, version, {
        Fragment,
        Text,
        Comment,
        Static
    });
}
function devtoolsUnmountApp(app) {
    emit$1("app:unmount" /* APP_UNMOUNT */ , app);
}
const devtoolsComponentAdded = /* @__PURE__ */ createDevtoolsComponentHook("component:added" /* COMPONENT_ADDED */ );
const devtoolsComponentUpdated = /* @__PURE__ */ createDevtoolsComponentHook("component:updated" /* COMPONENT_UPDATED */ );
const _devtoolsComponentRemoved = /* @__PURE__ */ createDevtoolsComponentHook("component:removed" /* COMPONENT_REMOVED */ );
const devtoolsComponentRemoved = (component)=>{
    if (devtools && typeof devtools.cleanupBuffer === "function" && // remove the component if it wasn't buffered
    !devtools.cleanupBuffer(component)) _devtoolsComponentRemoved(component);
};
function createDevtoolsComponentHook(hook) {
    return (component)=>{
        emit$1(hook, component.appContext.app, component.uid, component.parent ? component.parent.uid : void 0, component);
    };
}
const devtoolsPerfStart = /* @__PURE__ */ createDevtoolsPerformanceHook("perf:start" /* PERFORMANCE_START */ );
const devtoolsPerfEnd = /* @__PURE__ */ createDevtoolsPerformanceHook("perf:end" /* PERFORMANCE_END */ );
function createDevtoolsPerformanceHook(hook) {
    return (component, type, time)=>{
        emit$1(hook, component.appContext.app, component.uid, component, type, time);
    };
}
function devtoolsComponentEmit(component, event, params) {
    emit$1("component:emit" /* COMPONENT_EMIT */ , component.appContext.app, component, event, params);
}
function emit(instance, event, ...rawArgs) {
    if (instance.isUnmounted) return;
    const props = instance.vnode.props || (0, _shared.EMPTY_OBJ);
    {
        const { emitsOptions, propsOptions: [propsOptions] } = instance;
        if (emitsOptions) {
            if (!(event in emitsOptions) && true) {
                if (!propsOptions || !((0, _shared.toHandlerKey)(event) in propsOptions)) warn(`Component emitted event "${event}" but it is neither declared in the emits option nor as an "${(0, _shared.toHandlerKey)(event)}" prop.`);
            } else {
                const validator = emitsOptions[event];
                if ((0, _shared.isFunction)(validator)) {
                    const isValid = validator(...rawArgs);
                    if (!isValid) warn(`Invalid event arguments: event validation failed for event "${event}".`);
                }
            }
        }
    }
    let args = rawArgs;
    const isModelListener = event.startsWith("update:");
    const modelArg = isModelListener && event.slice(7);
    if (modelArg && modelArg in props) {
        const modifiersKey = `${modelArg === "modelValue" ? "model" : modelArg}Modifiers`;
        const { number, trim } = props[modifiersKey] || (0, _shared.EMPTY_OBJ);
        if (trim) args = rawArgs.map((a)=>(0, _shared.isString)(a) ? a.trim() : a);
        if (number) args = rawArgs.map((0, _shared.looseToNumber));
    }
    devtoolsComponentEmit(instance, event, args);
    {
        const lowerCaseEvent = event.toLowerCase();
        if (lowerCaseEvent !== event && props[(0, _shared.toHandlerKey)(lowerCaseEvent)]) warn(`Event "${lowerCaseEvent}" is emitted in component ${formatComponentName(instance, instance.type)} but the handler is registered for "${event}". Note that HTML attributes are case-insensitive and you cannot use v-on to listen to camelCase events when using in-DOM templates. You should probably use "${(0, _shared.hyphenate)(event)}" instead of "${event}".`);
    }
    let handlerName;
    let handler = props[handlerName = (0, _shared.toHandlerKey)(event)] || // also try camelCase event handler (#2249)
    props[handlerName = (0, _shared.toHandlerKey)((0, _shared.camelize)(event))];
    if (!handler && isModelListener) handler = props[handlerName = (0, _shared.toHandlerKey)((0, _shared.hyphenate)(event))];
    if (handler) callWithAsyncErrorHandling(handler, instance, 6, args);
    const onceHandler = props[handlerName + `Once`];
    if (onceHandler) {
        if (!instance.emitted) instance.emitted = {};
        else if (instance.emitted[handlerName]) return;
        instance.emitted[handlerName] = true;
        callWithAsyncErrorHandling(onceHandler, instance, 6, args);
    }
}
function normalizeEmitsOptions(comp, appContext, asMixin = false) {
    const cache = appContext.emitsCache;
    const cached = cache.get(comp);
    if (cached !== void 0) return cached;
    const raw = comp.emits;
    let normalized = {};
    let hasExtends = false;
    if (__VUE_OPTIONS_API__ && !(0, _shared.isFunction)(comp)) {
        const extendEmits = (raw2)=>{
            const normalizedFromExtend = normalizeEmitsOptions(raw2, appContext, true);
            if (normalizedFromExtend) {
                hasExtends = true;
                (0, _shared.extend)(normalized, normalizedFromExtend);
            }
        };
        if (!asMixin && appContext.mixins.length) appContext.mixins.forEach(extendEmits);
        if (comp.extends) extendEmits(comp.extends);
        if (comp.mixins) comp.mixins.forEach(extendEmits);
    }
    if (!raw && !hasExtends) {
        if ((0, _shared.isObject)(comp)) cache.set(comp, null);
        return null;
    }
    if ((0, _shared.isArray)(raw)) raw.forEach((key)=>normalized[key] = null);
    else (0, _shared.extend)(normalized, raw);
    if ((0, _shared.isObject)(comp)) cache.set(comp, normalized);
    return normalized;
}
function isEmitListener(options, key) {
    if (!options || !(0, _shared.isOn)(key)) return false;
    key = key.slice(2).replace(/Once$/, "");
    return (0, _shared.hasOwn)(options, key[0].toLowerCase() + key.slice(1)) || (0, _shared.hasOwn)(options, (0, _shared.hyphenate)(key)) || (0, _shared.hasOwn)(options, key);
}
let currentRenderingInstance = null;
let currentScopeId = null;
function setCurrentRenderingInstance(instance) {
    const prev = currentRenderingInstance;
    currentRenderingInstance = instance;
    currentScopeId = instance && instance.type.__scopeId || null;
    return prev;
}
function pushScopeId(id) {
    currentScopeId = id;
}
function popScopeId() {
    currentScopeId = null;
}
const withScopeId = (_id)=>withCtx;
function withCtx(fn, ctx = currentRenderingInstance, isNonScopedSlot) {
    if (!ctx) return fn;
    if (fn._n) return fn;
    const renderFnWithContext = (...args)=>{
        if (renderFnWithContext._d) setBlockTracking(-1);
        const prevInstance = setCurrentRenderingInstance(ctx);
        let res;
        try {
            res = fn(...args);
        } finally{
            setCurrentRenderingInstance(prevInstance);
            if (renderFnWithContext._d) setBlockTracking(1);
        }
        devtoolsComponentUpdated(ctx);
        return res;
    };
    renderFnWithContext._n = true;
    renderFnWithContext._c = true;
    renderFnWithContext._d = true;
    return renderFnWithContext;
}
let accessedAttrs = false;
function markAttrsAccessed() {
    accessedAttrs = true;
}
function renderComponentRoot(instance) {
    const { type: Component, vnode, proxy, withProxy, props, propsOptions: [propsOptions], slots, attrs, emit, render, renderCache, data, setupState, ctx, inheritAttrs } = instance;
    let result;
    let fallthroughAttrs;
    const prev = setCurrentRenderingInstance(instance);
    accessedAttrs = false;
    try {
        if (vnode.shapeFlag & 4) {
            const proxyToUse = withProxy || proxy;
            result = normalizeVNode(render.call(proxyToUse, proxyToUse, renderCache, props, setupState, data, ctx));
            fallthroughAttrs = attrs;
        } else {
            const render2 = Component;
            if (attrs === props) markAttrsAccessed();
            result = normalizeVNode(render2.length > 1 ? render2(props, {
                get attrs () {
                    markAttrsAccessed();
                    return attrs;
                },
                slots,
                emit
            }) : render2(props, null));
            fallthroughAttrs = Component.props ? attrs : getFunctionalFallthrough(attrs);
        }
    } catch (err) {
        blockStack.length = 0;
        handleError(err, instance, 1);
        result = createVNode(Comment);
    }
    let root = result;
    let setRoot = void 0;
    if (result.patchFlag > 0 && result.patchFlag & 2048) [root, setRoot] = getChildRoot(result);
    if (fallthroughAttrs && inheritAttrs !== false) {
        const keys = Object.keys(fallthroughAttrs);
        const { shapeFlag } = root;
        if (keys.length) {
            if (shapeFlag & 7) {
                if (propsOptions && keys.some((0, _shared.isModelListener))) fallthroughAttrs = filterModelListeners(fallthroughAttrs, propsOptions);
                root = cloneVNode(root, fallthroughAttrs);
            } else if (!accessedAttrs && root.type !== Comment) {
                const allAttrs = Object.keys(attrs);
                const eventAttrs = [];
                const extraAttrs = [];
                for(let i = 0, l = allAttrs.length; i < l; i++){
                    const key = allAttrs[i];
                    if ((0, _shared.isOn)(key)) {
                        if (!(0, _shared.isModelListener)(key)) eventAttrs.push(key[2].toLowerCase() + key.slice(3));
                    } else extraAttrs.push(key);
                }
                if (extraAttrs.length) warn(`Extraneous non-props attributes (${extraAttrs.join(", ")}) were passed to component but could not be automatically inherited because component renders fragment or text root nodes.`);
                if (eventAttrs.length) warn(`Extraneous non-emits event listeners (${eventAttrs.join(", ")}) were passed to component but could not be automatically inherited because component renders fragment or text root nodes. If the listener is intended to be a component custom event listener only, declare it using the "emits" option.`);
            }
        }
    }
    if (vnode.dirs) {
        if (!isElementRoot(root)) warn(`Runtime directive used on component with non-element root node. The directives will not function as intended.`);
        root = cloneVNode(root);
        root.dirs = root.dirs ? root.dirs.concat(vnode.dirs) : vnode.dirs;
    }
    if (vnode.transition) {
        if (!isElementRoot(root)) warn(`Component inside <Transition> renders non-element root node that cannot be animated.`);
        root.transition = vnode.transition;
    }
    if (setRoot) setRoot(root);
    else result = root;
    setCurrentRenderingInstance(prev);
    return result;
}
const getChildRoot = (vnode)=>{
    const rawChildren = vnode.children;
    const dynamicChildren = vnode.dynamicChildren;
    const childRoot = filterSingleRoot(rawChildren);
    if (!childRoot) return [
        vnode,
        void 0
    ];
    const index = rawChildren.indexOf(childRoot);
    const dynamicIndex = dynamicChildren ? dynamicChildren.indexOf(childRoot) : -1;
    const setRoot = (updatedRoot)=>{
        rawChildren[index] = updatedRoot;
        if (dynamicChildren) {
            if (dynamicIndex > -1) dynamicChildren[dynamicIndex] = updatedRoot;
            else if (updatedRoot.patchFlag > 0) vnode.dynamicChildren = [
                ...dynamicChildren,
                updatedRoot
            ];
        }
    };
    return [
        normalizeVNode(childRoot),
        setRoot
    ];
};
function filterSingleRoot(children) {
    let singleRoot;
    for(let i = 0; i < children.length; i++){
        const child = children[i];
        if (isVNode(child)) {
            if (child.type !== Comment || child.children === "v-if") {
                if (singleRoot) return;
                else singleRoot = child;
            }
        } else return;
    }
    return singleRoot;
}
const getFunctionalFallthrough = (attrs)=>{
    let res;
    for(const key in attrs)if (key === "class" || key === "style" || (0, _shared.isOn)(key)) (res || (res = {}))[key] = attrs[key];
    return res;
};
const filterModelListeners = (attrs, props)=>{
    const res = {};
    for(const key in attrs)if (!(0, _shared.isModelListener)(key) || !(key.slice(9) in props)) res[key] = attrs[key];
    return res;
};
const isElementRoot = (vnode)=>{
    return vnode.shapeFlag & 7 || vnode.type === Comment;
};
function shouldUpdateComponent(prevVNode, nextVNode, optimized) {
    const { props: prevProps, children: prevChildren, component } = prevVNode;
    const { props: nextProps, children: nextChildren, patchFlag } = nextVNode;
    const emits = component.emitsOptions;
    if ((prevChildren || nextChildren) && isHmrUpdating) return true;
    if (nextVNode.dirs || nextVNode.transition) return true;
    if (optimized && patchFlag >= 0) {
        if (patchFlag & 1024) return true;
        if (patchFlag & 16) {
            if (!prevProps) return !!nextProps;
            return hasPropsChanged(prevProps, nextProps, emits);
        } else if (patchFlag & 8) {
            const dynamicProps = nextVNode.dynamicProps;
            for(let i = 0; i < dynamicProps.length; i++){
                const key = dynamicProps[i];
                if (nextProps[key] !== prevProps[key] && !isEmitListener(emits, key)) return true;
            }
        }
    } else {
        if (prevChildren || nextChildren) {
            if (!nextChildren || !nextChildren.$stable) return true;
        }
        if (prevProps === nextProps) return false;
        if (!prevProps) return !!nextProps;
        if (!nextProps) return true;
        return hasPropsChanged(prevProps, nextProps, emits);
    }
    return false;
}
function hasPropsChanged(prevProps, nextProps, emitsOptions) {
    const nextKeys = Object.keys(nextProps);
    if (nextKeys.length !== Object.keys(prevProps).length) return true;
    for(let i = 0; i < nextKeys.length; i++){
        const key = nextKeys[i];
        if (nextProps[key] !== prevProps[key] && !isEmitListener(emitsOptions, key)) return true;
    }
    return false;
}
function updateHOCHostEl({ vnode, parent }, el) {
    while(parent && parent.subTree === vnode){
        (vnode = parent.vnode).el = el;
        parent = parent.parent;
    }
}
const isSuspense = (type)=>type.__isSuspense;
const SuspenseImpl = {
    name: "Suspense",
    // In order to make Suspense tree-shakable, we need to avoid importing it
    // directly in the renderer. The renderer checks for the __isSuspense flag
    // on a vnode's type and calls the `process` method, passing in renderer
    // internals.
    __isSuspense: true,
    process (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals) {
        if (n1 == null) mountSuspense(n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals);
        else patchSuspense(n1, n2, container, anchor, parentComponent, isSVG, slotScopeIds, optimized, rendererInternals);
    },
    hydrate: hydrateSuspense,
    create: createSuspenseBoundary,
    normalize: normalizeSuspenseChildren
};
const Suspense = SuspenseImpl;
function triggerEvent(vnode, name) {
    const eventListener = vnode.props && vnode.props[name];
    if ((0, _shared.isFunction)(eventListener)) eventListener();
}
function mountSuspense(vnode, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals) {
    const { p: patch, o: { createElement } } = rendererInternals;
    const hiddenContainer = createElement("div");
    const suspense = vnode.suspense = createSuspenseBoundary(vnode, parentSuspense, parentComponent, container, hiddenContainer, anchor, isSVG, slotScopeIds, optimized, rendererInternals);
    patch(null, suspense.pendingBranch = vnode.ssContent, hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds);
    if (suspense.deps > 0) {
        triggerEvent(vnode, "onPending");
        triggerEvent(vnode, "onFallback");
        patch(null, vnode.ssFallback, container, anchor, parentComponent, null, // fallback tree will not have suspense context
        isSVG, slotScopeIds);
        setActiveBranch(suspense, vnode.ssFallback);
    } else suspense.resolve(false, true);
}
function patchSuspense(n1, n2, container, anchor, parentComponent, isSVG, slotScopeIds, optimized, { p: patch, um: unmount, o: { createElement } }) {
    const suspense = n2.suspense = n1.suspense;
    suspense.vnode = n2;
    n2.el = n1.el;
    const newBranch = n2.ssContent;
    const newFallback = n2.ssFallback;
    const { activeBranch, pendingBranch, isInFallback, isHydrating } = suspense;
    if (pendingBranch) {
        suspense.pendingBranch = newBranch;
        if (isSameVNodeType(newBranch, pendingBranch)) {
            patch(pendingBranch, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);
            if (suspense.deps <= 0) suspense.resolve();
            else if (isInFallback) {
                patch(activeBranch, newFallback, container, anchor, parentComponent, null, // fallback tree will not have suspense context
                isSVG, slotScopeIds, optimized);
                setActiveBranch(suspense, newFallback);
            }
        } else {
            suspense.pendingId++;
            if (isHydrating) {
                suspense.isHydrating = false;
                suspense.activeBranch = pendingBranch;
            } else unmount(pendingBranch, parentComponent, suspense);
            suspense.deps = 0;
            suspense.effects.length = 0;
            suspense.hiddenContainer = createElement("div");
            if (isInFallback) {
                patch(null, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);
                if (suspense.deps <= 0) suspense.resolve();
                else {
                    patch(activeBranch, newFallback, container, anchor, parentComponent, null, // fallback tree will not have suspense context
                    isSVG, slotScopeIds, optimized);
                    setActiveBranch(suspense, newFallback);
                }
            } else if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {
                patch(activeBranch, newBranch, container, anchor, parentComponent, suspense, isSVG, slotScopeIds, optimized);
                suspense.resolve(true);
            } else {
                patch(null, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);
                if (suspense.deps <= 0) suspense.resolve();
            }
        }
    } else if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {
        patch(activeBranch, newBranch, container, anchor, parentComponent, suspense, isSVG, slotScopeIds, optimized);
        setActiveBranch(suspense, newBranch);
    } else {
        triggerEvent(n2, "onPending");
        suspense.pendingBranch = newBranch;
        suspense.pendingId++;
        patch(null, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);
        if (suspense.deps <= 0) suspense.resolve();
        else {
            const { timeout, pendingId } = suspense;
            if (timeout > 0) setTimeout(()=>{
                if (suspense.pendingId === pendingId) suspense.fallback(newFallback);
            }, timeout);
            else if (timeout === 0) suspense.fallback(newFallback);
        }
    }
}
let hasWarned = false;
function createSuspenseBoundary(vnode, parentSuspense, parentComponent, container, hiddenContainer, anchor, isSVG, slotScopeIds, optimized, rendererInternals, isHydrating = false) {
    if (!hasWarned) {
        hasWarned = true;
        console[console.info ? "info" : "log"](`<Suspense> is an experimental feature and its API will likely change.`);
    }
    const { p: patch, m: move, um: unmount, n: next, o: { parentNode, remove } } = rendererInternals;
    let parentSuspenseId;
    const isSuspensible = isVNodeSuspensible(vnode);
    if (isSuspensible) {
        if (parentSuspense == null ? void 0 : parentSuspense.pendingBranch) {
            parentSuspenseId = parentSuspense.pendingId;
            parentSuspense.deps++;
        }
    }
    const timeout = vnode.props ? (0, _shared.toNumber)(vnode.props.timeout) : void 0;
    assertNumber(timeout, `Suspense timeout`);
    const suspense = {
        vnode,
        parent: parentSuspense,
        parentComponent,
        isSVG,
        container,
        hiddenContainer,
        anchor,
        deps: 0,
        pendingId: 0,
        timeout: typeof timeout === "number" ? timeout : -1,
        activeBranch: null,
        pendingBranch: null,
        isInFallback: true,
        isHydrating,
        isUnmounted: false,
        effects: [],
        resolve (resume = false, sync = false) {
            if (!resume && !suspense.pendingBranch) throw new Error(`suspense.resolve() is called without a pending branch.`);
            if (suspense.isUnmounted) throw new Error(`suspense.resolve() is called on an already unmounted suspense boundary.`);
            const { vnode: vnode2, activeBranch, pendingBranch, pendingId, effects, parentComponent: parentComponent2, container: container2 } = suspense;
            if (suspense.isHydrating) suspense.isHydrating = false;
            else if (!resume) {
                const delayEnter = activeBranch && pendingBranch.transition && pendingBranch.transition.mode === "out-in";
                if (delayEnter) activeBranch.transition.afterLeave = ()=>{
                    if (pendingId === suspense.pendingId) move(pendingBranch, container2, anchor2, 0);
                };
                let { anchor: anchor2 } = suspense;
                if (activeBranch) {
                    anchor2 = next(activeBranch);
                    unmount(activeBranch, parentComponent2, suspense, true);
                }
                if (!delayEnter) move(pendingBranch, container2, anchor2, 0);
            }
            setActiveBranch(suspense, pendingBranch);
            suspense.pendingBranch = null;
            suspense.isInFallback = false;
            let parent = suspense.parent;
            let hasUnresolvedAncestor = false;
            while(parent){
                if (parent.pendingBranch) {
                    parent.effects.push(...effects);
                    hasUnresolvedAncestor = true;
                    break;
                }
                parent = parent.parent;
            }
            if (!hasUnresolvedAncestor) queuePostFlushCb(effects);
            suspense.effects = [];
            if (isSuspensible) {
                if (parentSuspense && parentSuspense.pendingBranch && parentSuspenseId === parentSuspense.pendingId) {
                    parentSuspense.deps--;
                    if (parentSuspense.deps === 0 && !sync) parentSuspense.resolve();
                }
            }
            triggerEvent(vnode2, "onResolve");
        },
        fallback (fallbackVNode) {
            if (!suspense.pendingBranch) return;
            const { vnode: vnode2, activeBranch, parentComponent: parentComponent2, container: container2, isSVG: isSVG2 } = suspense;
            triggerEvent(vnode2, "onFallback");
            const anchor2 = next(activeBranch);
            const mountFallback = ()=>{
                if (!suspense.isInFallback) return;
                patch(null, fallbackVNode, container2, anchor2, parentComponent2, null, // fallback tree will not have suspense context
                isSVG2, slotScopeIds, optimized);
                setActiveBranch(suspense, fallbackVNode);
            };
            const delayEnter = fallbackVNode.transition && fallbackVNode.transition.mode === "out-in";
            if (delayEnter) activeBranch.transition.afterLeave = mountFallback;
            suspense.isInFallback = true;
            unmount(activeBranch, parentComponent2, null, // no suspense so unmount hooks fire now
            true);
            if (!delayEnter) mountFallback();
        },
        move (container2, anchor2, type) {
            suspense.activeBranch && move(suspense.activeBranch, container2, anchor2, type);
            suspense.container = container2;
        },
        next () {
            return suspense.activeBranch && next(suspense.activeBranch);
        },
        registerDep (instance, setupRenderEffect) {
            const isInPendingSuspense = !!suspense.pendingBranch;
            if (isInPendingSuspense) suspense.deps++;
            const hydratedEl = instance.vnode.el;
            instance.asyncDep.catch((err)=>{
                handleError(err, instance, 0);
            }).then((asyncSetupResult)=>{
                if (instance.isUnmounted || suspense.isUnmounted || suspense.pendingId !== instance.suspenseId) return;
                instance.asyncResolved = true;
                const { vnode: vnode2 } = instance;
                pushWarningContext(vnode2);
                handleSetupResult(instance, asyncSetupResult, false);
                if (hydratedEl) vnode2.el = hydratedEl;
                const placeholder = !hydratedEl && instance.subTree.el;
                setupRenderEffect(instance, vnode2, // component may have been moved before resolve.
                // if this is not a hydration, instance.subTree will be the comment
                // placeholder.
                parentNode(hydratedEl || instance.subTree.el), // anchor will not be used if this is hydration, so only need to
                // consider the comment placeholder case.
                hydratedEl ? null : next(instance.subTree), suspense, isSVG, optimized);
                if (placeholder) remove(placeholder);
                updateHOCHostEl(instance, vnode2.el);
                popWarningContext();
                if (isInPendingSuspense && --suspense.deps === 0) suspense.resolve();
            });
        },
        unmount (parentSuspense2, doRemove) {
            suspense.isUnmounted = true;
            if (suspense.activeBranch) unmount(suspense.activeBranch, parentComponent, parentSuspense2, doRemove);
            if (suspense.pendingBranch) unmount(suspense.pendingBranch, parentComponent, parentSuspense2, doRemove);
        }
    };
    return suspense;
}
function hydrateSuspense(node, vnode, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals, hydrateNode) {
    const suspense = vnode.suspense = createSuspenseBoundary(vnode, parentSuspense, parentComponent, node.parentNode, document.createElement("div"), null, isSVG, slotScopeIds, optimized, rendererInternals, true);
    const result = hydrateNode(node, suspense.pendingBranch = vnode.ssContent, parentComponent, suspense, slotScopeIds, optimized);
    if (suspense.deps === 0) suspense.resolve(false, true);
    return result;
}
function normalizeSuspenseChildren(vnode) {
    const { shapeFlag, children } = vnode;
    const isSlotChildren = shapeFlag & 32;
    vnode.ssContent = normalizeSuspenseSlot(isSlotChildren ? children.default : children);
    vnode.ssFallback = isSlotChildren ? normalizeSuspenseSlot(children.fallback) : createVNode(Comment);
}
function normalizeSuspenseSlot(s) {
    let block;
    if ((0, _shared.isFunction)(s)) {
        const trackBlock = isBlockTreeEnabled && s._c;
        if (trackBlock) {
            s._d = false;
            openBlock();
        }
        s = s();
        if (trackBlock) {
            s._d = true;
            block = currentBlock;
            closeBlock();
        }
    }
    if ((0, _shared.isArray)(s)) {
        const singleChild = filterSingleRoot(s);
        if (!singleChild) warn(`<Suspense> slots expect a single root node.`);
        s = singleChild;
    }
    s = normalizeVNode(s);
    if (block && !s.dynamicChildren) s.dynamicChildren = block.filter((c)=>c !== s);
    return s;
}
function queueEffectWithSuspense(fn, suspense) {
    if (suspense && suspense.pendingBranch) {
        if ((0, _shared.isArray)(fn)) suspense.effects.push(...fn);
        else suspense.effects.push(fn);
    } else queuePostFlushCb(fn);
}
function setActiveBranch(suspense, branch) {
    suspense.activeBranch = branch;
    const { vnode, parentComponent } = suspense;
    const el = vnode.el = branch.el;
    if (parentComponent && parentComponent.subTree === vnode) {
        parentComponent.vnode.el = el;
        updateHOCHostEl(parentComponent, el);
    }
}
function isVNodeSuspensible(vnode) {
    var _a;
    return ((_a = vnode.props) == null ? void 0 : _a.suspensible) != null && vnode.props.suspensible !== false;
}
function watchEffect(effect, options) {
    return doWatch(effect, null, options);
}
function watchPostEffect(effect, options) {
    return doWatch(effect, null, (0, _shared.extend)({}, options, {
        flush: "post"
    }));
}
function watchSyncEffect(effect, options) {
    return doWatch(effect, null, (0, _shared.extend)({}, options, {
        flush: "sync"
    }));
}
const INITIAL_WATCHER_VALUE = {};
function watch(source, cb, options) {
    if (!(0, _shared.isFunction)(cb)) warn(`\`watch(fn, options?)\` signature has been moved to a separate API. Use \`watchEffect(fn, options?)\` instead. \`watch\` now only supports \`watch(source, cb, options?) signature.`);
    return doWatch(source, cb, options);
}
function doWatch(source, cb, { immediate, deep, flush, onTrack, onTrigger } = (0, _shared.EMPTY_OBJ)) {
    var _a;
    if (!cb) {
        if (immediate !== void 0) warn(`watch() "immediate" option is only respected when using the watch(source, callback, options?) signature.`);
        if (deep !== void 0) warn(`watch() "deep" option is only respected when using the watch(source, callback, options?) signature.`);
    }
    const warnInvalidSource = (s)=>{
        warn(`Invalid watch source: `, s, `A watch source can only be a getter/effect function, a ref, a reactive object, or an array of these types.`);
    };
    const instance = (0, _reactivity.getCurrentScope)() === ((_a = currentInstance) == null ? void 0 : _a.scope) ? currentInstance : null;
    let getter;
    let forceTrigger = false;
    let isMultiSource = false;
    if ((0, _reactivity.isRef)(source)) {
        getter = ()=>source.value;
        forceTrigger = (0, _reactivity.isShallow)(source);
    } else if ((0, _reactivity.isReactive)(source)) {
        getter = ()=>source;
        deep = true;
    } else if ((0, _shared.isArray)(source)) {
        isMultiSource = true;
        forceTrigger = source.some((s)=>(0, _reactivity.isReactive)(s) || (0, _reactivity.isShallow)(s));
        getter = ()=>source.map((s)=>{
                if ((0, _reactivity.isRef)(s)) return s.value;
                else if ((0, _reactivity.isReactive)(s)) return traverse(s);
                else if ((0, _shared.isFunction)(s)) return callWithErrorHandling(s, instance, 2);
                else warnInvalidSource(s);
            });
    } else if ((0, _shared.isFunction)(source)) {
        if (cb) getter = ()=>callWithErrorHandling(source, instance, 2);
        else getter = ()=>{
            if (instance && instance.isUnmounted) return;
            if (cleanup) cleanup();
            return callWithAsyncErrorHandling(source, instance, 3, [
                onCleanup
            ]);
        };
    } else {
        getter = (0, _shared.NOOP);
        warnInvalidSource(source);
    }
    if (cb && deep) {
        const baseGetter = getter;
        getter = ()=>traverse(baseGetter());
    }
    let cleanup;
    let onCleanup = (fn)=>{
        cleanup = effect.onStop = ()=>{
            callWithErrorHandling(fn, instance, 4);
        };
    };
    let ssrCleanup;
    if (isInSSRComponentSetup) {
        onCleanup = (0, _shared.NOOP);
        if (!cb) getter();
        else if (immediate) callWithAsyncErrorHandling(cb, instance, 3, [
            getter(),
            isMultiSource ? [] : void 0,
            onCleanup
        ]);
        if (flush === "sync") {
            const ctx = useSSRContext();
            ssrCleanup = ctx.__watcherHandles || (ctx.__watcherHandles = []);
        } else return 0, _shared.NOOP;
    }
    let oldValue = isMultiSource ? new Array(source.length).fill(INITIAL_WATCHER_VALUE) : INITIAL_WATCHER_VALUE;
    const job = ()=>{
        if (!effect.active) return;
        if (cb) {
            const newValue = effect.run();
            if (deep || forceTrigger || (isMultiSource ? newValue.some((v1, i)=>(0, _shared.hasChanged)(v1, oldValue[i])) : (0, _shared.hasChanged)(newValue, oldValue)) || false) {
                if (cleanup) cleanup();
                callWithAsyncErrorHandling(cb, instance, 3, [
                    newValue,
                    // pass undefined as the old value when it's changed for the first time
                    oldValue === INITIAL_WATCHER_VALUE ? void 0 : isMultiSource && oldValue[0] === INITIAL_WATCHER_VALUE ? [] : oldValue,
                    onCleanup
                ]);
                oldValue = newValue;
            }
        } else effect.run();
    };
    job.allowRecurse = !!cb;
    let scheduler;
    if (flush === "sync") scheduler = job;
    else if (flush === "post") scheduler = ()=>queuePostRenderEffect(job, instance && instance.suspense);
    else {
        job.pre = true;
        if (instance) job.id = instance.uid;
        scheduler = ()=>queueJob(job);
    }
    const effect = new (0, _reactivity.ReactiveEffect)(getter, scheduler);
    effect.onTrack = onTrack;
    effect.onTrigger = onTrigger;
    if (cb) {
        if (immediate) job();
        else oldValue = effect.run();
    } else if (flush === "post") queuePostRenderEffect(effect.run.bind(effect), instance && instance.suspense);
    else effect.run();
    const unwatch = ()=>{
        effect.stop();
        if (instance && instance.scope) (0, _shared.remove)(instance.scope.effects, effect);
    };
    if (ssrCleanup) ssrCleanup.push(unwatch);
    return unwatch;
}
function instanceWatch(source, value1, options) {
    const publicThis = this.proxy;
    const getter = (0, _shared.isString)(source) ? source.includes(".") ? createPathGetter(publicThis, source) : ()=>publicThis[source] : source.bind(publicThis, publicThis);
    let cb;
    if ((0, _shared.isFunction)(value1)) cb = value1;
    else {
        cb = value1.handler;
        options = value1;
    }
    const cur = currentInstance;
    setCurrentInstance(this);
    const res = doWatch(getter, cb.bind(publicThis), options);
    if (cur) setCurrentInstance(cur);
    else unsetCurrentInstance();
    return res;
}
function createPathGetter(ctx, path) {
    const segments = path.split(".");
    return ()=>{
        let cur = ctx;
        for(let i = 0; i < segments.length && cur; i++)cur = cur[segments[i]];
        return cur;
    };
}
function traverse(value1, seen) {
    if (!(0, _shared.isObject)(value1) || value1["__v_skip"]) return value1;
    seen = seen || /* @__PURE__ */ new Set();
    if (seen.has(value1)) return value1;
    seen.add(value1);
    if ((0, _reactivity.isRef)(value1)) traverse(value1.value, seen);
    else if ((0, _shared.isArray)(value1)) for(let i = 0; i < value1.length; i++)traverse(value1[i], seen);
    else if ((0, _shared.isSet)(value1) || (0, _shared.isMap)(value1)) value1.forEach((v1)=>{
        traverse(v1, seen);
    });
    else if ((0, _shared.isPlainObject)(value1)) for(const key in value1)traverse(value1[key], seen);
    return value1;
}
function validateDirectiveName(name) {
    if ((0, _shared.isBuiltInDirective)(name)) warn("Do not use built-in directive ids as custom directive id: " + name);
}
function withDirectives(vnode, directives) {
    const internalInstance = currentRenderingInstance;
    if (internalInstance === null) {
        warn(`withDirectives can only be used inside render functions.`);
        return vnode;
    }
    const instance = getExposeProxy(internalInstance) || internalInstance.proxy;
    const bindings = vnode.dirs || (vnode.dirs = []);
    for(let i = 0; i < directives.length; i++){
        let [dir, value1, arg, modifiers = (0, _shared.EMPTY_OBJ)] = directives[i];
        if (dir) {
            if ((0, _shared.isFunction)(dir)) dir = {
                mounted: dir,
                updated: dir
            };
            if (dir.deep) traverse(value1);
            bindings.push({
                dir,
                instance,
                value: value1,
                oldValue: void 0,
                arg,
                modifiers
            });
        }
    }
    return vnode;
}
function invokeDirectiveHook(vnode, prevVNode, instance, name) {
    const bindings = vnode.dirs;
    const oldBindings = prevVNode && prevVNode.dirs;
    for(let i = 0; i < bindings.length; i++){
        const binding = bindings[i];
        if (oldBindings) binding.oldValue = oldBindings[i].value;
        let hook = binding.dir[name];
        if (hook) {
            (0, _reactivity.pauseTracking)();
            callWithAsyncErrorHandling(hook, instance, 8, [
                vnode.el,
                binding,
                vnode,
                prevVNode
            ]);
            (0, _reactivity.resetTracking)();
        }
    }
}
function useTransitionState() {
    const state = {
        isMounted: false,
        isLeaving: false,
        isUnmounting: false,
        leavingVNodes: /* @__PURE__ */ new Map()
    };
    onMounted(()=>{
        state.isMounted = true;
    });
    onBeforeUnmount(()=>{
        state.isUnmounting = true;
    });
    return state;
}
const TransitionHookValidator = [
    Function,
    Array
];
const BaseTransitionPropsValidators = {
    mode: String,
    appear: Boolean,
    persisted: Boolean,
    // enter
    onBeforeEnter: TransitionHookValidator,
    onEnter: TransitionHookValidator,
    onAfterEnter: TransitionHookValidator,
    onEnterCancelled: TransitionHookValidator,
    // leave
    onBeforeLeave: TransitionHookValidator,
    onLeave: TransitionHookValidator,
    onAfterLeave: TransitionHookValidator,
    onLeaveCancelled: TransitionHookValidator,
    // appear
    onBeforeAppear: TransitionHookValidator,
    onAppear: TransitionHookValidator,
    onAfterAppear: TransitionHookValidator,
    onAppearCancelled: TransitionHookValidator
};
const BaseTransitionImpl = {
    name: `BaseTransition`,
    props: BaseTransitionPropsValidators,
    setup (props, { slots }) {
        const instance = getCurrentInstance();
        const state = useTransitionState();
        let prevTransitionKey;
        return ()=>{
            const children = slots.default && getTransitionRawChildren(slots.default(), true);
            if (!children || !children.length) return;
            let child = children[0];
            if (children.length > 1) {
                let hasFound = false;
                for (const c of children)if (c.type !== Comment) {
                    if (hasFound) {
                        warn("<transition> can only be used on a single element or component. Use <transition-group> for lists.");
                        break;
                    }
                    child = c;
                    hasFound = true;
                }
            }
            const rawProps = (0, _reactivity.toRaw)(props);
            const { mode } = rawProps;
            if (mode && mode !== "in-out" && mode !== "out-in" && mode !== "default") warn(`invalid <transition> mode: ${mode}`);
            if (state.isLeaving) return emptyPlaceholder(child);
            const innerChild = getKeepAliveChild(child);
            if (!innerChild) return emptyPlaceholder(child);
            const enterHooks = resolveTransitionHooks(innerChild, rawProps, state, instance);
            setTransitionHooks(innerChild, enterHooks);
            const oldChild = instance.subTree;
            const oldInnerChild = oldChild && getKeepAliveChild(oldChild);
            let transitionKeyChanged = false;
            const { getTransitionKey } = innerChild.type;
            if (getTransitionKey) {
                const key = getTransitionKey();
                if (prevTransitionKey === void 0) prevTransitionKey = key;
                else if (key !== prevTransitionKey) {
                    prevTransitionKey = key;
                    transitionKeyChanged = true;
                }
            }
            if (oldInnerChild && oldInnerChild.type !== Comment && (!isSameVNodeType(innerChild, oldInnerChild) || transitionKeyChanged)) {
                const leavingHooks = resolveTransitionHooks(oldInnerChild, rawProps, state, instance);
                setTransitionHooks(oldInnerChild, leavingHooks);
                if (mode === "out-in") {
                    state.isLeaving = true;
                    leavingHooks.afterLeave = ()=>{
                        state.isLeaving = false;
                        if (instance.update.active !== false) instance.update();
                    };
                    return emptyPlaceholder(child);
                } else if (mode === "in-out" && innerChild.type !== Comment) leavingHooks.delayLeave = (el, earlyRemove, delayedLeave)=>{
                    const leavingVNodesCache = getLeavingNodesForType(state, oldInnerChild);
                    leavingVNodesCache[String(oldInnerChild.key)] = oldInnerChild;
                    el._leaveCb = ()=>{
                        earlyRemove();
                        el._leaveCb = void 0;
                        delete enterHooks.delayedLeave;
                    };
                    enterHooks.delayedLeave = delayedLeave;
                };
            }
            return child;
        };
    }
};
const BaseTransition = BaseTransitionImpl;
function getLeavingNodesForType(state, vnode) {
    const { leavingVNodes } = state;
    let leavingVNodesCache = leavingVNodes.get(vnode.type);
    if (!leavingVNodesCache) {
        leavingVNodesCache = /* @__PURE__ */ Object.create(null);
        leavingVNodes.set(vnode.type, leavingVNodesCache);
    }
    return leavingVNodesCache;
}
function resolveTransitionHooks(vnode, props, state, instance) {
    const { appear, mode, persisted = false, onBeforeEnter, onEnter, onAfterEnter, onEnterCancelled, onBeforeLeave, onLeave, onAfterLeave, onLeaveCancelled, onBeforeAppear, onAppear, onAfterAppear, onAppearCancelled } = props;
    const key = String(vnode.key);
    const leavingVNodesCache = getLeavingNodesForType(state, vnode);
    const callHook = (hook, args)=>{
        hook && callWithAsyncErrorHandling(hook, instance, 9, args);
    };
    const callAsyncHook = (hook, args)=>{
        const done = args[1];
        callHook(hook, args);
        if ((0, _shared.isArray)(hook)) {
            if (hook.every((hook2)=>hook2.length <= 1)) done();
        } else if (hook.length <= 1) done();
    };
    const hooks = {
        mode,
        persisted,
        beforeEnter (el) {
            let hook = onBeforeEnter;
            if (!state.isMounted) {
                if (appear) hook = onBeforeAppear || onBeforeEnter;
                else return;
            }
            if (el._leaveCb) el._leaveCb(true);
            const leavingVNode = leavingVNodesCache[key];
            if (leavingVNode && isSameVNodeType(vnode, leavingVNode) && leavingVNode.el._leaveCb) leavingVNode.el._leaveCb();
            callHook(hook, [
                el
            ]);
        },
        enter (el) {
            let hook = onEnter;
            let afterHook = onAfterEnter;
            let cancelHook = onEnterCancelled;
            if (!state.isMounted) {
                if (appear) {
                    hook = onAppear || onEnter;
                    afterHook = onAfterAppear || onAfterEnter;
                    cancelHook = onAppearCancelled || onEnterCancelled;
                } else return;
            }
            let called = false;
            const done = el._enterCb = (cancelled)=>{
                if (called) return;
                called = true;
                if (cancelled) callHook(cancelHook, [
                    el
                ]);
                else callHook(afterHook, [
                    el
                ]);
                if (hooks.delayedLeave) hooks.delayedLeave();
                el._enterCb = void 0;
            };
            if (hook) callAsyncHook(hook, [
                el,
                done
            ]);
            else done();
        },
        leave (el, remove) {
            const key2 = String(vnode.key);
            if (el._enterCb) el._enterCb(true);
            if (state.isUnmounting) return remove();
            callHook(onBeforeLeave, [
                el
            ]);
            let called = false;
            const done = el._leaveCb = (cancelled)=>{
                if (called) return;
                called = true;
                remove();
                if (cancelled) callHook(onLeaveCancelled, [
                    el
                ]);
                else callHook(onAfterLeave, [
                    el
                ]);
                el._leaveCb = void 0;
                if (leavingVNodesCache[key2] === vnode) delete leavingVNodesCache[key2];
            };
            leavingVNodesCache[key2] = vnode;
            if (onLeave) callAsyncHook(onLeave, [
                el,
                done
            ]);
            else done();
        },
        clone (vnode2) {
            return resolveTransitionHooks(vnode2, props, state, instance);
        }
    };
    return hooks;
}
function emptyPlaceholder(vnode) {
    if (isKeepAlive(vnode)) {
        vnode = cloneVNode(vnode);
        vnode.children = null;
        return vnode;
    }
}
function getKeepAliveChild(vnode) {
    return isKeepAlive(vnode) ? vnode.children ? vnode.children[0] : void 0 : vnode;
}
function setTransitionHooks(vnode, hooks) {
    if (vnode.shapeFlag & 6 && vnode.component) setTransitionHooks(vnode.component.subTree, hooks);
    else if (vnode.shapeFlag & 128) {
        vnode.ssContent.transition = hooks.clone(vnode.ssContent);
        vnode.ssFallback.transition = hooks.clone(vnode.ssFallback);
    } else vnode.transition = hooks;
}
function getTransitionRawChildren(children, keepComment = false, parentKey) {
    let ret = [];
    let keyedFragmentCount = 0;
    for(let i = 0; i < children.length; i++){
        let child = children[i];
        const key = parentKey == null ? child.key : String(parentKey) + String(child.key != null ? child.key : i);
        if (child.type === Fragment) {
            if (child.patchFlag & 128) keyedFragmentCount++;
            ret = ret.concat(getTransitionRawChildren(child.children, keepComment, key));
        } else if (keepComment || child.type !== Comment) ret.push(key != null ? cloneVNode(child, {
            key
        }) : child);
    }
    if (keyedFragmentCount > 1) for(let i = 0; i < ret.length; i++)ret[i].patchFlag = -2;
    return ret;
}
function defineComponent(options, extraOptions) {
    return (0, _shared.isFunction)(options) ? // #8326: extend call and options.name access are considered side-effects
    // by Rollup, so we have to wrap it in a pure-annotated IIFE.
    /* @__PURE__ */ (()=>(0, _shared.extend)({
            name: options.name
        }, extraOptions, {
            setup: options
        }))() : options;
}
const isAsyncWrapper = (i)=>!!i.type.__asyncLoader;
function defineAsyncComponent(source) {
    if ((0, _shared.isFunction)(source)) source = {
        loader: source
    };
    const { loader, loadingComponent, errorComponent, delay = 200, timeout, // undefined = never times out
    suspensible = true, onError: userOnError } = source;
    let pendingRequest = null;
    let resolvedComp;
    let retries = 0;
    const retry = ()=>{
        retries++;
        pendingRequest = null;
        return load();
    };
    const load = ()=>{
        let thisRequest;
        return pendingRequest || (thisRequest = pendingRequest = loader().catch((err)=>{
            err = err instanceof Error ? err : new Error(String(err));
            if (userOnError) return new Promise((resolve, reject)=>{
                const userRetry = ()=>resolve(retry());
                const userFail = ()=>reject(err);
                userOnError(err, userRetry, userFail, retries + 1);
            });
            else throw err;
        }).then((comp)=>{
            if (thisRequest !== pendingRequest && pendingRequest) return pendingRequest;
            if (!comp) warn(`Async component loader resolved to undefined. If you are using retry(), make sure to return its return value.`);
            if (comp && (comp.__esModule || comp[Symbol.toStringTag] === "Module")) comp = comp.default;
            if (comp && !(0, _shared.isObject)(comp) && !(0, _shared.isFunction)(comp)) throw new Error(`Invalid async component load result: ${comp}`);
            resolvedComp = comp;
            return comp;
        }));
    };
    return defineComponent({
        name: "AsyncComponentWrapper",
        __asyncLoader: load,
        get __asyncResolved () {
            return resolvedComp;
        },
        setup () {
            const instance = currentInstance;
            if (resolvedComp) return ()=>createInnerComp(resolvedComp, instance);
            const onError = (err)=>{
                pendingRequest = null;
                handleError(err, instance, 13, !errorComponent);
            };
            if (suspensible && instance.suspense || isInSSRComponentSetup) return load().then((comp)=>{
                return ()=>createInnerComp(comp, instance);
            }).catch((err)=>{
                onError(err);
                return ()=>errorComponent ? createVNode(errorComponent, {
                        error: err
                    }) : null;
            });
            const loaded = (0, _reactivity.ref)(false);
            const error = (0, _reactivity.ref)();
            const delayed = (0, _reactivity.ref)(!!delay);
            if (delay) setTimeout(()=>{
                delayed.value = false;
            }, delay);
            if (timeout != null) setTimeout(()=>{
                if (!loaded.value && !error.value) {
                    const err = new Error(`Async component timed out after ${timeout}ms.`);
                    onError(err);
                    error.value = err;
                }
            }, timeout);
            load().then(()=>{
                loaded.value = true;
                if (instance.parent && isKeepAlive(instance.parent.vnode)) queueJob(instance.parent.update);
            }).catch((err)=>{
                onError(err);
                error.value = err;
            });
            return ()=>{
                if (loaded.value && resolvedComp) return createInnerComp(resolvedComp, instance);
                else if (error.value && errorComponent) return createVNode(errorComponent, {
                    error: error.value
                });
                else if (loadingComponent && !delayed.value) return createVNode(loadingComponent);
            };
        }
    });
}
function createInnerComp(comp, parent) {
    const { ref: ref2, props, children, ce } = parent.vnode;
    const vnode = createVNode(comp, props, children);
    vnode.ref = ref2;
    vnode.ce = ce;
    delete parent.vnode.ce;
    return vnode;
}
const isKeepAlive = (vnode)=>vnode.type.__isKeepAlive;
const KeepAliveImpl = {
    name: `KeepAlive`,
    // Marker for special handling inside the renderer. We are not using a ===
    // check directly on KeepAlive in the renderer, because importing it directly
    // would prevent it from being tree-shaken.
    __isKeepAlive: true,
    props: {
        include: [
            String,
            RegExp,
            Array
        ],
        exclude: [
            String,
            RegExp,
            Array
        ],
        max: [
            String,
            Number
        ]
    },
    setup (props, { slots }) {
        const instance = getCurrentInstance();
        const sharedContext = instance.ctx;
        if (!sharedContext.renderer) return ()=>{
            const children = slots.default && slots.default();
            return children && children.length === 1 ? children[0] : children;
        };
        const cache = /* @__PURE__ */ new Map();
        const keys = /* @__PURE__ */ new Set();
        let current = null;
        instance.__v_cache = cache;
        const parentSuspense = instance.suspense;
        const { renderer: { p: patch, m: move, um: _unmount, o: { createElement } } } = sharedContext;
        const storageContainer = createElement("div");
        sharedContext.activate = (vnode, container, anchor, isSVG, optimized)=>{
            const instance2 = vnode.component;
            move(vnode, container, anchor, 0, parentSuspense);
            patch(instance2.vnode, vnode, container, anchor, instance2, parentSuspense, isSVG, vnode.slotScopeIds, optimized);
            queuePostRenderEffect(()=>{
                instance2.isDeactivated = false;
                if (instance2.a) (0, _shared.invokeArrayFns)(instance2.a);
                const vnodeHook = vnode.props && vnode.props.onVnodeMounted;
                if (vnodeHook) invokeVNodeHook(vnodeHook, instance2.parent, vnode);
            }, parentSuspense);
            devtoolsComponentAdded(instance2);
        };
        sharedContext.deactivate = (vnode)=>{
            const instance2 = vnode.component;
            move(vnode, storageContainer, null, 1, parentSuspense);
            queuePostRenderEffect(()=>{
                if (instance2.da) (0, _shared.invokeArrayFns)(instance2.da);
                const vnodeHook = vnode.props && vnode.props.onVnodeUnmounted;
                if (vnodeHook) invokeVNodeHook(vnodeHook, instance2.parent, vnode);
                instance2.isDeactivated = true;
            }, parentSuspense);
            devtoolsComponentAdded(instance2);
        };
        function unmount(vnode) {
            resetShapeFlag(vnode);
            _unmount(vnode, instance, parentSuspense, true);
        }
        function pruneCache(filter) {
            cache.forEach((vnode, key)=>{
                const name = getComponentName(vnode.type);
                if (name && (!filter || !filter(name))) pruneCacheEntry(key);
            });
        }
        function pruneCacheEntry(key) {
            const cached = cache.get(key);
            if (!current || !isSameVNodeType(cached, current)) unmount(cached);
            else if (current) resetShapeFlag(current);
            cache.delete(key);
            keys.delete(key);
        }
        watch(()=>[
                props.include,
                props.exclude
            ], ([include, exclude])=>{
            include && pruneCache((name)=>matches(include, name));
            exclude && pruneCache((name)=>!matches(exclude, name));
        }, // prune post-render after `current` has been updated
        {
            flush: "post",
            deep: true
        });
        let pendingCacheKey = null;
        const cacheSubtree = ()=>{
            if (pendingCacheKey != null) cache.set(pendingCacheKey, getInnerChild(instance.subTree));
        };
        onMounted(cacheSubtree);
        onUpdated(cacheSubtree);
        onBeforeUnmount(()=>{
            cache.forEach((cached)=>{
                const { subTree, suspense } = instance;
                const vnode = getInnerChild(subTree);
                if (cached.type === vnode.type && cached.key === vnode.key) {
                    resetShapeFlag(vnode);
                    const da = vnode.component.da;
                    da && queuePostRenderEffect(da, suspense);
                    return;
                }
                unmount(cached);
            });
        });
        return ()=>{
            pendingCacheKey = null;
            if (!slots.default) return null;
            const children = slots.default();
            const rawVNode = children[0];
            if (children.length > 1) {
                warn(`KeepAlive should contain exactly one component child.`);
                current = null;
                return children;
            } else if (!isVNode(rawVNode) || !(rawVNode.shapeFlag & 4) && !(rawVNode.shapeFlag & 128)) {
                current = null;
                return rawVNode;
            }
            let vnode = getInnerChild(rawVNode);
            const comp = vnode.type;
            const name = getComponentName(isAsyncWrapper(vnode) ? vnode.type.__asyncResolved || {} : comp);
            const { include, exclude, max } = props;
            if (include && (!name || !matches(include, name)) || exclude && name && matches(exclude, name)) {
                current = vnode;
                return rawVNode;
            }
            const key = vnode.key == null ? comp : vnode.key;
            const cachedVNode = cache.get(key);
            if (vnode.el) {
                vnode = cloneVNode(vnode);
                if (rawVNode.shapeFlag & 128) rawVNode.ssContent = vnode;
            }
            pendingCacheKey = key;
            if (cachedVNode) {
                vnode.el = cachedVNode.el;
                vnode.component = cachedVNode.component;
                if (vnode.transition) setTransitionHooks(vnode, vnode.transition);
                vnode.shapeFlag |= 512;
                keys.delete(key);
                keys.add(key);
            } else {
                keys.add(key);
                if (max && keys.size > parseInt(max, 10)) pruneCacheEntry(keys.values().next().value);
            }
            vnode.shapeFlag |= 256;
            current = vnode;
            return isSuspense(rawVNode.type) ? rawVNode : vnode;
        };
    }
};
const KeepAlive = KeepAliveImpl;
function matches(pattern, name) {
    if ((0, _shared.isArray)(pattern)) return pattern.some((p)=>matches(p, name));
    else if ((0, _shared.isString)(pattern)) return pattern.split(",").includes(name);
    else if ((0, _shared.isRegExp)(pattern)) return pattern.test(name);
    return false;
}
function onActivated(hook, target) {
    registerKeepAliveHook(hook, "a", target);
}
function onDeactivated(hook, target) {
    registerKeepAliveHook(hook, "da", target);
}
function registerKeepAliveHook(hook, type, target = currentInstance) {
    const wrappedHook = hook.__wdc || (hook.__wdc = ()=>{
        let current = target;
        while(current){
            if (current.isDeactivated) return;
            current = current.parent;
        }
        return hook();
    });
    injectHook(type, wrappedHook, target);
    if (target) {
        let current = target.parent;
        while(current && current.parent){
            if (isKeepAlive(current.parent.vnode)) injectToKeepAliveRoot(wrappedHook, type, target, current);
            current = current.parent;
        }
    }
}
function injectToKeepAliveRoot(hook, type, target, keepAliveRoot) {
    const injected = injectHook(type, hook, keepAliveRoot, true);
    onUnmounted(()=>{
        (0, _shared.remove)(keepAliveRoot[type], injected);
    }, target);
}
function resetShapeFlag(vnode) {
    vnode.shapeFlag &= -257;
    vnode.shapeFlag &= -513;
}
function getInnerChild(vnode) {
    return vnode.shapeFlag & 128 ? vnode.ssContent : vnode;
}
function injectHook(type, hook, target = currentInstance, prepend = false) {
    if (target) {
        const hooks = target[type] || (target[type] = []);
        const wrappedHook = hook.__weh || (hook.__weh = (...args)=>{
            if (target.isUnmounted) return;
            (0, _reactivity.pauseTracking)();
            setCurrentInstance(target);
            const res = callWithAsyncErrorHandling(hook, target, type, args);
            unsetCurrentInstance();
            (0, _reactivity.resetTracking)();
            return res;
        });
        if (prepend) hooks.unshift(wrappedHook);
        else hooks.push(wrappedHook);
        return wrappedHook;
    } else {
        const apiName = (0, _shared.toHandlerKey)(ErrorTypeStrings[type].replace(/ hook$/, ""));
        warn(`${apiName} is called when there is no active component instance to be associated with. Lifecycle injection APIs can only be used during execution of setup().` + ` If you are using async setup(), make sure to register lifecycle hooks before the first await statement.`);
    }
}
const createHook = (lifecycle)=>(hook, target = currentInstance)=>// post-create lifecycle registrations are noops during SSR (except for serverPrefetch)
        (!isInSSRComponentSetup || lifecycle === "sp") && injectHook(lifecycle, (...args)=>hook(...args), target);
const onBeforeMount = createHook("bm");
const onMounted = createHook("m");
const onBeforeUpdate = createHook("bu");
const onUpdated = createHook("u");
const onBeforeUnmount = createHook("bum");
const onUnmounted = createHook("um");
const onServerPrefetch = createHook("sp");
const onRenderTriggered = createHook("rtg");
const onRenderTracked = createHook("rtc");
function onErrorCaptured(hook, target = currentInstance) {
    injectHook("ec", hook, target);
}
const COMPONENTS = "components";
const DIRECTIVES = "directives";
function resolveComponent(name, maybeSelfReference) {
    return resolveAsset(COMPONENTS, name, true, maybeSelfReference) || name;
}
const NULL_DYNAMIC_COMPONENT = Symbol.for("v-ndc");
function resolveDynamicComponent(component) {
    if ((0, _shared.isString)(component)) return resolveAsset(COMPONENTS, component, false) || component;
    else return component || NULL_DYNAMIC_COMPONENT;
}
function resolveDirective(name) {
    return resolveAsset(DIRECTIVES, name);
}
function resolveAsset(type, name, warnMissing = true, maybeSelfReference = false) {
    const instance = currentRenderingInstance || currentInstance;
    if (instance) {
        const Component = instance.type;
        if (type === COMPONENTS) {
            const selfName = getComponentName(Component, false);
            if (selfName && (selfName === name || selfName === (0, _shared.camelize)(name) || selfName === (0, _shared.capitalize)((0, _shared.camelize)(name)))) return Component;
        }
        const res = // local registration
        // check instance[type] first which is resolved for options API
        resolve(instance[type] || Component[type], name) || // global registration
        resolve(instance.appContext[type], name);
        if (!res && maybeSelfReference) return Component;
        if (warnMissing && !res) {
            const extra = type === COMPONENTS ? `
If this is a native custom element, make sure to exclude it from component resolution via compilerOptions.isCustomElement.` : ``;
            warn(`Failed to resolve ${type.slice(0, -1)}: ${name}${extra}`);
        }
        return res;
    } else warn(`resolve${(0, _shared.capitalize)(type.slice(0, -1))} can only be used in render() or setup().`);
}
function resolve(registry, name) {
    return registry && (registry[name] || registry[(0, _shared.camelize)(name)] || registry[(0, _shared.capitalize)((0, _shared.camelize)(name))]);
}
function renderList(source, renderItem, cache, index) {
    let ret;
    const cached = cache && cache[index];
    if ((0, _shared.isArray)(source) || (0, _shared.isString)(source)) {
        ret = new Array(source.length);
        for(let i = 0, l = source.length; i < l; i++)ret[i] = renderItem(source[i], i, void 0, cached && cached[i]);
    } else if (typeof source === "number") {
        if (!Number.isInteger(source)) warn(`The v-for range expect an integer value but got ${source}.`);
        ret = new Array(source);
        for(let i = 0; i < source; i++)ret[i] = renderItem(i + 1, i, void 0, cached && cached[i]);
    } else if ((0, _shared.isObject)(source)) {
        if (source[Symbol.iterator]) ret = Array.from(source, (item, i)=>renderItem(item, i, void 0, cached && cached[i]));
        else {
            const keys = Object.keys(source);
            ret = new Array(keys.length);
            for(let i = 0, l = keys.length; i < l; i++){
                const key = keys[i];
                ret[i] = renderItem(source[key], key, i, cached && cached[i]);
            }
        }
    } else ret = [];
    if (cache) cache[index] = ret;
    return ret;
}
function createSlots(slots, dynamicSlots) {
    for(let i = 0; i < dynamicSlots.length; i++){
        const slot = dynamicSlots[i];
        if ((0, _shared.isArray)(slot)) for(let j = 0; j < slot.length; j++)slots[slot[j].name] = slot[j].fn;
        else if (slot) slots[slot.name] = slot.key ? (...args)=>{
            const res = slot.fn(...args);
            if (res) res.key = slot.key;
            return res;
        } : slot.fn;
    }
    return slots;
}
function renderSlot(slots, name, props = {}, fallback, noSlotted) {
    if (currentRenderingInstance.isCE || currentRenderingInstance.parent && isAsyncWrapper(currentRenderingInstance.parent) && currentRenderingInstance.parent.isCE) {
        if (name !== "default") props.name = name;
        return createVNode("slot", props, fallback && fallback());
    }
    let slot = slots[name];
    if (slot && slot.length > 1) {
        warn(`SSR-optimized slot function detected in a non-SSR-optimized render function. You need to mark this component with $dynamic-slots in the parent template.`);
        slot = ()=>[];
    }
    if (slot && slot._c) slot._d = false;
    openBlock();
    const validSlotContent = slot && ensureValidVNode(slot(props));
    const rendered = createBlock(Fragment, {
        key: props.key || // slot content array of a dynamic conditional slot may have a branch
        // key attached in the `createSlots` helper, respect that
        validSlotContent && validSlotContent.key || `_${name}`
    }, validSlotContent || (fallback ? fallback() : []), validSlotContent && slots._ === 1 ? 64 : -2);
    if (!noSlotted && rendered.scopeId) rendered.slotScopeIds = [
        rendered.scopeId + "-s"
    ];
    if (slot && slot._c) slot._d = true;
    return rendered;
}
function ensureValidVNode(vnodes) {
    return vnodes.some((child)=>{
        if (!isVNode(child)) return true;
        if (child.type === Comment) return false;
        if (child.type === Fragment && !ensureValidVNode(child.children)) return false;
        return true;
    }) ? vnodes : null;
}
function toHandlers(obj, preserveCaseIfNecessary) {
    const ret = {};
    if (!(0, _shared.isObject)(obj)) {
        warn(`v-on with no argument expects an object value.`);
        return ret;
    }
    for(const key in obj)ret[preserveCaseIfNecessary && /[A-Z]/.test(key) ? `on:${key}` : (0, _shared.toHandlerKey)(key)] = obj[key];
    return ret;
}
const getPublicInstance = (i)=>{
    if (!i) return null;
    if (isStatefulComponent(i)) return getExposeProxy(i) || i.proxy;
    return getPublicInstance(i.parent);
};
const publicPropertiesMap = // Move PURE marker to new line to workaround compiler discarding it
// due to type annotation
/* @__PURE__ */ (0, _shared.extend)(/* @__PURE__ */ Object.create(null), {
    $: (i)=>i,
    $el: (i)=>i.vnode.el,
    $data: (i)=>i.data,
    $props: (i)=>(0, _reactivity.shallowReadonly)(i.props),
    $attrs: (i)=>(0, _reactivity.shallowReadonly)(i.attrs),
    $slots: (i)=>(0, _reactivity.shallowReadonly)(i.slots),
    $refs: (i)=>(0, _reactivity.shallowReadonly)(i.refs),
    $parent: (i)=>getPublicInstance(i.parent),
    $root: (i)=>getPublicInstance(i.root),
    $emit: (i)=>i.emit,
    $options: (i)=>__VUE_OPTIONS_API__ ? resolveMergedOptions(i) : i.type,
    $forceUpdate: (i)=>i.f || (i.f = ()=>queueJob(i.update)),
    $nextTick: (i)=>i.n || (i.n = nextTick.bind(i.proxy)),
    $watch: (i)=>__VUE_OPTIONS_API__ ? instanceWatch.bind(i) : (0, _shared.NOOP)
});
const isReservedPrefix = (key)=>key === "_" || key === "$";
const hasSetupBinding = (state, key)=>state !== (0, _shared.EMPTY_OBJ) && !state.__isScriptSetup && (0, _shared.hasOwn)(state, key);
const PublicInstanceProxyHandlers = {
    get ({ _: instance }, key) {
        const { ctx, setupState, data, props, accessCache, type, appContext } = instance;
        if (key === "__isVue") return true;
        let normalizedProps;
        if (key[0] !== "$") {
            const n = accessCache[key];
            if (n !== void 0) switch(n){
                case 1 /* SETUP */ :
                    return setupState[key];
                case 2 /* DATA */ :
                    return data[key];
                case 4 /* CONTEXT */ :
                    return ctx[key];
                case 3 /* PROPS */ :
                    return props[key];
            }
            else if (hasSetupBinding(setupState, key)) {
                accessCache[key] = 1 /* SETUP */ ;
                return setupState[key];
            } else if (data !== (0, _shared.EMPTY_OBJ) && (0, _shared.hasOwn)(data, key)) {
                accessCache[key] = 2 /* DATA */ ;
                return data[key];
            } else if (// only cache other properties when instance has declared (thus stable)
            // props
            (normalizedProps = instance.propsOptions[0]) && (0, _shared.hasOwn)(normalizedProps, key)) {
                accessCache[key] = 3 /* PROPS */ ;
                return props[key];
            } else if (ctx !== (0, _shared.EMPTY_OBJ) && (0, _shared.hasOwn)(ctx, key)) {
                accessCache[key] = 4 /* CONTEXT */ ;
                return ctx[key];
            } else if (!__VUE_OPTIONS_API__ || shouldCacheAccess) accessCache[key] = 0 /* OTHER */ ;
        }
        const publicGetter = publicPropertiesMap[key];
        let cssModule, globalProperties;
        if (publicGetter) {
            if (key === "$attrs") {
                (0, _reactivity.track)(instance, "get", key);
                markAttrsAccessed();
            } else if (key === "$slots") (0, _reactivity.track)(instance, "get", key);
            return publicGetter(instance);
        } else if (// css module (injected by vue-loader)
        (cssModule = type.__cssModules) && (cssModule = cssModule[key])) return cssModule;
        else if (ctx !== (0, _shared.EMPTY_OBJ) && (0, _shared.hasOwn)(ctx, key)) {
            accessCache[key] = 4 /* CONTEXT */ ;
            return ctx[key];
        } else if (// global properties
        globalProperties = appContext.config.globalProperties, (0, _shared.hasOwn)(globalProperties, key)) return globalProperties[key];
        else if (currentRenderingInstance && (!(0, _shared.isString)(key) || // #1091 avoid internal isRef/isVNode checks on component instance leading
        // to infinite warning loop
        key.indexOf("__v") !== 0)) {
            if (data !== (0, _shared.EMPTY_OBJ) && isReservedPrefix(key[0]) && (0, _shared.hasOwn)(data, key)) warn(`Property ${JSON.stringify(key)} must be accessed via $data because it starts with a reserved character ("$" or "_") and is not proxied on the render context.`);
            else if (instance === currentRenderingInstance) warn(`Property ${JSON.stringify(key)} was accessed during render but is not defined on instance.`);
        }
    },
    set ({ _: instance }, key, value1) {
        const { data, setupState, ctx } = instance;
        if (hasSetupBinding(setupState, key)) {
            setupState[key] = value1;
            return true;
        } else if ((0, setupState.__isScriptSetup) && (0, _shared.hasOwn)(setupState, key)) {
            warn(`Cannot mutate <script setup> binding "${key}" from Options API.`);
            return false;
        } else if (data !== (0, _shared.EMPTY_OBJ) && (0, _shared.hasOwn)(data, key)) {
            data[key] = value1;
            return true;
        } else if ((0, _shared.hasOwn)(instance.props, key)) {
            warn(`Attempting to mutate prop "${key}". Props are readonly.`);
            return false;
        }
        if (key[0] === "$" && key.slice(1) in instance) {
            warn(`Attempting to mutate public property "${key}". Properties starting with $ are reserved and readonly.`);
            return false;
        } else if (key in instance.appContext.config.globalProperties) Object.defineProperty(ctx, key, {
            enumerable: true,
            configurable: true,
            value: value1
        });
        else ctx[key] = value1;
        return true;
    },
    has ({ _: { data, setupState, accessCache, ctx, appContext, propsOptions } }, key) {
        let normalizedProps;
        return !!accessCache[key] || data !== (0, _shared.EMPTY_OBJ) && (0, _shared.hasOwn)(data, key) || hasSetupBinding(setupState, key) || (normalizedProps = propsOptions[0]) && (0, _shared.hasOwn)(normalizedProps, key) || (0, _shared.hasOwn)(ctx, key) || (0, _shared.hasOwn)(publicPropertiesMap, key) || (0, _shared.hasOwn)(appContext.config.globalProperties, key);
    },
    defineProperty (target, key, descriptor) {
        if (descriptor.get != null) target._.accessCache[key] = 0;
        else if ((0, _shared.hasOwn)(descriptor, "value")) this.set(target, key, descriptor.value, null);
        return Reflect.defineProperty(target, key, descriptor);
    }
};
PublicInstanceProxyHandlers.ownKeys = (target)=>{
    warn(`Avoid app logic that relies on enumerating keys on a component instance. The keys will be empty in production mode to avoid performance overhead.`);
    return Reflect.ownKeys(target);
};
const RuntimeCompiledPublicInstanceProxyHandlers = /* @__PURE__ */ (0, _shared.extend)({}, PublicInstanceProxyHandlers, {
    get (target, key) {
        if (key === Symbol.unscopables) return;
        return PublicInstanceProxyHandlers.get(target, key, target);
    },
    has (_, key) {
        const has = key[0] !== "_" && !(0, _shared.isGloballyWhitelisted)(key);
        if (!has && PublicInstanceProxyHandlers.has(_, key)) warn(`Property ${JSON.stringify(key)} should not start with _ which is a reserved prefix for Vue internals.`);
        return has;
    }
});
function createDevRenderContext(instance) {
    const target = {};
    Object.defineProperty(target, `_`, {
        configurable: true,
        enumerable: false,
        get: ()=>instance
    });
    Object.keys(publicPropertiesMap).forEach((key)=>{
        Object.defineProperty(target, key, {
            configurable: true,
            enumerable: false,
            get: ()=>publicPropertiesMap[key](instance),
            // intercepted by the proxy so no need for implementation,
            // but needed to prevent set errors
            set: (0, _shared.NOOP)
        });
    });
    return target;
}
function exposePropsOnRenderContext(instance) {
    const { ctx, propsOptions: [propsOptions] } = instance;
    if (propsOptions) Object.keys(propsOptions).forEach((key)=>{
        Object.defineProperty(ctx, key, {
            enumerable: true,
            configurable: true,
            get: ()=>instance.props[key],
            set: (0, _shared.NOOP)
        });
    });
}
function exposeSetupStateOnRenderContext(instance) {
    const { ctx, setupState } = instance;
    Object.keys((0, _reactivity.toRaw)(setupState)).forEach((key)=>{
        if (!setupState.__isScriptSetup) {
            if (isReservedPrefix(key[0])) {
                warn(`setup() return property ${JSON.stringify(key)} should not start with "$" or "_" which are reserved prefixes for Vue internals.`);
                return;
            }
            Object.defineProperty(ctx, key, {
                enumerable: true,
                configurable: true,
                get: ()=>setupState[key],
                set: (0, _shared.NOOP)
            });
        }
    });
}
const warnRuntimeUsage = (method)=>warn(`${method}() is a compiler-hint helper that is only usable inside <script setup> of a single file component. Its arguments should be compiled away and passing it at runtime has no effect.`);
function defineProps() {
    warnRuntimeUsage(`defineProps`);
    return null;
}
function defineEmits() {
    warnRuntimeUsage(`defineEmits`);
    return null;
}
function defineExpose(exposed) {
    warnRuntimeUsage(`defineExpose`);
}
function defineOptions(options) {
    warnRuntimeUsage(`defineOptions`);
}
function defineSlots() {
    warnRuntimeUsage(`defineSlots`);
    return null;
}
function defineModel() {
    warnRuntimeUsage("defineModel");
}
function withDefaults(props, defaults) {
    warnRuntimeUsage(`withDefaults`);
    return null;
}
function useSlots() {
    return getContext().slots;
}
function useAttrs() {
    return getContext().attrs;
}
function useModel(props, name, options) {
    const i = getCurrentInstance();
    if (!i) {
        warn(`useModel() called without active instance.`);
        return (0, _reactivity.ref)();
    }
    if (!i.propsOptions[0][name]) {
        warn(`useModel() called with prop "${name}" which is not declared.`);
        return (0, _reactivity.ref)();
    }
    if (options && options.local) {
        const proxy = (0, _reactivity.ref)(props[name]);
        watch(()=>props[name], (v1)=>proxy.value = v1);
        watch(proxy, (value1)=>{
            if (value1 !== props[name]) i.emit(`update:${name}`, value1);
        });
        return proxy;
    } else return {
        __v_isRef: true,
        get value () {
            return props[name];
        },
        set value (value){
            i.emit(`update:${name}`, value);
        }
    };
}
function getContext() {
    const i = getCurrentInstance();
    if (!i) warn(`useContext() called without active instance.`);
    return i.setupContext || (i.setupContext = createSetupContext(i));
}
function normalizePropsOrEmits(props) {
    return (0, _shared.isArray)(props) ? props.reduce((normalized, p)=>(normalized[p] = null, normalized), {}) : props;
}
function mergeDefaults(raw, defaults) {
    const props = normalizePropsOrEmits(raw);
    for(const key in defaults){
        if (key.startsWith("__skip")) continue;
        let opt = props[key];
        if (opt) {
            if ((0, _shared.isArray)(opt) || (0, _shared.isFunction)(opt)) opt = props[key] = {
                type: opt,
                default: defaults[key]
            };
            else opt.default = defaults[key];
        } else if (opt === null) opt = props[key] = {
            default: defaults[key]
        };
        else warn(`props default key "${key}" has no corresponding declaration.`);
        if (opt && defaults[`__skip_${key}`]) opt.skipFactory = true;
    }
    return props;
}
function mergeModels(a, b) {
    if (!a || !b) return a || b;
    if ((0, _shared.isArray)(a) && (0, _shared.isArray)(b)) return a.concat(b);
    return (0, _shared.extend)({}, normalizePropsOrEmits(a), normalizePropsOrEmits(b));
}
function createPropsRestProxy(props, excludedKeys) {
    const ret = {};
    for(const key in props)if (!excludedKeys.includes(key)) Object.defineProperty(ret, key, {
        enumerable: true,
        get: ()=>props[key]
    });
    return ret;
}
function withAsyncContext(getAwaitable) {
    const ctx = getCurrentInstance();
    if (!ctx) warn(`withAsyncContext called without active current instance. This is likely a bug.`);
    let awaitable = getAwaitable();
    unsetCurrentInstance();
    if ((0, _shared.isPromise)(awaitable)) awaitable = awaitable.catch((e)=>{
        setCurrentInstance(ctx);
        throw e;
    });
    return [
        awaitable,
        ()=>setCurrentInstance(ctx)
    ];
}
function createDuplicateChecker() {
    const cache = /* @__PURE__ */ Object.create(null);
    return (type, key)=>{
        if (cache[key]) warn(`${type} property "${key}" is already defined in ${cache[key]}.`);
        else cache[key] = type;
    };
}
let shouldCacheAccess = true;
function applyOptions(instance) {
    const options = resolveMergedOptions(instance);
    const publicThis = instance.proxy;
    const ctx = instance.ctx;
    shouldCacheAccess = false;
    if (options.beforeCreate) callHook(options.beforeCreate, instance, "bc");
    const { // state
    data: dataOptions, computed: computedOptions, methods, watch: watchOptions, provide: provideOptions, inject: injectOptions, // lifecycle
    created, beforeMount, mounted, beforeUpdate, updated, activated, deactivated, beforeDestroy, beforeUnmount, destroyed, unmounted, render, renderTracked, renderTriggered, errorCaptured, serverPrefetch, // public API
    expose, inheritAttrs, // assets
    components, directives, filters } = options;
    const checkDuplicateProperties = createDuplicateChecker();
    {
        const [propsOptions] = instance.propsOptions;
        if (propsOptions) for(const key in propsOptions)checkDuplicateProperties("Props" /* PROPS */ , key);
    }
    if (injectOptions) resolveInjections(injectOptions, ctx, checkDuplicateProperties);
    if (methods) for(const key in methods){
        const methodHandler = methods[key];
        if ((0, _shared.isFunction)(methodHandler)) {
            Object.defineProperty(ctx, key, {
                value: methodHandler.bind(publicThis),
                configurable: true,
                enumerable: true,
                writable: true
            });
            checkDuplicateProperties("Methods" /* METHODS */ , key);
        } else warn(`Method "${key}" has type "${typeof methodHandler}" in the component definition. Did you reference the function correctly?`);
    }
    if (dataOptions) {
        if (!(0, _shared.isFunction)(dataOptions)) warn(`The data option must be a function. Plain object usage is no longer supported.`);
        const data = dataOptions.call(publicThis, publicThis);
        if ((0, _shared.isPromise)(data)) warn(`data() returned a Promise - note data() cannot be async; If you intend to perform data fetching before component renders, use async setup() + <Suspense>.`);
        if (!(0, _shared.isObject)(data)) warn(`data() should return an object.`);
        else {
            instance.data = (0, _reactivity.reactive)(data);
            for(const key in data){
                checkDuplicateProperties("Data" /* DATA */ , key);
                if (!isReservedPrefix(key[0])) Object.defineProperty(ctx, key, {
                    configurable: true,
                    enumerable: true,
                    get: ()=>data[key],
                    set: (0, _shared.NOOP)
                });
            }
        }
    }
    shouldCacheAccess = true;
    if (computedOptions) for(const key in computedOptions){
        const opt = computedOptions[key];
        const get = (0, _shared.isFunction)(opt) ? opt.bind(publicThis, publicThis) : (0, _shared.isFunction)(opt.get) ? opt.get.bind(publicThis, publicThis) : (0, _shared.NOOP);
        if (get === (0, _shared.NOOP)) warn(`Computed property "${key}" has no getter.`);
        const set = !(0, _shared.isFunction)(opt) && (0, _shared.isFunction)(opt.set) ? opt.set.bind(publicThis) : ()=>{
            warn(`Write operation failed: computed property "${key}" is readonly.`);
        };
        const c = computed({
            get,
            set
        });
        Object.defineProperty(ctx, key, {
            enumerable: true,
            configurable: true,
            get: ()=>c.value,
            set: (v1)=>c.value = v1
        });
        checkDuplicateProperties("Computed" /* COMPUTED */ , key);
    }
    if (watchOptions) for(const key in watchOptions)createWatcher(watchOptions[key], ctx, publicThis, key);
    if (provideOptions) {
        const provides = (0, _shared.isFunction)(provideOptions) ? provideOptions.call(publicThis) : provideOptions;
        Reflect.ownKeys(provides).forEach((key)=>{
            provide(key, provides[key]);
        });
    }
    if (created) callHook(created, instance, "c");
    function registerLifecycleHook(register, hook) {
        if ((0, _shared.isArray)(hook)) hook.forEach((_hook)=>register(_hook.bind(publicThis)));
        else if (hook) register(hook.bind(publicThis));
    }
    registerLifecycleHook(onBeforeMount, beforeMount);
    registerLifecycleHook(onMounted, mounted);
    registerLifecycleHook(onBeforeUpdate, beforeUpdate);
    registerLifecycleHook(onUpdated, updated);
    registerLifecycleHook(onActivated, activated);
    registerLifecycleHook(onDeactivated, deactivated);
    registerLifecycleHook(onErrorCaptured, errorCaptured);
    registerLifecycleHook(onRenderTracked, renderTracked);
    registerLifecycleHook(onRenderTriggered, renderTriggered);
    registerLifecycleHook(onBeforeUnmount, beforeUnmount);
    registerLifecycleHook(onUnmounted, unmounted);
    registerLifecycleHook(onServerPrefetch, serverPrefetch);
    if ((0, _shared.isArray)(expose)) {
        if (expose.length) {
            const exposed = instance.exposed || (instance.exposed = {});
            expose.forEach((key)=>{
                Object.defineProperty(exposed, key, {
                    get: ()=>publicThis[key],
                    set: (val)=>publicThis[key] = val
                });
            });
        } else if (!instance.exposed) instance.exposed = {};
    }
    if (render && instance.render === (0, _shared.NOOP)) instance.render = render;
    if (inheritAttrs != null) instance.inheritAttrs = inheritAttrs;
    if (components) instance.components = components;
    if (directives) instance.directives = directives;
}
function resolveInjections(injectOptions, ctx, checkDuplicateProperties = (0, _shared.NOOP)) {
    if ((0, _shared.isArray)(injectOptions)) injectOptions = normalizeInject(injectOptions);
    for(const key in injectOptions){
        const opt = injectOptions[key];
        let injected;
        if ((0, _shared.isObject)(opt)) {
            if ("default" in opt) injected = inject(opt.from || key, opt.default, true);
            else injected = inject(opt.from || key);
        } else injected = inject(opt);
        if ((0, _reactivity.isRef)(injected)) Object.defineProperty(ctx, key, {
            enumerable: true,
            configurable: true,
            get: ()=>injected.value,
            set: (v1)=>injected.value = v1
        });
        else ctx[key] = injected;
        checkDuplicateProperties("Inject" /* INJECT */ , key);
    }
}
function callHook(hook, instance, type) {
    callWithAsyncErrorHandling((0, _shared.isArray)(hook) ? hook.map((h)=>h.bind(instance.proxy)) : hook.bind(instance.proxy), instance, type);
}
function createWatcher(raw, ctx, publicThis, key) {
    const getter = key.includes(".") ? createPathGetter(publicThis, key) : ()=>publicThis[key];
    if ((0, _shared.isString)(raw)) {
        const handler = ctx[raw];
        if ((0, _shared.isFunction)(handler)) watch(getter, handler);
        else warn(`Invalid watch handler specified by key "${raw}"`, handler);
    } else if ((0, _shared.isFunction)(raw)) watch(getter, raw.bind(publicThis));
    else if ((0, _shared.isObject)(raw)) {
        if ((0, _shared.isArray)(raw)) raw.forEach((r)=>createWatcher(r, ctx, publicThis, key));
        else {
            const handler = (0, _shared.isFunction)(raw.handler) ? raw.handler.bind(publicThis) : ctx[raw.handler];
            if ((0, _shared.isFunction)(handler)) watch(getter, handler, raw);
            else warn(`Invalid watch handler specified by key "${raw.handler}"`, handler);
        }
    } else warn(`Invalid watch option: "${key}"`, raw);
}
function resolveMergedOptions(instance) {
    const base = instance.type;
    const { mixins, extends: extendsOptions } = base;
    const { mixins: globalMixins, optionsCache: cache, config: { optionMergeStrategies } } = instance.appContext;
    const cached = cache.get(base);
    let resolved;
    if (cached) resolved = cached;
    else if (!globalMixins.length && !mixins && !extendsOptions) resolved = base;
    else {
        resolved = {};
        if (globalMixins.length) globalMixins.forEach((m)=>mergeOptions(resolved, m, optionMergeStrategies, true));
        mergeOptions(resolved, base, optionMergeStrategies);
    }
    if ((0, _shared.isObject)(base)) cache.set(base, resolved);
    return resolved;
}
function mergeOptions(to, from, strats, asMixin = false) {
    const { mixins, extends: extendsOptions } = from;
    if (extendsOptions) mergeOptions(to, extendsOptions, strats, true);
    if (mixins) mixins.forEach((m)=>mergeOptions(to, m, strats, true));
    for(const key in from)if (asMixin && key === "expose") warn(`"expose" option is ignored when declared in mixins or extends. It should only be declared in the base component itself.`);
    else {
        const strat = internalOptionMergeStrats[key] || strats && strats[key];
        to[key] = strat ? strat(to[key], from[key]) : from[key];
    }
    return to;
}
const internalOptionMergeStrats = {
    data: mergeDataFn,
    props: mergeEmitsOrPropsOptions,
    emits: mergeEmitsOrPropsOptions,
    // objects
    methods: mergeObjectOptions,
    computed: mergeObjectOptions,
    // lifecycle
    beforeCreate: mergeAsArray,
    created: mergeAsArray,
    beforeMount: mergeAsArray,
    mounted: mergeAsArray,
    beforeUpdate: mergeAsArray,
    updated: mergeAsArray,
    beforeDestroy: mergeAsArray,
    beforeUnmount: mergeAsArray,
    destroyed: mergeAsArray,
    unmounted: mergeAsArray,
    activated: mergeAsArray,
    deactivated: mergeAsArray,
    errorCaptured: mergeAsArray,
    serverPrefetch: mergeAsArray,
    // assets
    components: mergeObjectOptions,
    directives: mergeObjectOptions,
    // watch
    watch: mergeWatchOptions,
    // provide / inject
    provide: mergeDataFn,
    inject: mergeInject
};
function mergeDataFn(to, from) {
    if (!from) return to;
    if (!to) return from;
    return function mergedDataFn() {
        return (0, _shared.extend)((0, _shared.isFunction)(to) ? to.call(this, this) : to, (0, _shared.isFunction)(from) ? from.call(this, this) : from);
    };
}
function mergeInject(to, from) {
    return mergeObjectOptions(normalizeInject(to), normalizeInject(from));
}
function normalizeInject(raw) {
    if ((0, _shared.isArray)(raw)) {
        const res = {};
        for(let i = 0; i < raw.length; i++)res[raw[i]] = raw[i];
        return res;
    }
    return raw;
}
function mergeAsArray(to, from) {
    return to ? [
        ...new Set([].concat(to, from))
    ] : from;
}
function mergeObjectOptions(to, from) {
    return to ? (0, _shared.extend)(/* @__PURE__ */ Object.create(null), to, from) : from;
}
function mergeEmitsOrPropsOptions(to, from) {
    if (to) {
        if ((0, _shared.isArray)(to) && (0, _shared.isArray)(from)) return [
            .../* @__PURE__ */ new Set([
                ...to,
                ...from
            ])
        ];
        return (0, _shared.extend)(/* @__PURE__ */ Object.create(null), normalizePropsOrEmits(to), normalizePropsOrEmits(from != null ? from : {}));
    } else return from;
}
function mergeWatchOptions(to, from) {
    if (!to) return from;
    if (!from) return to;
    const merged = (0, _shared.extend)(/* @__PURE__ */ Object.create(null), to);
    for(const key in from)merged[key] = mergeAsArray(to[key], from[key]);
    return merged;
}
function createAppContext() {
    return {
        app: null,
        config: {
            isNativeTag: (0, _shared.NO),
            performance: false,
            globalProperties: {},
            optionMergeStrategies: {},
            errorHandler: void 0,
            warnHandler: void 0,
            compilerOptions: {}
        },
        mixins: [],
        components: {},
        directives: {},
        provides: /* @__PURE__ */ Object.create(null),
        optionsCache: /* @__PURE__ */ new WeakMap(),
        propsCache: /* @__PURE__ */ new WeakMap(),
        emitsCache: /* @__PURE__ */ new WeakMap()
    };
}
let uid$1 = 0;
function createAppAPI(render, hydrate) {
    return function createApp(rootComponent, rootProps = null) {
        if (!(0, _shared.isFunction)(rootComponent)) rootComponent = (0, _shared.extend)({}, rootComponent);
        if (rootProps != null && !(0, _shared.isObject)(rootProps)) {
            warn(`root props passed to app.mount() must be an object.`);
            rootProps = null;
        }
        const context = createAppContext();
        Object.defineProperty(context.config, "unwrapInjectedRef", {
            get () {
                return true;
            },
            set () {
                warn(`app.config.unwrapInjectedRef has been deprecated. 3.3 now alawys unwraps injected refs in Options API.`);
            }
        });
        const installedPlugins = /* @__PURE__ */ new Set();
        let isMounted = false;
        const app = context.app = {
            _uid: uid$1++,
            _component: rootComponent,
            _props: rootProps,
            _container: null,
            _context: context,
            _instance: null,
            version,
            get config () {
                return context.config;
            },
            set config (v){
                warn(`app.config cannot be replaced. Modify individual options instead.`);
            },
            use (plugin, ...options) {
                if (installedPlugins.has(plugin)) warn(`Plugin has already been applied to target app.`);
                else if (plugin && (0, _shared.isFunction)(plugin.install)) {
                    installedPlugins.add(plugin);
                    plugin.install(app, ...options);
                } else if ((0, _shared.isFunction)(plugin)) {
                    installedPlugins.add(plugin);
                    plugin(app, ...options);
                } else warn(`A plugin must either be a function or an object with an "install" function.`);
                return app;
            },
            mixin (mixin) {
                if (__VUE_OPTIONS_API__) {
                    if (!context.mixins.includes(mixin)) context.mixins.push(mixin);
                    else warn("Mixin has already been applied to target app" + (mixin.name ? `: ${mixin.name}` : ""));
                } else warn("Mixins are only available in builds supporting Options API");
                return app;
            },
            component (name, component) {
                validateComponentName(name, context.config);
                if (!component) return context.components[name];
                if (0, context.components[name]) warn(`Component "${name}" has already been registered in target app.`);
                context.components[name] = component;
                return app;
            },
            directive (name, directive) {
                validateDirectiveName(name);
                if (!directive) return context.directives[name];
                if (0, context.directives[name]) warn(`Directive "${name}" has already been registered in target app.`);
                context.directives[name] = directive;
                return app;
            },
            mount (rootContainer, isHydrate, isSVG) {
                if (!isMounted) {
                    if (0, rootContainer.__vue_app__) warn(`There is already an app instance mounted on the host container.
 If you want to mount another app on the same host container, you need to unmount the previous app by calling \`app.unmount()\` first.`);
                    const vnode = createVNode(rootComponent, rootProps);
                    vnode.appContext = context;
                    context.reload = ()=>{
                        render(cloneVNode(vnode), rootContainer, isSVG);
                    };
                    if (isHydrate && hydrate) hydrate(vnode, rootContainer);
                    else render(vnode, rootContainer, isSVG);
                    isMounted = true;
                    app._container = rootContainer;
                    rootContainer.__vue_app__ = app;
                    app._instance = vnode.component;
                    devtoolsInitApp(app, version);
                    return getExposeProxy(vnode.component) || vnode.component.proxy;
                } else warn(`App has already been mounted.
If you want to remount the same app, move your app creation logic into a factory function and create fresh app instances for each mount - e.g. \`const createMyApp = () => createApp(App)\``);
            },
            unmount () {
                if (isMounted) {
                    render(null, app._container);
                    app._instance = null;
                    devtoolsUnmountApp(app);
                    delete app._container.__vue_app__;
                } else warn(`Cannot unmount an app that is not mounted.`);
            },
            provide (key, value1) {
                if (key in context.provides) warn(`App already provides property with key "${String(key)}". It will be overwritten with the new value.`);
                context.provides[key] = value1;
                return app;
            },
            runWithContext (fn) {
                currentApp = app;
                try {
                    return fn();
                } finally{
                    currentApp = null;
                }
            }
        };
        return app;
    };
}
let currentApp = null;
function provide(key, value1) {
    if (!currentInstance) warn(`provide() can only be used inside setup().`);
    else {
        let provides = currentInstance.provides;
        const parentProvides = currentInstance.parent && currentInstance.parent.provides;
        if (parentProvides === provides) provides = currentInstance.provides = Object.create(parentProvides);
        provides[key] = value1;
    }
}
function inject(key, defaultValue, treatDefaultAsFactory = false) {
    const instance = currentInstance || currentRenderingInstance;
    if (instance || currentApp) {
        const provides = instance ? instance.parent == null ? instance.vnode.appContext && instance.vnode.appContext.provides : instance.parent.provides : currentApp._context.provides;
        if (provides && key in provides) return provides[key];
        else if (arguments.length > 1) return treatDefaultAsFactory && (0, _shared.isFunction)(defaultValue) ? defaultValue.call(instance && instance.proxy) : defaultValue;
        else warn(`injection "${String(key)}" not found.`);
    } else warn(`inject() can only be used inside setup() or functional components.`);
}
function hasInjectionContext() {
    return !!(currentInstance || currentRenderingInstance || currentApp);
}
function initProps(instance, rawProps, isStateful, isSSR = false) {
    const props = {};
    const attrs = {};
    (0, _shared.def)(attrs, InternalObjectKey, 1);
    instance.propsDefaults = /* @__PURE__ */ Object.create(null);
    setFullProps(instance, rawProps, props, attrs);
    for(const key in instance.propsOptions[0])if (!(key in props)) props[key] = void 0;
    validateProps(rawProps || {}, props, instance);
    if (isStateful) instance.props = isSSR ? props : (0, _reactivity.shallowReactive)(props);
    else if (!instance.type.props) instance.props = attrs;
    else instance.props = props;
    instance.attrs = attrs;
}
function isInHmrContext(instance) {
    while(instance){
        if (instance.type.__hmrId) return true;
        instance = instance.parent;
    }
}
function updateProps(instance, rawProps, rawPrevProps, optimized) {
    const { props, attrs, vnode: { patchFlag } } = instance;
    const rawCurrentProps = (0, _reactivity.toRaw)(props);
    const [options] = instance.propsOptions;
    let hasAttrsChanged = false;
    if (// always force full diff in dev
    // - #1942 if hmr is enabled with sfc component
    // - vite#872 non-sfc component used by sfc component
    !isInHmrContext(instance) && (optimized || patchFlag > 0) && !(patchFlag & 16)) {
        if (patchFlag & 8) {
            const propsToUpdate = instance.vnode.dynamicProps;
            for(let i = 0; i < propsToUpdate.length; i++){
                let key = propsToUpdate[i];
                if (isEmitListener(instance.emitsOptions, key)) continue;
                const value1 = rawProps[key];
                if (options) {
                    if ((0, _shared.hasOwn)(attrs, key)) {
                        if (value1 !== attrs[key]) {
                            attrs[key] = value1;
                            hasAttrsChanged = true;
                        }
                    } else {
                        const camelizedKey = (0, _shared.camelize)(key);
                        props[camelizedKey] = resolvePropValue(options, rawCurrentProps, camelizedKey, value1, instance, false);
                    }
                } else if (value1 !== attrs[key]) {
                    attrs[key] = value1;
                    hasAttrsChanged = true;
                }
            }
        }
    } else {
        if (setFullProps(instance, rawProps, props, attrs)) hasAttrsChanged = true;
        let kebabKey;
        for(const key in rawCurrentProps)if (!rawProps || // for camelCase
        !(0, _shared.hasOwn)(rawProps, key) && // it's possible the original props was passed in as kebab-case
        // and converted to camelCase (#955)
        ((kebabKey = (0, _shared.hyphenate)(key)) === key || !(0, _shared.hasOwn)(rawProps, kebabKey))) {
            if (options) {
                if (rawPrevProps && // for camelCase
                (rawPrevProps[key] !== void 0 || // for kebab-case
                rawPrevProps[kebabKey] !== void 0)) props[key] = resolvePropValue(options, rawCurrentProps, key, void 0, instance, true);
            } else delete props[key];
        }
        if (attrs !== rawCurrentProps) {
            for(const key in attrs)if (!rawProps || !(0, _shared.hasOwn)(rawProps, key) && true) {
                delete attrs[key];
                hasAttrsChanged = true;
            }
        }
    }
    if (hasAttrsChanged) (0, _reactivity.trigger)(instance, "set", "$attrs");
    validateProps(rawProps || {}, props, instance);
}
function setFullProps(instance, rawProps, props, attrs) {
    const [options, needCastKeys] = instance.propsOptions;
    let hasAttrsChanged = false;
    let rawCastValues;
    if (rawProps) for(let key in rawProps){
        if ((0, _shared.isReservedProp)(key)) continue;
        const value1 = rawProps[key];
        let camelKey;
        if (options && (0, _shared.hasOwn)(options, camelKey = (0, _shared.camelize)(key))) {
            if (!needCastKeys || !needCastKeys.includes(camelKey)) props[camelKey] = value1;
            else (rawCastValues || (rawCastValues = {}))[camelKey] = value1;
        } else if (!isEmitListener(instance.emitsOptions, key)) {
            if (!(key in attrs) || value1 !== attrs[key]) {
                attrs[key] = value1;
                hasAttrsChanged = true;
            }
        }
    }
    if (needCastKeys) {
        const rawCurrentProps = (0, _reactivity.toRaw)(props);
        const castValues = rawCastValues || (0, _shared.EMPTY_OBJ);
        for(let i = 0; i < needCastKeys.length; i++){
            const key = needCastKeys[i];
            props[key] = resolvePropValue(options, rawCurrentProps, key, castValues[key], instance, !(0, _shared.hasOwn)(castValues, key));
        }
    }
    return hasAttrsChanged;
}
function resolvePropValue(options, props, key, value1, instance, isAbsent) {
    const opt = options[key];
    if (opt != null) {
        const hasDefault = (0, _shared.hasOwn)(opt, "default");
        if (hasDefault && value1 === void 0) {
            const defaultValue = opt.default;
            if (opt.type !== Function && !opt.skipFactory && (0, _shared.isFunction)(defaultValue)) {
                const { propsDefaults } = instance;
                if (key in propsDefaults) value1 = propsDefaults[key];
                else {
                    setCurrentInstance(instance);
                    value1 = propsDefaults[key] = defaultValue.call(null, props);
                    unsetCurrentInstance();
                }
            } else value1 = defaultValue;
        }
        if (opt[0 /* shouldCast */ ]) {
            if (isAbsent && !hasDefault) value1 = false;
            else if (opt[1 /* shouldCastTrue */ ] && (value1 === "" || value1 === (0, _shared.hyphenate)(key))) value1 = true;
        }
    }
    return value1;
}
function normalizePropsOptions(comp, appContext, asMixin = false) {
    const cache = appContext.propsCache;
    const cached = cache.get(comp);
    if (cached) return cached;
    const raw = comp.props;
    const normalized = {};
    const needCastKeys = [];
    let hasExtends = false;
    if (__VUE_OPTIONS_API__ && !(0, _shared.isFunction)(comp)) {
        const extendProps = (raw2)=>{
            hasExtends = true;
            const [props, keys] = normalizePropsOptions(raw2, appContext, true);
            (0, _shared.extend)(normalized, props);
            if (keys) needCastKeys.push(...keys);
        };
        if (!asMixin && appContext.mixins.length) appContext.mixins.forEach(extendProps);
        if (comp.extends) extendProps(comp.extends);
        if (comp.mixins) comp.mixins.forEach(extendProps);
    }
    if (!raw && !hasExtends) {
        if ((0, _shared.isObject)(comp)) cache.set(comp, (0, _shared.EMPTY_ARR));
        return 0, _shared.EMPTY_ARR;
    }
    if ((0, _shared.isArray)(raw)) for(let i = 0; i < raw.length; i++){
        if (!(0, _shared.isString)(raw[i])) warn(`props must be strings when using array syntax.`, raw[i]);
        const normalizedKey = (0, _shared.camelize)(raw[i]);
        if (validatePropName(normalizedKey)) normalized[normalizedKey] = (0, _shared.EMPTY_OBJ);
    }
    else if (raw) {
        if (!(0, _shared.isObject)(raw)) warn(`invalid props options`, raw);
        for(const key in raw){
            const normalizedKey = (0, _shared.camelize)(key);
            if (validatePropName(normalizedKey)) {
                const opt = raw[key];
                const prop = normalized[normalizedKey] = (0, _shared.isArray)(opt) || (0, _shared.isFunction)(opt) ? {
                    type: opt
                } : (0, _shared.extend)({}, opt);
                if (prop) {
                    const booleanIndex = getTypeIndex(Boolean, prop.type);
                    const stringIndex = getTypeIndex(String, prop.type);
                    prop[0 /* shouldCast */ ] = booleanIndex > -1;
                    prop[1 /* shouldCastTrue */ ] = stringIndex < 0 || booleanIndex < stringIndex;
                    if (booleanIndex > -1 || (0, _shared.hasOwn)(prop, "default")) needCastKeys.push(normalizedKey);
                }
            }
        }
    }
    const res = [
        normalized,
        needCastKeys
    ];
    if ((0, _shared.isObject)(comp)) cache.set(comp, res);
    return res;
}
function validatePropName(key) {
    if (key[0] !== "$") return true;
    else warn(`Invalid prop name: "${key}" is a reserved property.`);
    return false;
}
function getType(ctor) {
    const match = ctor && ctor.toString().match(/^\s*(function|class) (\w+)/);
    return match ? match[2] : ctor === null ? "null" : "";
}
function isSameType(a, b) {
    return getType(a) === getType(b);
}
function getTypeIndex(type, expectedTypes) {
    if ((0, _shared.isArray)(expectedTypes)) return expectedTypes.findIndex((t)=>isSameType(t, type));
    else if ((0, _shared.isFunction)(expectedTypes)) return isSameType(expectedTypes, type) ? 0 : -1;
    return -1;
}
function validateProps(rawProps, props, instance) {
    const resolvedValues = (0, _reactivity.toRaw)(props);
    const options = instance.propsOptions[0];
    for(const key in options){
        let opt = options[key];
        if (opt == null) continue;
        validateProp(key, resolvedValues[key], opt, !(0, _shared.hasOwn)(rawProps, key) && !(0, _shared.hasOwn)(rawProps, (0, _shared.hyphenate)(key)));
    }
}
function validateProp(name, value1, prop, isAbsent) {
    const { type, required, validator, skipCheck } = prop;
    if (required && isAbsent) {
        warn('Missing required prop: "' + name + '"');
        return;
    }
    if (value1 == null && !required) return;
    if (type != null && type !== true && !skipCheck) {
        let isValid = false;
        const types = (0, _shared.isArray)(type) ? type : [
            type
        ];
        const expectedTypes = [];
        for(let i = 0; i < types.length && !isValid; i++){
            const { valid, expectedType } = assertType(value1, types[i]);
            expectedTypes.push(expectedType || "");
            isValid = valid;
        }
        if (!isValid) {
            warn(getInvalidTypeMessage(name, value1, expectedTypes));
            return;
        }
    }
    if (validator && !validator(value1)) warn('Invalid prop: custom validator check failed for prop "' + name + '".');
}
const isSimpleType = /* @__PURE__ */ (0, _shared.makeMap)("String,Number,Boolean,Function,Symbol,BigInt");
function assertType(value1, type) {
    let valid;
    const expectedType = getType(type);
    if (isSimpleType(expectedType)) {
        const t = typeof value1;
        valid = t === expectedType.toLowerCase();
        if (!valid && t === "object") valid = value1 instanceof type;
    } else if (expectedType === "Object") valid = (0, _shared.isObject)(value1);
    else if (expectedType === "Array") valid = (0, _shared.isArray)(value1);
    else if (expectedType === "null") valid = value1 === null;
    else valid = value1 instanceof type;
    return {
        valid,
        expectedType
    };
}
function getInvalidTypeMessage(name, value1, expectedTypes) {
    let message = `Invalid prop: type check failed for prop "${name}". Expected ${expectedTypes.map((0, _shared.capitalize)).join(" | ")}`;
    const expectedType = expectedTypes[0];
    const receivedType = (0, _shared.toRawType)(value1);
    const expectedValue = styleValue(value1, expectedType);
    const receivedValue = styleValue(value1, receivedType);
    if (expectedTypes.length === 1 && isExplicable(expectedType) && !isBoolean(expectedType, receivedType)) message += ` with value ${expectedValue}`;
    message += `, got ${receivedType} `;
    if (isExplicable(receivedType)) message += `with value ${receivedValue}.`;
    return message;
}
function styleValue(value1, type) {
    if (type === "String") return `"${value1}"`;
    else if (type === "Number") return `${Number(value1)}`;
    else return `${value1}`;
}
function isExplicable(type) {
    const explicitTypes = [
        "string",
        "number",
        "boolean"
    ];
    return explicitTypes.some((elem)=>type.toLowerCase() === elem);
}
function isBoolean(...args) {
    return args.some((elem)=>elem.toLowerCase() === "boolean");
}
const isInternalKey = (key)=>key[0] === "_" || key === "$stable";
const normalizeSlotValue = (value1)=>(0, _shared.isArray)(value1) ? value1.map(normalizeVNode) : [
        normalizeVNode(value1)
    ];
const normalizeSlot = (key, rawSlot, ctx)=>{
    if (rawSlot._n) return rawSlot;
    const normalized = withCtx((...args)=>{
        if (currentInstance) warn(`Slot "${key}" invoked outside of the render function: this will not track dependencies used in the slot. Invoke the slot function inside the render function instead.`);
        return normalizeSlotValue(rawSlot(...args));
    }, ctx);
    normalized._c = false;
    return normalized;
};
const normalizeObjectSlots = (rawSlots, slots, instance)=>{
    const ctx = rawSlots._ctx;
    for(const key in rawSlots){
        if (isInternalKey(key)) continue;
        const value1 = rawSlots[key];
        if ((0, _shared.isFunction)(value1)) slots[key] = normalizeSlot(key, value1, ctx);
        else if (value1 != null) {
            warn(`Non-function value encountered for slot "${key}". Prefer function slots for better performance.`);
            const normalized = normalizeSlotValue(value1);
            slots[key] = ()=>normalized;
        }
    }
};
const normalizeVNodeSlots = (instance, children)=>{
    if (!isKeepAlive(instance.vnode) && true) warn(`Non-function value encountered for default slot. Prefer function slots for better performance.`);
    const normalized = normalizeSlotValue(children);
    instance.slots.default = ()=>normalized;
};
const initSlots = (instance, children)=>{
    if (instance.vnode.shapeFlag & 32) {
        const type = children._;
        if (type) {
            instance.slots = (0, _reactivity.toRaw)(children);
            (0, _shared.def)(children, "_", type);
        } else normalizeObjectSlots(children, instance.slots = {});
    } else {
        instance.slots = {};
        if (children) normalizeVNodeSlots(instance, children);
    }
    (0, _shared.def)(instance.slots, InternalObjectKey, 1);
};
const updateSlots = (instance, children, optimized)=>{
    const { vnode, slots } = instance;
    let needDeletionCheck = true;
    let deletionComparisonTarget = (0, _shared.EMPTY_OBJ);
    if (vnode.shapeFlag & 32) {
        const type = children._;
        if (type) {
            if (isHmrUpdating) {
                (0, _shared.extend)(slots, children);
                (0, _reactivity.trigger)(instance, "set", "$slots");
            } else if (optimized && type === 1) needDeletionCheck = false;
            else {
                (0, _shared.extend)(slots, children);
                if (!optimized && type === 1) delete slots._;
            }
        } else {
            needDeletionCheck = !children.$stable;
            normalizeObjectSlots(children, slots);
        }
        deletionComparisonTarget = children;
    } else if (children) {
        normalizeVNodeSlots(instance, children);
        deletionComparisonTarget = {
            default: 1
        };
    }
    if (needDeletionCheck) {
        for(const key in slots)if (!isInternalKey(key) && !(key in deletionComparisonTarget)) delete slots[key];
    }
};
function setRef(rawRef, oldRawRef, parentSuspense, vnode, isUnmount = false) {
    if ((0, _shared.isArray)(rawRef)) {
        rawRef.forEach((r, i)=>setRef(r, oldRawRef && ((0, _shared.isArray)(oldRawRef) ? oldRawRef[i] : oldRawRef), parentSuspense, vnode, isUnmount));
        return;
    }
    if (isAsyncWrapper(vnode) && !isUnmount) return;
    const refValue = vnode.shapeFlag & 4 ? getExposeProxy(vnode.component) || vnode.component.proxy : vnode.el;
    const value1 = isUnmount ? null : refValue;
    const { i: owner, r: ref } = rawRef;
    if (!owner) {
        warn(`Missing ref owner context. ref cannot be used on hoisted vnodes. A vnode with ref must be created inside the render function.`);
        return;
    }
    const oldRef = oldRawRef && oldRawRef.r;
    const refs = owner.refs === (0, _shared.EMPTY_OBJ) ? owner.refs = {} : owner.refs;
    const setupState = owner.setupState;
    if (oldRef != null && oldRef !== ref) {
        if ((0, _shared.isString)(oldRef)) {
            refs[oldRef] = null;
            if ((0, _shared.hasOwn)(setupState, oldRef)) setupState[oldRef] = null;
        } else if ((0, _reactivity.isRef)(oldRef)) oldRef.value = null;
    }
    if ((0, _shared.isFunction)(ref)) callWithErrorHandling(ref, owner, 12, [
        value1,
        refs
    ]);
    else {
        const _isString = (0, _shared.isString)(ref);
        const _isRef = (0, _reactivity.isRef)(ref);
        if (_isString || _isRef) {
            const doSet = ()=>{
                if (rawRef.f) {
                    const existing = _isString ? (0, _shared.hasOwn)(setupState, ref) ? setupState[ref] : refs[ref] : ref.value;
                    if (isUnmount) (0, _shared.isArray)(existing) && (0, _shared.remove)(existing, refValue);
                    else {
                        if (!(0, _shared.isArray)(existing)) {
                            if (_isString) {
                                refs[ref] = [
                                    refValue
                                ];
                                if ((0, _shared.hasOwn)(setupState, ref)) setupState[ref] = refs[ref];
                            } else {
                                ref.value = [
                                    refValue
                                ];
                                if (rawRef.k) refs[rawRef.k] = ref.value;
                            }
                        } else if (!existing.includes(refValue)) existing.push(refValue);
                    }
                } else if (_isString) {
                    refs[ref] = value1;
                    if ((0, _shared.hasOwn)(setupState, ref)) setupState[ref] = value1;
                } else if (_isRef) {
                    ref.value = value1;
                    if (rawRef.k) refs[rawRef.k] = value1;
                } else warn("Invalid template ref type:", ref, `(${typeof ref})`);
            };
            if (value1) {
                doSet.id = -1;
                queuePostRenderEffect(doSet, parentSuspense);
            } else doSet();
        } else warn("Invalid template ref type:", ref, `(${typeof ref})`);
    }
}
let hasMismatch = false;
const isSVGContainer = (container)=>/svg/.test(container.namespaceURI) && container.tagName !== "foreignObject";
const isComment = (node)=>node.nodeType === 8 /* COMMENT */ ;
function createHydrationFunctions(rendererInternals) {
    const { mt: mountComponent, p: patch, o: { patchProp, createText, nextSibling, parentNode, remove, insert, createComment } } = rendererInternals;
    const hydrate = (vnode, container)=>{
        if (!container.hasChildNodes()) {
            warn(`Attempting to hydrate existing markup but container is empty. Performing full mount instead.`);
            patch(null, vnode, container);
            flushPostFlushCbs();
            container._vnode = vnode;
            return;
        }
        hasMismatch = false;
        hydrateNode(container.firstChild, vnode, null, null, null);
        flushPostFlushCbs();
        container._vnode = vnode;
        if (hasMismatch && true) console.error(`Hydration completed but contains mismatches.`);
    };
    const hydrateNode = (node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized = false)=>{
        const isFragmentStart = isComment(node) && node.data === "[";
        const onMismatch = ()=>handleMismatch(node, vnode, parentComponent, parentSuspense, slotScopeIds, isFragmentStart);
        const { type, ref, shapeFlag, patchFlag } = vnode;
        let domType = node.nodeType;
        vnode.el = node;
        if (patchFlag === -2) {
            optimized = false;
            vnode.dynamicChildren = null;
        }
        let nextNode = null;
        switch(type){
            case Text:
                if (domType !== 3 /* TEXT */ ) {
                    if (vnode.children === "") {
                        insert(vnode.el = createText(""), parentNode(node), node);
                        nextNode = node;
                    } else nextNode = onMismatch();
                } else {
                    if (node.data !== vnode.children) {
                        hasMismatch = true;
                        warn(`Hydration text mismatch:
- Client: ${JSON.stringify(node.data)}
- Server: ${JSON.stringify(vnode.children)}`);
                        node.data = vnode.children;
                    }
                    nextNode = nextSibling(node);
                }
                break;
            case Comment:
                if (domType !== 8 /* COMMENT */  || isFragmentStart) nextNode = onMismatch();
                else nextNode = nextSibling(node);
                break;
            case Static:
                if (isFragmentStart) {
                    node = nextSibling(node);
                    domType = node.nodeType;
                }
                if (domType === 1 /* ELEMENT */  || domType === 3 /* TEXT */ ) {
                    nextNode = node;
                    const needToAdoptContent = !vnode.children.length;
                    for(let i = 0; i < vnode.staticCount; i++){
                        if (needToAdoptContent) vnode.children += nextNode.nodeType === 1 /* ELEMENT */  ? nextNode.outerHTML : nextNode.data;
                        if (i === vnode.staticCount - 1) vnode.anchor = nextNode;
                        nextNode = nextSibling(nextNode);
                    }
                    return isFragmentStart ? nextSibling(nextNode) : nextNode;
                } else onMismatch();
                break;
            case Fragment:
                if (!isFragmentStart) nextNode = onMismatch();
                else nextNode = hydrateFragment(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized);
                break;
            default:
                if (shapeFlag & 1) {
                    if (domType !== 1 /* ELEMENT */  || vnode.type.toLowerCase() !== node.tagName.toLowerCase()) nextNode = onMismatch();
                    else nextNode = hydrateElement(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized);
                } else if (shapeFlag & 6) {
                    vnode.slotScopeIds = slotScopeIds;
                    const container = parentNode(node);
                    mountComponent(vnode, container, null, parentComponent, parentSuspense, isSVGContainer(container), optimized);
                    nextNode = isFragmentStart ? locateClosingAsyncAnchor(node) : nextSibling(node);
                    if (nextNode && isComment(nextNode) && nextNode.data === "teleport end") nextNode = nextSibling(nextNode);
                    if (isAsyncWrapper(vnode)) {
                        let subTree;
                        if (isFragmentStart) {
                            subTree = createVNode(Fragment);
                            subTree.anchor = nextNode ? nextNode.previousSibling : container.lastChild;
                        } else subTree = node.nodeType === 3 ? createTextVNode("") : createVNode("div");
                        subTree.el = node;
                        vnode.component.subTree = subTree;
                    }
                } else if (shapeFlag & 64) {
                    if (domType !== 8 /* COMMENT */ ) nextNode = onMismatch();
                    else nextNode = vnode.type.hydrate(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, rendererInternals, hydrateChildren);
                } else if (shapeFlag & 128) nextNode = vnode.type.hydrate(node, vnode, parentComponent, parentSuspense, isSVGContainer(parentNode(node)), slotScopeIds, optimized, rendererInternals, hydrateNode);
                else warn("Invalid HostVNode type:", type, `(${typeof type})`);
        }
        if (ref != null) setRef(ref, null, parentSuspense, vnode);
        return nextNode;
    };
    const hydrateElement = (el, vnode, parentComponent, parentSuspense, slotScopeIds, optimized)=>{
        optimized = optimized || !!vnode.dynamicChildren;
        const { type, props, patchFlag, shapeFlag, dirs } = vnode;
        const forcePatchValue = type === "input" && dirs || type === "option";
        {
            if (dirs) invokeDirectiveHook(vnode, null, parentComponent, "created");
            if (props) {
                if (forcePatchValue || !optimized || patchFlag & 48) {
                    for(const key in props)if (forcePatchValue && key.endsWith("value") || (0, _shared.isOn)(key) && !(0, _shared.isReservedProp)(key)) patchProp(el, key, null, props[key], false, void 0, parentComponent);
                } else if (props.onClick) patchProp(el, "onClick", null, props.onClick, false, void 0, parentComponent);
            }
            let vnodeHooks;
            if (vnodeHooks = props && props.onVnodeBeforeMount) invokeVNodeHook(vnodeHooks, parentComponent, vnode);
            if (dirs) invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
            if ((vnodeHooks = props && props.onVnodeMounted) || dirs) queueEffectWithSuspense(()=>{
                vnodeHooks && invokeVNodeHook(vnodeHooks, parentComponent, vnode);
                dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
            }, parentSuspense);
            if (shapeFlag & 16 && // skip if element has innerHTML / textContent
            !(props && (props.innerHTML || props.textContent))) {
                let next = hydrateChildren(el.firstChild, vnode, el, parentComponent, parentSuspense, slotScopeIds, optimized);
                let hasWarned = false;
                while(next){
                    hasMismatch = true;
                    if (!hasWarned) {
                        warn(`Hydration children mismatch in <${vnode.type}>: server rendered element contains more child nodes than client vdom.`);
                        hasWarned = true;
                    }
                    const cur = next;
                    next = next.nextSibling;
                    remove(cur);
                }
            } else if (shapeFlag & 8) {
                if (el.textContent !== vnode.children) {
                    hasMismatch = true;
                    warn(`Hydration text content mismatch in <${vnode.type}>:
- Client: ${el.textContent}
- Server: ${vnode.children}`);
                    el.textContent = vnode.children;
                }
            }
        }
        return el.nextSibling;
    };
    const hydrateChildren = (node, parentVNode, container, parentComponent, parentSuspense, slotScopeIds, optimized)=>{
        optimized = optimized || !!parentVNode.dynamicChildren;
        const children = parentVNode.children;
        const l = children.length;
        let hasWarned = false;
        for(let i = 0; i < l; i++){
            const vnode = optimized ? children[i] : children[i] = normalizeVNode(children[i]);
            if (node) node = hydrateNode(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized);
            else if (vnode.type === Text && !vnode.children) continue;
            else {
                hasMismatch = true;
                if (!hasWarned) {
                    warn(`Hydration children mismatch in <${container.tagName.toLowerCase()}>: server rendered element contains fewer child nodes than client vdom.`);
                    hasWarned = true;
                }
                patch(null, vnode, container, null, parentComponent, parentSuspense, isSVGContainer(container), slotScopeIds);
            }
        }
        return node;
    };
    const hydrateFragment = (node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized)=>{
        const { slotScopeIds: fragmentSlotScopeIds } = vnode;
        if (fragmentSlotScopeIds) slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
        const container = parentNode(node);
        const next = hydrateChildren(nextSibling(node), vnode, container, parentComponent, parentSuspense, slotScopeIds, optimized);
        if (next && isComment(next) && next.data === "]") return nextSibling(vnode.anchor = next);
        else {
            hasMismatch = true;
            insert(vnode.anchor = createComment(`]`), container, next);
            return next;
        }
    };
    const handleMismatch = (node, vnode, parentComponent, parentSuspense, slotScopeIds, isFragment)=>{
        hasMismatch = true;
        warn(`Hydration node mismatch:
- Client vnode:`, vnode.type, `
- Server rendered DOM:`, node, node.nodeType === 3 /* TEXT */  ? `(text)` : isComment(node) && node.data === "[" ? `(start of fragment)` : ``);
        vnode.el = null;
        if (isFragment) {
            const end = locateClosingAsyncAnchor(node);
            while(true){
                const next2 = nextSibling(node);
                if (next2 && next2 !== end) remove(next2);
                else break;
            }
        }
        const next = nextSibling(node);
        const container = parentNode(node);
        remove(node);
        patch(null, vnode, container, next, parentComponent, parentSuspense, isSVGContainer(container), slotScopeIds);
        return next;
    };
    const locateClosingAsyncAnchor = (node)=>{
        let match = 0;
        while(node){
            node = nextSibling(node);
            if (node && isComment(node)) {
                if (node.data === "[") match++;
                if (node.data === "]") {
                    if (match === 0) return nextSibling(node);
                    else match--;
                }
            }
        }
        return node;
    };
    return [
        hydrate,
        hydrateNode
    ];
}
let supported;
let perf;
function startMeasure(instance, type) {
    if (instance.appContext.config.performance && isSupported()) perf.mark(`vue-${type}-${instance.uid}`);
    devtoolsPerfStart(instance, type, isSupported() ? perf.now() : Date.now());
}
function endMeasure(instance, type) {
    if (instance.appContext.config.performance && isSupported()) {
        const startTag = `vue-${type}-${instance.uid}`;
        const endTag = startTag + `:end`;
        perf.mark(endTag);
        perf.measure(`<${formatComponentName(instance, instance.type)}> ${type}`, startTag, endTag);
        perf.clearMarks(startTag);
        perf.clearMarks(endTag);
    }
    devtoolsPerfEnd(instance, type, isSupported() ? perf.now() : Date.now());
}
function isSupported() {
    if (supported !== void 0) return supported;
    if (typeof window !== "undefined" && window.performance) {
        supported = true;
        perf = window.performance;
    } else supported = false;
    return supported;
}
function initFeatureFlags() {
    const needWarn = [];
    if (typeof __VUE_OPTIONS_API__ !== "boolean") {
        needWarn.push(`__VUE_OPTIONS_API__`);
        (0, _shared.getGlobalThis)().__VUE_OPTIONS_API__ = true;
    }
    if (typeof __VUE_PROD_DEVTOOLS__ !== "boolean") {
        needWarn.push(`__VUE_PROD_DEVTOOLS__`);
        (0, _shared.getGlobalThis)().__VUE_PROD_DEVTOOLS__ = false;
    }
    if (0, needWarn.length) {
        const multi = needWarn.length > 1;
        console.warn(`Feature flag${multi ? `s` : ``} ${needWarn.join(", ")} ${multi ? `are` : `is`} not explicitly defined. You are running the esm-bundler build of Vue, which expects these compile-time feature flags to be globally injected via the bundler config in order to get better tree-shaking in the production bundle.

For more details, see https://link.vuejs.org/feature-flags.`);
    }
}
const queuePostRenderEffect = queueEffectWithSuspense;
function createRenderer(options) {
    return baseCreateRenderer(options);
}
function createHydrationRenderer(options) {
    return baseCreateRenderer(options, createHydrationFunctions);
}
function baseCreateRenderer(options, createHydrationFns) {
    initFeatureFlags();
    const target = (0, _shared.getGlobalThis)();
    target.__VUE__ = true;
    setDevtoolsHook(target.__VUE_DEVTOOLS_GLOBAL_HOOK__, target);
    const { insert: hostInsert, remove: hostRemove, patchProp: hostPatchProp, createElement: hostCreateElement, createText: hostCreateText, createComment: hostCreateComment, setText: hostSetText, setElementText: hostSetElementText, parentNode: hostParentNode, nextSibling: hostNextSibling, setScopeId: hostSetScopeId = (0, _shared.NOOP), insertStaticContent: hostInsertStaticContent } = options;
    const patch = (n1, n2, container, anchor = null, parentComponent = null, parentSuspense = null, isSVG = false, slotScopeIds = null, optimized = isHmrUpdating ? false : !!n2.dynamicChildren)=>{
        if (n1 === n2) return;
        if (n1 && !isSameVNodeType(n1, n2)) {
            anchor = getNextHostNode(n1);
            unmount(n1, parentComponent, parentSuspense, true);
            n1 = null;
        }
        if (n2.patchFlag === -2) {
            optimized = false;
            n2.dynamicChildren = null;
        }
        const { type, ref, shapeFlag } = n2;
        switch(type){
            case Text:
                processText(n1, n2, container, anchor);
                break;
            case Comment:
                processCommentNode(n1, n2, container, anchor);
                break;
            case Static:
                if (n1 == null) mountStaticNode(n2, container, anchor, isSVG);
                else patchStaticNode(n1, n2, container, isSVG);
                break;
            case Fragment:
                processFragment(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
                break;
            default:
                if (shapeFlag & 1) processElement(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
                else if (shapeFlag & 6) processComponent(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
                else if (shapeFlag & 64) type.process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals);
                else if (shapeFlag & 128) type.process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals);
                else warn("Invalid VNode type:", type, `(${typeof type})`);
        }
        if (ref != null && parentComponent) setRef(ref, n1 && n1.ref, parentSuspense, n2 || n1, !n2);
    };
    const processText = (n1, n2, container, anchor)=>{
        if (n1 == null) hostInsert(n2.el = hostCreateText(n2.children), container, anchor);
        else {
            const el = n2.el = n1.el;
            if (n2.children !== n1.children) hostSetText(el, n2.children);
        }
    };
    const processCommentNode = (n1, n2, container, anchor)=>{
        if (n1 == null) hostInsert(n2.el = hostCreateComment(n2.children || ""), container, anchor);
        else n2.el = n1.el;
    };
    const mountStaticNode = (n2, container, anchor, isSVG)=>{
        [n2.el, n2.anchor] = hostInsertStaticContent(n2.children, container, anchor, isSVG, n2.el, n2.anchor);
    };
    const patchStaticNode = (n1, n2, container, isSVG)=>{
        if (n2.children !== n1.children) {
            const anchor = hostNextSibling(n1.anchor);
            removeStaticNode(n1);
            [n2.el, n2.anchor] = hostInsertStaticContent(n2.children, container, anchor, isSVG);
        } else {
            n2.el = n1.el;
            n2.anchor = n1.anchor;
        }
    };
    const moveStaticNode = ({ el, anchor }, container, nextSibling)=>{
        let next;
        while(el && el !== anchor){
            next = hostNextSibling(el);
            hostInsert(el, container, nextSibling);
            el = next;
        }
        hostInsert(anchor, container, nextSibling);
    };
    const removeStaticNode = ({ el, anchor })=>{
        let next;
        while(el && el !== anchor){
            next = hostNextSibling(el);
            hostRemove(el);
            el = next;
        }
        hostRemove(anchor);
    };
    const processElement = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized)=>{
        isSVG = isSVG || n2.type === "svg";
        if (n1 == null) mountElement(n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        else patchElement(n1, n2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
    };
    const mountElement = (vnode, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized)=>{
        let el;
        let vnodeHook;
        const { type, props, shapeFlag, transition, dirs } = vnode;
        el = vnode.el = hostCreateElement(vnode.type, isSVG, props && props.is, props);
        if (shapeFlag & 8) hostSetElementText(el, vnode.children);
        else if (shapeFlag & 16) mountChildren(vnode.children, el, null, parentComponent, parentSuspense, isSVG && type !== "foreignObject", slotScopeIds, optimized);
        if (dirs) invokeDirectiveHook(vnode, null, parentComponent, "created");
        setScopeId(el, vnode, vnode.scopeId, slotScopeIds, parentComponent);
        if (props) {
            for(const key in props)if (key !== "value" && !(0, _shared.isReservedProp)(key)) hostPatchProp(el, key, null, props[key], isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);
            if ("value" in props) hostPatchProp(el, "value", null, props.value);
            if (vnodeHook = props.onVnodeBeforeMount) invokeVNodeHook(vnodeHook, parentComponent, vnode);
        }
        Object.defineProperty(el, "__vnode", {
            value: vnode,
            enumerable: false
        });
        Object.defineProperty(el, "__vueParentComponent", {
            value: parentComponent,
            enumerable: false
        });
        if (dirs) invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
        const needCallTransitionHooks = (!parentSuspense || parentSuspense && !parentSuspense.pendingBranch) && transition && !transition.persisted;
        if (needCallTransitionHooks) transition.beforeEnter(el);
        hostInsert(el, container, anchor);
        if ((vnodeHook = props && props.onVnodeMounted) || needCallTransitionHooks || dirs) queuePostRenderEffect(()=>{
            vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
            needCallTransitionHooks && transition.enter(el);
            dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
        }, parentSuspense);
    };
    const setScopeId = (el, vnode, scopeId, slotScopeIds, parentComponent)=>{
        if (scopeId) hostSetScopeId(el, scopeId);
        if (slotScopeIds) for(let i = 0; i < slotScopeIds.length; i++)hostSetScopeId(el, slotScopeIds[i]);
        if (parentComponent) {
            let subTree = parentComponent.subTree;
            if (subTree.patchFlag > 0 && subTree.patchFlag & 2048) subTree = filterSingleRoot(subTree.children) || subTree;
            if (vnode === subTree) {
                const parentVNode = parentComponent.vnode;
                setScopeId(el, parentVNode, parentVNode.scopeId, parentVNode.slotScopeIds, parentComponent.parent);
            }
        }
    };
    const mountChildren = (children, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, start = 0)=>{
        for(let i = start; i < children.length; i++){
            const child = children[i] = optimized ? cloneIfMounted(children[i]) : normalizeVNode(children[i]);
            patch(null, child, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        }
    };
    const patchElement = (n1, n2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized)=>{
        const el = n2.el = n1.el;
        let { patchFlag, dynamicChildren, dirs } = n2;
        patchFlag |= n1.patchFlag & 16;
        const oldProps = n1.props || (0, _shared.EMPTY_OBJ);
        const newProps = n2.props || (0, _shared.EMPTY_OBJ);
        let vnodeHook;
        parentComponent && toggleRecurse(parentComponent, false);
        if (vnodeHook = newProps.onVnodeBeforeUpdate) invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
        if (dirs) invokeDirectiveHook(n2, n1, parentComponent, "beforeUpdate");
        parentComponent && toggleRecurse(parentComponent, true);
        if (isHmrUpdating) {
            patchFlag = 0;
            optimized = false;
            dynamicChildren = null;
        }
        const areChildrenSVG = isSVG && n2.type !== "foreignObject";
        if (dynamicChildren) {
            patchBlockChildren(n1.dynamicChildren, dynamicChildren, el, parentComponent, parentSuspense, areChildrenSVG, slotScopeIds);
            traverseStaticChildren(n1, n2);
        } else if (!optimized) patchChildren(n1, n2, el, null, parentComponent, parentSuspense, areChildrenSVG, slotScopeIds, false);
        if (patchFlag > 0) {
            if (patchFlag & 16) patchProps(el, n2, oldProps, newProps, parentComponent, parentSuspense, isSVG);
            else {
                if (patchFlag & 2) {
                    if (oldProps.class !== newProps.class) hostPatchProp(el, "class", null, newProps.class, isSVG);
                }
                if (patchFlag & 4) hostPatchProp(el, "style", oldProps.style, newProps.style, isSVG);
                if (patchFlag & 8) {
                    const propsToUpdate = n2.dynamicProps;
                    for(let i = 0; i < propsToUpdate.length; i++){
                        const key = propsToUpdate[i];
                        const prev = oldProps[key];
                        const next = newProps[key];
                        if (next !== prev || key === "value") hostPatchProp(el, key, prev, next, isSVG, n1.children, parentComponent, parentSuspense, unmountChildren);
                    }
                }
            }
            if (patchFlag & 1) {
                if (n1.children !== n2.children) hostSetElementText(el, n2.children);
            }
        } else if (!optimized && dynamicChildren == null) patchProps(el, n2, oldProps, newProps, parentComponent, parentSuspense, isSVG);
        if ((vnodeHook = newProps.onVnodeUpdated) || dirs) queuePostRenderEffect(()=>{
            vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
            dirs && invokeDirectiveHook(n2, n1, parentComponent, "updated");
        }, parentSuspense);
    };
    const patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, isSVG, slotScopeIds)=>{
        for(let i = 0; i < newChildren.length; i++){
            const oldVNode = oldChildren[i];
            const newVNode = newChildren[i];
            const container = // oldVNode may be an errored async setup() component inside Suspense
            // which will not have a mounted element
            oldVNode.el && // - In the case of a Fragment, we need to provide the actual parent
            // of the Fragment itself so it can move its children.
            (oldVNode.type === Fragment || // - In the case of different nodes, there is going to be a replacement
            // which also requires the correct parent container
            !isSameVNodeType(oldVNode, newVNode) || // - In the case of a component, it could contain anything.
            oldVNode.shapeFlag & 70) ? hostParentNode(oldVNode.el) : // In other cases, the parent container is not actually used so we
            // just pass the block element here to avoid a DOM parentNode call.
            fallbackContainer;
            patch(oldVNode, newVNode, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, true);
        }
    };
    const patchProps = (el, vnode, oldProps, newProps, parentComponent, parentSuspense, isSVG)=>{
        if (oldProps !== newProps) {
            if (oldProps !== (0, _shared.EMPTY_OBJ)) {
                for(const key in oldProps)if (!(0, _shared.isReservedProp)(key) && !(key in newProps)) hostPatchProp(el, key, oldProps[key], null, isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);
            }
            for(const key in newProps){
                if ((0, _shared.isReservedProp)(key)) continue;
                const next = newProps[key];
                const prev = oldProps[key];
                if (next !== prev && key !== "value") hostPatchProp(el, key, prev, next, isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);
            }
            if ("value" in newProps) hostPatchProp(el, "value", oldProps.value, newProps.value);
        }
    };
    const processFragment = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized)=>{
        const fragmentStartAnchor = n2.el = n1 ? n1.el : hostCreateText("");
        const fragmentEndAnchor = n2.anchor = n1 ? n1.anchor : hostCreateText("");
        let { patchFlag, dynamicChildren, slotScopeIds: fragmentSlotScopeIds } = n2;
        if (// #5523 dev root fragment may inherit directives
        isHmrUpdating || patchFlag & 2048) {
            patchFlag = 0;
            optimized = false;
            dynamicChildren = null;
        }
        if (fragmentSlotScopeIds) slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
        if (n1 == null) {
            hostInsert(fragmentStartAnchor, container, anchor);
            hostInsert(fragmentEndAnchor, container, anchor);
            mountChildren(n2.children, container, fragmentEndAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        } else if (patchFlag > 0 && patchFlag & 64 && dynamicChildren && // #2715 the previous fragment could've been a BAILed one as a result
        // of renderSlot() with no valid children
        n1.dynamicChildren) {
            patchBlockChildren(n1.dynamicChildren, dynamicChildren, container, parentComponent, parentSuspense, isSVG, slotScopeIds);
            traverseStaticChildren(n1, n2);
        } else patchChildren(n1, n2, container, fragmentEndAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
    };
    const processComponent = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized)=>{
        n2.slotScopeIds = slotScopeIds;
        if (n1 == null) {
            if (n2.shapeFlag & 512) parentComponent.ctx.activate(n2, container, anchor, isSVG, optimized);
            else mountComponent(n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized);
        } else updateComponent(n1, n2, optimized);
    };
    const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, isSVG, optimized)=>{
        const instance = initialVNode.component = createComponentInstance(initialVNode, parentComponent, parentSuspense);
        if (0, instance.type.__hmrId) registerHMR(instance);
        pushWarningContext(initialVNode);
        startMeasure(instance, `mount`);
        if (isKeepAlive(initialVNode)) instance.ctx.renderer = internals;
        startMeasure(instance, `init`);
        setupComponent(instance);
        endMeasure(instance, `init`);
        if (instance.asyncDep) {
            parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect);
            if (!initialVNode.el) {
                const placeholder = instance.subTree = createVNode(Comment);
                processCommentNode(null, placeholder, container, anchor);
            }
            return;
        }
        setupRenderEffect(instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized);
        popWarningContext();
        endMeasure(instance, `mount`);
    };
    const updateComponent = (n1, n2, optimized)=>{
        const instance = n2.component = n1.component;
        if (shouldUpdateComponent(n1, n2, optimized)) {
            if (instance.asyncDep && !instance.asyncResolved) {
                pushWarningContext(n2);
                updateComponentPreRender(instance, n2, optimized);
                popWarningContext();
                return;
            } else {
                instance.next = n2;
                invalidateJob(instance.update);
                instance.update();
            }
        } else {
            n2.el = n1.el;
            instance.vnode = n2;
        }
    };
    const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized)=>{
        const componentUpdateFn = ()=>{
            if (!instance.isMounted) {
                let vnodeHook;
                const { el, props } = initialVNode;
                const { bm, m, parent } = instance;
                const isAsyncWrapperVNode = isAsyncWrapper(initialVNode);
                toggleRecurse(instance, false);
                if (bm) (0, _shared.invokeArrayFns)(bm);
                if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeBeforeMount)) invokeVNodeHook(vnodeHook, parent, initialVNode);
                toggleRecurse(instance, true);
                if (el && hydrateNode) {
                    const hydrateSubTree = ()=>{
                        startMeasure(instance, `render`);
                        instance.subTree = renderComponentRoot(instance);
                        endMeasure(instance, `render`);
                        startMeasure(instance, `hydrate`);
                        hydrateNode(el, instance.subTree, instance, parentSuspense, null);
                        endMeasure(instance, `hydrate`);
                    };
                    if (isAsyncWrapperVNode) initialVNode.type.__asyncLoader().then(// note: we are moving the render call into an async callback,
                    // which means it won't track dependencies - but it's ok because
                    // a server-rendered async wrapper is already in resolved state
                    // and it will never need to change.
                    ()=>!instance.isUnmounted && hydrateSubTree());
                    else hydrateSubTree();
                } else {
                    startMeasure(instance, `render`);
                    const subTree = instance.subTree = renderComponentRoot(instance);
                    endMeasure(instance, `render`);
                    startMeasure(instance, `patch`);
                    patch(null, subTree, container, anchor, instance, parentSuspense, isSVG);
                    endMeasure(instance, `patch`);
                    initialVNode.el = subTree.el;
                }
                if (m) queuePostRenderEffect(m, parentSuspense);
                if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeMounted)) {
                    const scopedInitialVNode = initialVNode;
                    queuePostRenderEffect(()=>invokeVNodeHook(vnodeHook, parent, scopedInitialVNode), parentSuspense);
                }
                if (initialVNode.shapeFlag & 256 || parent && isAsyncWrapper(parent.vnode) && parent.vnode.shapeFlag & 256) instance.a && queuePostRenderEffect(instance.a, parentSuspense);
                instance.isMounted = true;
                devtoolsComponentAdded(instance);
                initialVNode = container = anchor = null;
            } else {
                let { next, bu, u, parent, vnode } = instance;
                let originNext = next;
                let vnodeHook;
                pushWarningContext(next || instance.vnode);
                toggleRecurse(instance, false);
                if (next) {
                    next.el = vnode.el;
                    updateComponentPreRender(instance, next, optimized);
                } else next = vnode;
                if (bu) (0, _shared.invokeArrayFns)(bu);
                if (vnodeHook = next.props && next.props.onVnodeBeforeUpdate) invokeVNodeHook(vnodeHook, parent, next, vnode);
                toggleRecurse(instance, true);
                startMeasure(instance, `render`);
                const nextTree = renderComponentRoot(instance);
                endMeasure(instance, `render`);
                const prevTree = instance.subTree;
                instance.subTree = nextTree;
                startMeasure(instance, `patch`);
                patch(prevTree, nextTree, // parent may have changed if it's in a teleport
                hostParentNode(prevTree.el), // anchor may have changed if it's in a fragment
                getNextHostNode(prevTree), instance, parentSuspense, isSVG);
                endMeasure(instance, `patch`);
                next.el = nextTree.el;
                if (originNext === null) updateHOCHostEl(instance, nextTree.el);
                if (u) queuePostRenderEffect(u, parentSuspense);
                if (vnodeHook = next.props && next.props.onVnodeUpdated) queuePostRenderEffect(()=>invokeVNodeHook(vnodeHook, parent, next, vnode), parentSuspense);
                devtoolsComponentUpdated(instance);
                popWarningContext();
            }
        };
        const effect = instance.effect = new (0, _reactivity.ReactiveEffect)(componentUpdateFn, ()=>queueJob(update), instance.scope);
        const update = instance.update = ()=>effect.run();
        update.id = instance.uid;
        toggleRecurse(instance, true);
        effect.onTrack = instance.rtc ? (e)=>(0, _shared.invokeArrayFns)(instance.rtc, e) : void 0;
        effect.onTrigger = instance.rtg ? (e)=>(0, _shared.invokeArrayFns)(instance.rtg, e) : void 0;
        update.ownerInstance = instance;
        update();
    };
    const updateComponentPreRender = (instance, nextVNode, optimized)=>{
        nextVNode.component = instance;
        const prevProps = instance.vnode.props;
        instance.vnode = nextVNode;
        instance.next = null;
        updateProps(instance, nextVNode.props, prevProps, optimized);
        updateSlots(instance, nextVNode.children, optimized);
        (0, _reactivity.pauseTracking)();
        flushPreFlushCbs();
        (0, _reactivity.resetTracking)();
    };
    const patchChildren = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized = false)=>{
        const c1 = n1 && n1.children;
        const prevShapeFlag = n1 ? n1.shapeFlag : 0;
        const c2 = n2.children;
        const { patchFlag, shapeFlag } = n2;
        if (patchFlag > 0) {
            if (patchFlag & 128) {
                patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
                return;
            } else if (patchFlag & 256) {
                patchUnkeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
                return;
            }
        }
        if (shapeFlag & 8) {
            if (prevShapeFlag & 16) unmountChildren(c1, parentComponent, parentSuspense);
            if (c2 !== c1) hostSetElementText(container, c2);
        } else if (prevShapeFlag & 16) {
            if (shapeFlag & 16) patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
            else unmountChildren(c1, parentComponent, parentSuspense, true);
        } else {
            if (prevShapeFlag & 8) hostSetElementText(container, "");
            if (shapeFlag & 16) mountChildren(c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        }
    };
    const patchUnkeyedChildren = (c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized)=>{
        c1 = c1 || (0, _shared.EMPTY_ARR);
        c2 = c2 || (0, _shared.EMPTY_ARR);
        const oldLength = c1.length;
        const newLength = c2.length;
        const commonLength = Math.min(oldLength, newLength);
        let i;
        for(i = 0; i < commonLength; i++){
            const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
            patch(c1[i], nextChild, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        }
        if (oldLength > newLength) unmountChildren(c1, parentComponent, parentSuspense, true, false, commonLength);
        else mountChildren(c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, commonLength);
    };
    const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized)=>{
        let i = 0;
        const l2 = c2.length;
        let e1 = c1.length - 1;
        let e2 = l2 - 1;
        while(i <= e1 && i <= e2){
            const n1 = c1[i];
            const n2 = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
            if (isSameVNodeType(n1, n2)) patch(n1, n2, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
            else break;
            i++;
        }
        while(i <= e1 && i <= e2){
            const n1 = c1[e1];
            const n2 = c2[e2] = optimized ? cloneIfMounted(c2[e2]) : normalizeVNode(c2[e2]);
            if (isSameVNodeType(n1, n2)) patch(n1, n2, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
            else break;
            e1--;
            e2--;
        }
        if (i > e1) {
            if (i <= e2) {
                const nextPos = e2 + 1;
                const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;
                while(i <= e2){
                    patch(null, c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]), container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
                    i++;
                }
            }
        } else if (i > e2) while(i <= e1){
            unmount(c1[i], parentComponent, parentSuspense, true);
            i++;
        }
        else {
            const s1 = i;
            const s2 = i;
            const keyToNewIndexMap = /* @__PURE__ */ new Map();
            for(i = s2; i <= e2; i++){
                const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
                if (nextChild.key != null) {
                    if (keyToNewIndexMap.has(nextChild.key)) warn(`Duplicate keys found during update:`, JSON.stringify(nextChild.key), `Make sure keys are unique.`);
                    keyToNewIndexMap.set(nextChild.key, i);
                }
            }
            let j;
            let patched = 0;
            const toBePatched = e2 - s2 + 1;
            let moved = false;
            let maxNewIndexSoFar = 0;
            const newIndexToOldIndexMap = new Array(toBePatched);
            for(i = 0; i < toBePatched; i++)newIndexToOldIndexMap[i] = 0;
            for(i = s1; i <= e1; i++){
                const prevChild = c1[i];
                if (patched >= toBePatched) {
                    unmount(prevChild, parentComponent, parentSuspense, true);
                    continue;
                }
                let newIndex;
                if (prevChild.key != null) newIndex = keyToNewIndexMap.get(prevChild.key);
                else {
                    for(j = s2; j <= e2; j++)if (newIndexToOldIndexMap[j - s2] === 0 && isSameVNodeType(prevChild, c2[j])) {
                        newIndex = j;
                        break;
                    }
                }
                if (newIndex === void 0) unmount(prevChild, parentComponent, parentSuspense, true);
                else {
                    newIndexToOldIndexMap[newIndex - s2] = i + 1;
                    if (newIndex >= maxNewIndexSoFar) maxNewIndexSoFar = newIndex;
                    else moved = true;
                    patch(prevChild, c2[newIndex], container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
                    patched++;
                }
            }
            const increasingNewIndexSequence = moved ? getSequence(newIndexToOldIndexMap) : (0, _shared.EMPTY_ARR);
            j = increasingNewIndexSequence.length - 1;
            for(i = toBePatched - 1; i >= 0; i--){
                const nextIndex = s2 + i;
                const nextChild = c2[nextIndex];
                const anchor = nextIndex + 1 < l2 ? c2[nextIndex + 1].el : parentAnchor;
                if (newIndexToOldIndexMap[i] === 0) patch(null, nextChild, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
                else if (moved) {
                    if (j < 0 || i !== increasingNewIndexSequence[j]) move(nextChild, container, anchor, 2);
                    else j--;
                }
            }
        }
    };
    const move = (vnode, container, anchor, moveType, parentSuspense = null)=>{
        const { el, type, transition, children, shapeFlag } = vnode;
        if (shapeFlag & 6) {
            move(vnode.component.subTree, container, anchor, moveType);
            return;
        }
        if (shapeFlag & 128) {
            vnode.suspense.move(container, anchor, moveType);
            return;
        }
        if (shapeFlag & 64) {
            type.move(vnode, container, anchor, internals);
            return;
        }
        if (type === Fragment) {
            hostInsert(el, container, anchor);
            for(let i = 0; i < children.length; i++)move(children[i], container, anchor, moveType);
            hostInsert(vnode.anchor, container, anchor);
            return;
        }
        if (type === Static) {
            moveStaticNode(vnode, container, anchor);
            return;
        }
        const needTransition = moveType !== 2 && shapeFlag & 1 && transition;
        if (needTransition) {
            if (moveType === 0) {
                transition.beforeEnter(el);
                hostInsert(el, container, anchor);
                queuePostRenderEffect(()=>transition.enter(el), parentSuspense);
            } else {
                const { leave, delayLeave, afterLeave } = transition;
                const remove2 = ()=>hostInsert(el, container, anchor);
                const performLeave = ()=>{
                    leave(el, ()=>{
                        remove2();
                        afterLeave && afterLeave();
                    });
                };
                if (delayLeave) delayLeave(el, remove2, performLeave);
                else performLeave();
            }
        } else hostInsert(el, container, anchor);
    };
    const unmount = (vnode, parentComponent, parentSuspense, doRemove = false, optimized = false)=>{
        const { type, props, ref, children, dynamicChildren, shapeFlag, patchFlag, dirs } = vnode;
        if (ref != null) setRef(ref, null, parentSuspense, vnode, true);
        if (shapeFlag & 256) {
            parentComponent.ctx.deactivate(vnode);
            return;
        }
        const shouldInvokeDirs = shapeFlag & 1 && dirs;
        const shouldInvokeVnodeHook = !isAsyncWrapper(vnode);
        let vnodeHook;
        if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeBeforeUnmount)) invokeVNodeHook(vnodeHook, parentComponent, vnode);
        if (shapeFlag & 6) unmountComponent(vnode.component, parentSuspense, doRemove);
        else {
            if (shapeFlag & 128) {
                vnode.suspense.unmount(parentSuspense, doRemove);
                return;
            }
            if (shouldInvokeDirs) invokeDirectiveHook(vnode, null, parentComponent, "beforeUnmount");
            if (shapeFlag & 64) vnode.type.remove(vnode, parentComponent, parentSuspense, optimized, internals, doRemove);
            else if (dynamicChildren && // #1153: fast path should not be taken for non-stable (v-for) fragments
            (type !== Fragment || patchFlag > 0 && patchFlag & 64)) unmountChildren(dynamicChildren, parentComponent, parentSuspense, false, true);
            else if (type === Fragment && patchFlag & 384 || !optimized && shapeFlag & 16) unmountChildren(children, parentComponent, parentSuspense);
            if (doRemove) remove(vnode);
        }
        if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeUnmounted) || shouldInvokeDirs) queuePostRenderEffect(()=>{
            vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
            shouldInvokeDirs && invokeDirectiveHook(vnode, null, parentComponent, "unmounted");
        }, parentSuspense);
    };
    const remove = (vnode)=>{
        const { type, el, anchor, transition } = vnode;
        if (type === Fragment) {
            if (vnode.patchFlag > 0 && vnode.patchFlag & 2048 && transition && !transition.persisted) vnode.children.forEach((child)=>{
                if (child.type === Comment) hostRemove(child.el);
                else remove(child);
            });
            else removeFragment(el, anchor);
            return;
        }
        if (type === Static) {
            removeStaticNode(vnode);
            return;
        }
        const performRemove = ()=>{
            hostRemove(el);
            if (transition && !transition.persisted && transition.afterLeave) transition.afterLeave();
        };
        if (vnode.shapeFlag & 1 && transition && !transition.persisted) {
            const { leave, delayLeave } = transition;
            const performLeave = ()=>leave(el, performRemove);
            if (delayLeave) delayLeave(vnode.el, performRemove, performLeave);
            else performLeave();
        } else performRemove();
    };
    const removeFragment = (cur, end)=>{
        let next;
        while(cur !== end){
            next = hostNextSibling(cur);
            hostRemove(cur);
            cur = next;
        }
        hostRemove(end);
    };
    const unmountComponent = (instance, parentSuspense, doRemove)=>{
        if (0, instance.type.__hmrId) unregisterHMR(instance);
        const { bum, scope, update, subTree, um } = instance;
        if (bum) (0, _shared.invokeArrayFns)(bum);
        scope.stop();
        if (update) {
            update.active = false;
            unmount(subTree, instance, parentSuspense, doRemove);
        }
        if (um) queuePostRenderEffect(um, parentSuspense);
        queuePostRenderEffect(()=>{
            instance.isUnmounted = true;
        }, parentSuspense);
        if (parentSuspense && parentSuspense.pendingBranch && !parentSuspense.isUnmounted && instance.asyncDep && !instance.asyncResolved && instance.suspenseId === parentSuspense.pendingId) {
            parentSuspense.deps--;
            if (parentSuspense.deps === 0) parentSuspense.resolve();
        }
        devtoolsComponentRemoved(instance);
    };
    const unmountChildren = (children, parentComponent, parentSuspense, doRemove = false, optimized = false, start = 0)=>{
        for(let i = start; i < children.length; i++)unmount(children[i], parentComponent, parentSuspense, doRemove, optimized);
    };
    const getNextHostNode = (vnode)=>{
        if (vnode.shapeFlag & 6) return getNextHostNode(vnode.component.subTree);
        if (vnode.shapeFlag & 128) return vnode.suspense.next();
        return hostNextSibling(vnode.anchor || vnode.el);
    };
    const render = (vnode, container, isSVG)=>{
        if (vnode == null) {
            if (container._vnode) unmount(container._vnode, null, null, true);
        } else patch(container._vnode || null, vnode, container, null, null, null, isSVG);
        flushPreFlushCbs();
        flushPostFlushCbs();
        container._vnode = vnode;
    };
    const internals = {
        p: patch,
        um: unmount,
        m: move,
        r: remove,
        mt: mountComponent,
        mc: mountChildren,
        pc: patchChildren,
        pbc: patchBlockChildren,
        n: getNextHostNode,
        o: options
    };
    let hydrate;
    let hydrateNode;
    if (createHydrationFns) [hydrate, hydrateNode] = createHydrationFns(internals);
    return {
        render,
        hydrate,
        createApp: createAppAPI(render, hydrate)
    };
}
function toggleRecurse({ effect, update }, allowed) {
    effect.allowRecurse = update.allowRecurse = allowed;
}
function traverseStaticChildren(n1, n2, shallow = false) {
    const ch1 = n1.children;
    const ch2 = n2.children;
    if ((0, _shared.isArray)(ch1) && (0, _shared.isArray)(ch2)) for(let i = 0; i < ch1.length; i++){
        const c1 = ch1[i];
        let c2 = ch2[i];
        if (c2.shapeFlag & 1 && !c2.dynamicChildren) {
            if (c2.patchFlag <= 0 || c2.patchFlag === 32) {
                c2 = ch2[i] = cloneIfMounted(ch2[i]);
                c2.el = c1.el;
            }
            if (!shallow) traverseStaticChildren(c1, c2);
        }
        if (c2.type === Text) c2.el = c1.el;
        if (c2.type === Comment && !c2.el) c2.el = c1.el;
    }
}
function getSequence(arr) {
    const p = arr.slice();
    const result = [
        0
    ];
    let i, j, u, v1, c;
    const len = arr.length;
    for(i = 0; i < len; i++){
        const arrI = arr[i];
        if (arrI !== 0) {
            j = result[result.length - 1];
            if (arr[j] < arrI) {
                p[i] = j;
                result.push(i);
                continue;
            }
            u = 0;
            v1 = result.length - 1;
            while(u < v1){
                c = u + v1 >> 1;
                if (arr[result[c]] < arrI) u = c + 1;
                else v1 = c;
            }
            if (arrI < arr[result[u]]) {
                if (u > 0) p[i] = result[u - 1];
                result[u] = i;
            }
        }
    }
    u = result.length;
    v1 = result[u - 1];
    while(u-- > 0){
        result[u] = v1;
        v1 = p[v1];
    }
    return result;
}
const isTeleport = (type)=>type.__isTeleport;
const isTeleportDisabled = (props)=>props && (props.disabled || props.disabled === "");
const isTargetSVG = (target)=>typeof SVGElement !== "undefined" && target instanceof SVGElement;
const resolveTarget = (props, select)=>{
    const targetSelector = props && props.to;
    if ((0, _shared.isString)(targetSelector)) {
        if (!select) {
            warn(`Current renderer does not support string target for Teleports. (missing querySelector renderer option)`);
            return null;
        } else {
            const target = select(targetSelector);
            if (!target) warn(`Failed to locate Teleport target with selector "${targetSelector}". Note the target element must exist before the component is mounted - i.e. the target cannot be rendered by the component itself, and ideally should be outside of the entire Vue component tree.`);
            return target;
        }
    } else {
        if (!targetSelector && !isTeleportDisabled(props)) warn(`Invalid Teleport target: ${targetSelector}`);
        return targetSelector;
    }
};
const TeleportImpl = {
    __isTeleport: true,
    process (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals) {
        const { mc: mountChildren, pc: patchChildren, pbc: patchBlockChildren, o: { insert, querySelector, createText, createComment } } = internals;
        const disabled = isTeleportDisabled(n2.props);
        let { shapeFlag, children, dynamicChildren } = n2;
        if (isHmrUpdating) {
            optimized = false;
            dynamicChildren = null;
        }
        if (n1 == null) {
            const placeholder = n2.el = createComment("teleport start");
            const mainAnchor = n2.anchor = createComment("teleport end");
            insert(placeholder, container, anchor);
            insert(mainAnchor, container, anchor);
            const target = n2.target = resolveTarget(n2.props, querySelector);
            const targetAnchor = n2.targetAnchor = createText("");
            if (target) {
                insert(targetAnchor, target);
                isSVG = isSVG || isTargetSVG(target);
            } else if (!disabled) warn("Invalid Teleport target on mount:", target, `(${typeof target})`);
            const mount = (container2, anchor2)=>{
                if (shapeFlag & 16) mountChildren(children, container2, anchor2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
            };
            if (disabled) mount(container, mainAnchor);
            else if (target) mount(target, targetAnchor);
        } else {
            n2.el = n1.el;
            const mainAnchor = n2.anchor = n1.anchor;
            const target = n2.target = n1.target;
            const targetAnchor = n2.targetAnchor = n1.targetAnchor;
            const wasDisabled = isTeleportDisabled(n1.props);
            const currentContainer = wasDisabled ? container : target;
            const currentAnchor = wasDisabled ? mainAnchor : targetAnchor;
            isSVG = isSVG || isTargetSVG(target);
            if (dynamicChildren) {
                patchBlockChildren(n1.dynamicChildren, dynamicChildren, currentContainer, parentComponent, parentSuspense, isSVG, slotScopeIds);
                traverseStaticChildren(n1, n2, true);
            } else if (!optimized) patchChildren(n1, n2, currentContainer, currentAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, false);
            if (disabled) {
                if (!wasDisabled) moveTeleport(n2, container, mainAnchor, internals, 1);
            } else {
                if ((n2.props && n2.props.to) !== (n1.props && n1.props.to)) {
                    const nextTarget = n2.target = resolveTarget(n2.props, querySelector);
                    if (nextTarget) moveTeleport(n2, nextTarget, null, internals, 0);
                    else warn("Invalid Teleport target on update:", target, `(${typeof target})`);
                } else if (wasDisabled) moveTeleport(n2, target, targetAnchor, internals, 1);
            }
        }
        updateCssVars(n2);
    },
    remove (vnode, parentComponent, parentSuspense, optimized, { um: unmount, o: { remove: hostRemove } }, doRemove) {
        const { shapeFlag, children, anchor, targetAnchor, target, props } = vnode;
        if (target) hostRemove(targetAnchor);
        if (doRemove || !isTeleportDisabled(props)) {
            hostRemove(anchor);
            if (shapeFlag & 16) for(let i = 0; i < children.length; i++){
                const child = children[i];
                unmount(child, parentComponent, parentSuspense, true, !!child.dynamicChildren);
            }
        }
    },
    move: moveTeleport,
    hydrate: hydrateTeleport
};
function moveTeleport(vnode, container, parentAnchor, { o: { insert }, m: move }, moveType = 2) {
    if (moveType === 0) insert(vnode.targetAnchor, container, parentAnchor);
    const { el, anchor, shapeFlag, children, props } = vnode;
    const isReorder = moveType === 2;
    if (isReorder) insert(el, container, parentAnchor);
    if (!isReorder || isTeleportDisabled(props)) {
        if (shapeFlag & 16) for(let i = 0; i < children.length; i++)move(children[i], container, parentAnchor, 2);
    }
    if (isReorder) insert(anchor, container, parentAnchor);
}
function hydrateTeleport(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, { o: { nextSibling, parentNode, querySelector } }, hydrateChildren) {
    const target = vnode.target = resolveTarget(vnode.props, querySelector);
    if (target) {
        const targetNode = target._lpa || target.firstChild;
        if (vnode.shapeFlag & 16) {
            if (isTeleportDisabled(vnode.props)) {
                vnode.anchor = hydrateChildren(nextSibling(node), vnode, parentNode(node), parentComponent, parentSuspense, slotScopeIds, optimized);
                vnode.targetAnchor = targetNode;
            } else {
                vnode.anchor = nextSibling(node);
                let targetAnchor = targetNode;
                while(targetAnchor){
                    targetAnchor = nextSibling(targetAnchor);
                    if (targetAnchor && targetAnchor.nodeType === 8 && targetAnchor.data === "teleport anchor") {
                        vnode.targetAnchor = targetAnchor;
                        target._lpa = vnode.targetAnchor && nextSibling(vnode.targetAnchor);
                        break;
                    }
                }
                hydrateChildren(targetNode, vnode, target, parentComponent, parentSuspense, slotScopeIds, optimized);
            }
        }
        updateCssVars(vnode);
    }
    return vnode.anchor && nextSibling(vnode.anchor);
}
const Teleport = TeleportImpl;
function updateCssVars(vnode) {
    const ctx = vnode.ctx;
    if (ctx && ctx.ut) {
        let node = vnode.children[0].el;
        while(node !== vnode.targetAnchor){
            if (node.nodeType === 1) node.setAttribute("data-v-owner", ctx.uid);
            node = node.nextSibling;
        }
        ctx.ut();
    }
}
const Fragment = Symbol.for("v-fgt");
const Text = Symbol.for("v-txt");
const Comment = Symbol.for("v-cmt");
const Static = Symbol.for("v-stc");
const blockStack = [];
let currentBlock = null;
function openBlock(disableTracking = false) {
    blockStack.push(currentBlock = disableTracking ? null : []);
}
function closeBlock() {
    blockStack.pop();
    currentBlock = blockStack[blockStack.length - 1] || null;
}
let isBlockTreeEnabled = 1;
function setBlockTracking(value1) {
    isBlockTreeEnabled += value1;
}
function setupBlock(vnode) {
    vnode.dynamicChildren = isBlockTreeEnabled > 0 ? currentBlock || (0, _shared.EMPTY_ARR) : null;
    closeBlock();
    if (isBlockTreeEnabled > 0 && currentBlock) currentBlock.push(vnode);
    return vnode;
}
function createElementBlock(type, props, children, patchFlag, dynamicProps, shapeFlag) {
    return setupBlock(createBaseVNode(type, props, children, patchFlag, dynamicProps, shapeFlag, true));
}
function createBlock(type, props, children, patchFlag, dynamicProps) {
    return setupBlock(createVNode(type, props, children, patchFlag, dynamicProps, true));
}
function isVNode(value1) {
    return value1 ? value1.__v_isVNode === true : false;
}
function isSameVNodeType(n1, n2) {
    if (n2.shapeFlag & 6 && hmrDirtyComponents.has(n2.type)) {
        n1.shapeFlag &= -257;
        n2.shapeFlag &= -513;
        return false;
    }
    return n1.type === n2.type && n1.key === n2.key;
}
let vnodeArgsTransformer;
function transformVNodeArgs(transformer) {
    vnodeArgsTransformer = transformer;
}
const createVNodeWithArgsTransform = (...args)=>{
    return _createVNode(...vnodeArgsTransformer ? vnodeArgsTransformer(args, currentRenderingInstance) : args);
};
const InternalObjectKey = `__vInternal`;
const normalizeKey = ({ key })=>key != null ? key : null;
const normalizeRef = ({ ref, ref_key, ref_for })=>{
    if (typeof ref === "number") ref = "" + ref;
    return ref != null ? (0, _shared.isString)(ref) || (0, _reactivity.isRef)(ref) || (0, _shared.isFunction)(ref) ? {
        i: currentRenderingInstance,
        r: ref,
        k: ref_key,
        f: !!ref_for
    } : ref : null;
};
function createBaseVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, shapeFlag = type === Fragment ? 0 : 1, isBlockNode = false, needFullChildrenNormalization = false) {
    const vnode = {
        __v_isVNode: true,
        __v_skip: true,
        type,
        props,
        key: props && normalizeKey(props),
        ref: props && normalizeRef(props),
        scopeId: currentScopeId,
        slotScopeIds: null,
        children,
        component: null,
        suspense: null,
        ssContent: null,
        ssFallback: null,
        dirs: null,
        transition: null,
        el: null,
        anchor: null,
        target: null,
        targetAnchor: null,
        staticCount: 0,
        shapeFlag,
        patchFlag,
        dynamicProps,
        dynamicChildren: null,
        appContext: null,
        ctx: currentRenderingInstance
    };
    if (needFullChildrenNormalization) {
        normalizeChildren(vnode, children);
        if (shapeFlag & 128) type.normalize(vnode);
    } else if (children) vnode.shapeFlag |= (0, _shared.isString)(children) ? 8 : 16;
    if (vnode.key !== vnode.key) warn(`VNode created with invalid key (NaN). VNode type:`, vnode.type);
    if (isBlockTreeEnabled > 0 && // avoid a block node from tracking itself
    !isBlockNode && // has current parent block
    currentBlock && // presence of a patch flag indicates this node needs patching on updates.
    // component nodes also should always be patched, because even if the
    // component doesn't need to update, it needs to persist the instance on to
    // the next vnode so that it can be properly unmounted later.
    (vnode.patchFlag > 0 || shapeFlag & 6) && // the EVENTS flag is only for hydration and if it is the only flag, the
    // vnode should not be considered dynamic due to handler caching.
    vnode.patchFlag !== 32) currentBlock.push(vnode);
    return vnode;
}
const createVNode = createVNodeWithArgsTransform;
function _createVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {
    if (!type || type === NULL_DYNAMIC_COMPONENT) {
        if (!type) warn(`Invalid vnode type when creating vnode: ${type}.`);
        type = Comment;
    }
    if (isVNode(type)) {
        const cloned = cloneVNode(type, props, true);
        if (children) normalizeChildren(cloned, children);
        if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock) {
            if (cloned.shapeFlag & 6) currentBlock[currentBlock.indexOf(type)] = cloned;
            else currentBlock.push(cloned);
        }
        cloned.patchFlag |= -2;
        return cloned;
    }
    if (isClassComponent(type)) type = type.__vccOpts;
    if (props) {
        props = guardReactiveProps(props);
        let { class: klass, style } = props;
        if (klass && !(0, _shared.isString)(klass)) props.class = (0, _shared.normalizeClass)(klass);
        if ((0, _shared.isObject)(style)) {
            if ((0, _reactivity.isProxy)(style) && !(0, _shared.isArray)(style)) style = (0, _shared.extend)({}, style);
            props.style = (0, _shared.normalizeStyle)(style);
        }
    }
    const shapeFlag = (0, _shared.isString)(type) ? 1 : isSuspense(type) ? 128 : isTeleport(type) ? 64 : (0, _shared.isObject)(type) ? 4 : (0, _shared.isFunction)(type) ? 2 : 0;
    if (shapeFlag & 4 && (0, _reactivity.isProxy)(type)) {
        type = (0, _reactivity.toRaw)(type);
        warn(`Vue received a Component which was made a reactive object. This can lead to unnecessary performance overhead, and should be avoided by marking the component with \`markRaw\` or using \`shallowRef\` instead of \`ref\`.`, `
Component that was made reactive: `, type);
    }
    return createBaseVNode(type, props, children, patchFlag, dynamicProps, shapeFlag, isBlockNode, true);
}
function guardReactiveProps(props) {
    if (!props) return null;
    return (0, _reactivity.isProxy)(props) || InternalObjectKey in props ? (0, _shared.extend)({}, props) : props;
}
function cloneVNode(vnode, extraProps, mergeRef = false) {
    const { props, ref, patchFlag, children } = vnode;
    const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;
    const cloned = {
        __v_isVNode: true,
        __v_skip: true,
        type: vnode.type,
        props: mergedProps,
        key: mergedProps && normalizeKey(mergedProps),
        ref: extraProps && extraProps.ref ? // #2078 in the case of <component :is="vnode" ref="extra"/>
        // if the vnode itself already has a ref, cloneVNode will need to merge
        // the refs so the single vnode can be set on multiple refs
        mergeRef && ref ? (0, _shared.isArray)(ref) ? ref.concat(normalizeRef(extraProps)) : [
            ref,
            normalizeRef(extraProps)
        ] : normalizeRef(extraProps) : ref,
        scopeId: vnode.scopeId,
        slotScopeIds: vnode.slotScopeIds,
        children: patchFlag === -1 && (0, _shared.isArray)(children) ? children.map(deepCloneVNode) : children,
        target: vnode.target,
        targetAnchor: vnode.targetAnchor,
        staticCount: vnode.staticCount,
        shapeFlag: vnode.shapeFlag,
        // if the vnode is cloned with extra props, we can no longer assume its
        // existing patch flag to be reliable and need to add the FULL_PROPS flag.
        // note: preserve flag for fragments since they use the flag for children
        // fast paths only.
        patchFlag: extraProps && vnode.type !== Fragment ? patchFlag === -1 ? 16 : patchFlag | 16 : patchFlag,
        dynamicProps: vnode.dynamicProps,
        dynamicChildren: vnode.dynamicChildren,
        appContext: vnode.appContext,
        dirs: vnode.dirs,
        transition: vnode.transition,
        // These should technically only be non-null on mounted VNodes. However,
        // they *should* be copied for kept-alive vnodes. So we just always copy
        // them since them being non-null during a mount doesn't affect the logic as
        // they will simply be overwritten.
        component: vnode.component,
        suspense: vnode.suspense,
        ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),
        ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),
        el: vnode.el,
        anchor: vnode.anchor,
        ctx: vnode.ctx,
        ce: vnode.ce
    };
    return cloned;
}
function deepCloneVNode(vnode) {
    const cloned = cloneVNode(vnode);
    if ((0, _shared.isArray)(vnode.children)) cloned.children = vnode.children.map(deepCloneVNode);
    return cloned;
}
function createTextVNode(text = " ", flag = 0) {
    return createVNode(Text, null, text, flag);
}
function createStaticVNode(content, numberOfNodes) {
    const vnode = createVNode(Static, null, content);
    vnode.staticCount = numberOfNodes;
    return vnode;
}
function createCommentVNode(text = "", asBlock = false) {
    return asBlock ? (openBlock(), createBlock(Comment, null, text)) : createVNode(Comment, null, text);
}
function normalizeVNode(child) {
    if (child == null || typeof child === "boolean") return createVNode(Comment);
    else if ((0, _shared.isArray)(child)) return createVNode(Fragment, null, // #3666, avoid reference pollution when reusing vnode
    child.slice());
    else if (typeof child === "object") return cloneIfMounted(child);
    else return createVNode(Text, null, String(child));
}
function cloneIfMounted(child) {
    return child.el === null && child.patchFlag !== -1 || child.memo ? child : cloneVNode(child);
}
function normalizeChildren(vnode, children) {
    let type = 0;
    const { shapeFlag } = vnode;
    if (children == null) children = null;
    else if ((0, _shared.isArray)(children)) type = 16;
    else if (typeof children === "object") {
        if (shapeFlag & 65) {
            const slot = children.default;
            if (slot) {
                slot._c && (slot._d = false);
                normalizeChildren(vnode, slot());
                slot._c && (slot._d = true);
            }
            return;
        } else {
            type = 32;
            const slotFlag = children._;
            if (!slotFlag && !(InternalObjectKey in children)) children._ctx = currentRenderingInstance;
            else if (slotFlag === 3 && currentRenderingInstance) {
                if (currentRenderingInstance.slots._ === 1) children._ = 1;
                else {
                    children._ = 2;
                    vnode.patchFlag |= 1024;
                }
            }
        }
    } else if ((0, _shared.isFunction)(children)) {
        children = {
            default: children,
            _ctx: currentRenderingInstance
        };
        type = 32;
    } else {
        children = String(children);
        if (shapeFlag & 64) {
            type = 16;
            children = [
                createTextVNode(children)
            ];
        } else type = 8;
    }
    vnode.children = children;
    vnode.shapeFlag |= type;
}
function mergeProps(...args) {
    const ret = {};
    for(let i = 0; i < args.length; i++){
        const toMerge = args[i];
        for(const key in toMerge){
            if (key === "class") {
                if (ret.class !== toMerge.class) ret.class = (0, _shared.normalizeClass)([
                    ret.class,
                    toMerge.class
                ]);
            } else if (key === "style") ret.style = (0, _shared.normalizeStyle)([
                ret.style,
                toMerge.style
            ]);
            else if ((0, _shared.isOn)(key)) {
                const existing = ret[key];
                const incoming = toMerge[key];
                if (incoming && existing !== incoming && !((0, _shared.isArray)(existing) && existing.includes(incoming))) ret[key] = existing ? [].concat(existing, incoming) : incoming;
            } else if (key !== "") ret[key] = toMerge[key];
        }
    }
    return ret;
}
function invokeVNodeHook(hook, instance, vnode, prevVNode = null) {
    callWithAsyncErrorHandling(hook, instance, 7, [
        vnode,
        prevVNode
    ]);
}
const emptyAppContext = createAppContext();
let uid = 0;
function createComponentInstance(vnode, parent, suspense) {
    const type = vnode.type;
    const appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;
    const instance = {
        uid: uid++,
        vnode,
        type,
        parent,
        appContext,
        root: null,
        // to be immediately set
        next: null,
        subTree: null,
        // will be set synchronously right after creation
        effect: null,
        update: null,
        // will be set synchronously right after creation
        scope: new (0, _reactivity.EffectScope)(true),
        render: null,
        proxy: null,
        exposed: null,
        exposeProxy: null,
        withProxy: null,
        provides: parent ? parent.provides : Object.create(appContext.provides),
        accessCache: null,
        renderCache: [],
        // local resolved assets
        components: null,
        directives: null,
        // resolved props and emits options
        propsOptions: normalizePropsOptions(type, appContext),
        emitsOptions: normalizeEmitsOptions(type, appContext),
        // emit
        emit: null,
        // to be set immediately
        emitted: null,
        // props default value
        propsDefaults: (0, _shared.EMPTY_OBJ),
        // inheritAttrs
        inheritAttrs: type.inheritAttrs,
        // state
        ctx: (0, _shared.EMPTY_OBJ),
        data: (0, _shared.EMPTY_OBJ),
        props: (0, _shared.EMPTY_OBJ),
        attrs: (0, _shared.EMPTY_OBJ),
        slots: (0, _shared.EMPTY_OBJ),
        refs: (0, _shared.EMPTY_OBJ),
        setupState: (0, _shared.EMPTY_OBJ),
        setupContext: null,
        attrsProxy: null,
        slotsProxy: null,
        // suspense related
        suspense,
        suspenseId: suspense ? suspense.pendingId : 0,
        asyncDep: null,
        asyncResolved: false,
        // lifecycle hooks
        // not using enums here because it results in computed properties
        isMounted: false,
        isUnmounted: false,
        isDeactivated: false,
        bc: null,
        c: null,
        bm: null,
        m: null,
        bu: null,
        u: null,
        um: null,
        bum: null,
        da: null,
        a: null,
        rtg: null,
        rtc: null,
        ec: null,
        sp: null
    };
    instance.ctx = createDevRenderContext(instance);
    instance.root = parent ? parent.root : instance;
    instance.emit = emit.bind(null, instance);
    if (vnode.ce) vnode.ce(instance);
    return instance;
}
let currentInstance = null;
const getCurrentInstance = ()=>currentInstance || currentRenderingInstance;
let internalSetCurrentInstance;
let globalCurrentInstanceSetters;
let settersKey = "__VUE_INSTANCE_SETTERS__";
if (!(globalCurrentInstanceSetters = (0, _shared.getGlobalThis)()[settersKey])) globalCurrentInstanceSetters = (0, _shared.getGlobalThis)()[settersKey] = [];
globalCurrentInstanceSetters.push((i)=>currentInstance = i);
internalSetCurrentInstance = (instance)=>{
    if (globalCurrentInstanceSetters.length > 1) globalCurrentInstanceSetters.forEach((s)=>s(instance));
    else globalCurrentInstanceSetters[0](instance);
};
const setCurrentInstance = (instance)=>{
    internalSetCurrentInstance(instance);
    instance.scope.on();
};
const unsetCurrentInstance = ()=>{
    currentInstance && currentInstance.scope.off();
    internalSetCurrentInstance(null);
};
const isBuiltInTag = /* @__PURE__ */ (0, _shared.makeMap)("slot,component");
function validateComponentName(name, config) {
    const appIsNativeTag = config.isNativeTag || (0, _shared.NO);
    if (isBuiltInTag(name) || appIsNativeTag(name)) warn("Do not use built-in or reserved HTML elements as component id: " + name);
}
function isStatefulComponent(instance) {
    return instance.vnode.shapeFlag & 4;
}
let isInSSRComponentSetup = false;
function setupComponent(instance, isSSR = false) {
    isInSSRComponentSetup = isSSR;
    const { props, children } = instance.vnode;
    const isStateful = isStatefulComponent(instance);
    initProps(instance, props, isStateful, isSSR);
    initSlots(instance, children);
    const setupResult = isStateful ? setupStatefulComponent(instance, isSSR) : void 0;
    isInSSRComponentSetup = false;
    return setupResult;
}
function setupStatefulComponent(instance, isSSR) {
    var _a;
    const Component = instance.type;
    if (Component.name) validateComponentName(Component.name, instance.appContext.config);
    if (Component.components) {
        const names = Object.keys(Component.components);
        for(let i = 0; i < names.length; i++)validateComponentName(names[i], instance.appContext.config);
    }
    if (Component.directives) {
        const names = Object.keys(Component.directives);
        for(let i = 0; i < names.length; i++)validateDirectiveName(names[i]);
    }
    if (Component.compilerOptions && isRuntimeOnly()) warn(`"compilerOptions" is only supported when using a build of Vue that includes the runtime compiler. Since you are using a runtime-only build, the options should be passed via your build tool config instead.`);
    instance.accessCache = /* @__PURE__ */ Object.create(null);
    instance.proxy = (0, _reactivity.markRaw)(new Proxy(instance.ctx, PublicInstanceProxyHandlers));
    exposePropsOnRenderContext(instance);
    const { setup } = Component;
    if (setup) {
        const setupContext = instance.setupContext = setup.length > 1 ? createSetupContext(instance) : null;
        setCurrentInstance(instance);
        (0, _reactivity.pauseTracking)();
        const setupResult = callWithErrorHandling(setup, instance, 0, [
            (0, _reactivity.shallowReadonly)(instance.props),
            setupContext
        ]);
        (0, _reactivity.resetTracking)();
        unsetCurrentInstance();
        if ((0, _shared.isPromise)(setupResult)) {
            setupResult.then(unsetCurrentInstance, unsetCurrentInstance);
            if (isSSR) return setupResult.then((resolvedResult)=>{
                handleSetupResult(instance, resolvedResult, isSSR);
            }).catch((e)=>{
                handleError(e, instance, 0);
            });
            else {
                instance.asyncDep = setupResult;
                if (!instance.suspense) {
                    const name = (_a = Component.name) != null ? _a : "Anonymous";
                    warn(`Component <${name}>: setup function returned a promise, but no <Suspense> boundary was found in the parent component tree. A component with async setup() must be nested in a <Suspense> in order to be rendered.`);
                }
            }
        } else handleSetupResult(instance, setupResult, isSSR);
    } else finishComponentSetup(instance, isSSR);
}
function handleSetupResult(instance, setupResult, isSSR) {
    if ((0, _shared.isFunction)(setupResult)) {
        if (instance.type.__ssrInlineRender) instance.ssrRender = setupResult;
        else instance.render = setupResult;
    } else if ((0, _shared.isObject)(setupResult)) {
        if (isVNode(setupResult)) warn(`setup() should not return VNodes directly - return a render function instead.`);
        instance.devtoolsRawSetupState = setupResult;
        instance.setupState = (0, _reactivity.proxyRefs)(setupResult);
        exposeSetupStateOnRenderContext(instance);
    } else if (setupResult !== void 0) warn(`setup() should return an object. Received: ${setupResult === null ? "null" : typeof setupResult}`);
    finishComponentSetup(instance, isSSR);
}
let compile;
let installWithProxy;
function registerRuntimeCompiler(_compile) {
    compile = _compile;
    installWithProxy = (i)=>{
        if (i.render._rc) i.withProxy = new Proxy(i.ctx, RuntimeCompiledPublicInstanceProxyHandlers);
    };
}
const isRuntimeOnly = ()=>!compile;
function finishComponentSetup(instance, isSSR, skipOptions) {
    const Component = instance.type;
    if (!instance.render) {
        if (!isSSR && compile && !Component.render) {
            const template = Component.template || resolveMergedOptions(instance).template;
            if (template) {
                startMeasure(instance, `compile`);
                const { isCustomElement, compilerOptions } = instance.appContext.config;
                const { delimiters, compilerOptions: componentCompilerOptions } = Component;
                const finalCompilerOptions = (0, _shared.extend)((0, _shared.extend)({
                    isCustomElement,
                    delimiters
                }, compilerOptions), componentCompilerOptions);
                Component.render = compile(template, finalCompilerOptions);
                endMeasure(instance, `compile`);
            }
        }
        instance.render = Component.render || (0, _shared.NOOP);
        if (installWithProxy) installWithProxy(instance);
    }
    if (__VUE_OPTIONS_API__ && true) {
        setCurrentInstance(instance);
        (0, _reactivity.pauseTracking)();
        applyOptions(instance);
        (0, _reactivity.resetTracking)();
        unsetCurrentInstance();
    }
    if (!Component.render && instance.render === (0, _shared.NOOP) && !isSSR) {
        if (!compile && Component.template) warn(`Component provided template option but runtime compilation is not supported in this build of Vue.` + ` Configure your bundler to alias "vue" to "vue/dist/vue.esm-bundler.js".`);
        else warn(`Component is missing template or render function.`);
    }
}
function getAttrsProxy(instance) {
    return instance.attrsProxy || (instance.attrsProxy = new Proxy(instance.attrs, {
        get (target, key) {
            markAttrsAccessed();
            (0, _reactivity.track)(instance, "get", "$attrs");
            return target[key];
        },
        set () {
            warn(`setupContext.attrs is readonly.`);
            return false;
        },
        deleteProperty () {
            warn(`setupContext.attrs is readonly.`);
            return false;
        }
    }));
}
function getSlotsProxy(instance) {
    return instance.slotsProxy || (instance.slotsProxy = new Proxy(instance.slots, {
        get (target, key) {
            (0, _reactivity.track)(instance, "get", "$slots");
            return target[key];
        }
    }));
}
function createSetupContext(instance) {
    const expose = (exposed)=>{
        if (instance.exposed) warn(`expose() should be called only once per setup().`);
        if (exposed != null) {
            let exposedType = typeof exposed;
            if (exposedType === "object") {
                if ((0, _shared.isArray)(exposed)) exposedType = "array";
                else if ((0, _reactivity.isRef)(exposed)) exposedType = "ref";
            }
            if (exposedType !== "object") warn(`expose() should be passed a plain object, received ${exposedType}.`);
        }
        instance.exposed = exposed || {};
    };
    return Object.freeze({
        get attrs () {
            return getAttrsProxy(instance);
        },
        get slots () {
            return getSlotsProxy(instance);
        },
        get emit () {
            return (event, ...args)=>instance.emit(event, ...args);
        },
        expose
    });
}
function getExposeProxy(instance) {
    if (instance.exposed) return instance.exposeProxy || (instance.exposeProxy = new Proxy((0, _reactivity.proxyRefs)((0, _reactivity.markRaw)(instance.exposed)), {
        get (target, key) {
            if (key in target) return target[key];
            else if (key in publicPropertiesMap) return publicPropertiesMap[key](instance);
        },
        has (target, key) {
            return key in target || key in publicPropertiesMap;
        }
    }));
}
const classifyRE = /(?:^|[-_])(\w)/g;
const classify = (str)=>str.replace(classifyRE, (c)=>c.toUpperCase()).replace(/[-_]/g, "");
function getComponentName(Component, includeInferred = true) {
    return (0, _shared.isFunction)(Component) ? Component.displayName || Component.name : Component.name || includeInferred && Component.__name;
}
function formatComponentName(instance, Component, isRoot = false) {
    let name = getComponentName(Component);
    if (!name && Component.__file) {
        const match = Component.__file.match(/([^/\\]+)\.\w+$/);
        if (match) name = match[1];
    }
    if (!name && instance && instance.parent) {
        const inferFromRegistry = (registry)=>{
            for(const key in registry){
                if (registry[key] === Component) return key;
            }
        };
        name = inferFromRegistry(instance.components || instance.parent.type.components) || inferFromRegistry(instance.appContext.components);
    }
    return name ? classify(name) : isRoot ? `App` : `Anonymous`;
}
function isClassComponent(value1) {
    return (0, _shared.isFunction)(value1) && "__vccOpts" in value1;
}
const computed = (getterOrOptions, debugOptions)=>{
    return (0, _reactivity.computed)(getterOrOptions, debugOptions, isInSSRComponentSetup);
};
function h(type, propsOrChildren, children) {
    const l = arguments.length;
    if (l === 2) {
        if ((0, _shared.isObject)(propsOrChildren) && !(0, _shared.isArray)(propsOrChildren)) {
            if (isVNode(propsOrChildren)) return createVNode(type, null, [
                propsOrChildren
            ]);
            return createVNode(type, propsOrChildren);
        } else return createVNode(type, null, propsOrChildren);
    } else {
        if (l > 3) children = Array.prototype.slice.call(arguments, 2);
        else if (l === 3 && isVNode(children)) children = [
            children
        ];
        return createVNode(type, propsOrChildren, children);
    }
}
const ssrContextKey = Symbol.for("v-scx");
const useSSRContext = ()=>{
    {
        const ctx = inject(ssrContextKey);
        if (!ctx) warn(`Server rendering context not provided. Make sure to only call useSSRContext() conditionally in the server build.`);
        return ctx;
    }
};
function isShallow(value1) {
    return !!(value1 && value1["__v_isShallow"]);
}
function initCustomFormatter() {
    if (typeof window === "undefined") return;
    const vueStyle = {
        style: "color:#3ba776"
    };
    const numberStyle = {
        style: "color:#0b1bc9"
    };
    const stringStyle = {
        style: "color:#b62e24"
    };
    const keywordStyle = {
        style: "color:#9d288c"
    };
    const formatter = {
        header (obj) {
            if (!(0, _shared.isObject)(obj)) return null;
            if (obj.__isVue) return [
                "div",
                vueStyle,
                `VueInstance`
            ];
            else if ((0, _reactivity.isRef)(obj)) return [
                "div",
                {},
                [
                    "span",
                    vueStyle,
                    genRefFlag(obj)
                ],
                "<",
                formatValue(obj.value),
                `>`
            ];
            else if ((0, _reactivity.isReactive)(obj)) return [
                "div",
                {},
                [
                    "span",
                    vueStyle,
                    isShallow(obj) ? "ShallowReactive" : "Reactive"
                ],
                "<",
                formatValue(obj),
                `>${(0, _reactivity.isReadonly)(obj) ? ` (readonly)` : ``}`
            ];
            else if ((0, _reactivity.isReadonly)(obj)) return [
                "div",
                {},
                [
                    "span",
                    vueStyle,
                    isShallow(obj) ? "ShallowReadonly" : "Readonly"
                ],
                "<",
                formatValue(obj),
                ">"
            ];
            return null;
        },
        hasBody (obj) {
            return obj && obj.__isVue;
        },
        body (obj) {
            if (obj && obj.__isVue) return [
                "div",
                {},
                ...formatInstance(obj.$)
            ];
        }
    };
    function formatInstance(instance) {
        const blocks = [];
        if (instance.type.props && instance.props) blocks.push(createInstanceBlock("props", (0, _reactivity.toRaw)(instance.props)));
        if (instance.setupState !== (0, _shared.EMPTY_OBJ)) blocks.push(createInstanceBlock("setup", instance.setupState));
        if (instance.data !== (0, _shared.EMPTY_OBJ)) blocks.push(createInstanceBlock("data", (0, _reactivity.toRaw)(instance.data)));
        const computed = extractKeys(instance, "computed");
        if (computed) blocks.push(createInstanceBlock("computed", computed));
        const injected = extractKeys(instance, "inject");
        if (injected) blocks.push(createInstanceBlock("injected", injected));
        blocks.push([
            "div",
            {},
            [
                "span",
                {
                    style: keywordStyle.style + ";opacity:0.66"
                },
                "$ (internal): "
            ],
            [
                "object",
                {
                    object: instance
                }
            ]
        ]);
        return blocks;
    }
    function createInstanceBlock(type, target) {
        target = (0, _shared.extend)({}, target);
        if (!Object.keys(target).length) return [
            "span",
            {}
        ];
        return [
            "div",
            {
                style: "line-height:1.25em;margin-bottom:0.6em"
            },
            [
                "div",
                {
                    style: "color:#476582"
                },
                type
            ],
            [
                "div",
                {
                    style: "padding-left:1.25em"
                },
                ...Object.keys(target).map((key)=>{
                    return [
                        "div",
                        {},
                        [
                            "span",
                            keywordStyle,
                            key + ": "
                        ],
                        formatValue(target[key], false)
                    ];
                })
            ]
        ];
    }
    function formatValue(v1, asRaw = true) {
        if (typeof v1 === "number") return [
            "span",
            numberStyle,
            v1
        ];
        else if (typeof v1 === "string") return [
            "span",
            stringStyle,
            JSON.stringify(v1)
        ];
        else if (typeof v1 === "boolean") return [
            "span",
            keywordStyle,
            v1
        ];
        else if ((0, _shared.isObject)(v1)) return [
            "object",
            {
                object: asRaw ? (0, _reactivity.toRaw)(v1) : v1
            }
        ];
        else return [
            "span",
            stringStyle,
            String(v1)
        ];
    }
    function extractKeys(instance, type) {
        const Comp = instance.type;
        if ((0, _shared.isFunction)(Comp)) return;
        const extracted = {};
        for(const key in instance.ctx)if (isKeyOfType(Comp, key, type)) extracted[key] = instance.ctx[key];
        return extracted;
    }
    function isKeyOfType(Comp, key, type) {
        const opts = Comp[type];
        if ((0, _shared.isArray)(opts) && opts.includes(key) || (0, _shared.isObject)(opts) && key in opts) return true;
        if (Comp.extends && isKeyOfType(Comp.extends, key, type)) return true;
        if (Comp.mixins && Comp.mixins.some((m)=>isKeyOfType(m, key, type))) return true;
    }
    function genRefFlag(v1) {
        if (isShallow(v1)) return `ShallowRef`;
        if (v1.effect) return `ComputedRef`;
        return `Ref`;
    }
    if (window.devtoolsFormatters) window.devtoolsFormatters.push(formatter);
    else window.devtoolsFormatters = [
        formatter
    ];
}
function withMemo(memo, render, cache, index) {
    const cached = cache[index];
    if (cached && isMemoSame(cached, memo)) return cached;
    const ret = render();
    ret.memo = memo.slice();
    return cache[index] = ret;
}
function isMemoSame(cached, memo) {
    const prev = cached.memo;
    if (prev.length != memo.length) return false;
    for(let i = 0; i < prev.length; i++){
        if ((0, _shared.hasChanged)(prev[i], memo[i])) return false;
    }
    if (isBlockTreeEnabled > 0 && currentBlock) currentBlock.push(cached);
    return true;
}
const version = "3.3.4";
const _ssrUtils = {
    createComponentInstance,
    setupComponent,
    renderComponentRoot,
    setCurrentRenderingInstance,
    isVNode: isVNode,
    normalizeVNode
};
const ssrUtils = _ssrUtils;
const resolveFilter = null;
const compatUtils = null;

},{"@vue/reactivity":"fQHlL","@vue/shared":"5YL8y","@parcel/transformer-js/src/esmodule-helpers.js":"boKlo"}],"fQHlL":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "EffectScope", ()=>EffectScope);
parcelHelpers.export(exports, "ITERATE_KEY", ()=>ITERATE_KEY);
parcelHelpers.export(exports, "ReactiveEffect", ()=>ReactiveEffect);
parcelHelpers.export(exports, "computed", ()=>computed);
parcelHelpers.export(exports, "customRef", ()=>customRef);
parcelHelpers.export(exports, "deferredComputed", ()=>deferredComputed);
parcelHelpers.export(exports, "effect", ()=>effect);
parcelHelpers.export(exports, "effectScope", ()=>effectScope);
parcelHelpers.export(exports, "enableTracking", ()=>enableTracking);
parcelHelpers.export(exports, "getCurrentScope", ()=>getCurrentScope);
parcelHelpers.export(exports, "isProxy", ()=>isProxy);
parcelHelpers.export(exports, "isReactive", ()=>isReactive);
parcelHelpers.export(exports, "isReadonly", ()=>isReadonly);
parcelHelpers.export(exports, "isRef", ()=>isRef);
parcelHelpers.export(exports, "isShallow", ()=>isShallow);
parcelHelpers.export(exports, "markRaw", ()=>markRaw);
parcelHelpers.export(exports, "onScopeDispose", ()=>onScopeDispose);
parcelHelpers.export(exports, "pauseTracking", ()=>pauseTracking);
parcelHelpers.export(exports, "proxyRefs", ()=>proxyRefs);
parcelHelpers.export(exports, "reactive", ()=>reactive);
parcelHelpers.export(exports, "readonly", ()=>readonly);
parcelHelpers.export(exports, "ref", ()=>ref);
parcelHelpers.export(exports, "resetTracking", ()=>resetTracking);
parcelHelpers.export(exports, "shallowReactive", ()=>shallowReactive);
parcelHelpers.export(exports, "shallowReadonly", ()=>shallowReadonly);
parcelHelpers.export(exports, "shallowRef", ()=>shallowRef);
parcelHelpers.export(exports, "stop", ()=>stop);
parcelHelpers.export(exports, "toRaw", ()=>toRaw);
parcelHelpers.export(exports, "toRef", ()=>toRef);
parcelHelpers.export(exports, "toRefs", ()=>toRefs);
parcelHelpers.export(exports, "toValue", ()=>toValue);
parcelHelpers.export(exports, "track", ()=>track);
parcelHelpers.export(exports, "trigger", ()=>trigger);
parcelHelpers.export(exports, "triggerRef", ()=>triggerRef);
parcelHelpers.export(exports, "unref", ()=>unref);
var _shared = require("@vue/shared");
function warn(msg, ...args) {
    console.warn(`[Vue warn] ${msg}`, ...args);
}
let activeEffectScope;
class EffectScope {
    constructor(detached = false){
        this.detached = detached;
        /**
     * @internal
     */ this._active = true;
        /**
     * @internal
     */ this.effects = [];
        /**
     * @internal
     */ this.cleanups = [];
        this.parent = activeEffectScope;
        if (!detached && activeEffectScope) this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(this) - 1;
    }
    get active() {
        return this._active;
    }
    run(fn) {
        if (this._active) {
            const currentEffectScope = activeEffectScope;
            try {
                activeEffectScope = this;
                return fn();
            } finally{
                activeEffectScope = currentEffectScope;
            }
        } else warn(`cannot run an inactive effect scope.`);
    }
    /**
   * This should only be called on non-detached scopes
   * @internal
   */ on() {
        activeEffectScope = this;
    }
    /**
   * This should only be called on non-detached scopes
   * @internal
   */ off() {
        activeEffectScope = this.parent;
    }
    stop(fromParent) {
        if (this._active) {
            let i, l;
            for(i = 0, l = this.effects.length; i < l; i++)this.effects[i].stop();
            for(i = 0, l = this.cleanups.length; i < l; i++)this.cleanups[i]();
            if (this.scopes) for(i = 0, l = this.scopes.length; i < l; i++)this.scopes[i].stop(true);
            if (!this.detached && this.parent && !fromParent) {
                const last = this.parent.scopes.pop();
                if (last && last !== this) {
                    this.parent.scopes[this.index] = last;
                    last.index = this.index;
                }
            }
            this.parent = void 0;
            this._active = false;
        }
    }
}
function effectScope(detached) {
    return new EffectScope(detached);
}
function recordEffectScope(effect, scope = activeEffectScope) {
    if (scope && scope.active) scope.effects.push(effect);
}
function getCurrentScope() {
    return activeEffectScope;
}
function onScopeDispose(fn) {
    if (activeEffectScope) activeEffectScope.cleanups.push(fn);
    else warn(`onScopeDispose() is called when there is no active effect scope to be associated with.`);
}
const createDep = (effects)=>{
    const dep = new Set(effects);
    dep.w = 0;
    dep.n = 0;
    return dep;
};
const wasTracked = (dep)=>(dep.w & trackOpBit) > 0;
const newTracked = (dep)=>(dep.n & trackOpBit) > 0;
const initDepMarkers = ({ deps })=>{
    if (deps.length) for(let i = 0; i < deps.length; i++)deps[i].w |= trackOpBit;
};
const finalizeDepMarkers = (effect)=>{
    const { deps } = effect;
    if (deps.length) {
        let ptr = 0;
        for(let i = 0; i < deps.length; i++){
            const dep = deps[i];
            if (wasTracked(dep) && !newTracked(dep)) dep.delete(effect);
            else deps[ptr++] = dep;
            dep.w &= ~trackOpBit;
            dep.n &= ~trackOpBit;
        }
        deps.length = ptr;
    }
};
const targetMap = /* @__PURE__ */ new WeakMap();
let effectTrackDepth = 0;
let trackOpBit = 1;
const maxMarkerBits = 30;
let activeEffect;
const ITERATE_KEY = Symbol("iterate");
const MAP_KEY_ITERATE_KEY = Symbol("Map key iterate");
class ReactiveEffect {
    constructor(fn, scheduler = null, scope){
        this.fn = fn;
        this.scheduler = scheduler;
        this.active = true;
        this.deps = [];
        this.parent = void 0;
        recordEffectScope(this, scope);
    }
    run() {
        if (!this.active) return this.fn();
        let parent = activeEffect;
        let lastShouldTrack = shouldTrack;
        while(parent){
            if (parent === this) return;
            parent = parent.parent;
        }
        try {
            this.parent = activeEffect;
            activeEffect = this;
            shouldTrack = true;
            trackOpBit = 1 << ++effectTrackDepth;
            if (effectTrackDepth <= maxMarkerBits) initDepMarkers(this);
            else cleanupEffect(this);
            return this.fn();
        } finally{
            if (effectTrackDepth <= maxMarkerBits) finalizeDepMarkers(this);
            trackOpBit = 1 << --effectTrackDepth;
            activeEffect = this.parent;
            shouldTrack = lastShouldTrack;
            this.parent = void 0;
            if (this.deferStop) this.stop();
        }
    }
    stop() {
        if (activeEffect === this) this.deferStop = true;
        else if (this.active) {
            cleanupEffect(this);
            if (this.onStop) this.onStop();
            this.active = false;
        }
    }
}
function cleanupEffect(effect2) {
    const { deps } = effect2;
    if (deps.length) {
        for(let i = 0; i < deps.length; i++)deps[i].delete(effect2);
        deps.length = 0;
    }
}
function effect(fn, options) {
    if (fn.effect) fn = fn.effect.fn;
    const _effect = new ReactiveEffect(fn);
    if (options) {
        (0, _shared.extend)(_effect, options);
        if (options.scope) recordEffectScope(_effect, options.scope);
    }
    if (!options || !options.lazy) _effect.run();
    const runner = _effect.run.bind(_effect);
    runner.effect = _effect;
    return runner;
}
function stop(runner) {
    runner.effect.stop();
}
let shouldTrack = true;
const trackStack = [];
function pauseTracking() {
    trackStack.push(shouldTrack);
    shouldTrack = false;
}
function enableTracking() {
    trackStack.push(shouldTrack);
    shouldTrack = true;
}
function resetTracking() {
    const last = trackStack.pop();
    shouldTrack = last === void 0 ? true : last;
}
function track(target, type, key) {
    if (shouldTrack && activeEffect) {
        let depsMap = targetMap.get(target);
        if (!depsMap) targetMap.set(target, depsMap = /* @__PURE__ */ new Map());
        let dep = depsMap.get(key);
        if (!dep) depsMap.set(key, dep = createDep());
        const eventInfo = {
            effect: activeEffect,
            target,
            type,
            key
        };
        trackEffects(dep, eventInfo);
    }
}
function trackEffects(dep, debuggerEventExtraInfo) {
    let shouldTrack2 = false;
    if (effectTrackDepth <= maxMarkerBits) {
        if (!newTracked(dep)) {
            dep.n |= trackOpBit;
            shouldTrack2 = !wasTracked(dep);
        }
    } else shouldTrack2 = !dep.has(activeEffect);
    if (shouldTrack2) {
        dep.add(activeEffect);
        activeEffect.deps.push(dep);
        if (0, activeEffect.onTrack) activeEffect.onTrack((0, _shared.extend)({
            effect: activeEffect
        }, debuggerEventExtraInfo));
    }
}
function trigger(target, type, key, newValue, oldValue, oldTarget) {
    const depsMap = targetMap.get(target);
    if (!depsMap) return;
    let deps = [];
    if (type === "clear") deps = [
        ...depsMap.values()
    ];
    else if (key === "length" && (0, _shared.isArray)(target)) {
        const newLength = Number(newValue);
        depsMap.forEach((dep, key2)=>{
            if (key2 === "length" || key2 >= newLength) deps.push(dep);
        });
    } else {
        if (key !== void 0) deps.push(depsMap.get(key));
        switch(type){
            case "add":
                if (!(0, _shared.isArray)(target)) {
                    deps.push(depsMap.get(ITERATE_KEY));
                    if ((0, _shared.isMap)(target)) deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
                } else if ((0, _shared.isIntegerKey)(key)) deps.push(depsMap.get("length"));
                break;
            case "delete":
                if (!(0, _shared.isArray)(target)) {
                    deps.push(depsMap.get(ITERATE_KEY));
                    if ((0, _shared.isMap)(target)) deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
                }
                break;
            case "set":
                if ((0, _shared.isMap)(target)) deps.push(depsMap.get(ITERATE_KEY));
                break;
        }
    }
    const eventInfo = {
        target,
        type,
        key,
        newValue,
        oldValue,
        oldTarget
    };
    if (deps.length === 1) {
        if (deps[0]) triggerEffects(deps[0], eventInfo);
    } else {
        const effects = [];
        for (const dep of deps)if (dep) effects.push(...dep);
        triggerEffects(createDep(effects), eventInfo);
    }
}
function triggerEffects(dep, debuggerEventExtraInfo) {
    const effects = (0, _shared.isArray)(dep) ? dep : [
        ...dep
    ];
    for (const effect2 of effects)if (effect2.computed) triggerEffect(effect2, debuggerEventExtraInfo);
    for (const effect2 of effects)if (!effect2.computed) triggerEffect(effect2, debuggerEventExtraInfo);
}
function triggerEffect(effect2, debuggerEventExtraInfo) {
    if (effect2 !== activeEffect || effect2.allowRecurse) {
        if (0, effect2.onTrigger) effect2.onTrigger((0, _shared.extend)({
            effect: effect2
        }, debuggerEventExtraInfo));
        if (effect2.scheduler) effect2.scheduler();
        else effect2.run();
    }
}
function getDepFromReactive(object, key) {
    var _a;
    return (_a = targetMap.get(object)) == null ? void 0 : _a.get(key);
}
const isNonTrackableKeys = /* @__PURE__ */ (0, _shared.makeMap)(`__proto__,__v_isRef,__isVue`);
const builtInSymbols = new Set(/* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((key)=>key !== "arguments" && key !== "caller").map((key)=>Symbol[key]).filter((0, _shared.isSymbol)));
const get$1 = /* @__PURE__ */ createGetter();
const shallowGet = /* @__PURE__ */ createGetter(false, true);
const readonlyGet = /* @__PURE__ */ createGetter(true);
const shallowReadonlyGet = /* @__PURE__ */ createGetter(true, true);
const arrayInstrumentations = /* @__PURE__ */ createArrayInstrumentations();
function createArrayInstrumentations() {
    const instrumentations = {};
    [
        "includes",
        "indexOf",
        "lastIndexOf"
    ].forEach((key)=>{
        instrumentations[key] = function(...args) {
            const arr = toRaw(this);
            for(let i = 0, l = this.length; i < l; i++)track(arr, "get", i + "");
            const res = arr[key](...args);
            if (res === -1 || res === false) return arr[key](...args.map(toRaw));
            else return res;
        };
    });
    [
        "push",
        "pop",
        "shift",
        "unshift",
        "splice"
    ].forEach((key)=>{
        instrumentations[key] = function(...args) {
            pauseTracking();
            const res = toRaw(this)[key].apply(this, args);
            resetTracking();
            return res;
        };
    });
    return instrumentations;
}
function hasOwnProperty(key) {
    const obj = toRaw(this);
    track(obj, "has", key);
    return obj.hasOwnProperty(key);
}
function createGetter(isReadonly2 = false, shallow = false) {
    return function get2(target, key, receiver) {
        if (key === "__v_isReactive") return !isReadonly2;
        else if (key === "__v_isReadonly") return isReadonly2;
        else if (key === "__v_isShallow") return shallow;
        else if (key === "__v_raw" && receiver === (isReadonly2 ? shallow ? shallowReadonlyMap : readonlyMap : shallow ? shallowReactiveMap : reactiveMap).get(target)) return target;
        const targetIsArray = (0, _shared.isArray)(target);
        if (!isReadonly2) {
            if (targetIsArray && (0, _shared.hasOwn)(arrayInstrumentations, key)) return Reflect.get(arrayInstrumentations, key, receiver);
            if (key === "hasOwnProperty") return hasOwnProperty;
        }
        const res = Reflect.get(target, key, receiver);
        if ((0, _shared.isSymbol)(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) return res;
        if (!isReadonly2) track(target, "get", key);
        if (shallow) return res;
        if (isRef(res)) return targetIsArray && (0, _shared.isIntegerKey)(key) ? res : res.value;
        if ((0, _shared.isObject)(res)) return isReadonly2 ? readonly(res) : reactive(res);
        return res;
    };
}
const set$1 = /* @__PURE__ */ createSetter();
const shallowSet = /* @__PURE__ */ createSetter(true);
function createSetter(shallow = false) {
    return function set2(target, key, value, receiver) {
        let oldValue = target[key];
        if (isReadonly(oldValue) && isRef(oldValue) && !isRef(value)) return false;
        if (!shallow) {
            if (!isShallow(value) && !isReadonly(value)) {
                oldValue = toRaw(oldValue);
                value = toRaw(value);
            }
            if (!(0, _shared.isArray)(target) && isRef(oldValue) && !isRef(value)) {
                oldValue.value = value;
                return true;
            }
        }
        const hadKey = (0, _shared.isArray)(target) && (0, _shared.isIntegerKey)(key) ? Number(key) < target.length : (0, _shared.hasOwn)(target, key);
        const result = Reflect.set(target, key, value, receiver);
        if (target === toRaw(receiver)) {
            if (!hadKey) trigger(target, "add", key, value);
            else if ((0, _shared.hasChanged)(value, oldValue)) trigger(target, "set", key, value, oldValue);
        }
        return result;
    };
}
function deleteProperty(target, key) {
    const hadKey = (0, _shared.hasOwn)(target, key);
    const oldValue = target[key];
    const result = Reflect.deleteProperty(target, key);
    if (result && hadKey) trigger(target, "delete", key, void 0, oldValue);
    return result;
}
function has$1(target, key) {
    const result = Reflect.has(target, key);
    if (!(0, _shared.isSymbol)(key) || !builtInSymbols.has(key)) track(target, "has", key);
    return result;
}
function ownKeys(target) {
    track(target, "iterate", (0, _shared.isArray)(target) ? "length" : ITERATE_KEY);
    return Reflect.ownKeys(target);
}
const mutableHandlers = {
    get: get$1,
    set: set$1,
    deleteProperty,
    has: has$1,
    ownKeys
};
const readonlyHandlers = {
    get: readonlyGet,
    set (target, key) {
        warn(`Set operation on key "${String(key)}" failed: target is readonly.`, target);
        return true;
    },
    deleteProperty (target, key) {
        warn(`Delete operation on key "${String(key)}" failed: target is readonly.`, target);
        return true;
    }
};
const shallowReactiveHandlers = /* @__PURE__ */ (0, _shared.extend)({}, mutableHandlers, {
    get: shallowGet,
    set: shallowSet
});
const shallowReadonlyHandlers = /* @__PURE__ */ (0, _shared.extend)({}, readonlyHandlers, {
    get: shallowReadonlyGet
});
const toShallow = (value)=>value;
const getProto = (v)=>Reflect.getPrototypeOf(v);
function get(target, key, isReadonly = false, isShallow = false) {
    target = target["__v_raw"];
    const rawTarget = toRaw(target);
    const rawKey = toRaw(key);
    if (!isReadonly) {
        if (key !== rawKey) track(rawTarget, "get", key);
        track(rawTarget, "get", rawKey);
    }
    const { has: has2 } = getProto(rawTarget);
    const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;
    if (has2.call(rawTarget, key)) return wrap(target.get(key));
    else if (has2.call(rawTarget, rawKey)) return wrap(target.get(rawKey));
    else if (target !== rawTarget) target.get(key);
}
function has(key, isReadonly = false) {
    const target = this["__v_raw"];
    const rawTarget = toRaw(target);
    const rawKey = toRaw(key);
    if (!isReadonly) {
        if (key !== rawKey) track(rawTarget, "has", key);
        track(rawTarget, "has", rawKey);
    }
    return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);
}
function size(target, isReadonly = false) {
    target = target["__v_raw"];
    !isReadonly && track(toRaw(target), "iterate", ITERATE_KEY);
    return Reflect.get(target, "size", target);
}
function add(value) {
    value = toRaw(value);
    const target = toRaw(this);
    const proto = getProto(target);
    const hadKey = proto.has.call(target, value);
    if (!hadKey) {
        target.add(value);
        trigger(target, "add", value, value);
    }
    return this;
}
function set(key, value) {
    value = toRaw(value);
    const target = toRaw(this);
    const { has: has2, get: get2 } = getProto(target);
    let hadKey = has2.call(target, key);
    if (!hadKey) {
        key = toRaw(key);
        hadKey = has2.call(target, key);
    } else checkIdentityKeys(target, has2, key);
    const oldValue = get2.call(target, key);
    target.set(key, value);
    if (!hadKey) trigger(target, "add", key, value);
    else if ((0, _shared.hasChanged)(value, oldValue)) trigger(target, "set", key, value, oldValue);
    return this;
}
function deleteEntry(key) {
    const target = toRaw(this);
    const { has: has2, get: get2 } = getProto(target);
    let hadKey = has2.call(target, key);
    if (!hadKey) {
        key = toRaw(key);
        hadKey = has2.call(target, key);
    } else checkIdentityKeys(target, has2, key);
    const oldValue = get2 ? get2.call(target, key) : void 0;
    const result = target.delete(key);
    if (hadKey) trigger(target, "delete", key, void 0, oldValue);
    return result;
}
function clear() {
    const target = toRaw(this);
    const hadItems = target.size !== 0;
    const oldTarget = (0, _shared.isMap)(target) ? new Map(target) : new Set(target);
    const result = target.clear();
    if (hadItems) trigger(target, "clear", void 0, void 0, oldTarget);
    return result;
}
function createForEach(isReadonly, isShallow) {
    return function forEach(callback, thisArg) {
        const observed = this;
        const target = observed["__v_raw"];
        const rawTarget = toRaw(target);
        const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;
        !isReadonly && track(rawTarget, "iterate", ITERATE_KEY);
        return target.forEach((value, key)=>{
            return callback.call(thisArg, wrap(value), wrap(key), observed);
        });
    };
}
function createIterableMethod(method, isReadonly, isShallow) {
    return function(...args) {
        const target = this["__v_raw"];
        const rawTarget = toRaw(target);
        const targetIsMap = (0, _shared.isMap)(rawTarget);
        const isPair = method === "entries" || method === Symbol.iterator && targetIsMap;
        const isKeyOnly = method === "keys" && targetIsMap;
        const innerIterator = target[method](...args);
        const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;
        !isReadonly && track(rawTarget, "iterate", isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY);
        return {
            // iterator protocol
            next () {
                const { value, done } = innerIterator.next();
                return done ? {
                    value,
                    done
                } : {
                    value: isPair ? [
                        wrap(value[0]),
                        wrap(value[1])
                    ] : wrap(value),
                    done
                };
            },
            // iterable protocol
            [Symbol.iterator] () {
                return this;
            }
        };
    };
}
function createReadonlyMethod(type) {
    return function(...args) {
        {
            const key = args[0] ? `on key "${args[0]}" ` : ``;
            console.warn(`${(0, _shared.capitalize)(type)} operation ${key}failed: target is readonly.`, toRaw(this));
        }
        return type === "delete" ? false : this;
    };
}
function createInstrumentations() {
    const mutableInstrumentations2 = {
        get (key) {
            return get(this, key);
        },
        get size () {
            return size(this);
        },
        has,
        add,
        set,
        delete: deleteEntry,
        clear,
        forEach: createForEach(false, false)
    };
    const shallowInstrumentations2 = {
        get (key) {
            return get(this, key, false, true);
        },
        get size () {
            return size(this);
        },
        has,
        add,
        set,
        delete: deleteEntry,
        clear,
        forEach: createForEach(false, true)
    };
    const readonlyInstrumentations2 = {
        get (key) {
            return get(this, key, true);
        },
        get size () {
            return size(this, true);
        },
        has (key) {
            return has.call(this, key, true);
        },
        add: createReadonlyMethod("add"),
        set: createReadonlyMethod("set"),
        delete: createReadonlyMethod("delete"),
        clear: createReadonlyMethod("clear"),
        forEach: createForEach(true, false)
    };
    const shallowReadonlyInstrumentations2 = {
        get (key) {
            return get(this, key, true, true);
        },
        get size () {
            return size(this, true);
        },
        has (key) {
            return has.call(this, key, true);
        },
        add: createReadonlyMethod("add"),
        set: createReadonlyMethod("set"),
        delete: createReadonlyMethod("delete"),
        clear: createReadonlyMethod("clear"),
        forEach: createForEach(true, true)
    };
    const iteratorMethods = [
        "keys",
        "values",
        "entries",
        Symbol.iterator
    ];
    iteratorMethods.forEach((method)=>{
        mutableInstrumentations2[method] = createIterableMethod(method, false, false);
        readonlyInstrumentations2[method] = createIterableMethod(method, true, false);
        shallowInstrumentations2[method] = createIterableMethod(method, false, true);
        shallowReadonlyInstrumentations2[method] = createIterableMethod(method, true, true);
    });
    return [
        mutableInstrumentations2,
        readonlyInstrumentations2,
        shallowInstrumentations2,
        shallowReadonlyInstrumentations2
    ];
}
const [mutableInstrumentations, readonlyInstrumentations, shallowInstrumentations, shallowReadonlyInstrumentations] = /* @__PURE__ */ createInstrumentations();
function createInstrumentationGetter(isReadonly, shallow) {
    const instrumentations = shallow ? isReadonly ? shallowReadonlyInstrumentations : shallowInstrumentations : isReadonly ? readonlyInstrumentations : mutableInstrumentations;
    return (target, key, receiver)=>{
        if (key === "__v_isReactive") return !isReadonly;
        else if (key === "__v_isReadonly") return isReadonly;
        else if (key === "__v_raw") return target;
        return Reflect.get((0, _shared.hasOwn)(instrumentations, key) && key in target ? instrumentations : target, key, receiver);
    };
}
const mutableCollectionHandlers = {
    get: /* @__PURE__ */ createInstrumentationGetter(false, false)
};
const shallowCollectionHandlers = {
    get: /* @__PURE__ */ createInstrumentationGetter(false, true)
};
const readonlyCollectionHandlers = {
    get: /* @__PURE__ */ createInstrumentationGetter(true, false)
};
const shallowReadonlyCollectionHandlers = {
    get: /* @__PURE__ */ createInstrumentationGetter(true, true)
};
function checkIdentityKeys(target, has2, key) {
    const rawKey = toRaw(key);
    if (rawKey !== key && has2.call(target, rawKey)) {
        const type = (0, _shared.toRawType)(target);
        console.warn(`Reactive ${type} contains both the raw and reactive versions of the same object${type === `Map` ? ` as keys` : ``}, which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.`);
    }
}
const reactiveMap = /* @__PURE__ */ new WeakMap();
const shallowReactiveMap = /* @__PURE__ */ new WeakMap();
const readonlyMap = /* @__PURE__ */ new WeakMap();
const shallowReadonlyMap = /* @__PURE__ */ new WeakMap();
function targetTypeMap(rawType) {
    switch(rawType){
        case "Object":
        case "Array":
            return 1 /* COMMON */ ;
        case "Map":
        case "Set":
        case "WeakMap":
        case "WeakSet":
            return 2 /* COLLECTION */ ;
        default:
            return 0 /* INVALID */ ;
    }
}
function getTargetType(value) {
    return value["__v_skip"] || !Object.isExtensible(value) ? 0 /* INVALID */  : targetTypeMap((0, _shared.toRawType)(value));
}
function reactive(target) {
    if (isReadonly(target)) return target;
    return createReactiveObject(target, false, mutableHandlers, mutableCollectionHandlers, reactiveMap);
}
function shallowReactive(target) {
    return createReactiveObject(target, false, shallowReactiveHandlers, shallowCollectionHandlers, shallowReactiveMap);
}
function readonly(target) {
    return createReactiveObject(target, true, readonlyHandlers, readonlyCollectionHandlers, readonlyMap);
}
function shallowReadonly(target) {
    return createReactiveObject(target, true, shallowReadonlyHandlers, shallowReadonlyCollectionHandlers, shallowReadonlyMap);
}
function createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {
    if (!(0, _shared.isObject)(target)) {
        console.warn(`value cannot be made reactive: ${String(target)}`);
        return target;
    }
    if (target["__v_raw"] && !(isReadonly2 && target["__v_isReactive"])) return target;
    const existingProxy = proxyMap.get(target);
    if (existingProxy) return existingProxy;
    const targetType = getTargetType(target);
    if (targetType === 0 /* INVALID */ ) return target;
    const proxy = new Proxy(target, targetType === 2 /* COLLECTION */  ? collectionHandlers : baseHandlers);
    proxyMap.set(target, proxy);
    return proxy;
}
function isReactive(value) {
    if (isReadonly(value)) return isReactive(value["__v_raw"]);
    return !!(value && value["__v_isReactive"]);
}
function isReadonly(value) {
    return !!(value && value["__v_isReadonly"]);
}
function isShallow(value) {
    return !!(value && value["__v_isShallow"]);
}
function isProxy(value) {
    return isReactive(value) || isReadonly(value);
}
function toRaw(observed) {
    const raw = observed && observed["__v_raw"];
    return raw ? toRaw(raw) : observed;
}
function markRaw(value) {
    (0, _shared.def)(value, "__v_skip", true);
    return value;
}
const toReactive = (value)=>(0, _shared.isObject)(value) ? reactive(value) : value;
const toReadonly = (value)=>(0, _shared.isObject)(value) ? readonly(value) : value;
function trackRefValue(ref2) {
    if (shouldTrack && activeEffect) {
        ref2 = toRaw(ref2);
        trackEffects(ref2.dep || (ref2.dep = createDep()), {
            target: ref2,
            type: "get",
            key: "value"
        });
    }
}
function triggerRefValue(ref2, newVal) {
    ref2 = toRaw(ref2);
    const dep = ref2.dep;
    if (dep) triggerEffects(dep, {
        target: ref2,
        type: "set",
        key: "value",
        newValue: newVal
    });
}
function isRef(r) {
    return !!(r && r.__v_isRef === true);
}
function ref(value) {
    return createRef(value, false);
}
function shallowRef(value) {
    return createRef(value, true);
}
function createRef(rawValue, shallow) {
    if (isRef(rawValue)) return rawValue;
    return new RefImpl(rawValue, shallow);
}
class RefImpl {
    constructor(value, __v_isShallow){
        this.__v_isShallow = __v_isShallow;
        this.dep = void 0;
        this.__v_isRef = true;
        this._rawValue = __v_isShallow ? value : toRaw(value);
        this._value = __v_isShallow ? value : toReactive(value);
    }
    get value() {
        trackRefValue(this);
        return this._value;
    }
    set value(newVal) {
        const useDirectValue = this.__v_isShallow || isShallow(newVal) || isReadonly(newVal);
        newVal = useDirectValue ? newVal : toRaw(newVal);
        if ((0, _shared.hasChanged)(newVal, this._rawValue)) {
            this._rawValue = newVal;
            this._value = useDirectValue ? newVal : toReactive(newVal);
            triggerRefValue(this, newVal);
        }
    }
}
function triggerRef(ref2) {
    triggerRefValue(ref2, (0, ref2.value));
}
function unref(ref2) {
    return isRef(ref2) ? ref2.value : ref2;
}
function toValue(source) {
    return (0, _shared.isFunction)(source) ? source() : unref(source);
}
const shallowUnwrapHandlers = {
    get: (target, key, receiver)=>unref(Reflect.get(target, key, receiver)),
    set: (target, key, value, receiver)=>{
        const oldValue = target[key];
        if (isRef(oldValue) && !isRef(value)) {
            oldValue.value = value;
            return true;
        } else return Reflect.set(target, key, value, receiver);
    }
};
function proxyRefs(objectWithRefs) {
    return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);
}
class CustomRefImpl {
    constructor(factory){
        this.dep = void 0;
        this.__v_isRef = true;
        const { get, set } = factory(()=>trackRefValue(this), ()=>triggerRefValue(this));
        this._get = get;
        this._set = set;
    }
    get value() {
        return this._get();
    }
    set value(newVal) {
        this._set(newVal);
    }
}
function customRef(factory) {
    return new CustomRefImpl(factory);
}
function toRefs(object) {
    if (!isProxy(object)) console.warn(`toRefs() expects a reactive object but received a plain one.`);
    const ret = (0, _shared.isArray)(object) ? new Array(object.length) : {};
    for(const key in object)ret[key] = propertyToRef(object, key);
    return ret;
}
class ObjectRefImpl {
    constructor(_object, _key, _defaultValue){
        this._object = _object;
        this._key = _key;
        this._defaultValue = _defaultValue;
        this.__v_isRef = true;
    }
    get value() {
        const val = this._object[this._key];
        return val === void 0 ? this._defaultValue : val;
    }
    set value(newVal) {
        this._object[this._key] = newVal;
    }
    get dep() {
        return getDepFromReactive(toRaw(this._object), this._key);
    }
}
class GetterRefImpl {
    constructor(_getter){
        this._getter = _getter;
        this.__v_isRef = true;
        this.__v_isReadonly = true;
    }
    get value() {
        return this._getter();
    }
}
function toRef(source, key, defaultValue) {
    if (isRef(source)) return source;
    else if ((0, _shared.isFunction)(source)) return new GetterRefImpl(source);
    else if ((0, _shared.isObject)(source) && arguments.length > 1) return propertyToRef(source, key, defaultValue);
    else return ref(source);
}
function propertyToRef(source, key, defaultValue) {
    const val = source[key];
    return isRef(val) ? val : new ObjectRefImpl(source, key, defaultValue);
}
class ComputedRefImpl {
    constructor(getter, _setter, isReadonly, isSSR){
        this._setter = _setter;
        this.dep = void 0;
        this.__v_isRef = true;
        this["__v_isReadonly"] = false;
        this._dirty = true;
        this.effect = new ReactiveEffect(getter, ()=>{
            if (!this._dirty) {
                this._dirty = true;
                triggerRefValue(this);
            }
        });
        this.effect.computed = this;
        this.effect.active = this._cacheable = !isSSR;
        this["__v_isReadonly"] = isReadonly;
    }
    get value() {
        const self = toRaw(this);
        trackRefValue(self);
        if (self._dirty || !self._cacheable) {
            self._dirty = false;
            self._value = self.effect.run();
        }
        return self._value;
    }
    set value(newValue) {
        this._setter(newValue);
    }
}
function computed(getterOrOptions, debugOptions, isSSR = false) {
    let getter;
    let setter;
    const onlyGetter = (0, _shared.isFunction)(getterOrOptions);
    if (onlyGetter) {
        getter = getterOrOptions;
        setter = ()=>{
            console.warn("Write operation failed: computed value is readonly");
        };
    } else {
        getter = getterOrOptions.get;
        setter = getterOrOptions.set;
    }
    const cRef = new ComputedRefImpl(getter, setter, onlyGetter || !setter, isSSR);
    if (debugOptions && !isSSR) {
        cRef.effect.onTrack = debugOptions.onTrack;
        cRef.effect.onTrigger = debugOptions.onTrigger;
    }
    return cRef;
}
const tick = /* @__PURE__ */ Promise.resolve();
const queue = [];
let queued = false;
const scheduler = (fn)=>{
    queue.push(fn);
    if (!queued) {
        queued = true;
        tick.then(flush);
    }
};
const flush = ()=>{
    for(let i = 0; i < queue.length; i++)queue[i]();
    queue.length = 0;
    queued = false;
};
class DeferredComputedRefImpl {
    constructor(getter){
        this.dep = void 0;
        this._dirty = true;
        this.__v_isRef = true;
        this["__v_isReadonly"] = true;
        let compareTarget;
        let hasCompareTarget = false;
        let scheduled = false;
        this.effect = new ReactiveEffect(getter, (computedTrigger)=>{
            if (this.dep) {
                if (computedTrigger) {
                    compareTarget = this._value;
                    hasCompareTarget = true;
                } else if (!scheduled) {
                    const valueToCompare = hasCompareTarget ? compareTarget : this._value;
                    scheduled = true;
                    hasCompareTarget = false;
                    scheduler(()=>{
                        if (this.effect.active && this._get() !== valueToCompare) triggerRefValue(this);
                        scheduled = false;
                    });
                }
                for (const e of this.dep)if (e.computed instanceof DeferredComputedRefImpl) e.scheduler(true);
            }
            this._dirty = true;
        });
        this.effect.computed = this;
    }
    _get() {
        if (this._dirty) {
            this._dirty = false;
            return this._value = this.effect.run();
        }
        return this._value;
    }
    get value() {
        trackRefValue(this);
        return toRaw(this)._get();
    }
}
function deferredComputed(getter) {
    return new DeferredComputedRefImpl(getter);
}

},{"@vue/shared":"5YL8y","@parcel/transformer-js/src/esmodule-helpers.js":"boKlo"}],"5YL8y":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "EMPTY_ARR", ()=>EMPTY_ARR);
parcelHelpers.export(exports, "EMPTY_OBJ", ()=>EMPTY_OBJ);
parcelHelpers.export(exports, "NO", ()=>NO);
parcelHelpers.export(exports, "NOOP", ()=>NOOP);
parcelHelpers.export(exports, "PatchFlagNames", ()=>PatchFlagNames);
parcelHelpers.export(exports, "camelize", ()=>camelize);
parcelHelpers.export(exports, "capitalize", ()=>capitalize);
parcelHelpers.export(exports, "def", ()=>def);
parcelHelpers.export(exports, "escapeHtml", ()=>escapeHtml);
parcelHelpers.export(exports, "escapeHtmlComment", ()=>escapeHtmlComment);
parcelHelpers.export(exports, "extend", ()=>extend);
parcelHelpers.export(exports, "genPropsAccessExp", ()=>genPropsAccessExp);
parcelHelpers.export(exports, "generateCodeFrame", ()=>generateCodeFrame);
parcelHelpers.export(exports, "getGlobalThis", ()=>getGlobalThis);
parcelHelpers.export(exports, "hasChanged", ()=>hasChanged);
parcelHelpers.export(exports, "hasOwn", ()=>hasOwn);
parcelHelpers.export(exports, "hyphenate", ()=>hyphenate);
parcelHelpers.export(exports, "includeBooleanAttr", ()=>includeBooleanAttr);
parcelHelpers.export(exports, "invokeArrayFns", ()=>invokeArrayFns);
parcelHelpers.export(exports, "isArray", ()=>isArray);
parcelHelpers.export(exports, "isBooleanAttr", ()=>isBooleanAttr);
parcelHelpers.export(exports, "isBuiltInDirective", ()=>isBuiltInDirective);
parcelHelpers.export(exports, "isDate", ()=>isDate);
parcelHelpers.export(exports, "isFunction", ()=>isFunction);
parcelHelpers.export(exports, "isGloballyWhitelisted", ()=>isGloballyWhitelisted);
parcelHelpers.export(exports, "isHTMLTag", ()=>isHTMLTag);
parcelHelpers.export(exports, "isIntegerKey", ()=>isIntegerKey);
parcelHelpers.export(exports, "isKnownHtmlAttr", ()=>isKnownHtmlAttr);
parcelHelpers.export(exports, "isKnownSvgAttr", ()=>isKnownSvgAttr);
parcelHelpers.export(exports, "isMap", ()=>isMap);
parcelHelpers.export(exports, "isModelListener", ()=>isModelListener);
parcelHelpers.export(exports, "isObject", ()=>isObject);
parcelHelpers.export(exports, "isOn", ()=>isOn);
parcelHelpers.export(exports, "isPlainObject", ()=>isPlainObject);
parcelHelpers.export(exports, "isPromise", ()=>isPromise);
parcelHelpers.export(exports, "isRegExp", ()=>isRegExp);
parcelHelpers.export(exports, "isReservedProp", ()=>isReservedProp);
parcelHelpers.export(exports, "isSSRSafeAttrName", ()=>isSSRSafeAttrName);
parcelHelpers.export(exports, "isSVGTag", ()=>isSVGTag);
parcelHelpers.export(exports, "isSet", ()=>isSet);
parcelHelpers.export(exports, "isSpecialBooleanAttr", ()=>isSpecialBooleanAttr);
parcelHelpers.export(exports, "isString", ()=>isString);
parcelHelpers.export(exports, "isSymbol", ()=>isSymbol);
parcelHelpers.export(exports, "isVoidTag", ()=>isVoidTag);
parcelHelpers.export(exports, "looseEqual", ()=>looseEqual);
parcelHelpers.export(exports, "looseIndexOf", ()=>looseIndexOf);
parcelHelpers.export(exports, "looseToNumber", ()=>looseToNumber);
parcelHelpers.export(exports, "makeMap", ()=>makeMap);
parcelHelpers.export(exports, "normalizeClass", ()=>normalizeClass);
parcelHelpers.export(exports, "normalizeProps", ()=>normalizeProps);
parcelHelpers.export(exports, "normalizeStyle", ()=>normalizeStyle);
parcelHelpers.export(exports, "objectToString", ()=>objectToString);
parcelHelpers.export(exports, "parseStringStyle", ()=>parseStringStyle);
parcelHelpers.export(exports, "propsToAttrMap", ()=>propsToAttrMap);
parcelHelpers.export(exports, "remove", ()=>remove);
parcelHelpers.export(exports, "slotFlagsText", ()=>slotFlagsText);
parcelHelpers.export(exports, "stringifyStyle", ()=>stringifyStyle);
parcelHelpers.export(exports, "toDisplayString", ()=>toDisplayString);
parcelHelpers.export(exports, "toHandlerKey", ()=>toHandlerKey);
parcelHelpers.export(exports, "toNumber", ()=>toNumber);
parcelHelpers.export(exports, "toRawType", ()=>toRawType);
parcelHelpers.export(exports, "toTypeString", ()=>toTypeString);
var global = arguments[3];
function makeMap(str, expectsLowerCase) {
    const map = /* @__PURE__ */ Object.create(null);
    const list = str.split(",");
    for(let i = 0; i < list.length; i++)map[list[i]] = true;
    return expectsLowerCase ? (val)=>!!map[val.toLowerCase()] : (val)=>!!map[val];
}
const EMPTY_OBJ = Object.freeze({});
const EMPTY_ARR = Object.freeze([]);
const NOOP = ()=>{};
const NO = ()=>false;
const onRE = /^on[^a-z]/;
const isOn = (key)=>onRE.test(key);
const isModelListener = (key)=>key.startsWith("onUpdate:");
const extend = Object.assign;
const remove = (arr, el)=>{
    const i = arr.indexOf(el);
    if (i > -1) arr.splice(i, 1);
};
const hasOwnProperty = Object.prototype.hasOwnProperty;
const hasOwn = (val, key)=>hasOwnProperty.call(val, key);
const isArray = Array.isArray;
const isMap = (val)=>toTypeString(val) === "[object Map]";
const isSet = (val)=>toTypeString(val) === "[object Set]";
const isDate = (val)=>toTypeString(val) === "[object Date]";
const isRegExp = (val)=>toTypeString(val) === "[object RegExp]";
const isFunction = (val)=>typeof val === "function";
const isString = (val)=>typeof val === "string";
const isSymbol = (val)=>typeof val === "symbol";
const isObject = (val)=>val !== null && typeof val === "object";
const isPromise = (val)=>{
    return isObject(val) && isFunction(val.then) && isFunction(val.catch);
};
const objectToString = Object.prototype.toString;
const toTypeString = (value)=>objectToString.call(value);
const toRawType = (value)=>{
    return toTypeString(value).slice(8, -1);
};
const isPlainObject = (val)=>toTypeString(val) === "[object Object]";
const isIntegerKey = (key)=>isString(key) && key !== "NaN" && key[0] !== "-" && "" + parseInt(key, 10) === key;
const isReservedProp = /* @__PURE__ */ makeMap(// the leading comma is intentional so empty string "" is also included
",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted");
const isBuiltInDirective = /* @__PURE__ */ makeMap("bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo");
const cacheStringFunction = (fn)=>{
    const cache = /* @__PURE__ */ Object.create(null);
    return (str)=>{
        const hit = cache[str];
        return hit || (cache[str] = fn(str));
    };
};
const camelizeRE = /-(\w)/g;
const camelize = cacheStringFunction((str)=>{
    return str.replace(camelizeRE, (_, c)=>c ? c.toUpperCase() : "");
});
const hyphenateRE = /\B([A-Z])/g;
const hyphenate = cacheStringFunction((str)=>str.replace(hyphenateRE, "-$1").toLowerCase());
const capitalize = cacheStringFunction((str)=>str.charAt(0).toUpperCase() + str.slice(1));
const toHandlerKey = cacheStringFunction((str)=>str ? `on${capitalize(str)}` : ``);
const hasChanged = (value, oldValue)=>!Object.is(value, oldValue);
const invokeArrayFns = (fns, arg)=>{
    for(let i = 0; i < fns.length; i++)fns[i](arg);
};
const def = (obj, key, value)=>{
    Object.defineProperty(obj, key, {
        configurable: true,
        enumerable: false,
        value
    });
};
const looseToNumber = (val)=>{
    const n = parseFloat(val);
    return isNaN(n) ? val : n;
};
const toNumber = (val)=>{
    const n = isString(val) ? Number(val) : NaN;
    return isNaN(n) ? val : n;
};
let _globalThis;
const getGlobalThis = ()=>{
    return _globalThis || (_globalThis = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
};
const identRE = /^[_$a-zA-Z\xA0-\uFFFF][_$a-zA-Z0-9\xA0-\uFFFF]*$/;
function genPropsAccessExp(name) {
    return identRE.test(name) ? `__props.${name}` : `__props[${JSON.stringify(name)}]`;
}
const PatchFlagNames = {
    [1]: `TEXT`,
    [2]: `CLASS`,
    [4]: `STYLE`,
    [8]: `PROPS`,
    [16]: `FULL_PROPS`,
    [32]: `HYDRATE_EVENTS`,
    [64]: `STABLE_FRAGMENT`,
    [128]: `KEYED_FRAGMENT`,
    [256]: `UNKEYED_FRAGMENT`,
    [512]: `NEED_PATCH`,
    [1024]: `DYNAMIC_SLOTS`,
    [2048]: `DEV_ROOT_FRAGMENT`,
    [-1]: `HOISTED`,
    [-2]: `BAIL`
};
const slotFlagsText = {
    [1]: "STABLE",
    [2]: "DYNAMIC",
    [3]: "FORWARDED"
};
const GLOBALS_WHITE_LISTED = "Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt,console";
const isGloballyWhitelisted = /* @__PURE__ */ makeMap(GLOBALS_WHITE_LISTED);
const range = 2;
function generateCodeFrame(source, start = 0, end = source.length) {
    let lines = source.split(/(\r?\n)/);
    const newlineSequences = lines.filter((_, idx)=>idx % 2 === 1);
    lines = lines.filter((_, idx)=>idx % 2 === 0);
    let count = 0;
    const res = [];
    for(let i = 0; i < lines.length; i++){
        count += lines[i].length + (newlineSequences[i] && newlineSequences[i].length || 0);
        if (count >= start) {
            for(let j = i - range; j <= i + range || end > count; j++){
                if (j < 0 || j >= lines.length) continue;
                const line = j + 1;
                res.push(`${line}${" ".repeat(Math.max(3 - String(line).length, 0))}|  ${lines[j]}`);
                const lineLength = lines[j].length;
                const newLineSeqLength = newlineSequences[j] && newlineSequences[j].length || 0;
                if (j === i) {
                    const pad = start - (count - (lineLength + newLineSeqLength));
                    const length = Math.max(1, end > count ? lineLength - pad : end - start);
                    res.push(`   |  ` + " ".repeat(pad) + "^".repeat(length));
                } else if (j > i) {
                    if (end > count) {
                        const length = Math.max(Math.min(end - count, lineLength), 1);
                        res.push(`   |  ` + "^".repeat(length));
                    }
                    count += lineLength + newLineSeqLength;
                }
            }
            break;
        }
    }
    return res.join("\n");
}
function normalizeStyle(value) {
    if (isArray(value)) {
        const res = {};
        for(let i = 0; i < value.length; i++){
            const item = value[i];
            const normalized = isString(item) ? parseStringStyle(item) : normalizeStyle(item);
            if (normalized) for(const key in normalized)res[key] = normalized[key];
        }
        return res;
    } else if (isString(value)) return value;
    else if (isObject(value)) return value;
}
const listDelimiterRE = /;(?![^(]*\))/g;
const propertyDelimiterRE = /:([^]+)/;
const styleCommentRE = /\/\*[^]*?\*\//g;
function parseStringStyle(cssText) {
    const ret = {};
    cssText.replace(styleCommentRE, "").split(listDelimiterRE).forEach((item)=>{
        if (item) {
            const tmp = item.split(propertyDelimiterRE);
            tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
        }
    });
    return ret;
}
function stringifyStyle(styles) {
    let ret = "";
    if (!styles || isString(styles)) return ret;
    for(const key in styles){
        const value = styles[key];
        const normalizedKey = key.startsWith(`--`) ? key : hyphenate(key);
        if (isString(value) || typeof value === "number") ret += `${normalizedKey}:${value};`;
    }
    return ret;
}
function normalizeClass(value) {
    let res = "";
    if (isString(value)) res = value;
    else if (isArray(value)) for(let i = 0; i < value.length; i++){
        const normalized = normalizeClass(value[i]);
        if (normalized) res += normalized + " ";
    }
    else if (isObject(value)) {
        for(const name in value)if (value[name]) res += name + " ";
    }
    return res.trim();
}
function normalizeProps(props) {
    if (!props) return null;
    let { class: klass, style } = props;
    if (klass && !isString(klass)) props.class = normalizeClass(klass);
    if (style) props.style = normalizeStyle(style);
    return props;
}
const HTML_TAGS = "html,body,base,head,link,meta,style,title,address,article,aside,footer,header,hgroup,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot";
const SVG_TAGS = "svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistantLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,text,textPath,title,tspan,unknown,use,view";
const VOID_TAGS = "area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr";
const isHTMLTag = /* @__PURE__ */ makeMap(HTML_TAGS);
const isSVGTag = /* @__PURE__ */ makeMap(SVG_TAGS);
const isVoidTag = /* @__PURE__ */ makeMap(VOID_TAGS);
const specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
const isSpecialBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs);
const isBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs + `,async,autofocus,autoplay,controls,default,defer,disabled,hidden,inert,loop,open,required,reversed,scoped,seamless,checked,muted,multiple,selected`);
function includeBooleanAttr(value) {
    return !!value || value === "";
}
const unsafeAttrCharRE = /[>/="'\u0009\u000a\u000c\u0020]/;
const attrValidationCache = {};
function isSSRSafeAttrName(name) {
    if (attrValidationCache.hasOwnProperty(name)) return attrValidationCache[name];
    const isUnsafe = unsafeAttrCharRE.test(name);
    if (isUnsafe) console.error(`unsafe attribute name: ${name}`);
    return attrValidationCache[name] = !isUnsafe;
}
const propsToAttrMap = {
    acceptCharset: "accept-charset",
    className: "class",
    htmlFor: "for",
    httpEquiv: "http-equiv"
};
const isKnownHtmlAttr = /* @__PURE__ */ makeMap(`accept,accept-charset,accesskey,action,align,allow,alt,async,autocapitalize,autocomplete,autofocus,autoplay,background,bgcolor,border,buffered,capture,challenge,charset,checked,cite,class,code,codebase,color,cols,colspan,content,contenteditable,contextmenu,controls,coords,crossorigin,csp,data,datetime,decoding,default,defer,dir,dirname,disabled,download,draggable,dropzone,enctype,enterkeyhint,for,form,formaction,formenctype,formmethod,formnovalidate,formtarget,headers,height,hidden,high,href,hreflang,http-equiv,icon,id,importance,inert,integrity,ismap,itemprop,keytype,kind,label,lang,language,loading,list,loop,low,manifest,max,maxlength,minlength,media,min,multiple,muted,name,novalidate,open,optimum,pattern,ping,placeholder,poster,preload,radiogroup,readonly,referrerpolicy,rel,required,reversed,rows,rowspan,sandbox,scope,scoped,selected,shape,size,sizes,slot,span,spellcheck,src,srcdoc,srclang,srcset,start,step,style,summary,tabindex,target,title,translate,type,usemap,value,width,wrap`);
const isKnownSvgAttr = /* @__PURE__ */ makeMap(`xmlns,accent-height,accumulate,additive,alignment-baseline,alphabetic,amplitude,arabic-form,ascent,attributeName,attributeType,azimuth,baseFrequency,baseline-shift,baseProfile,bbox,begin,bias,by,calcMode,cap-height,class,clip,clipPathUnits,clip-path,clip-rule,color,color-interpolation,color-interpolation-filters,color-profile,color-rendering,contentScriptType,contentStyleType,crossorigin,cursor,cx,cy,d,decelerate,descent,diffuseConstant,direction,display,divisor,dominant-baseline,dur,dx,dy,edgeMode,elevation,enable-background,end,exponent,fill,fill-opacity,fill-rule,filter,filterRes,filterUnits,flood-color,flood-opacity,font-family,font-size,font-size-adjust,font-stretch,font-style,font-variant,font-weight,format,from,fr,fx,fy,g1,g2,glyph-name,glyph-orientation-horizontal,glyph-orientation-vertical,glyphRef,gradientTransform,gradientUnits,hanging,height,href,hreflang,horiz-adv-x,horiz-origin-x,id,ideographic,image-rendering,in,in2,intercept,k,k1,k2,k3,k4,kernelMatrix,kernelUnitLength,kerning,keyPoints,keySplines,keyTimes,lang,lengthAdjust,letter-spacing,lighting-color,limitingConeAngle,local,marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,mask,maskContentUnits,maskUnits,mathematical,max,media,method,min,mode,name,numOctaves,offset,opacity,operator,order,orient,orientation,origin,overflow,overline-position,overline-thickness,panose-1,paint-order,path,pathLength,patternContentUnits,patternTransform,patternUnits,ping,pointer-events,points,pointsAtX,pointsAtY,pointsAtZ,preserveAlpha,preserveAspectRatio,primitiveUnits,r,radius,referrerPolicy,refX,refY,rel,rendering-intent,repeatCount,repeatDur,requiredExtensions,requiredFeatures,restart,result,rotate,rx,ry,scale,seed,shape-rendering,slope,spacing,specularConstant,specularExponent,speed,spreadMethod,startOffset,stdDeviation,stemh,stemv,stitchTiles,stop-color,stop-opacity,strikethrough-position,strikethrough-thickness,string,stroke,stroke-dasharray,stroke-dashoffset,stroke-linecap,stroke-linejoin,stroke-miterlimit,stroke-opacity,stroke-width,style,surfaceScale,systemLanguage,tabindex,tableValues,target,targetX,targetY,text-anchor,text-decoration,text-rendering,textLength,to,transform,transform-origin,type,u1,u2,underline-position,underline-thickness,unicode,unicode-bidi,unicode-range,units-per-em,v-alphabetic,v-hanging,v-ideographic,v-mathematical,values,vector-effect,version,vert-adv-y,vert-origin-x,vert-origin-y,viewBox,viewTarget,visibility,width,widths,word-spacing,writing-mode,x,x-height,x1,x2,xChannelSelector,xlink:actuate,xlink:arcrole,xlink:href,xlink:role,xlink:show,xlink:title,xlink:type,xml:base,xml:lang,xml:space,y,y1,y2,yChannelSelector,z,zoomAndPan`);
const escapeRE = /["'&<>]/;
function escapeHtml(string) {
    const str = "" + string;
    const match = escapeRE.exec(str);
    if (!match) return str;
    let html = "";
    let escaped;
    let index;
    let lastIndex = 0;
    for(index = match.index; index < str.length; index++){
        switch(str.charCodeAt(index)){
            case 34:
                escaped = "&quot;";
                break;
            case 38:
                escaped = "&amp;";
                break;
            case 39:
                escaped = "&#39;";
                break;
            case 60:
                escaped = "&lt;";
                break;
            case 62:
                escaped = "&gt;";
                break;
            default:
                continue;
        }
        if (lastIndex !== index) html += str.slice(lastIndex, index);
        lastIndex = index + 1;
        html += escaped;
    }
    return lastIndex !== index ? html + str.slice(lastIndex, index) : html;
}
const commentStripRE = /^-?>|<!--|-->|--!>|<!-$/g;
function escapeHtmlComment(src) {
    return src.replace(commentStripRE, "");
}
function looseCompareArrays(a, b) {
    if (a.length !== b.length) return false;
    let equal = true;
    for(let i = 0; equal && i < a.length; i++)equal = looseEqual(a[i], b[i]);
    return equal;
}
function looseEqual(a, b) {
    if (a === b) return true;
    let aValidType = isDate(a);
    let bValidType = isDate(b);
    if (aValidType || bValidType) return aValidType && bValidType ? a.getTime() === b.getTime() : false;
    aValidType = isSymbol(a);
    bValidType = isSymbol(b);
    if (aValidType || bValidType) return a === b;
    aValidType = isArray(a);
    bValidType = isArray(b);
    if (aValidType || bValidType) return aValidType && bValidType ? looseCompareArrays(a, b) : false;
    aValidType = isObject(a);
    bValidType = isObject(b);
    if (aValidType || bValidType) {
        if (!aValidType || !bValidType) return false;
        const aKeysCount = Object.keys(a).length;
        const bKeysCount = Object.keys(b).length;
        if (aKeysCount !== bKeysCount) return false;
        for(const key in a){
            const aHasKey = a.hasOwnProperty(key);
            const bHasKey = b.hasOwnProperty(key);
            if (aHasKey && !bHasKey || !aHasKey && bHasKey || !looseEqual(a[key], b[key])) return false;
        }
    }
    return String(a) === String(b);
}
function looseIndexOf(arr, val) {
    return arr.findIndex((item)=>looseEqual(item, val));
}
const toDisplayString = (val)=>{
    return isString(val) ? val : val == null ? "" : isArray(val) || isObject(val) && (val.toString === objectToString || !isFunction(val.toString)) ? JSON.stringify(val, replacer, 2) : String(val);
};
const replacer = (_key, val)=>{
    if (val && val.__v_isRef) return replacer(_key, val.value);
    else if (isMap(val)) return {
        [`Map(${val.size})`]: [
            ...val.entries()
        ].reduce((entries, [key, val2])=>{
            entries[`${key} =>`] = val2;
            return entries;
        }, {})
    };
    else if (isSet(val)) return {
        [`Set(${val.size})`]: [
            ...val.values()
        ]
    };
    else if (isObject(val) && !isArray(val) && !isPlainObject(val)) return String(val);
    return val;
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"boKlo"}],"boKlo":[function(require,module,exports) {
exports.interopDefault = function(a) {
    return a && a.__esModule ? a : {
        default: a
    };
};
exports.defineInteropFlag = function(a) {
    Object.defineProperty(a, "__esModule", {
        value: true
    });
};
exports.exportAll = function(source, dest) {
    Object.keys(source).forEach(function(key) {
        if (key === "default" || key === "__esModule" || dest.hasOwnProperty(key)) return;
        Object.defineProperty(dest, key, {
            enumerable: true,
            get: function() {
                return source[key];
            }
        });
    });
    return dest;
};
exports.export = function(dest, destName, get) {
    Object.defineProperty(dest, destName, {
        enumerable: true,
        get: get
    });
};

},{}],"b2Mq6":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "createShadowContainer", ()=>createShadowContainer);
parcelHelpers.export(exports, "createAnchorObserver", ()=>createAnchorObserver);
parcelHelpers.export(exports, "createRender", ()=>createRender);
async function createShadowDOM(Mount) {
    const shadowHost = document.createElement("plasmo-csui");
    const shadowRoot = typeof Mount.createShadowRoot === "function" ? await Mount.createShadowRoot(shadowHost) : shadowHost.attachShadow({
        mode: "open"
    });
    const shadowContainer = document.createElement("div");
    shadowContainer.id = "plasmo-shadow-container";
    shadowContainer.style.zIndex = "2147483647";
    shadowContainer.style.position = "relative";
    shadowRoot.appendChild(shadowContainer);
    return {
        shadowHost,
        shadowRoot,
        shadowContainer
    };
}
async function injectAnchor(Mount, anchor, { shadowHost, shadowRoot }, mountState) {
    if (typeof Mount.getStyle === "function") {
        const sfcStyleContent = typeof Mount.getSfcStyleContent === "function" ? await Mount.getSfcStyleContent() : "";
        shadowRoot.prepend(await Mount.getStyle({
            ...anchor,
            sfcStyleContent
        }));
    }
    if (typeof Mount.getShadowHostId === "function") shadowHost.id = await Mount.getShadowHostId(anchor);
    if (typeof Mount.mountShadowHost === "function") await Mount.mountShadowHost({
        shadowHost,
        anchor,
        mountState
    });
    else if (anchor.type === "inline") anchor.element.insertAdjacentElement("afterend", shadowHost);
    else document.documentElement.prepend(shadowHost);
}
async function createShadowContainer(Mount, anchor, mountState) {
    const shadowDom = await createShadowDOM(Mount);
    mountState?.hostSet.add(shadowDom.shadowHost);
    mountState?.hostMap.set(shadowDom.shadowHost, anchor);
    await injectAnchor(Mount, anchor, shadowDom, mountState);
    return shadowDom.shadowContainer;
}
const isVisible = (el)=>{
    if (!el) return false;
    const elementRect = el.getBoundingClientRect();
    const elementStyle = globalThis.getComputedStyle(el);
    // console.log(elementRect, elementStyle)
    if (elementStyle.display === "none") return false;
    if (elementStyle.visibility === "hidden") return false;
    if (elementStyle.opacity === "0") return false;
    if (elementRect.width === 0 && elementRect.height === 0 && elementStyle.overflow !== "hidden") return false;
    // Check if the element is irrevocably off-screen:
    if (elementRect.x + elementRect.width < 0 || elementRect.y + elementRect.height < 0) return false;
    return true;
};
function createAnchorObserver(Mount) {
    const mountState = {
        document: document || window.document,
        observer: null,
        mountInterval: null,
        isMounting: false,
        isMutated: false,
        hostSet: new Set(),
        hostMap: new WeakMap(),
        overlayTargetList: []
    };
    const isMounted = (el)=>el?.id ? !!document.getElementById(el.id) : el?.getRootNode({
            composed: true
        }) === mountState.document;
    const hasInlineAnchor = typeof Mount.getInlineAnchor === "function";
    const hasOverlayAnchor = typeof Mount.getOverlayAnchor === "function";
    const hasInlineAnchorList = typeof Mount.getInlineAnchorList === "function";
    const hasOverlayAnchorList = typeof Mount.getOverlayAnchorList === "function";
    const shouldObserve = hasInlineAnchor || hasOverlayAnchor || hasInlineAnchorList || hasOverlayAnchorList;
    if (!shouldObserve) return null;
    async function mountAnchors(render) {
        mountState.isMounting = true;
        const mountedInlineAnchorSet = new WeakSet();
        // There should only be 1 overlay mount
        let overlayHost = null;
        // Go through mounted sets and check if they are still mounted
        for (const el of mountState.hostSet)if (isMounted(el)) {
            const anchor = mountState.hostMap.get(el);
            if (!!anchor) {
                if (anchor.type === "inline") mountedInlineAnchorSet.add(anchor.element);
                else if (anchor.type === "overlay") overlayHost = el;
            }
        } else mountState.hostSet.delete(el);
        const [inlineAnchor, inlineAnchorList, overlayAnchor, overlayAnchorList] = await Promise.all([
            hasInlineAnchor ? Mount.getInlineAnchor() : null,
            hasInlineAnchorList ? Mount.getInlineAnchorList() : null,
            hasOverlayAnchor ? Mount.getOverlayAnchor() : null,
            hasOverlayAnchorList ? Mount.getOverlayAnchorList() : null
        ]);
        const renderList = [];
        if (!!inlineAnchor && !mountedInlineAnchorSet.has(inlineAnchor)) renderList.push({
            element: inlineAnchor,
            type: "inline"
        });
        if ((inlineAnchorList?.length || 0) > 0) inlineAnchorList.forEach((inlineAnchor)=>{
            if (inlineAnchor instanceof Element && !mountedInlineAnchorSet.has(inlineAnchor)) renderList.push({
                element: inlineAnchor,
                type: "inline"
            });
        });
        const overlayTargetList = [];
        if (!!overlayAnchor && isVisible(overlayAnchor)) overlayTargetList.push(overlayAnchor);
        if ((overlayAnchorList?.length || 0) > 0) overlayAnchorList.forEach((el)=>{
            if (el instanceof Element && isVisible(el)) overlayTargetList.push(el);
        });
        if (overlayTargetList.length > 0) {
            mountState.overlayTargetList = overlayTargetList;
            if (!overlayHost) renderList.push({
                element: document.documentElement,
                type: "overlay"
            });
        } else {
            overlayHost?.remove();
            mountState.hostSet.delete(overlayHost);
        }
        await Promise.all(renderList.map(render));
        if (mountState.isMutated) {
            mountState.isMutated = false;
            await mountAnchors(render);
        }
        mountState.isMounting = false;
    }
    const start = (render)=>{
        mountState.observer = new MutationObserver(()=>{
            if (mountState.isMounting) {
                mountState.isMutated = true;
                return;
            }
            mountAnchors(render);
        });
        // Need to watch the subtree for shadowDOM
        mountState.observer.observe(document.documentElement, {
            childList: true,
            subtree: true
        });
        mountState.mountInterval = setInterval(()=>{
            if (mountState.isMounting) {
                mountState.isMutated = true;
                return;
            }
            mountAnchors(render);
        }, 142);
    };
    return {
        start,
        mountState
    };
}
const createRender = (Mount, containers, mountState, renderFx)=>{
    const createRootContainer = (anchor)=>typeof Mount.getRootContainer === "function" ? Mount.getRootContainer({
            anchor,
            mountState
        }) : createShadowContainer(Mount, anchor, mountState);
    if (typeof Mount.render === "function") return (anchor)=>Mount.render({
            anchor,
            createRootContainer
        }, ...containers);
    return async (anchor)=>{
        const rootContainer = await createRootContainer(anchor);
        return renderFx(anchor, rootContainer);
    };
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"boKlo"}],"7z4EY":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "createOverlayCSUIContainer", ()=>createOverlayCSUIContainer);
parcelHelpers.export(exports, "createInlineCSUIContainer", ()=>createInlineCSUIContainer);
const createOverlayCSUIContainer = (props)=>{
    const container = document.createElement("div");
    container.className = "plasmo-csui-container";
    container.id = props.id;
    container.style.cssText = `
    display: flex;
    position: relative;
    top: 0px;
    left: 0px;
  `;
    if (props.anchor.type === "overlay") {
        const updatePosition = async ()=>{
            const rect = props.anchor.element.getBoundingClientRect();
            if (!rect) return;
            const pos = {
                left: rect.left + window.scrollX,
                top: rect.top + window.scrollY
            };
            container.style.top = `${pos.top}px`;
            container.style.left = `${pos.left}px`;
        };
        updatePosition();
        props.watchOverlayAnchor?.(updatePosition);
        window.addEventListener("scroll", updatePosition);
        window.addEventListener("resize", updatePosition);
    }
    return container;
};
const createInlineCSUIContainer = (props)=>{
    const container = document.createElement("div");
    container.className = "plasmo-csui-container";
    container.id = "plasmo-inline";
    container.style.cssText = `
    display: flex;
    position: relative;
    top: 0px;
    left: 0px;
  `;
    return container;
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"boKlo"}],"4j7Mh":[function(require,module,exports) {
globalThis.__VUE_OPTIONS_API__ = true;
globalThis.__VUE_PROD_DEVTOOLS__ = true;

},{}],"lmDTV":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
let script;
let initialize = ()=>{
    script = require("6f7e64279f59014e");
    if (script.__esModule) script = script.default;
    script.render = require("1547550baebce2fe").render;
    require("2b517b1c0c8fa3a5").default(script);
    script.__scopeId = "data-v-bb9a52";
    script.__file = "/Users/davidzimberknopf/Documents/Apps/vue-plasmo-text/src/contents/plasmo-overlay.vue";
};
initialize();
if (module.hot) {
    script.__hmrId = "bb9a52-hmr";
    module.hot.accept(()=>{
        setTimeout(()=>{
            initialize();
            if (!__VUE_HMR_RUNTIME__.createRecord("bb9a52-hmr", script)) __VUE_HMR_RUNTIME__.reload("bb9a52-hmr", script);
        }, 0);
    });
}
exports.default = script;

},{"6f7e64279f59014e":"gSoUF","1547550baebce2fe":"eC1Wg","2b517b1c0c8fa3a5":"vB9fF","@parcel/transformer-js/src/esmodule-helpers.js":"boKlo"}],"gSoUF":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "config", ()=>config);
var _plasmoOverlayCss = require("data-text:~/contents/plasmo-overlay.css");
var _plasmoOverlayCssDefault = parcelHelpers.interopDefault(_plasmoOverlayCss);
const config = {
    matches: [
        "https://www.plasmo.com/*"
    ]
};
const getStyle = ()=>{
    const style = document.createElement("style");
    style.textContent = (0, _plasmoOverlayCssDefault.default);
    return style;
};
exports.default = {
    plasmo: {
        getStyle
    },
    setup () {},
    mounted () {}
};

},{"data-text:~/contents/plasmo-overlay.css":"kGyuA","@parcel/transformer-js/src/esmodule-helpers.js":"boKlo"}],"kGyuA":[function(require,module,exports) {
module.exports = ".hw-top {\n  color: #fff;\n  background: red;\n  font-family: Fascinate;\n}\n\n#plasmo-shadow-container {\n  background-color: purple;\n  width: 200px;\n}\n\n#plasmo-mount-container {\n  border: 8px solid #0ff;\n}\n\n";

},{}],"eC1Wg":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "render", ()=>render);
var _vue = require("vue");
const _hoisted_1 = {
    className: "hw-top"
};
function render(_ctx, _cache, $props, $setup, $data, $options) {
    return (0, _vue.openBlock)(), (0, _vue.createElementBlock)("span", _hoisted_1, " If I can have honesty, it's easier to overlook mistakes ");
}
if (module.hot) module.hot.accept(()=>{
    __VUE_HMR_RUNTIME__.rerender("bb9a52-hmr", render);
});

},{"vue":"dmrjI","@parcel/transformer-js/src/esmodule-helpers.js":"boKlo"}],"vB9fF":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
let NOOP = ()=>{};
exports.default = (script)=>{};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"boKlo"}],"Lil6q":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const styleRawString = ``;
exports.default = styleRawString;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"boKlo"}]},["V8rbn","keCgq"], "keCgq", "parcelRequire05f1")

//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFPO0FBQ1Q7OztBQ3REQSxXQUFXLHNCQUFzQjtBQUNqQyxXQUFXLHdCQUF3Qjs7Ozs7QUNBbEMsSUFBSTtBQUNKLElBQUksYUFBYTtJQUNmLFNBQVMsUUFBUTtJQUNqQixJQUFJLE9BQU8sWUFBWSxTQUFTLE9BQU87SUFDdkMsT0FBTyxTQUFTLFFBQVEsb0JBQWlDO0lBRXpELFFBQVEsb0JBQStCLFFBQVE7SUFDL0MsT0FBTyxZQUFZO0lBQ25CLE9BQU8sU0FBUztBQUNsQjtBQUNBO0FBQ0EsSUFBSSxPQUFPLEtBQUs7SUFDZCxPQUFPLFVBQVU7SUFDakIsT0FBTyxJQUFJLE9BQU87UUFDaEIsV0FBVztZQUNUO1lBQ0EsSUFBSSxDQUFDLG9CQUFvQixhQUFhLGNBQWMsU0FDbEQsb0JBQW9CLE9BQU8sY0FBYztRQUU3QyxHQUFHO0lBQ0w7QUFDRjtrQkFDZTs7Ozs7NENBYkg7QUFIYjs7QUFHTyxNQUFNLFNBQXlCO0lBQ3BDLFNBQVM7UUFBQztLQUFWO0FBQ0Y7QUFFQSxNQUFNLFdBQTJCO0lBQy9CLE1BQU0sUUFBUSxTQUFTLGNBQWM7SUFDckMsTUFBTSxjQUFjLENBQUEsR0FBQSxnQ0FBTTtJQUMxQixPQUFPO0FBQ1Q7a0JBRWU7SUFDYixRQUFRO1FBQ047SUFDRjtJQUNBLFVBQVM7SUFDVCxZQUFXO0FBQ2I7OztBQzFCQSxPQUFPLFVBQVU7Ozs7O0EsNEM7QTtBRENULE1BQUEsYUFBQTtJQUFBLFdBQVU7QUFBVjtBLFMsTyxJLEUsTSxFLE0sRSxNLEUsSyxFLFE7SUFBTixPQUFBLENBQUEsR0FBQSxjQUFBLEtBQUEsQ0FBQSxHQUFBLHVCQUFBLEVBRU8sUUFGUCxZQUF5QjtBO0EsSSxPLEssTyxJLE87SSxvQixTLGM7QTs7Ozs7QUFBMUIsSUFBSSxPQUFPLEtBQU87a0JBRUgsQ0FBQSxVQUVmOzs7OztBQUpELE1BQU0saUJBQWlCLENBQUMsQ0FBQztrQkFDViIsInNvdXJjZXMiOlsibm9kZV9tb2R1bGVzL0BwbGFzbW9ocS9wYXJjZWwtcnVudGltZS9kaXN0L3J1bnRpbWUtN2E5MTZjM2M4Mzc0OWRmYy5qcyIsIi5wbGFzbW8vc3RhdGljL2NvbnRlbnRzL3BsYXNtby1vdmVybGF5LnRzIiwibm9kZV9tb2R1bGVzL3Z1ZS9kaXN0L3Z1ZS5ydW50aW1lLmVzbS1idW5kbGVyLmpzIiwibm9kZV9tb2R1bGVzL0B2dWUvcnVudGltZS1kb20vZGlzdC9ydW50aW1lLWRvbS5lc20tYnVuZGxlci5qcyIsIm5vZGVfbW9kdWxlcy9AdnVlL3J1bnRpbWUtY29yZS9kaXN0L3J1bnRpbWUtY29yZS5lc20tYnVuZGxlci5qcyIsIm5vZGVfbW9kdWxlcy9AdnVlL3JlYWN0aXZpdHkvZGlzdC9yZWFjdGl2aXR5LmVzbS1idW5kbGVyLmpzIiwibm9kZV9tb2R1bGVzL0B2dWUvc2hhcmVkL2Rpc3Qvc2hhcmVkLmVzbS1idW5kbGVyLmpzIiwibm9kZV9tb2R1bGVzL0BwYXJjZWwvdHJhbnNmb3JtZXItanMvc3JjL2VzbW9kdWxlLWhlbHBlcnMuanMiLCIucGxhc21vL3N0YXRpYy9jb21tb24vY3N1aS50cyIsIi5wbGFzbW8vc3RhdGljL2NvbW1vbi9jc3VpLWNvbnRhaW5lci12YW5pbGxhLnRzeCIsIi5wbGFzbW8vc3RhdGljL2NvbW1vbi92dWUudHMiLCJzcmMvY29udGVudHMvcGxhc21vLW92ZXJsYXkudnVlIiwibm9kZV9tb2R1bGVzL0BwYXJjZWwvcnVudGltZS1qcy9saWIvYnVuZGxlcy9ydW50aW1lLTU2MTg2MWZkMGE1ZTVkOWUuanMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIHA9dHlwZW9mIGdsb2JhbFRoaXMucHJvY2VzczxcInVcIj9nbG9iYWxUaGlzLnByb2Nlc3MuYXJndjpbXTt2YXIgeT0oKT0+dHlwZW9mIGdsb2JhbFRoaXMucHJvY2VzczxcInVcIj9nbG9iYWxUaGlzLnByb2Nlc3MuZW52Ont9O3ZhciBNPW5ldyBTZXQocCksXz1lPT5NLmhhcyhlKSx6PXAuZmlsdGVyKGU9PmUuc3RhcnRzV2l0aChcIi0tXCIpJiZlLmluY2x1ZGVzKFwiPVwiKSkubWFwKGU9PmUuc3BsaXQoXCI9XCIpKS5yZWR1Y2UoKGUsW3Qsb10pPT4oZVt0XT1vLGUpLHt9KTt2YXIgWD1fKFwiLS1kcnktcnVuXCIpLGQ9KCk9Pl8oXCItLXZlcmJvc2VcIil8fHkoKS5WRVJCT1NFPT09XCJ0cnVlXCIsRz1kKCk7dmFyIHU9KGU9XCJcIiwuLi50KT0+Y29uc29sZS5sb2coZS5wYWRFbmQoOSksXCJ8XCIsLi4udCk7dmFyIHY9KC4uLmUpPT5jb25zb2xlLmVycm9yKFwiXFx1ezFGNTM0fSBFUlJPUlwiLnBhZEVuZCg5KSxcInxcIiwuLi5lKSx4PSguLi5lKT0+dShcIlxcdXsxRjUzNX0gSU5GT1wiLC4uLmUpLGc9KC4uLmUpPT51KFwiXFx1ezFGN0UwfSBXQVJOXCIsLi4uZSksRD0wLGM9KC4uLmUpPT5kKCkmJnUoYFxcdXsxRjdFMX0gJHtEKyt9YCwuLi5lKTt2YXIgcz17XCJpc0NvbnRlbnRTY3JpcHRcIjp0cnVlLFwiaXNCYWNrZ3JvdW5kXCI6ZmFsc2UsXCJpc1JlYWN0XCI6ZmFsc2UsXCJydW50aW1lc1wiOltcInNjcmlwdC1ydW50aW1lXCJdLFwiaG9zdFwiOlwibG9jYWxob3N0XCIsXCJwb3J0XCI6MTgxNSxcImVudHJ5RmlsZVBhdGhcIjpcIi9Vc2Vycy9kYXZpZHppbWJlcmtub3BmL0RvY3VtZW50cy9BcHBzL3Z1ZS1wbGFzbW8tdGV4dC8ucGxhc21vL3N0YXRpYy9jb250ZW50cy9wbGFzbW8tb3ZlcmxheS50c1wiLFwiYnVuZGxlSWRcIjpcIjYyYmY2OTNjOWYzYjkxM2ZcIixcImVudkhhc2hcIjpcImU3OTJmYmJkYWE3OGVlODRcIixcInZlcmJvc2VcIjpcImZhbHNlXCIsXCJzZWN1cmVcIjpmYWxzZSxcInNlcnZlclBvcnRcIjo1MjcxMn07bW9kdWxlLmJ1bmRsZS5ITVJfQlVORExFX0lEPXMuYnVuZGxlSWQ7Z2xvYmFsVGhpcy5wcm9jZXNzPXthcmd2OltdLGVudjp7VkVSQk9TRTpzLnZlcmJvc2V9fTt2YXIgSD1tb2R1bGUuYnVuZGxlLk1vZHVsZTtmdW5jdGlvbiBJKGUpe0guY2FsbCh0aGlzLGUpLHRoaXMuaG90PXtkYXRhOm1vZHVsZS5idW5kbGUuaG90RGF0YVtlXSxfYWNjZXB0Q2FsbGJhY2tzOltdLF9kaXNwb3NlQ2FsbGJhY2tzOltdLGFjY2VwdDpmdW5jdGlvbih0KXt0aGlzLl9hY2NlcHRDYWxsYmFja3MucHVzaCh0fHxmdW5jdGlvbigpe30pfSxkaXNwb3NlOmZ1bmN0aW9uKHQpe3RoaXMuX2Rpc3Bvc2VDYWxsYmFja3MucHVzaCh0KX19LG1vZHVsZS5idW5kbGUuaG90RGF0YVtlXT12b2lkIDB9bW9kdWxlLmJ1bmRsZS5Nb2R1bGU9STttb2R1bGUuYnVuZGxlLmhvdERhdGE9e307dmFyIGw9Z2xvYmFsVGhpcy5icm93c2VyfHxnbG9iYWxUaGlzLmNocm9tZXx8bnVsbDtmdW5jdGlvbiBiKCl7cmV0dXJuIXMuaG9zdHx8cy5ob3N0PT09XCIwLjAuMC4wXCI/bG9jYXRpb24ucHJvdG9jb2wuaW5kZXhPZihcImh0dHBcIik9PT0wP2xvY2F0aW9uLmhvc3RuYW1lOlwibG9jYWxob3N0XCI6cy5ob3N0fWZ1bmN0aW9uIEMoKXtyZXR1cm4gcy5wb3J0fHxsb2NhdGlvbi5wb3J0fXZhciBFPVwiX19wbGFzbW9fcnVudGltZV9zY3JpcHRfXCI7ZnVuY3Rpb24gTChlLHQpe2xldHttb2R1bGVzOm99PWU7cmV0dXJuIG8/ISFvW3RdOiExfWZ1bmN0aW9uIFMoZT1DKCkpe2xldCB0PWIoKTtyZXR1cm5gJHtzLnNlY3VyZXx8bG9jYXRpb24ucHJvdG9jb2w9PT1cImh0dHBzOlwiJiYhL2xvY2FsaG9zdHwxMjcuMC4wLjF8MC4wLjAuMC8udGVzdCh0KT9cIndzc1wiOlwid3NcIn06Ly8ke3R9OiR7ZX0vYH1mdW5jdGlvbiBPKGUpe3R5cGVvZiBlLm1lc3NhZ2U9PVwic3RyaW5nXCImJnYoXCJbcGxhc21vL3BhcmNlbC1ydW50aW1lXTogXCIrZS5tZXNzYWdlKX1mdW5jdGlvbiBQKGUpe2lmKHR5cGVvZiBnbG9iYWxUaGlzLldlYlNvY2tldD5cInVcIilyZXR1cm47bGV0IHQ9bmV3IFdlYlNvY2tldChTKCkpO3JldHVybiB0LmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsYXN5bmMgZnVuY3Rpb24obyl7bGV0IHI9SlNPTi5wYXJzZShvLmRhdGEpO2lmKHIudHlwZT09PVwidXBkYXRlXCImJmF3YWl0IGUoci5hc3NldHMpLHIudHlwZT09PVwiZXJyb3JcIilmb3IobGV0IGkgb2Ygci5kaWFnbm9zdGljcy5hbnNpKXtsZXQgdz1pLmNvZGVmcmFtZXx8aS5zdGFjaztnKFwiW3BsYXNtby9wYXJjZWwtcnVudGltZV06IFwiK2kubWVzc2FnZStgXG5gK3crYFxuXG5gK2kuaGludHMuam9pbihgXG5gKSl9fSksdC5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIixPKSx0LmFkZEV2ZW50TGlzdGVuZXIoXCJvcGVuXCIsKCk9Pnt4KGBbcGxhc21vL3BhcmNlbC1ydW50aW1lXTogQ29ubmVjdGVkIHRvIEhNUiBzZXJ2ZXIgZm9yICR7cy5lbnRyeUZpbGVQYXRofWApfSksdC5hZGRFdmVudExpc3RlbmVyKFwiY2xvc2VcIiwoKT0+e2coYFtwbGFzbW8vcGFyY2VsLXJ1bnRpbWVdOiBDb25uZWN0aW9uIHRvIHRoZSBITVIgc2VydmVyIGlzIGNsb3NlZCBmb3IgJHtzLmVudHJ5RmlsZVBhdGh9YCl9KSx0fXZhciBuPVwiX19wbGFzbW8tbG9hZGluZ19fXCI7ZnVuY3Rpb24gbSgpe3JldHVybiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChuKX1mdW5jdGlvbiBmKCl7cmV0dXJuIW0oKX1mdW5jdGlvbiBCKCl7bGV0IGU9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtyZXR1cm4gZS5pZD1uLGUuaW5uZXJIVE1MPWBcbiAgPHN0eWxlPlxuICAgICMke259IHtcbiAgICAgIGJhY2tncm91bmQ6ICNmM2YzZjM7XG4gICAgICBjb2xvcjogIzMzMztcbiAgICAgIGJvcmRlcjogMXB4IHNvbGlkICMzMzM7XG4gICAgICBib3gtc2hhZG93OiAjMzMzIDQuN3B4IDQuN3B4O1xuICAgIH1cblxuICAgICMke259OmhvdmVyIHtcbiAgICAgIGJhY2tncm91bmQ6ICNlM2UzZTM7XG4gICAgICBjb2xvcjogIzQ0NDtcbiAgICB9XG5cbiAgICBAa2V5ZnJhbWVzIHBsYXNtby1sb2FkaW5nLWFuaW1hdGUtc3ZnLWZpbGwge1xuICAgICAgMCUge1xuICAgICAgICBmaWxsOiB0cmFuc3BhcmVudDtcbiAgICAgIH1cbiAgICBcbiAgICAgIDEwMCUge1xuICAgICAgICBmaWxsOiAjMzMzO1xuICAgICAgfVxuICAgIH1cblxuICAgICMke259IC5zdmctZWxlbS0xIHtcbiAgICAgIGFuaW1hdGlvbjogcGxhc21vLWxvYWRpbmctYW5pbWF0ZS1zdmctZmlsbCAxLjQ3cyBjdWJpYy1iZXppZXIoMC40NywgMCwgMC43NDUsIDAuNzE1KSAwLjhzIGJvdGggaW5maW5pdGU7XG4gICAgfVxuXG4gICAgIyR7bn0gLnN2Zy1lbGVtLTIge1xuICAgICAgYW5pbWF0aW9uOiBwbGFzbW8tbG9hZGluZy1hbmltYXRlLXN2Zy1maWxsIDEuNDdzIGN1YmljLWJlemllcigwLjQ3LCAwLCAwLjc0NSwgMC43MTUpIDAuOXMgYm90aCBpbmZpbml0ZTtcbiAgICB9XG4gICAgXG4gICAgIyR7bn0gLnN2Zy1lbGVtLTMge1xuICAgICAgYW5pbWF0aW9uOiBwbGFzbW8tbG9hZGluZy1hbmltYXRlLXN2Zy1maWxsIDEuNDdzIGN1YmljLWJlemllcigwLjQ3LCAwLCAwLjc0NSwgMC43MTUpIDFzIGJvdGggaW5maW5pdGU7XG4gICAgfVxuXG4gICAgIyR7bn0gLmhpZGRlbiB7XG4gICAgICBkaXNwbGF5OiBub25lO1xuICAgIH1cblxuICA8L3N0eWxlPlxuICBcbiAgPHN2ZyBoZWlnaHQ9XCIzMlwiIHdpZHRoPVwiMzJcIiB2aWV3Qm94PVwiMCAwIDI2NCAzNTRcIiBmaWxsPVwibm9uZVwiIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIj5cbiAgICA8cGF0aCBkPVwiTTEzOS4yMjEgMjgyLjI0M0MxNTQuMjUyIDI4Mi4yNDMgMTY2LjkwMyAyOTQuODQ5IDE2MS4zMzggMzA4LjgxMkMxNTkuNDg5IDMxMy40NTQgMTU3LjE1IDMxNy45MTMgMTU0LjM0NyAzMjIuMTA5QzE0Ni40NjQgMzMzLjkwOSAxMzUuMjYgMzQzLjEwNyAxMjIuMTUxIDM0OC41MzhDMTA5LjA0MyAzNTMuOTY5IDk0LjYxODIgMzU1LjM5IDgwLjcwMjIgMzUyLjYyMUM2Ni43ODYxIDM0OS44NTIgNTQuMDAzNCAzNDMuMDE4IDQzLjk3MDUgMzMyLjk4M0MzMy45Mzc1IDMyMi45NDcgMjcuMTA1IDMxMC4xNjIgMjQuMzM2OSAyOTYuMjQyQzIxLjU2ODkgMjgyLjMyMyAyMi45ODk1IDI2Ny44OTUgMjguNDE5MyAyNTQuNzgzQzMzLjg0OTEgMjQxLjY3MSA0My4wNDQxIDIzMC40NjQgNTQuODQxNiAyMjIuNTc5QzU5LjAzNTMgMjE5Ljc3NyA2My40OTA4IDIxNy40MzggNjguMTI5NSAyMTUuNTg4QzgyLjA5MTUgMjEwLjAyMSA5NC42OTc4IDIyMi42NzEgOTQuNjk3OCAyMzcuNzAzTDk0LjY5NzggMjU1LjAyN0M5NC42OTc4IDI3MC4wNTggMTA2Ljg4MyAyODIuMjQzIDEyMS45MTQgMjgyLjI0M0gxMzkuMjIxWlwiIGZpbGw9XCIjMzMzXCIgY2xhc3M9XCJzdmctZWxlbS0xXCIgPjwvcGF0aD5cbiAgICA8cGF0aCBkPVwiTTE5Mi4yNjEgMTQyLjAyOEMxOTIuMjYxIDEyNi45OTYgMjA0Ljg2NyAxMTQuMzQ2IDIxOC44MjkgMTE5LjkxM0MyMjMuNDY4IDEyMS43NjMgMjI3LjkyMyAxMjQuMTAyIDIzMi4xMTcgMTI2LjkwNEMyNDMuOTE1IDEzNC43ODkgMjUzLjExIDE0NS45OTYgMjU4LjUzOSAxNTkuMTA4QzI2My45NjkgMTcyLjIyIDI2NS4zOSAxODYuNjQ4IDI2Mi42MjIgMjAwLjU2N0MyNTkuODU0IDIxNC40ODcgMjUzLjAyMSAyMjcuMjcyIDI0Mi45ODggMjM3LjMwOEMyMzIuOTU1IDI0Ny4zNDMgMjIwLjE3MyAyNTQuMTc3IDIwNi4yNTYgMjU2Ljk0NkMxOTIuMzQgMjU5LjcxNSAxNzcuOTE2IDI1OC4yOTQgMTY0LjgwNyAyNTIuODYzQzE1MS42OTkgMjQ3LjQzMiAxNDAuNDk1IDIzOC4yMzQgMTMyLjYxMiAyMjYuNDM0QzEyOS44MDggMjIyLjIzOCAxMjcuNDcgMjE3Ljc3OSAxMjUuNjIgMjEzLjEzN0MxMjAuMDU2IDE5OS4xNzQgMTMyLjcwNyAxODYuNTY4IDE0Ny43MzggMTg2LjU2OEwxNjUuMDQ0IDE4Ni41NjhDMTgwLjA3NiAxODYuNTY4IDE5Mi4yNjEgMTc0LjM4MyAxOTIuMjYxIDE1OS4zNTJMMTkyLjI2MSAxNDIuMDI4WlwiIGZpbGw9XCIjMzMzXCIgY2xhc3M9XCJzdmctZWxlbS0yXCIgPjwvcGF0aD5cbiAgICA8cGF0aCBkPVwiTTk1LjY1MjIgMTY0LjEzNUM5NS42NTIyIDE3OS4xNjcgODMuMjI3OSAxOTEuNzI1IDY4LjgwMTMgMTg3LjUwNUM1OS41MTQ1IDE4NC43ODggNTAuNjQzMiAxODAuNjYzIDQyLjUxMDYgMTc1LjIyN0MyNi43ODA2IDE2NC43MTQgMTQuNTIwNiAxNDkuNzcyIDcuMjgwODkgMTMyLjI4OUMwLjA0MTE4MyAxMTQuODA3IC0xLjg1MzA1IDk1LjU2OTcgMS44Mzc3MiA3Ny4wMTA0QzUuNTI4NDkgNTguNDUxMSAxNC42Mzg1IDQxLjQwMzMgMjguMDE1NyAyOC4wMjI4QzQxLjM5MyAxNC42NDIzIDU4LjQzNjYgNS41MzAwNiA3Ni45OTE0IDEuODM4MzlDOTUuNTQ2MSAtMS44NTMyOSAxMTQuNzc5IDAuMDQxNDE2MiAxMzIuMjU3IDcuMjgyOUMxNDkuNzM1IDE0LjUyNDQgMTY0LjY3NCAyNi43ODc0IDE3NS4xODQgNDIuNTIxMkMxODAuNjIgNTAuNjU3NiAxODQuNzQ0IDU5LjUzMzIgMTg3LjQ2IDY4LjgyNDVDMTkxLjY3OCA4My4yNTE5IDE3OS4xMTkgOTUuNjc1OSAxNjQuMDg4IDk1LjY3NTlMMTIyLjg2OSA5NS42NzU5QzEwNy44MzcgOTUuNjc1OSA5NS42NTIyIDEwNy44NjEgOTUuNjUyMiAxMjIuODkyTDk1LjY1MjIgMTY0LjEzNVpcIiBmaWxsPVwiIzMzM1wiIGNsYXNzPVwic3ZnLWVsZW0tM1wiPjwvcGF0aD5cbiAgPC9zdmc+XG4gIDxzcGFuIGNsYXNzPVwiaGlkZGVuXCI+Q29udGV4dCBJbnZhbGlkYXRlZCwgUHJlc3MgdG8gUmVsb2FkPC9zcGFuPlxuICBgLGUuc3R5bGUucG9pbnRlckV2ZW50cz1cIm5vbmVcIixlLnN0eWxlLnBvc2l0aW9uPVwiZml4ZWRcIixlLnN0eWxlLmJvdHRvbT1cIjE0LjdweFwiLGUuc3R5bGUucmlnaHQ9XCIxNC43cHhcIixlLnN0eWxlLmZvbnRGYW1pbHk9XCJzYW5zLXNlcmlmXCIsZS5zdHlsZS5kaXNwbGF5PVwiZmxleFwiLGUuc3R5bGUuanVzdGlmeUNvbnRlbnQ9XCJjZW50ZXJcIixlLnN0eWxlLmFsaWduSXRlbXM9XCJjZW50ZXJcIixlLnN0eWxlLnBhZGRpbmc9XCIxNC43cHhcIixlLnN0eWxlLmdhcD1cIjE0LjdweFwiLGUuc3R5bGUuYm9yZGVyUmFkaXVzPVwiNC43cHhcIixlLnN0eWxlLnpJbmRleD1cIjIxNDc0ODM2NDdcIixlLnN0eWxlLm9wYWNpdHk9XCIwXCIsZS5zdHlsZS50cmFuc2l0aW9uPVwiYWxsIDAuNDdzIGVhc2UtaW4tb3V0XCIsZX1mdW5jdGlvbiAkKGUpe3JldHVybiBuZXcgUHJvbWlzZSh0PT57ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50PyhmKCkmJihkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuYXBwZW5kQ2hpbGQoZSksdCgpKSx0KCkpOmdsb2JhbFRoaXMuYWRkRXZlbnRMaXN0ZW5lcihcIkRPTUNvbnRlbnRMb2FkZWRcIiwoKT0+e2YoKSYmZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmFwcGVuZENoaWxkKGUpLHQoKX0pfSl9dmFyIFI9KCk9PntsZXQgZTtpZihmKCkpe2xldCB0PUIoKTtlPSQodCl9cmV0dXJue3Nob3c6YXN5bmMoe3JlbG9hZEJ1dHRvbjp0PSExfT17fSk9Pnthd2FpdCBlO2xldCBvPW0oKTtvLnN0eWxlLm9wYWNpdHk9XCIxXCIsdCYmKG8ub25jbGljaz1yPT57ci5zdG9wUHJvcGFnYXRpb24oKSxnbG9iYWxUaGlzLmxvY2F0aW9uLnJlbG9hZCgpfSxvLnF1ZXJ5U2VsZWN0b3IoXCJzcGFuXCIpLmNsYXNzTGlzdC5yZW1vdmUoXCJoaWRkZW5cIiksby5zdHlsZS5jdXJzb3I9XCJwb2ludGVyXCIsby5zdHlsZS5wb2ludGVyRXZlbnRzPVwiYWxsXCIpfSxoaWRlOmFzeW5jKCk9Pnthd2FpdCBlO2xldCB0PW0oKTt0LnN0eWxlLm9wYWNpdHk9XCIwXCJ9fX07dmFyIEY9YCR7RX0ke21vZHVsZS5pZH1fX2AsYSxUPSExLEE9UigpO2FzeW5jIGZ1bmN0aW9uIGgoKXtjKFwiU2NyaXB0IFJ1bnRpbWUgLSByZWxvYWRpbmdcIiksVD9nbG9iYWxUaGlzLmxvY2F0aW9uPy5yZWxvYWQ/LigpOkEuc2hvdyh7cmVsb2FkQnV0dG9uOiEwfSl9ZnVuY3Rpb24gaygpe2E/LmRpc2Nvbm5lY3QoKSxhPWw/LnJ1bnRpbWUuY29ubmVjdCh7bmFtZTpGfSksYS5vbkRpc2Nvbm5lY3QuYWRkTGlzdGVuZXIoKCk9PntoKCl9KSxhLm9uTWVzc2FnZS5hZGRMaXN0ZW5lcihlPT57ZS5fX3BsYXNtb19jc19yZWxvYWRfXyYmaCgpLGUuX19wbGFzbW9fY3NfYWN0aXZlX3RhYl9fJiYoVD0hMCl9KX1mdW5jdGlvbiBOKCl7aWYobD8ucnVudGltZSl0cnl7aygpLHNldEludGVydmFsKGssMjRlMyl9Y2F0Y2h7cmV0dXJufX1OKCk7UChhc3luYyBlPT57YyhcIlNjcmlwdCBydW50aW1lIC0gb24gdXBkYXRlZCBhc3NldHNcIiksZS5maWx0ZXIobz0+by5lbnZIYXNoPT09cy5lbnZIYXNoKS5zb21lKG89PkwobW9kdWxlLmJ1bmRsZSxvLmlkKSkmJihBLnNob3coKSxsPy5ydW50aW1lP2EucG9zdE1lc3NhZ2Uoe19fcGxhc21vX2NzX2NoYW5nZWRfXzohMH0pOnNldFRpbWVvdXQoKCk9PntoKCl9LDQ3MDApKX0pO1xuIiwiaW1wb3J0IHsgY3JlYXRlQXBwIH0gZnJvbSBcInZ1ZVwiXG5cbmltcG9ydCB7IGNyZWF0ZUFuY2hvck9ic2VydmVyLCBjcmVhdGVSZW5kZXIgfSBmcm9tIFwiQHBsYXNtby1zdGF0aWMtY29tbW9uL2NzdWlcIlxuaW1wb3J0IHtcbiAgY3JlYXRlSW5saW5lQ1NVSUNvbnRhaW5lcixcbiAgY3JlYXRlT3ZlcmxheUNTVUlDb250YWluZXJcbn0gZnJvbSBcIkBwbGFzbW8tc3RhdGljLWNvbW1vbi9jc3VpLWNvbnRhaW5lci12YW5pbGxhXCJcblxuaW1wb3J0IHR5cGUge1xuICBQbGFzbW9DU1VJLFxuICBQbGFzbW9DU1VJQW5jaG9yLFxuICBQbGFzbW9DU1VJSFRNTENvbnRhaW5lclxufSBmcm9tIFwifnR5cGVcIlxuXG5pbXBvcnQgXCJAcGxhc21vLXN0YXRpYy1jb21tb24vdnVlXCJcblxuLy8gQHRzLWlnbm9yZVxuaW1wb3J0IFJhd01vdW50IGZyb20gXCJ+Y29udGVudHMvcGxhc21vLW92ZXJsYXlcIlxuLy8gQHRzLWlnbm9yZVxuaW1wb3J0IFNmY1N0eWxlQ29udGVudCBmcm9tIFwic3R5bGUtcmF3On5jb250ZW50cy9wbGFzbW8tb3ZlcmxheVwiXG5cbi8vIEVzY2FwZSBwYXJjZWwncyBzdGF0aWMgYW5hbHl6ZXJcbmNvbnN0IE1vdW50ID0gKFJhd01vdW50LnBsYXNtbyB8fCB7fSkgYXMgUGxhc21vQ1NVSTxQbGFzbW9DU1VJSFRNTENvbnRhaW5lcj5cblxuaWYgKHR5cGVvZiBTZmNTdHlsZUNvbnRlbnQgPT09IFwic3RyaW5nXCIpIHtcbiAgTW91bnQuZ2V0U2ZjU3R5bGVDb250ZW50ID0gKCkgPT4gU2ZjU3R5bGVDb250ZW50XG5cbiAgaWYgKHR5cGVvZiBNb3VudC5nZXRTdHlsZSAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgTW91bnQuZ2V0U3R5bGUgPSAoeyBzZmNTdHlsZUNvbnRlbnQgfSkgPT4ge1xuICAgICAgY29uc3QgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKVxuICAgICAgZWxlbWVudC50ZXh0Q29udGVudCA9IHNmY1N0eWxlQ29udGVudFxuICAgICAgcmV0dXJuIGVsZW1lbnRcbiAgICB9XG4gIH1cbn1cblxuY29uc3Qgb2JzZXJ2ZXIgPSBjcmVhdGVBbmNob3JPYnNlcnZlcihNb3VudClcblxuY29uc3QgcmVuZGVyID0gY3JlYXRlUmVuZGVyKFxuICBNb3VudCxcbiAgW2NyZWF0ZUlubGluZUNTVUlDb250YWluZXIsIGNyZWF0ZU92ZXJsYXlDU1VJQ29udGFpbmVyXSxcbiAgb2JzZXJ2ZXI/Lm1vdW50U3RhdGUsXG4gIGFzeW5jIChhbmNob3IsIHJvb3RDb250YWluZXIpID0+IHtcbiAgICBzd2l0Y2ggKGFuY2hvci50eXBlKSB7XG4gICAgICBjYXNlIFwiaW5saW5lXCI6IHtcbiAgICAgICAgY29uc3QgbW91bnRQb2ludCA9IGNyZWF0ZUlubGluZUNTVUlDb250YWluZXIoeyBhbmNob3IgfSlcbiAgICAgICAgcm9vdENvbnRhaW5lci5hcHBlbmRDaGlsZChtb3VudFBvaW50KVxuXG4gICAgICAgIGNvbnN0IGFwcCA9IGNyZWF0ZUFwcChSYXdNb3VudClcbiAgICAgICAgYXBwLmNvbmZpZy5nbG9iYWxQcm9wZXJ0aWVzLiRhbmNob3IgPSBhbmNob3JcbiAgICAgICAgYXBwLm1vdW50KG1vdW50UG9pbnQpXG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBjYXNlIFwib3ZlcmxheVwiOiB7XG4gICAgICAgIGNvbnN0IHRhcmdldExpc3QgPSBvYnNlcnZlcj8ubW91bnRTdGF0ZS5vdmVybGF5VGFyZ2V0TGlzdCB8fCBbXG4gICAgICAgICAgYW5jaG9yLmVsZW1lbnRcbiAgICAgICAgXVxuXG4gICAgICAgIHRhcmdldExpc3QuZm9yRWFjaCgodGFyZ2V0LCBpKSA9PiB7XG4gICAgICAgICAgY29uc3QgaWQgPSBgcGxhc21vLW92ZXJsYXktJHtpfWBcbiAgICAgICAgICBjb25zdCBpbm5lckFuY2hvcjogUGxhc21vQ1NVSUFuY2hvciA9IHtcbiAgICAgICAgICAgIGVsZW1lbnQ6IHRhcmdldCxcbiAgICAgICAgICAgIHR5cGU6IFwib3ZlcmxheVwiXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgbW91bnRQb2ludCA9IGNyZWF0ZU92ZXJsYXlDU1VJQ29udGFpbmVyKHtcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgYW5jaG9yOiBpbm5lckFuY2hvcixcbiAgICAgICAgICAgIHdhdGNoT3ZlcmxheUFuY2hvcjogTW91bnQud2F0Y2hPdmVybGF5QW5jaG9yXG4gICAgICAgICAgfSlcblxuICAgICAgICAgIHJvb3RDb250YWluZXIuYXBwZW5kQ2hpbGQobW91bnRQb2ludClcblxuICAgICAgICAgIGNvbnN0IGFwcCA9IGNyZWF0ZUFwcChSYXdNb3VudClcbiAgICAgICAgICBhcHAuY29uZmlnLmdsb2JhbFByb3BlcnRpZXMuJGFuY2hvciA9IGlubmVyQW5jaG9yXG4gICAgICAgICAgYXBwLm1vdW50KG1vdW50UG9pbnQpXG4gICAgICAgIH0pXG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICB9XG4pXG5cbmlmICghIW9ic2VydmVyKSB7XG4gIG9ic2VydmVyLnN0YXJ0KHJlbmRlcilcbn0gZWxzZSB7XG4gIHJlbmRlcih7XG4gICAgZWxlbWVudDogZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LFxuICAgIHR5cGU6IFwib3ZlcmxheVwiXG4gIH0pXG59XG5cbmlmICh0eXBlb2YgTW91bnQud2F0Y2ggPT09IFwiZnVuY3Rpb25cIikge1xuICBNb3VudC53YXRjaCh7XG4gICAgb2JzZXJ2ZXIsXG4gICAgcmVuZGVyXG4gIH0pXG59XG4iLCJpbXBvcnQgeyBpbml0Q3VzdG9tRm9ybWF0dGVyLCB3YXJuIH0gZnJvbSAnQHZ1ZS9ydW50aW1lLWRvbSc7XG5leHBvcnQgKiBmcm9tICdAdnVlL3J1bnRpbWUtZG9tJztcblxuZnVuY3Rpb24gaW5pdERldigpIHtcbiAge1xuICAgIGluaXRDdXN0b21Gb3JtYXR0ZXIoKTtcbiAgfVxufVxuXG5pZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICBpbml0RGV2KCk7XG59XG5jb25zdCBjb21waWxlID0gKCkgPT4ge1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIHdhcm4oXG4gICAgICBgUnVudGltZSBjb21waWxhdGlvbiBpcyBub3Qgc3VwcG9ydGVkIGluIHRoaXMgYnVpbGQgb2YgVnVlLmAgKyAoYCBDb25maWd1cmUgeW91ciBidW5kbGVyIHRvIGFsaWFzIFwidnVlXCIgdG8gXCJ2dWUvZGlzdC92dWUuZXNtLWJ1bmRsZXIuanNcIi5gIClcbiAgICAgIC8qIHNob3VsZCBub3QgaGFwcGVuICovXG4gICAgKTtcbiAgfVxufTtcblxuZXhwb3J0IHsgY29tcGlsZSB9O1xuIiwiaW1wb3J0IHsgd2FybiwgY2FtZWxpemUsIGNhbGxXaXRoQXN5bmNFcnJvckhhbmRsaW5nLCBkZWZpbmVDb21wb25lbnQsIG5leHRUaWNrLCBjcmVhdGVWTm9kZSwgZ2V0Q3VycmVudEluc3RhbmNlLCB3YXRjaFBvc3RFZmZlY3QsIG9uTW91bnRlZCwgb25Vbm1vdW50ZWQsIEZyYWdtZW50LCBTdGF0aWMsIGgsIEJhc2VUcmFuc2l0aW9uLCBCYXNlVHJhbnNpdGlvblByb3BzVmFsaWRhdG9ycywgYXNzZXJ0TnVtYmVyLCB1c2VUcmFuc2l0aW9uU3RhdGUsIG9uVXBkYXRlZCwgdG9SYXcsIGdldFRyYW5zaXRpb25SYXdDaGlsZHJlbiwgc2V0VHJhbnNpdGlvbkhvb2tzLCByZXNvbHZlVHJhbnNpdGlvbkhvb2tzLCBpc1J1bnRpbWVPbmx5LCBjcmVhdGVSZW5kZXJlciwgY3JlYXRlSHlkcmF0aW9uUmVuZGVyZXIgfSBmcm9tICdAdnVlL3J1bnRpbWUtY29yZSc7XG5leHBvcnQgKiBmcm9tICdAdnVlL3J1bnRpbWUtY29yZSc7XG5pbXBvcnQgeyBpc1N0cmluZywgaXNBcnJheSwgaHlwaGVuYXRlLCBjYXBpdGFsaXplLCBpc1NwZWNpYWxCb29sZWFuQXR0ciwgaW5jbHVkZUJvb2xlYW5BdHRyLCBpc09uLCBpc01vZGVsTGlzdGVuZXIsIGlzRnVuY3Rpb24sIGNhbWVsaXplIGFzIGNhbWVsaXplJDEsIHRvTnVtYmVyLCBleHRlbmQsIEVNUFRZX09CSiwgaXNPYmplY3QsIGxvb3NlVG9OdW1iZXIsIGxvb3NlSW5kZXhPZiwgaXNTZXQsIGxvb3NlRXF1YWwsIGludm9rZUFycmF5Rm5zLCBpc0hUTUxUYWcsIGlzU1ZHVGFnIH0gZnJvbSAnQHZ1ZS9zaGFyZWQnO1xuXG5jb25zdCBzdmdOUyA9IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIjtcbmNvbnN0IGRvYyA9IHR5cGVvZiBkb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIiA/IGRvY3VtZW50IDogbnVsbDtcbmNvbnN0IHRlbXBsYXRlQ29udGFpbmVyID0gZG9jICYmIC8qIEBfX1BVUkVfXyAqLyBkb2MuY3JlYXRlRWxlbWVudChcInRlbXBsYXRlXCIpO1xuY29uc3Qgbm9kZU9wcyA9IHtcbiAgaW5zZXJ0OiAoY2hpbGQsIHBhcmVudCwgYW5jaG9yKSA9PiB7XG4gICAgcGFyZW50Lmluc2VydEJlZm9yZShjaGlsZCwgYW5jaG9yIHx8IG51bGwpO1xuICB9LFxuICByZW1vdmU6IChjaGlsZCkgPT4ge1xuICAgIGNvbnN0IHBhcmVudCA9IGNoaWxkLnBhcmVudE5vZGU7XG4gICAgaWYgKHBhcmVudCkge1xuICAgICAgcGFyZW50LnJlbW92ZUNoaWxkKGNoaWxkKTtcbiAgICB9XG4gIH0sXG4gIGNyZWF0ZUVsZW1lbnQ6ICh0YWcsIGlzU1ZHLCBpcywgcHJvcHMpID0+IHtcbiAgICBjb25zdCBlbCA9IGlzU1ZHID8gZG9jLmNyZWF0ZUVsZW1lbnROUyhzdmdOUywgdGFnKSA6IGRvYy5jcmVhdGVFbGVtZW50KHRhZywgaXMgPyB7IGlzIH0gOiB2b2lkIDApO1xuICAgIGlmICh0YWcgPT09IFwic2VsZWN0XCIgJiYgcHJvcHMgJiYgcHJvcHMubXVsdGlwbGUgIT0gbnVsbCkge1xuICAgICAgZWwuc2V0QXR0cmlidXRlKFwibXVsdGlwbGVcIiwgcHJvcHMubXVsdGlwbGUpO1xuICAgIH1cbiAgICByZXR1cm4gZWw7XG4gIH0sXG4gIGNyZWF0ZVRleHQ6ICh0ZXh0KSA9PiBkb2MuY3JlYXRlVGV4dE5vZGUodGV4dCksXG4gIGNyZWF0ZUNvbW1lbnQ6ICh0ZXh0KSA9PiBkb2MuY3JlYXRlQ29tbWVudCh0ZXh0KSxcbiAgc2V0VGV4dDogKG5vZGUsIHRleHQpID0+IHtcbiAgICBub2RlLm5vZGVWYWx1ZSA9IHRleHQ7XG4gIH0sXG4gIHNldEVsZW1lbnRUZXh0OiAoZWwsIHRleHQpID0+IHtcbiAgICBlbC50ZXh0Q29udGVudCA9IHRleHQ7XG4gIH0sXG4gIHBhcmVudE5vZGU6IChub2RlKSA9PiBub2RlLnBhcmVudE5vZGUsXG4gIG5leHRTaWJsaW5nOiAobm9kZSkgPT4gbm9kZS5uZXh0U2libGluZyxcbiAgcXVlcnlTZWxlY3RvcjogKHNlbGVjdG9yKSA9PiBkb2MucXVlcnlTZWxlY3RvcihzZWxlY3RvciksXG4gIHNldFNjb3BlSWQoZWwsIGlkKSB7XG4gICAgZWwuc2V0QXR0cmlidXRlKGlkLCBcIlwiKTtcbiAgfSxcbiAgLy8gX19VTlNBRkVfX1xuICAvLyBSZWFzb246IGlubmVySFRNTC5cbiAgLy8gU3RhdGljIGNvbnRlbnQgaGVyZSBjYW4gb25seSBjb21lIGZyb20gY29tcGlsZWQgdGVtcGxhdGVzLlxuICAvLyBBcyBsb25nIGFzIHRoZSB1c2VyIG9ubHkgdXNlcyB0cnVzdGVkIHRlbXBsYXRlcywgdGhpcyBpcyBzYWZlLlxuICBpbnNlcnRTdGF0aWNDb250ZW50KGNvbnRlbnQsIHBhcmVudCwgYW5jaG9yLCBpc1NWRywgc3RhcnQsIGVuZCkge1xuICAgIGNvbnN0IGJlZm9yZSA9IGFuY2hvciA/IGFuY2hvci5wcmV2aW91c1NpYmxpbmcgOiBwYXJlbnQubGFzdENoaWxkO1xuICAgIGlmIChzdGFydCAmJiAoc3RhcnQgPT09IGVuZCB8fCBzdGFydC5uZXh0U2libGluZykpIHtcbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHBhcmVudC5pbnNlcnRCZWZvcmUoc3RhcnQuY2xvbmVOb2RlKHRydWUpLCBhbmNob3IpO1xuICAgICAgICBpZiAoc3RhcnQgPT09IGVuZCB8fCAhKHN0YXJ0ID0gc3RhcnQubmV4dFNpYmxpbmcpKVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0ZW1wbGF0ZUNvbnRhaW5lci5pbm5lckhUTUwgPSBpc1NWRyA/IGA8c3ZnPiR7Y29udGVudH08L3N2Zz5gIDogY29udGVudDtcbiAgICAgIGNvbnN0IHRlbXBsYXRlID0gdGVtcGxhdGVDb250YWluZXIuY29udGVudDtcbiAgICAgIGlmIChpc1NWRykge1xuICAgICAgICBjb25zdCB3cmFwcGVyID0gdGVtcGxhdGUuZmlyc3RDaGlsZDtcbiAgICAgICAgd2hpbGUgKHdyYXBwZXIuZmlyc3RDaGlsZCkge1xuICAgICAgICAgIHRlbXBsYXRlLmFwcGVuZENoaWxkKHdyYXBwZXIuZmlyc3RDaGlsZCk7XG4gICAgICAgIH1cbiAgICAgICAgdGVtcGxhdGUucmVtb3ZlQ2hpbGQod3JhcHBlcik7XG4gICAgICB9XG4gICAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKHRlbXBsYXRlLCBhbmNob3IpO1xuICAgIH1cbiAgICByZXR1cm4gW1xuICAgICAgLy8gZmlyc3RcbiAgICAgIGJlZm9yZSA/IGJlZm9yZS5uZXh0U2libGluZyA6IHBhcmVudC5maXJzdENoaWxkLFxuICAgICAgLy8gbGFzdFxuICAgICAgYW5jaG9yID8gYW5jaG9yLnByZXZpb3VzU2libGluZyA6IHBhcmVudC5sYXN0Q2hpbGRcbiAgICBdO1xuICB9XG59O1xuXG5mdW5jdGlvbiBwYXRjaENsYXNzKGVsLCB2YWx1ZSwgaXNTVkcpIHtcbiAgY29uc3QgdHJhbnNpdGlvbkNsYXNzZXMgPSBlbC5fdnRjO1xuICBpZiAodHJhbnNpdGlvbkNsYXNzZXMpIHtcbiAgICB2YWx1ZSA9ICh2YWx1ZSA/IFt2YWx1ZSwgLi4udHJhbnNpdGlvbkNsYXNzZXNdIDogWy4uLnRyYW5zaXRpb25DbGFzc2VzXSkuam9pbihcIiBcIik7XG4gIH1cbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoXCJjbGFzc1wiKTtcbiAgfSBlbHNlIGlmIChpc1NWRykge1xuICAgIGVsLnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICBlbC5jbGFzc05hbWUgPSB2YWx1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwYXRjaFN0eWxlKGVsLCBwcmV2LCBuZXh0KSB7XG4gIGNvbnN0IHN0eWxlID0gZWwuc3R5bGU7XG4gIGNvbnN0IGlzQ3NzU3RyaW5nID0gaXNTdHJpbmcobmV4dCk7XG4gIGlmIChuZXh0ICYmICFpc0Nzc1N0cmluZykge1xuICAgIGlmIChwcmV2ICYmICFpc1N0cmluZyhwcmV2KSkge1xuICAgICAgZm9yIChjb25zdCBrZXkgaW4gcHJldikge1xuICAgICAgICBpZiAobmV4dFtrZXldID09IG51bGwpIHtcbiAgICAgICAgICBzZXRTdHlsZShzdHlsZSwga2V5LCBcIlwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGNvbnN0IGtleSBpbiBuZXh0KSB7XG4gICAgICBzZXRTdHlsZShzdHlsZSwga2V5LCBuZXh0W2tleV0pO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBjb25zdCBjdXJyZW50RGlzcGxheSA9IHN0eWxlLmRpc3BsYXk7XG4gICAgaWYgKGlzQ3NzU3RyaW5nKSB7XG4gICAgICBpZiAocHJldiAhPT0gbmV4dCkge1xuICAgICAgICBzdHlsZS5jc3NUZXh0ID0gbmV4dDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHByZXYpIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShcInN0eWxlXCIpO1xuICAgIH1cbiAgICBpZiAoXCJfdm9kXCIgaW4gZWwpIHtcbiAgICAgIHN0eWxlLmRpc3BsYXkgPSBjdXJyZW50RGlzcGxheTtcbiAgICB9XG4gIH1cbn1cbmNvbnN0IHNlbWljb2xvblJFID0gL1teXFxcXF07XFxzKiQvO1xuY29uc3QgaW1wb3J0YW50UkUgPSAvXFxzKiFpbXBvcnRhbnQkLztcbmZ1bmN0aW9uIHNldFN0eWxlKHN0eWxlLCBuYW1lLCB2YWwpIHtcbiAgaWYgKGlzQXJyYXkodmFsKSkge1xuICAgIHZhbC5mb3JFYWNoKCh2KSA9PiBzZXRTdHlsZShzdHlsZSwgbmFtZSwgdikpO1xuICB9IGVsc2Uge1xuICAgIGlmICh2YWwgPT0gbnVsbClcbiAgICAgIHZhbCA9IFwiXCI7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgIGlmIChzZW1pY29sb25SRS50ZXN0KHZhbCkpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBgVW5leHBlY3RlZCBzZW1pY29sb24gYXQgdGhlIGVuZCBvZiAnJHtuYW1lfScgc3R5bGUgdmFsdWU6ICcke3ZhbH0nYFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobmFtZS5zdGFydHNXaXRoKFwiLS1cIikpIHtcbiAgICAgIHN0eWxlLnNldFByb3BlcnR5KG5hbWUsIHZhbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHByZWZpeGVkID0gYXV0b1ByZWZpeChzdHlsZSwgbmFtZSk7XG4gICAgICBpZiAoaW1wb3J0YW50UkUudGVzdCh2YWwpKSB7XG4gICAgICAgIHN0eWxlLnNldFByb3BlcnR5KFxuICAgICAgICAgIGh5cGhlbmF0ZShwcmVmaXhlZCksXG4gICAgICAgICAgdmFsLnJlcGxhY2UoaW1wb3J0YW50UkUsIFwiXCIpLFxuICAgICAgICAgIFwiaW1wb3J0YW50XCJcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0eWxlW3ByZWZpeGVkXSA9IHZhbDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmNvbnN0IHByZWZpeGVzID0gW1wiV2Via2l0XCIsIFwiTW96XCIsIFwibXNcIl07XG5jb25zdCBwcmVmaXhDYWNoZSA9IHt9O1xuZnVuY3Rpb24gYXV0b1ByZWZpeChzdHlsZSwgcmF3TmFtZSkge1xuICBjb25zdCBjYWNoZWQgPSBwcmVmaXhDYWNoZVtyYXdOYW1lXTtcbiAgaWYgKGNhY2hlZCkge1xuICAgIHJldHVybiBjYWNoZWQ7XG4gIH1cbiAgbGV0IG5hbWUgPSBjYW1lbGl6ZShyYXdOYW1lKTtcbiAgaWYgKG5hbWUgIT09IFwiZmlsdGVyXCIgJiYgbmFtZSBpbiBzdHlsZSkge1xuICAgIHJldHVybiBwcmVmaXhDYWNoZVtyYXdOYW1lXSA9IG5hbWU7XG4gIH1cbiAgbmFtZSA9IGNhcGl0YWxpemUobmFtZSk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcHJlZml4ZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBwcmVmaXhlZCA9IHByZWZpeGVzW2ldICsgbmFtZTtcbiAgICBpZiAocHJlZml4ZWQgaW4gc3R5bGUpIHtcbiAgICAgIHJldHVybiBwcmVmaXhDYWNoZVtyYXdOYW1lXSA9IHByZWZpeGVkO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmF3TmFtZTtcbn1cblxuY29uc3QgeGxpbmtOUyA9IFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiO1xuZnVuY3Rpb24gcGF0Y2hBdHRyKGVsLCBrZXksIHZhbHVlLCBpc1NWRywgaW5zdGFuY2UpIHtcbiAgaWYgKGlzU1ZHICYmIGtleS5zdGFydHNXaXRoKFwieGxpbms6XCIpKSB7XG4gICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZU5TKHhsaW5rTlMsIGtleS5zbGljZSg2LCBrZXkubGVuZ3RoKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZU5TKHhsaW5rTlMsIGtleSwgdmFsdWUpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBjb25zdCBpc0Jvb2xlYW4gPSBpc1NwZWNpYWxCb29sZWFuQXR0cihrZXkpO1xuICAgIGlmICh2YWx1ZSA9PSBudWxsIHx8IGlzQm9vbGVhbiAmJiAhaW5jbHVkZUJvb2xlYW5BdHRyKHZhbHVlKSkge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKGtleSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZShrZXksIGlzQm9vbGVhbiA/IFwiXCIgOiB2YWx1ZSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHBhdGNoRE9NUHJvcChlbCwga2V5LCB2YWx1ZSwgcHJldkNoaWxkcmVuLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCB1bm1vdW50Q2hpbGRyZW4pIHtcbiAgaWYgKGtleSA9PT0gXCJpbm5lckhUTUxcIiB8fCBrZXkgPT09IFwidGV4dENvbnRlbnRcIikge1xuICAgIGlmIChwcmV2Q2hpbGRyZW4pIHtcbiAgICAgIHVubW91bnRDaGlsZHJlbihwcmV2Q2hpbGRyZW4sIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UpO1xuICAgIH1cbiAgICBlbFtrZXldID0gdmFsdWUgPT0gbnVsbCA/IFwiXCIgOiB2YWx1ZTtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgdGFnID0gZWwudGFnTmFtZTtcbiAgaWYgKGtleSA9PT0gXCJ2YWx1ZVwiICYmIHRhZyAhPT0gXCJQUk9HUkVTU1wiICYmIC8vIGN1c3RvbSBlbGVtZW50cyBtYXkgdXNlIF92YWx1ZSBpbnRlcm5hbGx5XG4gICF0YWcuaW5jbHVkZXMoXCItXCIpKSB7XG4gICAgZWwuX3ZhbHVlID0gdmFsdWU7XG4gICAgY29uc3Qgb2xkVmFsdWUgPSB0YWcgPT09IFwiT1BUSU9OXCIgPyBlbC5nZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiKSA6IGVsLnZhbHVlO1xuICAgIGNvbnN0IG5ld1ZhbHVlID0gdmFsdWUgPT0gbnVsbCA/IFwiXCIgOiB2YWx1ZTtcbiAgICBpZiAob2xkVmFsdWUgIT09IG5ld1ZhbHVlKSB7XG4gICAgICBlbC52YWx1ZSA9IG5ld1ZhbHVlO1xuICAgIH1cbiAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKGtleSk7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuICBsZXQgbmVlZFJlbW92ZSA9IGZhbHNlO1xuICBpZiAodmFsdWUgPT09IFwiXCIgfHwgdmFsdWUgPT0gbnVsbCkge1xuICAgIGNvbnN0IHR5cGUgPSB0eXBlb2YgZWxba2V5XTtcbiAgICBpZiAodHlwZSA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgIHZhbHVlID0gaW5jbHVkZUJvb2xlYW5BdHRyKHZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKHZhbHVlID09IG51bGwgJiYgdHlwZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgdmFsdWUgPSBcIlwiO1xuICAgICAgbmVlZFJlbW92ZSA9IHRydWU7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSBcIm51bWJlclwiKSB7XG4gICAgICB2YWx1ZSA9IDA7XG4gICAgICBuZWVkUmVtb3ZlID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgdHJ5IHtcbiAgICBlbFtrZXldID0gdmFsdWU7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhbmVlZFJlbW92ZSkge1xuICAgICAgd2FybihcbiAgICAgICAgYEZhaWxlZCBzZXR0aW5nIHByb3AgXCIke2tleX1cIiBvbiA8JHt0YWcudG9Mb3dlckNhc2UoKX0+OiB2YWx1ZSAke3ZhbHVlfSBpcyBpbnZhbGlkLmAsXG4gICAgICAgIGVcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIG5lZWRSZW1vdmUgJiYgZWwucmVtb3ZlQXR0cmlidXRlKGtleSk7XG59XG5cbmZ1bmN0aW9uIGFkZEV2ZW50TGlzdGVuZXIoZWwsIGV2ZW50LCBoYW5kbGVyLCBvcHRpb25zKSB7XG4gIGVsLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXIsIG9wdGlvbnMpO1xufVxuZnVuY3Rpb24gcmVtb3ZlRXZlbnRMaXN0ZW5lcihlbCwgZXZlbnQsIGhhbmRsZXIsIG9wdGlvbnMpIHtcbiAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlciwgb3B0aW9ucyk7XG59XG5mdW5jdGlvbiBwYXRjaEV2ZW50KGVsLCByYXdOYW1lLCBwcmV2VmFsdWUsIG5leHRWYWx1ZSwgaW5zdGFuY2UgPSBudWxsKSB7XG4gIGNvbnN0IGludm9rZXJzID0gZWwuX3ZlaSB8fCAoZWwuX3ZlaSA9IHt9KTtcbiAgY29uc3QgZXhpc3RpbmdJbnZva2VyID0gaW52b2tlcnNbcmF3TmFtZV07XG4gIGlmIChuZXh0VmFsdWUgJiYgZXhpc3RpbmdJbnZva2VyKSB7XG4gICAgZXhpc3RpbmdJbnZva2VyLnZhbHVlID0gbmV4dFZhbHVlO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IFtuYW1lLCBvcHRpb25zXSA9IHBhcnNlTmFtZShyYXdOYW1lKTtcbiAgICBpZiAobmV4dFZhbHVlKSB7XG4gICAgICBjb25zdCBpbnZva2VyID0gaW52b2tlcnNbcmF3TmFtZV0gPSBjcmVhdGVJbnZva2VyKG5leHRWYWx1ZSwgaW5zdGFuY2UpO1xuICAgICAgYWRkRXZlbnRMaXN0ZW5lcihlbCwgbmFtZSwgaW52b2tlciwgb3B0aW9ucyk7XG4gICAgfSBlbHNlIGlmIChleGlzdGluZ0ludm9rZXIpIHtcbiAgICAgIHJlbW92ZUV2ZW50TGlzdGVuZXIoZWwsIG5hbWUsIGV4aXN0aW5nSW52b2tlciwgb3B0aW9ucyk7XG4gICAgICBpbnZva2Vyc1tyYXdOYW1lXSA9IHZvaWQgMDtcbiAgICB9XG4gIH1cbn1cbmNvbnN0IG9wdGlvbnNNb2RpZmllclJFID0gLyg/Ok9uY2V8UGFzc2l2ZXxDYXB0dXJlKSQvO1xuZnVuY3Rpb24gcGFyc2VOYW1lKG5hbWUpIHtcbiAgbGV0IG9wdGlvbnM7XG4gIGlmIChvcHRpb25zTW9kaWZpZXJSRS50ZXN0KG5hbWUpKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICAgIGxldCBtO1xuICAgIHdoaWxlIChtID0gbmFtZS5tYXRjaChvcHRpb25zTW9kaWZpZXJSRSkpIHtcbiAgICAgIG5hbWUgPSBuYW1lLnNsaWNlKDAsIG5hbWUubGVuZ3RoIC0gbVswXS5sZW5ndGgpO1xuICAgICAgb3B0aW9uc1ttWzBdLnRvTG93ZXJDYXNlKCldID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgY29uc3QgZXZlbnQgPSBuYW1lWzJdID09PSBcIjpcIiA/IG5hbWUuc2xpY2UoMykgOiBoeXBoZW5hdGUobmFtZS5zbGljZSgyKSk7XG4gIHJldHVybiBbZXZlbnQsIG9wdGlvbnNdO1xufVxubGV0IGNhY2hlZE5vdyA9IDA7XG5jb25zdCBwID0gLyogQF9fUFVSRV9fICovIFByb21pc2UucmVzb2x2ZSgpO1xuY29uc3QgZ2V0Tm93ID0gKCkgPT4gY2FjaGVkTm93IHx8IChwLnRoZW4oKCkgPT4gY2FjaGVkTm93ID0gMCksIGNhY2hlZE5vdyA9IERhdGUubm93KCkpO1xuZnVuY3Rpb24gY3JlYXRlSW52b2tlcihpbml0aWFsVmFsdWUsIGluc3RhbmNlKSB7XG4gIGNvbnN0IGludm9rZXIgPSAoZSkgPT4ge1xuICAgIGlmICghZS5fdnRzKSB7XG4gICAgICBlLl92dHMgPSBEYXRlLm5vdygpO1xuICAgIH0gZWxzZSBpZiAoZS5fdnRzIDw9IGludm9rZXIuYXR0YWNoZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY2FsbFdpdGhBc3luY0Vycm9ySGFuZGxpbmcoXG4gICAgICBwYXRjaFN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbihlLCBpbnZva2VyLnZhbHVlKSxcbiAgICAgIGluc3RhbmNlLFxuICAgICAgNSxcbiAgICAgIFtlXVxuICAgICk7XG4gIH07XG4gIGludm9rZXIudmFsdWUgPSBpbml0aWFsVmFsdWU7XG4gIGludm9rZXIuYXR0YWNoZWQgPSBnZXROb3coKTtcbiAgcmV0dXJuIGludm9rZXI7XG59XG5mdW5jdGlvbiBwYXRjaFN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbihlLCB2YWx1ZSkge1xuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICBjb25zdCBvcmlnaW5hbFN0b3AgPSBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbjtcbiAgICBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbiA9ICgpID0+IHtcbiAgICAgIG9yaWdpbmFsU3RvcC5jYWxsKGUpO1xuICAgICAgZS5fc3RvcHBlZCA9IHRydWU7XG4gICAgfTtcbiAgICByZXR1cm4gdmFsdWUubWFwKChmbikgPT4gKGUyKSA9PiAhZTIuX3N0b3BwZWQgJiYgZm4gJiYgZm4oZTIpKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbn1cblxuY29uc3QgbmF0aXZlT25SRSA9IC9eb25bYS16XS87XG5jb25zdCBwYXRjaFByb3AgPSAoZWwsIGtleSwgcHJldlZhbHVlLCBuZXh0VmFsdWUsIGlzU1ZHID0gZmFsc2UsIHByZXZDaGlsZHJlbiwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgdW5tb3VudENoaWxkcmVuKSA9PiB7XG4gIGlmIChrZXkgPT09IFwiY2xhc3NcIikge1xuICAgIHBhdGNoQ2xhc3MoZWwsIG5leHRWYWx1ZSwgaXNTVkcpO1xuICB9IGVsc2UgaWYgKGtleSA9PT0gXCJzdHlsZVwiKSB7XG4gICAgcGF0Y2hTdHlsZShlbCwgcHJldlZhbHVlLCBuZXh0VmFsdWUpO1xuICB9IGVsc2UgaWYgKGlzT24oa2V5KSkge1xuICAgIGlmICghaXNNb2RlbExpc3RlbmVyKGtleSkpIHtcbiAgICAgIHBhdGNoRXZlbnQoZWwsIGtleSwgcHJldlZhbHVlLCBuZXh0VmFsdWUsIHBhcmVudENvbXBvbmVudCk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGtleVswXSA9PT0gXCIuXCIgPyAoa2V5ID0ga2V5LnNsaWNlKDEpLCB0cnVlKSA6IGtleVswXSA9PT0gXCJeXCIgPyAoa2V5ID0ga2V5LnNsaWNlKDEpLCBmYWxzZSkgOiBzaG91bGRTZXRBc1Byb3AoZWwsIGtleSwgbmV4dFZhbHVlLCBpc1NWRykpIHtcbiAgICBwYXRjaERPTVByb3AoXG4gICAgICBlbCxcbiAgICAgIGtleSxcbiAgICAgIG5leHRWYWx1ZSxcbiAgICAgIHByZXZDaGlsZHJlbixcbiAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgdW5tb3VudENoaWxkcmVuXG4gICAgKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoa2V5ID09PSBcInRydWUtdmFsdWVcIikge1xuICAgICAgZWwuX3RydWVWYWx1ZSA9IG5leHRWYWx1ZTtcbiAgICB9IGVsc2UgaWYgKGtleSA9PT0gXCJmYWxzZS12YWx1ZVwiKSB7XG4gICAgICBlbC5fZmFsc2VWYWx1ZSA9IG5leHRWYWx1ZTtcbiAgICB9XG4gICAgcGF0Y2hBdHRyKGVsLCBrZXksIG5leHRWYWx1ZSwgaXNTVkcpO1xuICB9XG59O1xuZnVuY3Rpb24gc2hvdWxkU2V0QXNQcm9wKGVsLCBrZXksIHZhbHVlLCBpc1NWRykge1xuICBpZiAoaXNTVkcpIHtcbiAgICBpZiAoa2V5ID09PSBcImlubmVySFRNTFwiIHx8IGtleSA9PT0gXCJ0ZXh0Q29udGVudFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGtleSBpbiBlbCAmJiBuYXRpdmVPblJFLnRlc3Qoa2V5KSAmJiBpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoa2V5ID09PSBcInNwZWxsY2hlY2tcIiB8fCBrZXkgPT09IFwiZHJhZ2dhYmxlXCIgfHwga2V5ID09PSBcInRyYW5zbGF0ZVwiKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChrZXkgPT09IFwiZm9ybVwiKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChrZXkgPT09IFwibGlzdFwiICYmIGVsLnRhZ05hbWUgPT09IFwiSU5QVVRcIikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoa2V5ID09PSBcInR5cGVcIiAmJiBlbC50YWdOYW1lID09PSBcIlRFWFRBUkVBXCIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKG5hdGl2ZU9uUkUudGVzdChrZXkpICYmIGlzU3RyaW5nKHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4ga2V5IGluIGVsO1xufVxuXG5mdW5jdGlvbiBkZWZpbmVDdXN0b21FbGVtZW50KG9wdGlvbnMsIGh5ZHJhdGUyKSB7XG4gIGNvbnN0IENvbXAgPSBkZWZpbmVDb21wb25lbnQob3B0aW9ucyk7XG4gIGNsYXNzIFZ1ZUN1c3RvbUVsZW1lbnQgZXh0ZW5kcyBWdWVFbGVtZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihpbml0aWFsUHJvcHMpIHtcbiAgICAgIHN1cGVyKENvbXAsIGluaXRpYWxQcm9wcywgaHlkcmF0ZTIpO1xuICAgIH1cbiAgfVxuICBWdWVDdXN0b21FbGVtZW50LmRlZiA9IENvbXA7XG4gIHJldHVybiBWdWVDdXN0b21FbGVtZW50O1xufVxuY29uc3QgZGVmaW5lU1NSQ3VzdG9tRWxlbWVudCA9IChvcHRpb25zKSA9PiB7XG4gIHJldHVybiBkZWZpbmVDdXN0b21FbGVtZW50KG9wdGlvbnMsIGh5ZHJhdGUpO1xufTtcbmNvbnN0IEJhc2VDbGFzcyA9IHR5cGVvZiBIVE1MRWxlbWVudCAhPT0gXCJ1bmRlZmluZWRcIiA/IEhUTUxFbGVtZW50IDogY2xhc3Mge1xufTtcbmNsYXNzIFZ1ZUVsZW1lbnQgZXh0ZW5kcyBCYXNlQ2xhc3Mge1xuICBjb25zdHJ1Y3RvcihfZGVmLCBfcHJvcHMgPSB7fSwgaHlkcmF0ZTIpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuX2RlZiA9IF9kZWY7XG4gICAgdGhpcy5fcHJvcHMgPSBfcHJvcHM7XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgdGhpcy5faW5zdGFuY2UgPSBudWxsO1xuICAgIHRoaXMuX2Nvbm5lY3RlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3Jlc29sdmVkID0gZmFsc2U7XG4gICAgdGhpcy5fbnVtYmVyUHJvcHMgPSBudWxsO1xuICAgIGlmICh0aGlzLnNoYWRvd1Jvb3QgJiYgaHlkcmF0ZTIpIHtcbiAgICAgIGh5ZHJhdGUyKHRoaXMuX2NyZWF0ZVZOb2RlKCksIHRoaXMuc2hhZG93Um9vdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHRoaXMuc2hhZG93Um9vdCkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIGBDdXN0b20gZWxlbWVudCBoYXMgcHJlLXJlbmRlcmVkIGRlY2xhcmF0aXZlIHNoYWRvdyByb290IGJ1dCBpcyBub3QgZGVmaW5lZCBhcyBoeWRyYXRhYmxlLiBVc2UgXFxgZGVmaW5lU1NSQ3VzdG9tRWxlbWVudFxcYC5gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICB0aGlzLmF0dGFjaFNoYWRvdyh7IG1vZGU6IFwib3BlblwiIH0pO1xuICAgICAgaWYgKCF0aGlzLl9kZWYuX19hc3luY0xvYWRlcikge1xuICAgICAgICB0aGlzLl9yZXNvbHZlUHJvcHModGhpcy5fZGVmKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5fY29ubmVjdGVkID0gdHJ1ZTtcbiAgICBpZiAoIXRoaXMuX2luc3RhbmNlKSB7XG4gICAgICBpZiAodGhpcy5fcmVzb2x2ZWQpIHtcbiAgICAgICAgdGhpcy5fdXBkYXRlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9yZXNvbHZlRGVmKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIHRoaXMuX2Nvbm5lY3RlZCA9IGZhbHNlO1xuICAgIG5leHRUaWNrKCgpID0+IHtcbiAgICAgIGlmICghdGhpcy5fY29ubmVjdGVkKSB7XG4gICAgICAgIHJlbmRlcihudWxsLCB0aGlzLnNoYWRvd1Jvb3QpO1xuICAgICAgICB0aGlzLl9pbnN0YW5jZSA9IG51bGw7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIHJlc29sdmUgaW5uZXIgY29tcG9uZW50IGRlZmluaXRpb24gKGhhbmRsZSBwb3NzaWJsZSBhc3luYyBjb21wb25lbnQpXG4gICAqL1xuICBfcmVzb2x2ZURlZigpIHtcbiAgICB0aGlzLl9yZXNvbHZlZCA9IHRydWU7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmF0dHJpYnV0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMuX3NldEF0dHIodGhpcy5hdHRyaWJ1dGVzW2ldLm5hbWUpO1xuICAgIH1cbiAgICBuZXcgTXV0YXRpb25PYnNlcnZlcigobXV0YXRpb25zKSA9PiB7XG4gICAgICBmb3IgKGNvbnN0IG0gb2YgbXV0YXRpb25zKSB7XG4gICAgICAgIHRoaXMuX3NldEF0dHIobS5hdHRyaWJ1dGVOYW1lKTtcbiAgICAgIH1cbiAgICB9KS5vYnNlcnZlKHRoaXMsIHsgYXR0cmlidXRlczogdHJ1ZSB9KTtcbiAgICBjb25zdCByZXNvbHZlID0gKGRlZiwgaXNBc3luYyA9IGZhbHNlKSA9PiB7XG4gICAgICBjb25zdCB7IHByb3BzLCBzdHlsZXMgfSA9IGRlZjtcbiAgICAgIGxldCBudW1iZXJQcm9wcztcbiAgICAgIGlmIChwcm9wcyAmJiAhaXNBcnJheShwcm9wcykpIHtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcHJvcHMpIHtcbiAgICAgICAgICBjb25zdCBvcHQgPSBwcm9wc1trZXldO1xuICAgICAgICAgIGlmIChvcHQgPT09IE51bWJlciB8fCBvcHQgJiYgb3B0LnR5cGUgPT09IE51bWJlcikge1xuICAgICAgICAgICAgaWYgKGtleSBpbiB0aGlzLl9wcm9wcykge1xuICAgICAgICAgICAgICB0aGlzLl9wcm9wc1trZXldID0gdG9OdW1iZXIodGhpcy5fcHJvcHNba2V5XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAobnVtYmVyUHJvcHMgfHwgKG51bWJlclByb3BzID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCkpKVtjYW1lbGl6ZSQxKGtleSldID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuX251bWJlclByb3BzID0gbnVtYmVyUHJvcHM7XG4gICAgICBpZiAoaXNBc3luYykge1xuICAgICAgICB0aGlzLl9yZXNvbHZlUHJvcHMoZGVmKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2FwcGx5U3R5bGVzKHN0eWxlcyk7XG4gICAgICB0aGlzLl91cGRhdGUoKTtcbiAgICB9O1xuICAgIGNvbnN0IGFzeW5jRGVmID0gdGhpcy5fZGVmLl9fYXN5bmNMb2FkZXI7XG4gICAgaWYgKGFzeW5jRGVmKSB7XG4gICAgICBhc3luY0RlZigpLnRoZW4oKGRlZikgPT4gcmVzb2x2ZShkZWYsIHRydWUpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzb2x2ZSh0aGlzLl9kZWYpO1xuICAgIH1cbiAgfVxuICBfcmVzb2x2ZVByb3BzKGRlZikge1xuICAgIGNvbnN0IHsgcHJvcHMgfSA9IGRlZjtcbiAgICBjb25zdCBkZWNsYXJlZFByb3BLZXlzID0gaXNBcnJheShwcm9wcykgPyBwcm9wcyA6IE9iamVjdC5rZXlzKHByb3BzIHx8IHt9KTtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyh0aGlzKSkge1xuICAgICAgaWYgKGtleVswXSAhPT0gXCJfXCIgJiYgZGVjbGFyZWRQcm9wS2V5cy5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgIHRoaXMuX3NldFByb3Aoa2V5LCB0aGlzW2tleV0sIHRydWUsIGZhbHNlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChjb25zdCBrZXkgb2YgZGVjbGFyZWRQcm9wS2V5cy5tYXAoY2FtZWxpemUkMSkpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBrZXksIHtcbiAgICAgICAgZ2V0KCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9nZXRQcm9wKGtleSk7XG4gICAgICAgIH0sXG4gICAgICAgIHNldCh2YWwpIHtcbiAgICAgICAgICB0aGlzLl9zZXRQcm9wKGtleSwgdmFsKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIF9zZXRBdHRyKGtleSkge1xuICAgIGxldCB2YWx1ZSA9IHRoaXMuZ2V0QXR0cmlidXRlKGtleSk7XG4gICAgY29uc3QgY2FtZWxLZXkgPSBjYW1lbGl6ZSQxKGtleSk7XG4gICAgaWYgKHRoaXMuX251bWJlclByb3BzICYmIHRoaXMuX251bWJlclByb3BzW2NhbWVsS2V5XSkge1xuICAgICAgdmFsdWUgPSB0b051bWJlcih2YWx1ZSk7XG4gICAgfVxuICAgIHRoaXMuX3NldFByb3AoY2FtZWxLZXksIHZhbHVlLCBmYWxzZSk7XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX2dldFByb3Aoa2V5KSB7XG4gICAgcmV0dXJuIHRoaXMuX3Byb3BzW2tleV07XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX3NldFByb3Aoa2V5LCB2YWwsIHNob3VsZFJlZmxlY3QgPSB0cnVlLCBzaG91bGRVcGRhdGUgPSB0cnVlKSB7XG4gICAgaWYgKHZhbCAhPT0gdGhpcy5fcHJvcHNba2V5XSkge1xuICAgICAgdGhpcy5fcHJvcHNba2V5XSA9IHZhbDtcbiAgICAgIGlmIChzaG91bGRVcGRhdGUgJiYgdGhpcy5faW5zdGFuY2UpIHtcbiAgICAgICAgdGhpcy5fdXBkYXRlKCk7XG4gICAgICB9XG4gICAgICBpZiAoc2hvdWxkUmVmbGVjdCkge1xuICAgICAgICBpZiAodmFsID09PSB0cnVlKSB7XG4gICAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoaHlwaGVuYXRlKGtleSksIFwiXCIpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIHZhbCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKGh5cGhlbmF0ZShrZXkpLCB2YWwgKyBcIlwiKTtcbiAgICAgICAgfSBlbHNlIGlmICghdmFsKSB7XG4gICAgICAgICAgdGhpcy5yZW1vdmVBdHRyaWJ1dGUoaHlwaGVuYXRlKGtleSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIF91cGRhdGUoKSB7XG4gICAgcmVuZGVyKHRoaXMuX2NyZWF0ZVZOb2RlKCksIHRoaXMuc2hhZG93Um9vdCk7XG4gIH1cbiAgX2NyZWF0ZVZOb2RlKCkge1xuICAgIGNvbnN0IHZub2RlID0gY3JlYXRlVk5vZGUodGhpcy5fZGVmLCBleHRlbmQoe30sIHRoaXMuX3Byb3BzKSk7XG4gICAgaWYgKCF0aGlzLl9pbnN0YW5jZSkge1xuICAgICAgdm5vZGUuY2UgPSAoaW5zdGFuY2UpID0+IHtcbiAgICAgICAgdGhpcy5faW5zdGFuY2UgPSBpbnN0YW5jZTtcbiAgICAgICAgaW5zdGFuY2UuaXNDRSA9IHRydWU7XG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgaW5zdGFuY2UuY2VSZWxvYWQgPSAobmV3U3R5bGVzKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5fc3R5bGVzKSB7XG4gICAgICAgICAgICAgIHRoaXMuX3N0eWxlcy5mb3JFYWNoKChzKSA9PiB0aGlzLnNoYWRvd1Jvb3QucmVtb3ZlQ2hpbGQocykpO1xuICAgICAgICAgICAgICB0aGlzLl9zdHlsZXMubGVuZ3RoID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2FwcGx5U3R5bGVzKG5ld1N0eWxlcyk7XG4gICAgICAgICAgICB0aGlzLl9pbnN0YW5jZSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGUoKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRpc3BhdGNoID0gKGV2ZW50LCBhcmdzKSA9PiB7XG4gICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KFxuICAgICAgICAgICAgbmV3IEN1c3RvbUV2ZW50KGV2ZW50LCB7XG4gICAgICAgICAgICAgIGRldGFpbDogYXJnc1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICApO1xuICAgICAgICB9O1xuICAgICAgICBpbnN0YW5jZS5lbWl0ID0gKGV2ZW50LCAuLi5hcmdzKSA9PiB7XG4gICAgICAgICAgZGlzcGF0Y2goZXZlbnQsIGFyZ3MpO1xuICAgICAgICAgIGlmIChoeXBoZW5hdGUoZXZlbnQpICE9PSBldmVudCkge1xuICAgICAgICAgICAgZGlzcGF0Y2goaHlwaGVuYXRlKGV2ZW50KSwgYXJncyk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBsZXQgcGFyZW50ID0gdGhpcztcbiAgICAgICAgd2hpbGUgKHBhcmVudCA9IHBhcmVudCAmJiAocGFyZW50LnBhcmVudE5vZGUgfHwgcGFyZW50Lmhvc3QpKSB7XG4gICAgICAgICAgaWYgKHBhcmVudCBpbnN0YW5jZW9mIFZ1ZUVsZW1lbnQpIHtcbiAgICAgICAgICAgIGluc3RhbmNlLnBhcmVudCA9IHBhcmVudC5faW5zdGFuY2U7XG4gICAgICAgICAgICBpbnN0YW5jZS5wcm92aWRlcyA9IHBhcmVudC5faW5zdGFuY2UucHJvdmlkZXM7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB2bm9kZTtcbiAgfVxuICBfYXBwbHlTdHlsZXMoc3R5bGVzKSB7XG4gICAgaWYgKHN0eWxlcykge1xuICAgICAgc3R5bGVzLmZvckVhY2goKGNzcykgPT4ge1xuICAgICAgICBjb25zdCBzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xuICAgICAgICBzLnRleHRDb250ZW50ID0gY3NzO1xuICAgICAgICB0aGlzLnNoYWRvd1Jvb3QuYXBwZW5kQ2hpbGQocyk7XG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgKHRoaXMuX3N0eWxlcyB8fCAodGhpcy5fc3R5bGVzID0gW10pKS5wdXNoKHMpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdXNlQ3NzTW9kdWxlKG5hbWUgPSBcIiRzdHlsZVwiKSB7XG4gIHtcbiAgICBjb25zdCBpbnN0YW5jZSA9IGdldEN1cnJlbnRJbnN0YW5jZSgpO1xuICAgIGlmICghaW5zdGFuY2UpIHtcbiAgICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgd2FybihgdXNlQ3NzTW9kdWxlIG11c3QgYmUgY2FsbGVkIGluc2lkZSBzZXR1cCgpYCk7XG4gICAgICByZXR1cm4gRU1QVFlfT0JKO1xuICAgIH1cbiAgICBjb25zdCBtb2R1bGVzID0gaW5zdGFuY2UudHlwZS5fX2Nzc01vZHVsZXM7XG4gICAgaWYgKCFtb2R1bGVzKSB7XG4gICAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHdhcm4oYEN1cnJlbnQgaW5zdGFuY2UgZG9lcyBub3QgaGF2ZSBDU1MgbW9kdWxlcyBpbmplY3RlZC5gKTtcbiAgICAgIHJldHVybiBFTVBUWV9PQko7XG4gICAgfVxuICAgIGNvbnN0IG1vZCA9IG1vZHVsZXNbbmFtZV07XG4gICAgaWYgKCFtb2QpIHtcbiAgICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgd2FybihgQ3VycmVudCBpbnN0YW5jZSBkb2VzIG5vdCBoYXZlIENTUyBtb2R1bGUgbmFtZWQgXCIke25hbWV9XCIuYCk7XG4gICAgICByZXR1cm4gRU1QVFlfT0JKO1xuICAgIH1cbiAgICByZXR1cm4gbW9kO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVzZUNzc1ZhcnMoZ2V0dGVyKSB7XG4gIGNvbnN0IGluc3RhbmNlID0gZ2V0Q3VycmVudEluc3RhbmNlKCk7XG4gIGlmICghaW5zdGFuY2UpIHtcbiAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHdhcm4oYHVzZUNzc1ZhcnMgaXMgY2FsbGVkIHdpdGhvdXQgY3VycmVudCBhY3RpdmUgY29tcG9uZW50IGluc3RhbmNlLmApO1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCB1cGRhdGVUZWxlcG9ydHMgPSBpbnN0YW5jZS51dCA9ICh2YXJzID0gZ2V0dGVyKGluc3RhbmNlLnByb3h5KSkgPT4ge1xuICAgIEFycmF5LmZyb20oXG4gICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKGBbZGF0YS12LW93bmVyPVwiJHtpbnN0YW5jZS51aWR9XCJdYClcbiAgICApLmZvckVhY2goKG5vZGUpID0+IHNldFZhcnNPbk5vZGUobm9kZSwgdmFycykpO1xuICB9O1xuICBjb25zdCBzZXRWYXJzID0gKCkgPT4ge1xuICAgIGNvbnN0IHZhcnMgPSBnZXR0ZXIoaW5zdGFuY2UucHJveHkpO1xuICAgIHNldFZhcnNPblZOb2RlKGluc3RhbmNlLnN1YlRyZWUsIHZhcnMpO1xuICAgIHVwZGF0ZVRlbGVwb3J0cyh2YXJzKTtcbiAgfTtcbiAgd2F0Y2hQb3N0RWZmZWN0KHNldFZhcnMpO1xuICBvbk1vdW50ZWQoKCkgPT4ge1xuICAgIGNvbnN0IG9iID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoc2V0VmFycyk7XG4gICAgb2Iub2JzZXJ2ZShpbnN0YW5jZS5zdWJUcmVlLmVsLnBhcmVudE5vZGUsIHsgY2hpbGRMaXN0OiB0cnVlIH0pO1xuICAgIG9uVW5tb3VudGVkKCgpID0+IG9iLmRpc2Nvbm5lY3QoKSk7XG4gIH0pO1xufVxuZnVuY3Rpb24gc2V0VmFyc09uVk5vZGUodm5vZGUsIHZhcnMpIHtcbiAgaWYgKHZub2RlLnNoYXBlRmxhZyAmIDEyOCkge1xuICAgIGNvbnN0IHN1c3BlbnNlID0gdm5vZGUuc3VzcGVuc2U7XG4gICAgdm5vZGUgPSBzdXNwZW5zZS5hY3RpdmVCcmFuY2g7XG4gICAgaWYgKHN1c3BlbnNlLnBlbmRpbmdCcmFuY2ggJiYgIXN1c3BlbnNlLmlzSHlkcmF0aW5nKSB7XG4gICAgICBzdXNwZW5zZS5lZmZlY3RzLnB1c2goKCkgPT4ge1xuICAgICAgICBzZXRWYXJzT25WTm9kZShzdXNwZW5zZS5hY3RpdmVCcmFuY2gsIHZhcnMpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHdoaWxlICh2bm9kZS5jb21wb25lbnQpIHtcbiAgICB2bm9kZSA9IHZub2RlLmNvbXBvbmVudC5zdWJUcmVlO1xuICB9XG4gIGlmICh2bm9kZS5zaGFwZUZsYWcgJiAxICYmIHZub2RlLmVsKSB7XG4gICAgc2V0VmFyc09uTm9kZSh2bm9kZS5lbCwgdmFycyk7XG4gIH0gZWxzZSBpZiAodm5vZGUudHlwZSA9PT0gRnJhZ21lbnQpIHtcbiAgICB2bm9kZS5jaGlsZHJlbi5mb3JFYWNoKChjKSA9PiBzZXRWYXJzT25WTm9kZShjLCB2YXJzKSk7XG4gIH0gZWxzZSBpZiAodm5vZGUudHlwZSA9PT0gU3RhdGljKSB7XG4gICAgbGV0IHsgZWwsIGFuY2hvciB9ID0gdm5vZGU7XG4gICAgd2hpbGUgKGVsKSB7XG4gICAgICBzZXRWYXJzT25Ob2RlKGVsLCB2YXJzKTtcbiAgICAgIGlmIChlbCA9PT0gYW5jaG9yKVxuICAgICAgICBicmVhaztcbiAgICAgIGVsID0gZWwubmV4dFNpYmxpbmc7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBzZXRWYXJzT25Ob2RlKGVsLCB2YXJzKSB7XG4gIGlmIChlbC5ub2RlVHlwZSA9PT0gMSkge1xuICAgIGNvbnN0IHN0eWxlID0gZWwuc3R5bGU7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gdmFycykge1xuICAgICAgc3R5bGUuc2V0UHJvcGVydHkoYC0tJHtrZXl9YCwgdmFyc1trZXldKTtcbiAgICB9XG4gIH1cbn1cblxuY29uc3QgVFJBTlNJVElPTiA9IFwidHJhbnNpdGlvblwiO1xuY29uc3QgQU5JTUFUSU9OID0gXCJhbmltYXRpb25cIjtcbmNvbnN0IFRyYW5zaXRpb24gPSAocHJvcHMsIHsgc2xvdHMgfSkgPT4gaChCYXNlVHJhbnNpdGlvbiwgcmVzb2x2ZVRyYW5zaXRpb25Qcm9wcyhwcm9wcyksIHNsb3RzKTtcblRyYW5zaXRpb24uZGlzcGxheU5hbWUgPSBcIlRyYW5zaXRpb25cIjtcbmNvbnN0IERPTVRyYW5zaXRpb25Qcm9wc1ZhbGlkYXRvcnMgPSB7XG4gIG5hbWU6IFN0cmluZyxcbiAgdHlwZTogU3RyaW5nLFxuICBjc3M6IHtcbiAgICB0eXBlOiBCb29sZWFuLFxuICAgIGRlZmF1bHQ6IHRydWVcbiAgfSxcbiAgZHVyYXRpb246IFtTdHJpbmcsIE51bWJlciwgT2JqZWN0XSxcbiAgZW50ZXJGcm9tQ2xhc3M6IFN0cmluZyxcbiAgZW50ZXJBY3RpdmVDbGFzczogU3RyaW5nLFxuICBlbnRlclRvQ2xhc3M6IFN0cmluZyxcbiAgYXBwZWFyRnJvbUNsYXNzOiBTdHJpbmcsXG4gIGFwcGVhckFjdGl2ZUNsYXNzOiBTdHJpbmcsXG4gIGFwcGVhclRvQ2xhc3M6IFN0cmluZyxcbiAgbGVhdmVGcm9tQ2xhc3M6IFN0cmluZyxcbiAgbGVhdmVBY3RpdmVDbGFzczogU3RyaW5nLFxuICBsZWF2ZVRvQ2xhc3M6IFN0cmluZ1xufTtcbmNvbnN0IFRyYW5zaXRpb25Qcm9wc1ZhbGlkYXRvcnMgPSBUcmFuc2l0aW9uLnByb3BzID0gLyogQF9fUFVSRV9fICovIGV4dGVuZChcbiAge30sXG4gIEJhc2VUcmFuc2l0aW9uUHJvcHNWYWxpZGF0b3JzLFxuICBET01UcmFuc2l0aW9uUHJvcHNWYWxpZGF0b3JzXG4pO1xuY29uc3QgY2FsbEhvb2sgPSAoaG9vaywgYXJncyA9IFtdKSA9PiB7XG4gIGlmIChpc0FycmF5KGhvb2spKSB7XG4gICAgaG9vay5mb3JFYWNoKChoMikgPT4gaDIoLi4uYXJncykpO1xuICB9IGVsc2UgaWYgKGhvb2spIHtcbiAgICBob29rKC4uLmFyZ3MpO1xuICB9XG59O1xuY29uc3QgaGFzRXhwbGljaXRDYWxsYmFjayA9IChob29rKSA9PiB7XG4gIHJldHVybiBob29rID8gaXNBcnJheShob29rKSA/IGhvb2suc29tZSgoaDIpID0+IGgyLmxlbmd0aCA+IDEpIDogaG9vay5sZW5ndGggPiAxIDogZmFsc2U7XG59O1xuZnVuY3Rpb24gcmVzb2x2ZVRyYW5zaXRpb25Qcm9wcyhyYXdQcm9wcykge1xuICBjb25zdCBiYXNlUHJvcHMgPSB7fTtcbiAgZm9yIChjb25zdCBrZXkgaW4gcmF3UHJvcHMpIHtcbiAgICBpZiAoIShrZXkgaW4gRE9NVHJhbnNpdGlvblByb3BzVmFsaWRhdG9ycykpIHtcbiAgICAgIGJhc2VQcm9wc1trZXldID0gcmF3UHJvcHNba2V5XTtcbiAgICB9XG4gIH1cbiAgaWYgKHJhd1Byb3BzLmNzcyA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gYmFzZVByb3BzO1xuICB9XG4gIGNvbnN0IHtcbiAgICBuYW1lID0gXCJ2XCIsXG4gICAgdHlwZSxcbiAgICBkdXJhdGlvbixcbiAgICBlbnRlckZyb21DbGFzcyA9IGAke25hbWV9LWVudGVyLWZyb21gLFxuICAgIGVudGVyQWN0aXZlQ2xhc3MgPSBgJHtuYW1lfS1lbnRlci1hY3RpdmVgLFxuICAgIGVudGVyVG9DbGFzcyA9IGAke25hbWV9LWVudGVyLXRvYCxcbiAgICBhcHBlYXJGcm9tQ2xhc3MgPSBlbnRlckZyb21DbGFzcyxcbiAgICBhcHBlYXJBY3RpdmVDbGFzcyA9IGVudGVyQWN0aXZlQ2xhc3MsXG4gICAgYXBwZWFyVG9DbGFzcyA9IGVudGVyVG9DbGFzcyxcbiAgICBsZWF2ZUZyb21DbGFzcyA9IGAke25hbWV9LWxlYXZlLWZyb21gLFxuICAgIGxlYXZlQWN0aXZlQ2xhc3MgPSBgJHtuYW1lfS1sZWF2ZS1hY3RpdmVgLFxuICAgIGxlYXZlVG9DbGFzcyA9IGAke25hbWV9LWxlYXZlLXRvYFxuICB9ID0gcmF3UHJvcHM7XG4gIGNvbnN0IGR1cmF0aW9ucyA9IG5vcm1hbGl6ZUR1cmF0aW9uKGR1cmF0aW9uKTtcbiAgY29uc3QgZW50ZXJEdXJhdGlvbiA9IGR1cmF0aW9ucyAmJiBkdXJhdGlvbnNbMF07XG4gIGNvbnN0IGxlYXZlRHVyYXRpb24gPSBkdXJhdGlvbnMgJiYgZHVyYXRpb25zWzFdO1xuICBjb25zdCB7XG4gICAgb25CZWZvcmVFbnRlcixcbiAgICBvbkVudGVyLFxuICAgIG9uRW50ZXJDYW5jZWxsZWQsXG4gICAgb25MZWF2ZSxcbiAgICBvbkxlYXZlQ2FuY2VsbGVkLFxuICAgIG9uQmVmb3JlQXBwZWFyID0gb25CZWZvcmVFbnRlcixcbiAgICBvbkFwcGVhciA9IG9uRW50ZXIsXG4gICAgb25BcHBlYXJDYW5jZWxsZWQgPSBvbkVudGVyQ2FuY2VsbGVkXG4gIH0gPSBiYXNlUHJvcHM7XG4gIGNvbnN0IGZpbmlzaEVudGVyID0gKGVsLCBpc0FwcGVhciwgZG9uZSkgPT4ge1xuICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgaXNBcHBlYXIgPyBhcHBlYXJUb0NsYXNzIDogZW50ZXJUb0NsYXNzKTtcbiAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGlzQXBwZWFyID8gYXBwZWFyQWN0aXZlQ2xhc3MgOiBlbnRlckFjdGl2ZUNsYXNzKTtcbiAgICBkb25lICYmIGRvbmUoKTtcbiAgfTtcbiAgY29uc3QgZmluaXNoTGVhdmUgPSAoZWwsIGRvbmUpID0+IHtcbiAgICBlbC5faXNMZWF2aW5nID0gZmFsc2U7XG4gICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUZyb21DbGFzcyk7XG4gICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZVRvQ2xhc3MpO1xuICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVBY3RpdmVDbGFzcyk7XG4gICAgZG9uZSAmJiBkb25lKCk7XG4gIH07XG4gIGNvbnN0IG1ha2VFbnRlckhvb2sgPSAoaXNBcHBlYXIpID0+IHtcbiAgICByZXR1cm4gKGVsLCBkb25lKSA9PiB7XG4gICAgICBjb25zdCBob29rID0gaXNBcHBlYXIgPyBvbkFwcGVhciA6IG9uRW50ZXI7XG4gICAgICBjb25zdCByZXNvbHZlID0gKCkgPT4gZmluaXNoRW50ZXIoZWwsIGlzQXBwZWFyLCBkb25lKTtcbiAgICAgIGNhbGxIb29rKGhvb2ssIFtlbCwgcmVzb2x2ZV0pO1xuICAgICAgbmV4dEZyYW1lKCgpID0+IHtcbiAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBpc0FwcGVhciA/IGFwcGVhckZyb21DbGFzcyA6IGVudGVyRnJvbUNsYXNzKTtcbiAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBpc0FwcGVhciA/IGFwcGVhclRvQ2xhc3MgOiBlbnRlclRvQ2xhc3MpO1xuICAgICAgICBpZiAoIWhhc0V4cGxpY2l0Q2FsbGJhY2soaG9vaykpIHtcbiAgICAgICAgICB3aGVuVHJhbnNpdGlvbkVuZHMoZWwsIHR5cGUsIGVudGVyRHVyYXRpb24sIHJlc29sdmUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuICB9O1xuICByZXR1cm4gZXh0ZW5kKGJhc2VQcm9wcywge1xuICAgIG9uQmVmb3JlRW50ZXIoZWwpIHtcbiAgICAgIGNhbGxIb29rKG9uQmVmb3JlRW50ZXIsIFtlbF0pO1xuICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBlbnRlckZyb21DbGFzcyk7XG4gICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGVudGVyQWN0aXZlQ2xhc3MpO1xuICAgIH0sXG4gICAgb25CZWZvcmVBcHBlYXIoZWwpIHtcbiAgICAgIGNhbGxIb29rKG9uQmVmb3JlQXBwZWFyLCBbZWxdKTtcbiAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgYXBwZWFyRnJvbUNsYXNzKTtcbiAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgYXBwZWFyQWN0aXZlQ2xhc3MpO1xuICAgIH0sXG4gICAgb25FbnRlcjogbWFrZUVudGVySG9vayhmYWxzZSksXG4gICAgb25BcHBlYXI6IG1ha2VFbnRlckhvb2sodHJ1ZSksXG4gICAgb25MZWF2ZShlbCwgZG9uZSkge1xuICAgICAgZWwuX2lzTGVhdmluZyA9IHRydWU7XG4gICAgICBjb25zdCByZXNvbHZlID0gKCkgPT4gZmluaXNoTGVhdmUoZWwsIGRvbmUpO1xuICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUZyb21DbGFzcyk7XG4gICAgICBmb3JjZVJlZmxvdygpO1xuICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUFjdGl2ZUNsYXNzKTtcbiAgICAgIG5leHRGcmFtZSgoKSA9PiB7XG4gICAgICAgIGlmICghZWwuX2lzTGVhdmluZykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlRnJvbUNsYXNzKTtcbiAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZVRvQ2xhc3MpO1xuICAgICAgICBpZiAoIWhhc0V4cGxpY2l0Q2FsbGJhY2sob25MZWF2ZSkpIHtcbiAgICAgICAgICB3aGVuVHJhbnNpdGlvbkVuZHMoZWwsIHR5cGUsIGxlYXZlRHVyYXRpb24sIHJlc29sdmUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGNhbGxIb29rKG9uTGVhdmUsIFtlbCwgcmVzb2x2ZV0pO1xuICAgIH0sXG4gICAgb25FbnRlckNhbmNlbGxlZChlbCkge1xuICAgICAgZmluaXNoRW50ZXIoZWwsIGZhbHNlKTtcbiAgICAgIGNhbGxIb29rKG9uRW50ZXJDYW5jZWxsZWQsIFtlbF0pO1xuICAgIH0sXG4gICAgb25BcHBlYXJDYW5jZWxsZWQoZWwpIHtcbiAgICAgIGZpbmlzaEVudGVyKGVsLCB0cnVlKTtcbiAgICAgIGNhbGxIb29rKG9uQXBwZWFyQ2FuY2VsbGVkLCBbZWxdKTtcbiAgICB9LFxuICAgIG9uTGVhdmVDYW5jZWxsZWQoZWwpIHtcbiAgICAgIGZpbmlzaExlYXZlKGVsKTtcbiAgICAgIGNhbGxIb29rKG9uTGVhdmVDYW5jZWxsZWQsIFtlbF0pO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBub3JtYWxpemVEdXJhdGlvbihkdXJhdGlvbikge1xuICBpZiAoZHVyYXRpb24gPT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9IGVsc2UgaWYgKGlzT2JqZWN0KGR1cmF0aW9uKSkge1xuICAgIHJldHVybiBbTnVtYmVyT2YoZHVyYXRpb24uZW50ZXIpLCBOdW1iZXJPZihkdXJhdGlvbi5sZWF2ZSldO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IG4gPSBOdW1iZXJPZihkdXJhdGlvbik7XG4gICAgcmV0dXJuIFtuLCBuXTtcbiAgfVxufVxuZnVuY3Rpb24gTnVtYmVyT2YodmFsKSB7XG4gIGNvbnN0IHJlcyA9IHRvTnVtYmVyKHZhbCk7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgYXNzZXJ0TnVtYmVyKHJlcywgXCI8dHJhbnNpdGlvbj4gZXhwbGljaXQgZHVyYXRpb25cIik7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cbmZ1bmN0aW9uIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgY2xzKSB7XG4gIGNscy5zcGxpdCgvXFxzKy8pLmZvckVhY2goKGMpID0+IGMgJiYgZWwuY2xhc3NMaXN0LmFkZChjKSk7XG4gIChlbC5fdnRjIHx8IChlbC5fdnRjID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSkpLmFkZChjbHMpO1xufVxuZnVuY3Rpb24gcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBjbHMpIHtcbiAgY2xzLnNwbGl0KC9cXHMrLykuZm9yRWFjaCgoYykgPT4gYyAmJiBlbC5jbGFzc0xpc3QucmVtb3ZlKGMpKTtcbiAgY29uc3QgeyBfdnRjIH0gPSBlbDtcbiAgaWYgKF92dGMpIHtcbiAgICBfdnRjLmRlbGV0ZShjbHMpO1xuICAgIGlmICghX3Z0Yy5zaXplKSB7XG4gICAgICBlbC5fdnRjID0gdm9pZCAwO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gbmV4dEZyYW1lKGNiKSB7XG4gIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGNiKTtcbiAgfSk7XG59XG5sZXQgZW5kSWQgPSAwO1xuZnVuY3Rpb24gd2hlblRyYW5zaXRpb25FbmRzKGVsLCBleHBlY3RlZFR5cGUsIGV4cGxpY2l0VGltZW91dCwgcmVzb2x2ZSkge1xuICBjb25zdCBpZCA9IGVsLl9lbmRJZCA9ICsrZW5kSWQ7XG4gIGNvbnN0IHJlc29sdmVJZk5vdFN0YWxlID0gKCkgPT4ge1xuICAgIGlmIChpZCA9PT0gZWwuX2VuZElkKSB7XG4gICAgICByZXNvbHZlKCk7XG4gICAgfVxuICB9O1xuICBpZiAoZXhwbGljaXRUaW1lb3V0KSB7XG4gICAgcmV0dXJuIHNldFRpbWVvdXQocmVzb2x2ZUlmTm90U3RhbGUsIGV4cGxpY2l0VGltZW91dCk7XG4gIH1cbiAgY29uc3QgeyB0eXBlLCB0aW1lb3V0LCBwcm9wQ291bnQgfSA9IGdldFRyYW5zaXRpb25JbmZvKGVsLCBleHBlY3RlZFR5cGUpO1xuICBpZiAoIXR5cGUpIHtcbiAgICByZXR1cm4gcmVzb2x2ZSgpO1xuICB9XG4gIGNvbnN0IGVuZEV2ZW50ID0gdHlwZSArIFwiZW5kXCI7XG4gIGxldCBlbmRlZCA9IDA7XG4gIGNvbnN0IGVuZCA9ICgpID0+IHtcbiAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKGVuZEV2ZW50LCBvbkVuZCk7XG4gICAgcmVzb2x2ZUlmTm90U3RhbGUoKTtcbiAgfTtcbiAgY29uc3Qgb25FbmQgPSAoZSkgPT4ge1xuICAgIGlmIChlLnRhcmdldCA9PT0gZWwgJiYgKytlbmRlZCA+PSBwcm9wQ291bnQpIHtcbiAgICAgIGVuZCgpO1xuICAgIH1cbiAgfTtcbiAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgaWYgKGVuZGVkIDwgcHJvcENvdW50KSB7XG4gICAgICBlbmQoKTtcbiAgICB9XG4gIH0sIHRpbWVvdXQgKyAxKTtcbiAgZWwuYWRkRXZlbnRMaXN0ZW5lcihlbmRFdmVudCwgb25FbmQpO1xufVxuZnVuY3Rpb24gZ2V0VHJhbnNpdGlvbkluZm8oZWwsIGV4cGVjdGVkVHlwZSkge1xuICBjb25zdCBzdHlsZXMgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbCk7XG4gIGNvbnN0IGdldFN0eWxlUHJvcGVydGllcyA9IChrZXkpID0+IChzdHlsZXNba2V5XSB8fCBcIlwiKS5zcGxpdChcIiwgXCIpO1xuICBjb25zdCB0cmFuc2l0aW9uRGVsYXlzID0gZ2V0U3R5bGVQcm9wZXJ0aWVzKGAke1RSQU5TSVRJT059RGVsYXlgKTtcbiAgY29uc3QgdHJhbnNpdGlvbkR1cmF0aW9ucyA9IGdldFN0eWxlUHJvcGVydGllcyhgJHtUUkFOU0lUSU9OfUR1cmF0aW9uYCk7XG4gIGNvbnN0IHRyYW5zaXRpb25UaW1lb3V0ID0gZ2V0VGltZW91dCh0cmFuc2l0aW9uRGVsYXlzLCB0cmFuc2l0aW9uRHVyYXRpb25zKTtcbiAgY29uc3QgYW5pbWF0aW9uRGVsYXlzID0gZ2V0U3R5bGVQcm9wZXJ0aWVzKGAke0FOSU1BVElPTn1EZWxheWApO1xuICBjb25zdCBhbmltYXRpb25EdXJhdGlvbnMgPSBnZXRTdHlsZVByb3BlcnRpZXMoYCR7QU5JTUFUSU9OfUR1cmF0aW9uYCk7XG4gIGNvbnN0IGFuaW1hdGlvblRpbWVvdXQgPSBnZXRUaW1lb3V0KGFuaW1hdGlvbkRlbGF5cywgYW5pbWF0aW9uRHVyYXRpb25zKTtcbiAgbGV0IHR5cGUgPSBudWxsO1xuICBsZXQgdGltZW91dCA9IDA7XG4gIGxldCBwcm9wQ291bnQgPSAwO1xuICBpZiAoZXhwZWN0ZWRUeXBlID09PSBUUkFOU0lUSU9OKSB7XG4gICAgaWYgKHRyYW5zaXRpb25UaW1lb3V0ID4gMCkge1xuICAgICAgdHlwZSA9IFRSQU5TSVRJT047XG4gICAgICB0aW1lb3V0ID0gdHJhbnNpdGlvblRpbWVvdXQ7XG4gICAgICBwcm9wQ291bnQgPSB0cmFuc2l0aW9uRHVyYXRpb25zLmxlbmd0aDtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZXhwZWN0ZWRUeXBlID09PSBBTklNQVRJT04pIHtcbiAgICBpZiAoYW5pbWF0aW9uVGltZW91dCA+IDApIHtcbiAgICAgIHR5cGUgPSBBTklNQVRJT047XG4gICAgICB0aW1lb3V0ID0gYW5pbWF0aW9uVGltZW91dDtcbiAgICAgIHByb3BDb3VudCA9IGFuaW1hdGlvbkR1cmF0aW9ucy5sZW5ndGg7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRpbWVvdXQgPSBNYXRoLm1heCh0cmFuc2l0aW9uVGltZW91dCwgYW5pbWF0aW9uVGltZW91dCk7XG4gICAgdHlwZSA9IHRpbWVvdXQgPiAwID8gdHJhbnNpdGlvblRpbWVvdXQgPiBhbmltYXRpb25UaW1lb3V0ID8gVFJBTlNJVElPTiA6IEFOSU1BVElPTiA6IG51bGw7XG4gICAgcHJvcENvdW50ID0gdHlwZSA/IHR5cGUgPT09IFRSQU5TSVRJT04gPyB0cmFuc2l0aW9uRHVyYXRpb25zLmxlbmd0aCA6IGFuaW1hdGlvbkR1cmF0aW9ucy5sZW5ndGggOiAwO1xuICB9XG4gIGNvbnN0IGhhc1RyYW5zZm9ybSA9IHR5cGUgPT09IFRSQU5TSVRJT04gJiYgL1xcYih0cmFuc2Zvcm18YWxsKSgsfCQpLy50ZXN0KFxuICAgIGdldFN0eWxlUHJvcGVydGllcyhgJHtUUkFOU0lUSU9OfVByb3BlcnR5YCkudG9TdHJpbmcoKVxuICApO1xuICByZXR1cm4ge1xuICAgIHR5cGUsXG4gICAgdGltZW91dCxcbiAgICBwcm9wQ291bnQsXG4gICAgaGFzVHJhbnNmb3JtXG4gIH07XG59XG5mdW5jdGlvbiBnZXRUaW1lb3V0KGRlbGF5cywgZHVyYXRpb25zKSB7XG4gIHdoaWxlIChkZWxheXMubGVuZ3RoIDwgZHVyYXRpb25zLmxlbmd0aCkge1xuICAgIGRlbGF5cyA9IGRlbGF5cy5jb25jYXQoZGVsYXlzKTtcbiAgfVxuICByZXR1cm4gTWF0aC5tYXgoLi4uZHVyYXRpb25zLm1hcCgoZCwgaSkgPT4gdG9NcyhkKSArIHRvTXMoZGVsYXlzW2ldKSkpO1xufVxuZnVuY3Rpb24gdG9NcyhzKSB7XG4gIHJldHVybiBOdW1iZXIocy5zbGljZSgwLCAtMSkucmVwbGFjZShcIixcIiwgXCIuXCIpKSAqIDFlMztcbn1cbmZ1bmN0aW9uIGZvcmNlUmVmbG93KCkge1xuICByZXR1cm4gZG9jdW1lbnQuYm9keS5vZmZzZXRIZWlnaHQ7XG59XG5cbmNvbnN0IHBvc2l0aW9uTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG5jb25zdCBuZXdQb3NpdGlvbk1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuY29uc3QgVHJhbnNpdGlvbkdyb3VwSW1wbCA9IHtcbiAgbmFtZTogXCJUcmFuc2l0aW9uR3JvdXBcIixcbiAgcHJvcHM6IC8qIEBfX1BVUkVfXyAqLyBleHRlbmQoe30sIFRyYW5zaXRpb25Qcm9wc1ZhbGlkYXRvcnMsIHtcbiAgICB0YWc6IFN0cmluZyxcbiAgICBtb3ZlQ2xhc3M6IFN0cmluZ1xuICB9KSxcbiAgc2V0dXAocHJvcHMsIHsgc2xvdHMgfSkge1xuICAgIGNvbnN0IGluc3RhbmNlID0gZ2V0Q3VycmVudEluc3RhbmNlKCk7XG4gICAgY29uc3Qgc3RhdGUgPSB1c2VUcmFuc2l0aW9uU3RhdGUoKTtcbiAgICBsZXQgcHJldkNoaWxkcmVuO1xuICAgIGxldCBjaGlsZHJlbjtcbiAgICBvblVwZGF0ZWQoKCkgPT4ge1xuICAgICAgaWYgKCFwcmV2Q2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG1vdmVDbGFzcyA9IHByb3BzLm1vdmVDbGFzcyB8fCBgJHtwcm9wcy5uYW1lIHx8IFwidlwifS1tb3ZlYDtcbiAgICAgIGlmICghaGFzQ1NTVHJhbnNmb3JtKFxuICAgICAgICBwcmV2Q2hpbGRyZW5bMF0uZWwsXG4gICAgICAgIGluc3RhbmNlLnZub2RlLmVsLFxuICAgICAgICBtb3ZlQ2xhc3NcbiAgICAgICkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcHJldkNoaWxkcmVuLmZvckVhY2goY2FsbFBlbmRpbmdDYnMpO1xuICAgICAgcHJldkNoaWxkcmVuLmZvckVhY2gocmVjb3JkUG9zaXRpb24pO1xuICAgICAgY29uc3QgbW92ZWRDaGlsZHJlbiA9IHByZXZDaGlsZHJlbi5maWx0ZXIoYXBwbHlUcmFuc2xhdGlvbik7XG4gICAgICBmb3JjZVJlZmxvdygpO1xuICAgICAgbW92ZWRDaGlsZHJlbi5mb3JFYWNoKChjKSA9PiB7XG4gICAgICAgIGNvbnN0IGVsID0gYy5lbDtcbiAgICAgICAgY29uc3Qgc3R5bGUgPSBlbC5zdHlsZTtcbiAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBtb3ZlQ2xhc3MpO1xuICAgICAgICBzdHlsZS50cmFuc2Zvcm0gPSBzdHlsZS53ZWJraXRUcmFuc2Zvcm0gPSBzdHlsZS50cmFuc2l0aW9uRHVyYXRpb24gPSBcIlwiO1xuICAgICAgICBjb25zdCBjYiA9IGVsLl9tb3ZlQ2IgPSAoZSkgPT4ge1xuICAgICAgICAgIGlmIChlICYmIGUudGFyZ2V0ICE9PSBlbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWUgfHwgL3RyYW5zZm9ybSQvLnRlc3QoZS5wcm9wZXJ0eU5hbWUpKSB7XG4gICAgICAgICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKFwidHJhbnNpdGlvbmVuZFwiLCBjYik7XG4gICAgICAgICAgICBlbC5fbW92ZUNiID0gbnVsbDtcbiAgICAgICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbW92ZUNsYXNzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoXCJ0cmFuc2l0aW9uZW5kXCIsIGNiKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBjb25zdCByYXdQcm9wcyA9IHRvUmF3KHByb3BzKTtcbiAgICAgIGNvbnN0IGNzc1RyYW5zaXRpb25Qcm9wcyA9IHJlc29sdmVUcmFuc2l0aW9uUHJvcHMocmF3UHJvcHMpO1xuICAgICAgbGV0IHRhZyA9IHJhd1Byb3BzLnRhZyB8fCBGcmFnbWVudDtcbiAgICAgIHByZXZDaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgICAgY2hpbGRyZW4gPSBzbG90cy5kZWZhdWx0ID8gZ2V0VHJhbnNpdGlvblJhd0NoaWxkcmVuKHNsb3RzLmRlZmF1bHQoKSkgOiBbXTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgICAgaWYgKGNoaWxkLmtleSAhPSBudWxsKSB7XG4gICAgICAgICAgc2V0VHJhbnNpdGlvbkhvb2tzKFxuICAgICAgICAgICAgY2hpbGQsXG4gICAgICAgICAgICByZXNvbHZlVHJhbnNpdGlvbkhvb2tzKGNoaWxkLCBjc3NUcmFuc2l0aW9uUHJvcHMsIHN0YXRlLCBpbnN0YW5jZSlcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICB3YXJuKGA8VHJhbnNpdGlvbkdyb3VwPiBjaGlsZHJlbiBtdXN0IGJlIGtleWVkLmApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocHJldkNoaWxkcmVuKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJldkNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY29uc3QgY2hpbGQgPSBwcmV2Q2hpbGRyZW5baV07XG4gICAgICAgICAgc2V0VHJhbnNpdGlvbkhvb2tzKFxuICAgICAgICAgICAgY2hpbGQsXG4gICAgICAgICAgICByZXNvbHZlVHJhbnNpdGlvbkhvb2tzKGNoaWxkLCBjc3NUcmFuc2l0aW9uUHJvcHMsIHN0YXRlLCBpbnN0YW5jZSlcbiAgICAgICAgICApO1xuICAgICAgICAgIHBvc2l0aW9uTWFwLnNldChjaGlsZCwgY2hpbGQuZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gY3JlYXRlVk5vZGUodGFnLCBudWxsLCBjaGlsZHJlbik7XG4gICAgfTtcbiAgfVxufTtcbmNvbnN0IHJlbW92ZU1vZGUgPSAocHJvcHMpID0+IGRlbGV0ZSBwcm9wcy5tb2RlO1xuLyogQF9fUFVSRV9fICovIHJlbW92ZU1vZGUoVHJhbnNpdGlvbkdyb3VwSW1wbC5wcm9wcyk7XG5jb25zdCBUcmFuc2l0aW9uR3JvdXAgPSBUcmFuc2l0aW9uR3JvdXBJbXBsO1xuZnVuY3Rpb24gY2FsbFBlbmRpbmdDYnMoYykge1xuICBjb25zdCBlbCA9IGMuZWw7XG4gIGlmIChlbC5fbW92ZUNiKSB7XG4gICAgZWwuX21vdmVDYigpO1xuICB9XG4gIGlmIChlbC5fZW50ZXJDYikge1xuICAgIGVsLl9lbnRlckNiKCk7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlY29yZFBvc2l0aW9uKGMpIHtcbiAgbmV3UG9zaXRpb25NYXAuc2V0KGMsIGMuZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkpO1xufVxuZnVuY3Rpb24gYXBwbHlUcmFuc2xhdGlvbihjKSB7XG4gIGNvbnN0IG9sZFBvcyA9IHBvc2l0aW9uTWFwLmdldChjKTtcbiAgY29uc3QgbmV3UG9zID0gbmV3UG9zaXRpb25NYXAuZ2V0KGMpO1xuICBjb25zdCBkeCA9IG9sZFBvcy5sZWZ0IC0gbmV3UG9zLmxlZnQ7XG4gIGNvbnN0IGR5ID0gb2xkUG9zLnRvcCAtIG5ld1Bvcy50b3A7XG4gIGlmIChkeCB8fCBkeSkge1xuICAgIGNvbnN0IHMgPSBjLmVsLnN0eWxlO1xuICAgIHMudHJhbnNmb3JtID0gcy53ZWJraXRUcmFuc2Zvcm0gPSBgdHJhbnNsYXRlKCR7ZHh9cHgsJHtkeX1weClgO1xuICAgIHMudHJhbnNpdGlvbkR1cmF0aW9uID0gXCIwc1wiO1xuICAgIHJldHVybiBjO1xuICB9XG59XG5mdW5jdGlvbiBoYXNDU1NUcmFuc2Zvcm0oZWwsIHJvb3QsIG1vdmVDbGFzcykge1xuICBjb25zdCBjbG9uZSA9IGVsLmNsb25lTm9kZSgpO1xuICBpZiAoZWwuX3Z0Yykge1xuICAgIGVsLl92dGMuZm9yRWFjaCgoY2xzKSA9PiB7XG4gICAgICBjbHMuc3BsaXQoL1xccysvKS5mb3JFYWNoKChjKSA9PiBjICYmIGNsb25lLmNsYXNzTGlzdC5yZW1vdmUoYykpO1xuICAgIH0pO1xuICB9XG4gIG1vdmVDbGFzcy5zcGxpdCgvXFxzKy8pLmZvckVhY2goKGMpID0+IGMgJiYgY2xvbmUuY2xhc3NMaXN0LmFkZChjKSk7XG4gIGNsb25lLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgY29uc3QgY29udGFpbmVyID0gcm9vdC5ub2RlVHlwZSA9PT0gMSA/IHJvb3QgOiByb290LnBhcmVudE5vZGU7XG4gIGNvbnRhaW5lci5hcHBlbmRDaGlsZChjbG9uZSk7XG4gIGNvbnN0IHsgaGFzVHJhbnNmb3JtIH0gPSBnZXRUcmFuc2l0aW9uSW5mbyhjbG9uZSk7XG4gIGNvbnRhaW5lci5yZW1vdmVDaGlsZChjbG9uZSk7XG4gIHJldHVybiBoYXNUcmFuc2Zvcm07XG59XG5cbmNvbnN0IGdldE1vZGVsQXNzaWduZXIgPSAodm5vZGUpID0+IHtcbiAgY29uc3QgZm4gPSB2bm9kZS5wcm9wc1tcIm9uVXBkYXRlOm1vZGVsVmFsdWVcIl0gfHwgZmFsc2U7XG4gIHJldHVybiBpc0FycmF5KGZuKSA/ICh2YWx1ZSkgPT4gaW52b2tlQXJyYXlGbnMoZm4sIHZhbHVlKSA6IGZuO1xufTtcbmZ1bmN0aW9uIG9uQ29tcG9zaXRpb25TdGFydChlKSB7XG4gIGUudGFyZ2V0LmNvbXBvc2luZyA9IHRydWU7XG59XG5mdW5jdGlvbiBvbkNvbXBvc2l0aW9uRW5kKGUpIHtcbiAgY29uc3QgdGFyZ2V0ID0gZS50YXJnZXQ7XG4gIGlmICh0YXJnZXQuY29tcG9zaW5nKSB7XG4gICAgdGFyZ2V0LmNvbXBvc2luZyA9IGZhbHNlO1xuICAgIHRhcmdldC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChcImlucHV0XCIpKTtcbiAgfVxufVxuY29uc3Qgdk1vZGVsVGV4dCA9IHtcbiAgY3JlYXRlZChlbCwgeyBtb2RpZmllcnM6IHsgbGF6eSwgdHJpbSwgbnVtYmVyIH0gfSwgdm5vZGUpIHtcbiAgICBlbC5fYXNzaWduID0gZ2V0TW9kZWxBc3NpZ25lcih2bm9kZSk7XG4gICAgY29uc3QgY2FzdFRvTnVtYmVyID0gbnVtYmVyIHx8IHZub2RlLnByb3BzICYmIHZub2RlLnByb3BzLnR5cGUgPT09IFwibnVtYmVyXCI7XG4gICAgYWRkRXZlbnRMaXN0ZW5lcihlbCwgbGF6eSA/IFwiY2hhbmdlXCIgOiBcImlucHV0XCIsIChlKSA9PiB7XG4gICAgICBpZiAoZS50YXJnZXQuY29tcG9zaW5nKVxuICAgICAgICByZXR1cm47XG4gICAgICBsZXQgZG9tVmFsdWUgPSBlbC52YWx1ZTtcbiAgICAgIGlmICh0cmltKSB7XG4gICAgICAgIGRvbVZhbHVlID0gZG9tVmFsdWUudHJpbSgpO1xuICAgICAgfVxuICAgICAgaWYgKGNhc3RUb051bWJlcikge1xuICAgICAgICBkb21WYWx1ZSA9IGxvb3NlVG9OdW1iZXIoZG9tVmFsdWUpO1xuICAgICAgfVxuICAgICAgZWwuX2Fzc2lnbihkb21WYWx1ZSk7XG4gICAgfSk7XG4gICAgaWYgKHRyaW0pIHtcbiAgICAgIGFkZEV2ZW50TGlzdGVuZXIoZWwsIFwiY2hhbmdlXCIsICgpID0+IHtcbiAgICAgICAgZWwudmFsdWUgPSBlbC52YWx1ZS50cmltKCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKCFsYXp5KSB7XG4gICAgICBhZGRFdmVudExpc3RlbmVyKGVsLCBcImNvbXBvc2l0aW9uc3RhcnRcIiwgb25Db21wb3NpdGlvblN0YXJ0KTtcbiAgICAgIGFkZEV2ZW50TGlzdGVuZXIoZWwsIFwiY29tcG9zaXRpb25lbmRcIiwgb25Db21wb3NpdGlvbkVuZCk7XG4gICAgICBhZGRFdmVudExpc3RlbmVyKGVsLCBcImNoYW5nZVwiLCBvbkNvbXBvc2l0aW9uRW5kKTtcbiAgICB9XG4gIH0sXG4gIC8vIHNldCB2YWx1ZSBvbiBtb3VudGVkIHNvIGl0J3MgYWZ0ZXIgbWluL21heCBmb3IgdHlwZT1cInJhbmdlXCJcbiAgbW91bnRlZChlbCwgeyB2YWx1ZSB9KSB7XG4gICAgZWwudmFsdWUgPSB2YWx1ZSA9PSBudWxsID8gXCJcIiA6IHZhbHVlO1xuICB9LFxuICBiZWZvcmVVcGRhdGUoZWwsIHsgdmFsdWUsIG1vZGlmaWVyczogeyBsYXp5LCB0cmltLCBudW1iZXIgfSB9LCB2bm9kZSkge1xuICAgIGVsLl9hc3NpZ24gPSBnZXRNb2RlbEFzc2lnbmVyKHZub2RlKTtcbiAgICBpZiAoZWwuY29tcG9zaW5nKVxuICAgICAgcmV0dXJuO1xuICAgIGlmIChkb2N1bWVudC5hY3RpdmVFbGVtZW50ID09PSBlbCAmJiBlbC50eXBlICE9PSBcInJhbmdlXCIpIHtcbiAgICAgIGlmIChsYXp5KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh0cmltICYmIGVsLnZhbHVlLnRyaW0oKSA9PT0gdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKChudW1iZXIgfHwgZWwudHlwZSA9PT0gXCJudW1iZXJcIikgJiYgbG9vc2VUb051bWJlcihlbC52YWx1ZSkgPT09IHZhbHVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgbmV3VmFsdWUgPSB2YWx1ZSA9PSBudWxsID8gXCJcIiA6IHZhbHVlO1xuICAgIGlmIChlbC52YWx1ZSAhPT0gbmV3VmFsdWUpIHtcbiAgICAgIGVsLnZhbHVlID0gbmV3VmFsdWU7XG4gICAgfVxuICB9XG59O1xuY29uc3Qgdk1vZGVsQ2hlY2tib3ggPSB7XG4gIC8vICM0MDk2IGFycmF5IGNoZWNrYm94ZXMgbmVlZCB0byBiZSBkZWVwIHRyYXZlcnNlZFxuICBkZWVwOiB0cnVlLFxuICBjcmVhdGVkKGVsLCBfLCB2bm9kZSkge1xuICAgIGVsLl9hc3NpZ24gPSBnZXRNb2RlbEFzc2lnbmVyKHZub2RlKTtcbiAgICBhZGRFdmVudExpc3RlbmVyKGVsLCBcImNoYW5nZVwiLCAoKSA9PiB7XG4gICAgICBjb25zdCBtb2RlbFZhbHVlID0gZWwuX21vZGVsVmFsdWU7XG4gICAgICBjb25zdCBlbGVtZW50VmFsdWUgPSBnZXRWYWx1ZShlbCk7XG4gICAgICBjb25zdCBjaGVja2VkID0gZWwuY2hlY2tlZDtcbiAgICAgIGNvbnN0IGFzc2lnbiA9IGVsLl9hc3NpZ247XG4gICAgICBpZiAoaXNBcnJheShtb2RlbFZhbHVlKSkge1xuICAgICAgICBjb25zdCBpbmRleCA9IGxvb3NlSW5kZXhPZihtb2RlbFZhbHVlLCBlbGVtZW50VmFsdWUpO1xuICAgICAgICBjb25zdCBmb3VuZCA9IGluZGV4ICE9PSAtMTtcbiAgICAgICAgaWYgKGNoZWNrZWQgJiYgIWZvdW5kKSB7XG4gICAgICAgICAgYXNzaWduKG1vZGVsVmFsdWUuY29uY2F0KGVsZW1lbnRWYWx1ZSkpO1xuICAgICAgICB9IGVsc2UgaWYgKCFjaGVja2VkICYmIGZvdW5kKSB7XG4gICAgICAgICAgY29uc3QgZmlsdGVyZWQgPSBbLi4ubW9kZWxWYWx1ZV07XG4gICAgICAgICAgZmlsdGVyZWQuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICBhc3NpZ24oZmlsdGVyZWQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGlzU2V0KG1vZGVsVmFsdWUpKSB7XG4gICAgICAgIGNvbnN0IGNsb25lZCA9IG5ldyBTZXQobW9kZWxWYWx1ZSk7XG4gICAgICAgIGlmIChjaGVja2VkKSB7XG4gICAgICAgICAgY2xvbmVkLmFkZChlbGVtZW50VmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNsb25lZC5kZWxldGUoZWxlbWVudFZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBhc3NpZ24oY2xvbmVkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFzc2lnbihnZXRDaGVja2JveFZhbHVlKGVsLCBjaGVja2VkKSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG4gIC8vIHNldCBpbml0aWFsIGNoZWNrZWQgb24gbW91bnQgdG8gd2FpdCBmb3IgdHJ1ZS12YWx1ZS9mYWxzZS12YWx1ZVxuICBtb3VudGVkOiBzZXRDaGVja2VkLFxuICBiZWZvcmVVcGRhdGUoZWwsIGJpbmRpbmcsIHZub2RlKSB7XG4gICAgZWwuX2Fzc2lnbiA9IGdldE1vZGVsQXNzaWduZXIodm5vZGUpO1xuICAgIHNldENoZWNrZWQoZWwsIGJpbmRpbmcsIHZub2RlKTtcbiAgfVxufTtcbmZ1bmN0aW9uIHNldENoZWNrZWQoZWwsIHsgdmFsdWUsIG9sZFZhbHVlIH0sIHZub2RlKSB7XG4gIGVsLl9tb2RlbFZhbHVlID0gdmFsdWU7XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIGVsLmNoZWNrZWQgPSBsb29zZUluZGV4T2YodmFsdWUsIHZub2RlLnByb3BzLnZhbHVlKSA+IC0xO1xuICB9IGVsc2UgaWYgKGlzU2V0KHZhbHVlKSkge1xuICAgIGVsLmNoZWNrZWQgPSB2YWx1ZS5oYXModm5vZGUucHJvcHMudmFsdWUpO1xuICB9IGVsc2UgaWYgKHZhbHVlICE9PSBvbGRWYWx1ZSkge1xuICAgIGVsLmNoZWNrZWQgPSBsb29zZUVxdWFsKHZhbHVlLCBnZXRDaGVja2JveFZhbHVlKGVsLCB0cnVlKSk7XG4gIH1cbn1cbmNvbnN0IHZNb2RlbFJhZGlvID0ge1xuICBjcmVhdGVkKGVsLCB7IHZhbHVlIH0sIHZub2RlKSB7XG4gICAgZWwuY2hlY2tlZCA9IGxvb3NlRXF1YWwodmFsdWUsIHZub2RlLnByb3BzLnZhbHVlKTtcbiAgICBlbC5fYXNzaWduID0gZ2V0TW9kZWxBc3NpZ25lcih2bm9kZSk7XG4gICAgYWRkRXZlbnRMaXN0ZW5lcihlbCwgXCJjaGFuZ2VcIiwgKCkgPT4ge1xuICAgICAgZWwuX2Fzc2lnbihnZXRWYWx1ZShlbCkpO1xuICAgIH0pO1xuICB9LFxuICBiZWZvcmVVcGRhdGUoZWwsIHsgdmFsdWUsIG9sZFZhbHVlIH0sIHZub2RlKSB7XG4gICAgZWwuX2Fzc2lnbiA9IGdldE1vZGVsQXNzaWduZXIodm5vZGUpO1xuICAgIGlmICh2YWx1ZSAhPT0gb2xkVmFsdWUpIHtcbiAgICAgIGVsLmNoZWNrZWQgPSBsb29zZUVxdWFsKHZhbHVlLCB2bm9kZS5wcm9wcy52YWx1ZSk7XG4gICAgfVxuICB9XG59O1xuY29uc3Qgdk1vZGVsU2VsZWN0ID0ge1xuICAvLyA8c2VsZWN0IG11bHRpcGxlPiB2YWx1ZSBuZWVkIHRvIGJlIGRlZXAgdHJhdmVyc2VkXG4gIGRlZXA6IHRydWUsXG4gIGNyZWF0ZWQoZWwsIHsgdmFsdWUsIG1vZGlmaWVyczogeyBudW1iZXIgfSB9LCB2bm9kZSkge1xuICAgIGNvbnN0IGlzU2V0TW9kZWwgPSBpc1NldCh2YWx1ZSk7XG4gICAgYWRkRXZlbnRMaXN0ZW5lcihlbCwgXCJjaGFuZ2VcIiwgKCkgPT4ge1xuICAgICAgY29uc3Qgc2VsZWN0ZWRWYWwgPSBBcnJheS5wcm90b3R5cGUuZmlsdGVyLmNhbGwoZWwub3B0aW9ucywgKG8pID0+IG8uc2VsZWN0ZWQpLm1hcChcbiAgICAgICAgKG8pID0+IG51bWJlciA/IGxvb3NlVG9OdW1iZXIoZ2V0VmFsdWUobykpIDogZ2V0VmFsdWUobylcbiAgICAgICk7XG4gICAgICBlbC5fYXNzaWduKFxuICAgICAgICBlbC5tdWx0aXBsZSA/IGlzU2V0TW9kZWwgPyBuZXcgU2V0KHNlbGVjdGVkVmFsKSA6IHNlbGVjdGVkVmFsIDogc2VsZWN0ZWRWYWxbMF1cbiAgICAgICk7XG4gICAgfSk7XG4gICAgZWwuX2Fzc2lnbiA9IGdldE1vZGVsQXNzaWduZXIodm5vZGUpO1xuICB9LFxuICAvLyBzZXQgdmFsdWUgaW4gbW91bnRlZCAmIHVwZGF0ZWQgYmVjYXVzZSA8c2VsZWN0PiByZWxpZXMgb24gaXRzIGNoaWxkcmVuXG4gIC8vIDxvcHRpb24+cy5cbiAgbW91bnRlZChlbCwgeyB2YWx1ZSB9KSB7XG4gICAgc2V0U2VsZWN0ZWQoZWwsIHZhbHVlKTtcbiAgfSxcbiAgYmVmb3JlVXBkYXRlKGVsLCBfYmluZGluZywgdm5vZGUpIHtcbiAgICBlbC5fYXNzaWduID0gZ2V0TW9kZWxBc3NpZ25lcih2bm9kZSk7XG4gIH0sXG4gIHVwZGF0ZWQoZWwsIHsgdmFsdWUgfSkge1xuICAgIHNldFNlbGVjdGVkKGVsLCB2YWx1ZSk7XG4gIH1cbn07XG5mdW5jdGlvbiBzZXRTZWxlY3RlZChlbCwgdmFsdWUpIHtcbiAgY29uc3QgaXNNdWx0aXBsZSA9IGVsLm11bHRpcGxlO1xuICBpZiAoaXNNdWx0aXBsZSAmJiAhaXNBcnJheSh2YWx1ZSkgJiYgIWlzU2V0KHZhbHVlKSkge1xuICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgd2FybihcbiAgICAgIGA8c2VsZWN0IG11bHRpcGxlIHYtbW9kZWw+IGV4cGVjdHMgYW4gQXJyYXkgb3IgU2V0IHZhbHVlIGZvciBpdHMgYmluZGluZywgYnV0IGdvdCAke09iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkuc2xpY2UoOCwgLTEpfS5gXG4gICAgKTtcbiAgICByZXR1cm47XG4gIH1cbiAgZm9yIChsZXQgaSA9IDAsIGwgPSBlbC5vcHRpb25zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGNvbnN0IG9wdGlvbiA9IGVsLm9wdGlvbnNbaV07XG4gICAgY29uc3Qgb3B0aW9uVmFsdWUgPSBnZXRWYWx1ZShvcHRpb24pO1xuICAgIGlmIChpc011bHRpcGxlKSB7XG4gICAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgb3B0aW9uLnNlbGVjdGVkID0gbG9vc2VJbmRleE9mKHZhbHVlLCBvcHRpb25WYWx1ZSkgPiAtMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9wdGlvbi5zZWxlY3RlZCA9IHZhbHVlLmhhcyhvcHRpb25WYWx1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChsb29zZUVxdWFsKGdldFZhbHVlKG9wdGlvbiksIHZhbHVlKSkge1xuICAgICAgICBpZiAoZWwuc2VsZWN0ZWRJbmRleCAhPT0gaSlcbiAgICAgICAgICBlbC5zZWxlY3RlZEluZGV4ID0gaTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoIWlzTXVsdGlwbGUgJiYgZWwuc2VsZWN0ZWRJbmRleCAhPT0gLTEpIHtcbiAgICBlbC5zZWxlY3RlZEluZGV4ID0gLTE7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldFZhbHVlKGVsKSB7XG4gIHJldHVybiBcIl92YWx1ZVwiIGluIGVsID8gZWwuX3ZhbHVlIDogZWwudmFsdWU7XG59XG5mdW5jdGlvbiBnZXRDaGVja2JveFZhbHVlKGVsLCBjaGVja2VkKSB7XG4gIGNvbnN0IGtleSA9IGNoZWNrZWQgPyBcIl90cnVlVmFsdWVcIiA6IFwiX2ZhbHNlVmFsdWVcIjtcbiAgcmV0dXJuIGtleSBpbiBlbCA/IGVsW2tleV0gOiBjaGVja2VkO1xufVxuY29uc3Qgdk1vZGVsRHluYW1pYyA9IHtcbiAgY3JlYXRlZChlbCwgYmluZGluZywgdm5vZGUpIHtcbiAgICBjYWxsTW9kZWxIb29rKGVsLCBiaW5kaW5nLCB2bm9kZSwgbnVsbCwgXCJjcmVhdGVkXCIpO1xuICB9LFxuICBtb3VudGVkKGVsLCBiaW5kaW5nLCB2bm9kZSkge1xuICAgIGNhbGxNb2RlbEhvb2soZWwsIGJpbmRpbmcsIHZub2RlLCBudWxsLCBcIm1vdW50ZWRcIik7XG4gIH0sXG4gIGJlZm9yZVVwZGF0ZShlbCwgYmluZGluZywgdm5vZGUsIHByZXZWTm9kZSkge1xuICAgIGNhbGxNb2RlbEhvb2soZWwsIGJpbmRpbmcsIHZub2RlLCBwcmV2Vk5vZGUsIFwiYmVmb3JlVXBkYXRlXCIpO1xuICB9LFxuICB1cGRhdGVkKGVsLCBiaW5kaW5nLCB2bm9kZSwgcHJldlZOb2RlKSB7XG4gICAgY2FsbE1vZGVsSG9vayhlbCwgYmluZGluZywgdm5vZGUsIHByZXZWTm9kZSwgXCJ1cGRhdGVkXCIpO1xuICB9XG59O1xuZnVuY3Rpb24gcmVzb2x2ZUR5bmFtaWNNb2RlbCh0YWdOYW1lLCB0eXBlKSB7XG4gIHN3aXRjaCAodGFnTmFtZSkge1xuICAgIGNhc2UgXCJTRUxFQ1RcIjpcbiAgICAgIHJldHVybiB2TW9kZWxTZWxlY3Q7XG4gICAgY2FzZSBcIlRFWFRBUkVBXCI6XG4gICAgICByZXR1cm4gdk1vZGVsVGV4dDtcbiAgICBkZWZhdWx0OlxuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgXCJjaGVja2JveFwiOlxuICAgICAgICAgIHJldHVybiB2TW9kZWxDaGVja2JveDtcbiAgICAgICAgY2FzZSBcInJhZGlvXCI6XG4gICAgICAgICAgcmV0dXJuIHZNb2RlbFJhZGlvO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiB2TW9kZWxUZXh0O1xuICAgICAgfVxuICB9XG59XG5mdW5jdGlvbiBjYWxsTW9kZWxIb29rKGVsLCBiaW5kaW5nLCB2bm9kZSwgcHJldlZOb2RlLCBob29rKSB7XG4gIGNvbnN0IG1vZGVsVG9Vc2UgPSByZXNvbHZlRHluYW1pY01vZGVsKFxuICAgIGVsLnRhZ05hbWUsXG4gICAgdm5vZGUucHJvcHMgJiYgdm5vZGUucHJvcHMudHlwZVxuICApO1xuICBjb25zdCBmbiA9IG1vZGVsVG9Vc2VbaG9va107XG4gIGZuICYmIGZuKGVsLCBiaW5kaW5nLCB2bm9kZSwgcHJldlZOb2RlKTtcbn1cbmZ1bmN0aW9uIGluaXRWTW9kZWxGb3JTU1IoKSB7XG4gIHZNb2RlbFRleHQuZ2V0U1NSUHJvcHMgPSAoeyB2YWx1ZSB9KSA9PiAoeyB2YWx1ZSB9KTtcbiAgdk1vZGVsUmFkaW8uZ2V0U1NSUHJvcHMgPSAoeyB2YWx1ZSB9LCB2bm9kZSkgPT4ge1xuICAgIGlmICh2bm9kZS5wcm9wcyAmJiBsb29zZUVxdWFsKHZub2RlLnByb3BzLnZhbHVlLCB2YWx1ZSkpIHtcbiAgICAgIHJldHVybiB7IGNoZWNrZWQ6IHRydWUgfTtcbiAgICB9XG4gIH07XG4gIHZNb2RlbENoZWNrYm94LmdldFNTUlByb3BzID0gKHsgdmFsdWUgfSwgdm5vZGUpID0+IHtcbiAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIGlmICh2bm9kZS5wcm9wcyAmJiBsb29zZUluZGV4T2YodmFsdWUsIHZub2RlLnByb3BzLnZhbHVlKSA+IC0xKSB7XG4gICAgICAgIHJldHVybiB7IGNoZWNrZWQ6IHRydWUgfTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzU2V0KHZhbHVlKSkge1xuICAgICAgaWYgKHZub2RlLnByb3BzICYmIHZhbHVlLmhhcyh2bm9kZS5wcm9wcy52YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHsgY2hlY2tlZDogdHJ1ZSB9O1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodmFsdWUpIHtcbiAgICAgIHJldHVybiB7IGNoZWNrZWQ6IHRydWUgfTtcbiAgICB9XG4gIH07XG4gIHZNb2RlbER5bmFtaWMuZ2V0U1NSUHJvcHMgPSAoYmluZGluZywgdm5vZGUpID0+IHtcbiAgICBpZiAodHlwZW9mIHZub2RlLnR5cGUgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbW9kZWxUb1VzZSA9IHJlc29sdmVEeW5hbWljTW9kZWwoXG4gICAgICAvLyByZXNvbHZlRHluYW1pY01vZGVsIGV4cGVjdHMgYW4gdXBwZXJjYXNlIHRhZyBuYW1lLCBidXQgdm5vZGUudHlwZSBpcyBsb3dlcmNhc2VcbiAgICAgIHZub2RlLnR5cGUudG9VcHBlckNhc2UoKSxcbiAgICAgIHZub2RlLnByb3BzICYmIHZub2RlLnByb3BzLnR5cGVcbiAgICApO1xuICAgIGlmIChtb2RlbFRvVXNlLmdldFNTUlByb3BzKSB7XG4gICAgICByZXR1cm4gbW9kZWxUb1VzZS5nZXRTU1JQcm9wcyhiaW5kaW5nLCB2bm9kZSk7XG4gICAgfVxuICB9O1xufVxuXG5jb25zdCBzeXN0ZW1Nb2RpZmllcnMgPSBbXCJjdHJsXCIsIFwic2hpZnRcIiwgXCJhbHRcIiwgXCJtZXRhXCJdO1xuY29uc3QgbW9kaWZpZXJHdWFyZHMgPSB7XG4gIHN0b3A6IChlKSA9PiBlLnN0b3BQcm9wYWdhdGlvbigpLFxuICBwcmV2ZW50OiAoZSkgPT4gZS5wcmV2ZW50RGVmYXVsdCgpLFxuICBzZWxmOiAoZSkgPT4gZS50YXJnZXQgIT09IGUuY3VycmVudFRhcmdldCxcbiAgY3RybDogKGUpID0+ICFlLmN0cmxLZXksXG4gIHNoaWZ0OiAoZSkgPT4gIWUuc2hpZnRLZXksXG4gIGFsdDogKGUpID0+ICFlLmFsdEtleSxcbiAgbWV0YTogKGUpID0+ICFlLm1ldGFLZXksXG4gIGxlZnQ6IChlKSA9PiBcImJ1dHRvblwiIGluIGUgJiYgZS5idXR0b24gIT09IDAsXG4gIG1pZGRsZTogKGUpID0+IFwiYnV0dG9uXCIgaW4gZSAmJiBlLmJ1dHRvbiAhPT0gMSxcbiAgcmlnaHQ6IChlKSA9PiBcImJ1dHRvblwiIGluIGUgJiYgZS5idXR0b24gIT09IDIsXG4gIGV4YWN0OiAoZSwgbW9kaWZpZXJzKSA9PiBzeXN0ZW1Nb2RpZmllcnMuc29tZSgobSkgPT4gZVtgJHttfUtleWBdICYmICFtb2RpZmllcnMuaW5jbHVkZXMobSkpXG59O1xuY29uc3Qgd2l0aE1vZGlmaWVycyA9IChmbiwgbW9kaWZpZXJzKSA9PiB7XG4gIHJldHVybiAoZXZlbnQsIC4uLmFyZ3MpID0+IHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1vZGlmaWVycy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgZ3VhcmQgPSBtb2RpZmllckd1YXJkc1ttb2RpZmllcnNbaV1dO1xuICAgICAgaWYgKGd1YXJkICYmIGd1YXJkKGV2ZW50LCBtb2RpZmllcnMpKVxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHJldHVybiBmbihldmVudCwgLi4uYXJncyk7XG4gIH07XG59O1xuY29uc3Qga2V5TmFtZXMgPSB7XG4gIGVzYzogXCJlc2NhcGVcIixcbiAgc3BhY2U6IFwiIFwiLFxuICB1cDogXCJhcnJvdy11cFwiLFxuICBsZWZ0OiBcImFycm93LWxlZnRcIixcbiAgcmlnaHQ6IFwiYXJyb3ctcmlnaHRcIixcbiAgZG93bjogXCJhcnJvdy1kb3duXCIsXG4gIGRlbGV0ZTogXCJiYWNrc3BhY2VcIlxufTtcbmNvbnN0IHdpdGhLZXlzID0gKGZuLCBtb2RpZmllcnMpID0+IHtcbiAgcmV0dXJuIChldmVudCkgPT4ge1xuICAgIGlmICghKFwia2V5XCIgaW4gZXZlbnQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGV2ZW50S2V5ID0gaHlwaGVuYXRlKGV2ZW50LmtleSk7XG4gICAgaWYgKG1vZGlmaWVycy5zb21lKChrKSA9PiBrID09PSBldmVudEtleSB8fCBrZXlOYW1lc1trXSA9PT0gZXZlbnRLZXkpKSB7XG4gICAgICByZXR1cm4gZm4oZXZlbnQpO1xuICAgIH1cbiAgfTtcbn07XG5cbmNvbnN0IHZTaG93ID0ge1xuICBiZWZvcmVNb3VudChlbCwgeyB2YWx1ZSB9LCB7IHRyYW5zaXRpb24gfSkge1xuICAgIGVsLl92b2QgPSBlbC5zdHlsZS5kaXNwbGF5ID09PSBcIm5vbmVcIiA/IFwiXCIgOiBlbC5zdHlsZS5kaXNwbGF5O1xuICAgIGlmICh0cmFuc2l0aW9uICYmIHZhbHVlKSB7XG4gICAgICB0cmFuc2l0aW9uLmJlZm9yZUVudGVyKGVsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2V0RGlzcGxheShlbCwgdmFsdWUpO1xuICAgIH1cbiAgfSxcbiAgbW91bnRlZChlbCwgeyB2YWx1ZSB9LCB7IHRyYW5zaXRpb24gfSkge1xuICAgIGlmICh0cmFuc2l0aW9uICYmIHZhbHVlKSB7XG4gICAgICB0cmFuc2l0aW9uLmVudGVyKGVsKTtcbiAgICB9XG4gIH0sXG4gIHVwZGF0ZWQoZWwsIHsgdmFsdWUsIG9sZFZhbHVlIH0sIHsgdHJhbnNpdGlvbiB9KSB7XG4gICAgaWYgKCF2YWx1ZSA9PT0gIW9sZFZhbHVlKVxuICAgICAgcmV0dXJuO1xuICAgIGlmICh0cmFuc2l0aW9uKSB7XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgdHJhbnNpdGlvbi5iZWZvcmVFbnRlcihlbCk7XG4gICAgICAgIHNldERpc3BsYXkoZWwsIHRydWUpO1xuICAgICAgICB0cmFuc2l0aW9uLmVudGVyKGVsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyYW5zaXRpb24ubGVhdmUoZWwsICgpID0+IHtcbiAgICAgICAgICBzZXREaXNwbGF5KGVsLCBmYWxzZSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzZXREaXNwbGF5KGVsLCB2YWx1ZSk7XG4gICAgfVxuICB9LFxuICBiZWZvcmVVbm1vdW50KGVsLCB7IHZhbHVlIH0pIHtcbiAgICBzZXREaXNwbGF5KGVsLCB2YWx1ZSk7XG4gIH1cbn07XG5mdW5jdGlvbiBzZXREaXNwbGF5KGVsLCB2YWx1ZSkge1xuICBlbC5zdHlsZS5kaXNwbGF5ID0gdmFsdWUgPyBlbC5fdm9kIDogXCJub25lXCI7XG59XG5mdW5jdGlvbiBpbml0VlNob3dGb3JTU1IoKSB7XG4gIHZTaG93LmdldFNTUlByb3BzID0gKHsgdmFsdWUgfSkgPT4ge1xuICAgIGlmICghdmFsdWUpIHtcbiAgICAgIHJldHVybiB7IHN0eWxlOiB7IGRpc3BsYXk6IFwibm9uZVwiIH0gfTtcbiAgICB9XG4gIH07XG59XG5cbmNvbnN0IHJlbmRlcmVyT3B0aW9ucyA9IC8qIEBfX1BVUkVfXyAqLyBleHRlbmQoeyBwYXRjaFByb3AgfSwgbm9kZU9wcyk7XG5sZXQgcmVuZGVyZXI7XG5sZXQgZW5hYmxlZEh5ZHJhdGlvbiA9IGZhbHNlO1xuZnVuY3Rpb24gZW5zdXJlUmVuZGVyZXIoKSB7XG4gIHJldHVybiByZW5kZXJlciB8fCAocmVuZGVyZXIgPSBjcmVhdGVSZW5kZXJlcihyZW5kZXJlck9wdGlvbnMpKTtcbn1cbmZ1bmN0aW9uIGVuc3VyZUh5ZHJhdGlvblJlbmRlcmVyKCkge1xuICByZW5kZXJlciA9IGVuYWJsZWRIeWRyYXRpb24gPyByZW5kZXJlciA6IGNyZWF0ZUh5ZHJhdGlvblJlbmRlcmVyKHJlbmRlcmVyT3B0aW9ucyk7XG4gIGVuYWJsZWRIeWRyYXRpb24gPSB0cnVlO1xuICByZXR1cm4gcmVuZGVyZXI7XG59XG5jb25zdCByZW5kZXIgPSAoLi4uYXJncykgPT4ge1xuICBlbnN1cmVSZW5kZXJlcigpLnJlbmRlciguLi5hcmdzKTtcbn07XG5jb25zdCBoeWRyYXRlID0gKC4uLmFyZ3MpID0+IHtcbiAgZW5zdXJlSHlkcmF0aW9uUmVuZGVyZXIoKS5oeWRyYXRlKC4uLmFyZ3MpO1xufTtcbmNvbnN0IGNyZWF0ZUFwcCA9ICguLi5hcmdzKSA9PiB7XG4gIGNvbnN0IGFwcCA9IGVuc3VyZVJlbmRlcmVyKCkuY3JlYXRlQXBwKC4uLmFyZ3MpO1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIGluamVjdE5hdGl2ZVRhZ0NoZWNrKGFwcCk7XG4gICAgaW5qZWN0Q29tcGlsZXJPcHRpb25zQ2hlY2soYXBwKTtcbiAgfVxuICBjb25zdCB7IG1vdW50IH0gPSBhcHA7XG4gIGFwcC5tb3VudCA9IChjb250YWluZXJPclNlbGVjdG9yKSA9PiB7XG4gICAgY29uc3QgY29udGFpbmVyID0gbm9ybWFsaXplQ29udGFpbmVyKGNvbnRhaW5lck9yU2VsZWN0b3IpO1xuICAgIGlmICghY29udGFpbmVyKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGNvbXBvbmVudCA9IGFwcC5fY29tcG9uZW50O1xuICAgIGlmICghaXNGdW5jdGlvbihjb21wb25lbnQpICYmICFjb21wb25lbnQucmVuZGVyICYmICFjb21wb25lbnQudGVtcGxhdGUpIHtcbiAgICAgIGNvbXBvbmVudC50ZW1wbGF0ZSA9IGNvbnRhaW5lci5pbm5lckhUTUw7XG4gICAgfVxuICAgIGNvbnRhaW5lci5pbm5lckhUTUwgPSBcIlwiO1xuICAgIGNvbnN0IHByb3h5ID0gbW91bnQoY29udGFpbmVyLCBmYWxzZSwgY29udGFpbmVyIGluc3RhbmNlb2YgU1ZHRWxlbWVudCk7XG4gICAgaWYgKGNvbnRhaW5lciBpbnN0YW5jZW9mIEVsZW1lbnQpIHtcbiAgICAgIGNvbnRhaW5lci5yZW1vdmVBdHRyaWJ1dGUoXCJ2LWNsb2FrXCIpO1xuICAgICAgY29udGFpbmVyLnNldEF0dHJpYnV0ZShcImRhdGEtdi1hcHBcIiwgXCJcIik7XG4gICAgfVxuICAgIHJldHVybiBwcm94eTtcbiAgfTtcbiAgcmV0dXJuIGFwcDtcbn07XG5jb25zdCBjcmVhdGVTU1JBcHAgPSAoLi4uYXJncykgPT4ge1xuICBjb25zdCBhcHAgPSBlbnN1cmVIeWRyYXRpb25SZW5kZXJlcigpLmNyZWF0ZUFwcCguLi5hcmdzKTtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICBpbmplY3ROYXRpdmVUYWdDaGVjayhhcHApO1xuICAgIGluamVjdENvbXBpbGVyT3B0aW9uc0NoZWNrKGFwcCk7XG4gIH1cbiAgY29uc3QgeyBtb3VudCB9ID0gYXBwO1xuICBhcHAubW91bnQgPSAoY29udGFpbmVyT3JTZWxlY3RvcikgPT4ge1xuICAgIGNvbnN0IGNvbnRhaW5lciA9IG5vcm1hbGl6ZUNvbnRhaW5lcihjb250YWluZXJPclNlbGVjdG9yKTtcbiAgICBpZiAoY29udGFpbmVyKSB7XG4gICAgICByZXR1cm4gbW91bnQoY29udGFpbmVyLCB0cnVlLCBjb250YWluZXIgaW5zdGFuY2VvZiBTVkdFbGVtZW50KTtcbiAgICB9XG4gIH07XG4gIHJldHVybiBhcHA7XG59O1xuZnVuY3Rpb24gaW5qZWN0TmF0aXZlVGFnQ2hlY2soYXBwKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhcHAuY29uZmlnLCBcImlzTmF0aXZlVGFnXCIsIHtcbiAgICB2YWx1ZTogKHRhZykgPT4gaXNIVE1MVGFnKHRhZykgfHwgaXNTVkdUYWcodGFnKSxcbiAgICB3cml0YWJsZTogZmFsc2VcbiAgfSk7XG59XG5mdW5jdGlvbiBpbmplY3RDb21waWxlck9wdGlvbnNDaGVjayhhcHApIHtcbiAgaWYgKGlzUnVudGltZU9ubHkoKSkge1xuICAgIGNvbnN0IGlzQ3VzdG9tRWxlbWVudCA9IGFwcC5jb25maWcuaXNDdXN0b21FbGVtZW50O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhcHAuY29uZmlnLCBcImlzQ3VzdG9tRWxlbWVudFwiLCB7XG4gICAgICBnZXQoKSB7XG4gICAgICAgIHJldHVybiBpc0N1c3RvbUVsZW1lbnQ7XG4gICAgICB9LFxuICAgICAgc2V0KCkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIGBUaGUgXFxgaXNDdXN0b21FbGVtZW50XFxgIGNvbmZpZyBvcHRpb24gaXMgZGVwcmVjYXRlZC4gVXNlIFxcYGNvbXBpbGVyT3B0aW9ucy5pc0N1c3RvbUVsZW1lbnRcXGAgaW5zdGVhZC5gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgY29uc3QgY29tcGlsZXJPcHRpb25zID0gYXBwLmNvbmZpZy5jb21waWxlck9wdGlvbnM7XG4gICAgY29uc3QgbXNnID0gYFRoZSBcXGBjb21waWxlck9wdGlvbnNcXGAgY29uZmlnIG9wdGlvbiBpcyBvbmx5IHJlc3BlY3RlZCB3aGVuIHVzaW5nIGEgYnVpbGQgb2YgVnVlLmpzIHRoYXQgaW5jbHVkZXMgdGhlIHJ1bnRpbWUgY29tcGlsZXIgKGFrYSBcImZ1bGwgYnVpbGRcIikuIFNpbmNlIHlvdSBhcmUgdXNpbmcgdGhlIHJ1bnRpbWUtb25seSBidWlsZCwgXFxgY29tcGlsZXJPcHRpb25zXFxgIG11c3QgYmUgcGFzc2VkIHRvIFxcYEB2dWUvY29tcGlsZXItZG9tXFxgIGluIHRoZSBidWlsZCBzZXR1cCBpbnN0ZWFkLlxuLSBGb3IgdnVlLWxvYWRlcjogcGFzcyBpdCB2aWEgdnVlLWxvYWRlcidzIFxcYGNvbXBpbGVyT3B0aW9uc1xcYCBsb2FkZXIgb3B0aW9uLlxuLSBGb3IgdnVlLWNsaTogc2VlIGh0dHBzOi8vY2xpLnZ1ZWpzLm9yZy9ndWlkZS93ZWJwYWNrLmh0bWwjbW9kaWZ5aW5nLW9wdGlvbnMtb2YtYS1sb2FkZXJcbi0gRm9yIHZpdGU6IHBhc3MgaXQgdmlhIEB2aXRlanMvcGx1Z2luLXZ1ZSBvcHRpb25zLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3ZpdGVqcy92aXRlLXBsdWdpbi12dWUvdHJlZS9tYWluL3BhY2thZ2VzL3BsdWdpbi12dWUjZXhhbXBsZS1mb3ItcGFzc2luZy1vcHRpb25zLXRvLXZ1ZWNvbXBpbGVyLXNmY2A7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGFwcC5jb25maWcsIFwiY29tcGlsZXJPcHRpb25zXCIsIHtcbiAgICAgIGdldCgpIHtcbiAgICAgICAgd2Fybihtc2cpO1xuICAgICAgICByZXR1cm4gY29tcGlsZXJPcHRpb25zO1xuICAgICAgfSxcbiAgICAgIHNldCgpIHtcbiAgICAgICAgd2Fybihtc2cpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiBub3JtYWxpemVDb250YWluZXIoY29udGFpbmVyKSB7XG4gIGlmIChpc1N0cmluZyhjb250YWluZXIpKSB7XG4gICAgY29uc3QgcmVzID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcihjb250YWluZXIpO1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICFyZXMpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIGBGYWlsZWQgdG8gbW91bnQgYXBwOiBtb3VudCB0YXJnZXQgc2VsZWN0b3IgXCIke2NvbnRhaW5lcn1cIiByZXR1cm5lZCBudWxsLmBcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG4gIH1cbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgd2luZG93LlNoYWRvd1Jvb3QgJiYgY29udGFpbmVyIGluc3RhbmNlb2Ygd2luZG93LlNoYWRvd1Jvb3QgJiYgY29udGFpbmVyLm1vZGUgPT09IFwiY2xvc2VkXCIpIHtcbiAgICB3YXJuKFxuICAgICAgYG1vdW50aW5nIG9uIGEgU2hhZG93Um9vdCB3aXRoIFxcYHttb2RlOiBcImNsb3NlZFwifVxcYCBtYXkgbGVhZCB0byB1bnByZWRpY3RhYmxlIGJ1Z3NgXG4gICAgKTtcbiAgfVxuICByZXR1cm4gY29udGFpbmVyO1xufVxubGV0IHNzckRpcmVjdGl2ZUluaXRpYWxpemVkID0gZmFsc2U7XG5jb25zdCBpbml0RGlyZWN0aXZlc0ZvclNTUiA9ICgpID0+IHtcbiAgaWYgKCFzc3JEaXJlY3RpdmVJbml0aWFsaXplZCkge1xuICAgIHNzckRpcmVjdGl2ZUluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICBpbml0Vk1vZGVsRm9yU1NSKCk7XG4gICAgaW5pdFZTaG93Rm9yU1NSKCk7XG4gIH1cbn0gO1xuXG5leHBvcnQgeyBUcmFuc2l0aW9uLCBUcmFuc2l0aW9uR3JvdXAsIFZ1ZUVsZW1lbnQsIGNyZWF0ZUFwcCwgY3JlYXRlU1NSQXBwLCBkZWZpbmVDdXN0b21FbGVtZW50LCBkZWZpbmVTU1JDdXN0b21FbGVtZW50LCBoeWRyYXRlLCBpbml0RGlyZWN0aXZlc0ZvclNTUiwgcmVuZGVyLCB1c2VDc3NNb2R1bGUsIHVzZUNzc1ZhcnMsIHZNb2RlbENoZWNrYm94LCB2TW9kZWxEeW5hbWljLCB2TW9kZWxSYWRpbywgdk1vZGVsU2VsZWN0LCB2TW9kZWxUZXh0LCB2U2hvdywgd2l0aEtleXMsIHdpdGhNb2RpZmllcnMgfTtcbiIsImltcG9ydCB7IHBhdXNlVHJhY2tpbmcsIHJlc2V0VHJhY2tpbmcsIGlzUmVmLCB0b1JhdywgZ2V0Q3VycmVudFNjb3BlLCBpc1NoYWxsb3cgYXMgaXNTaGFsbG93JDEsIGlzUmVhY3RpdmUsIFJlYWN0aXZlRWZmZWN0LCByZWYsIHNoYWxsb3dSZWFkb25seSwgdHJhY2ssIHJlYWN0aXZlLCBzaGFsbG93UmVhY3RpdmUsIHRyaWdnZXIsIGlzUHJveHksIHByb3h5UmVmcywgbWFya1JhdywgRWZmZWN0U2NvcGUsIGNvbXB1dGVkIGFzIGNvbXB1dGVkJDEsIGlzUmVhZG9ubHkgfSBmcm9tICdAdnVlL3JlYWN0aXZpdHknO1xuZXhwb3J0IHsgRWZmZWN0U2NvcGUsIFJlYWN0aXZlRWZmZWN0LCBjdXN0b21SZWYsIGVmZmVjdCwgZWZmZWN0U2NvcGUsIGdldEN1cnJlbnRTY29wZSwgaXNQcm94eSwgaXNSZWFjdGl2ZSwgaXNSZWFkb25seSwgaXNSZWYsIGlzU2hhbGxvdywgbWFya1Jhdywgb25TY29wZURpc3Bvc2UsIHByb3h5UmVmcywgcmVhY3RpdmUsIHJlYWRvbmx5LCByZWYsIHNoYWxsb3dSZWFjdGl2ZSwgc2hhbGxvd1JlYWRvbmx5LCBzaGFsbG93UmVmLCBzdG9wLCB0b1JhdywgdG9SZWYsIHRvUmVmcywgdG9WYWx1ZSwgdHJpZ2dlclJlZiwgdW5yZWYgfSBmcm9tICdAdnVlL3JlYWN0aXZpdHknO1xuaW1wb3J0IHsgaXNTdHJpbmcsIGlzRnVuY3Rpb24sIGlzUHJvbWlzZSwgaXNBcnJheSwgTk9PUCwgZ2V0R2xvYmFsVGhpcywgZXh0ZW5kLCBFTVBUWV9PQkosIHRvSGFuZGxlcktleSwgbG9vc2VUb051bWJlciwgaHlwaGVuYXRlLCBjYW1lbGl6ZSwgaXNPYmplY3QsIGlzT24sIGhhc093biwgaXNNb2RlbExpc3RlbmVyLCB0b051bWJlciwgaGFzQ2hhbmdlZCwgcmVtb3ZlLCBpc1NldCwgaXNNYXAsIGlzUGxhaW5PYmplY3QsIGlzQnVpbHRJbkRpcmVjdGl2ZSwgaW52b2tlQXJyYXlGbnMsIGlzUmVnRXhwLCBjYXBpdGFsaXplLCBpc0dsb2JhbGx5V2hpdGVsaXN0ZWQsIE5PLCBkZWYsIGlzUmVzZXJ2ZWRQcm9wLCBFTVBUWV9BUlIsIHRvUmF3VHlwZSwgbWFrZU1hcCwgbm9ybWFsaXplQ2xhc3MsIG5vcm1hbGl6ZVN0eWxlIH0gZnJvbSAnQHZ1ZS9zaGFyZWQnO1xuZXhwb3J0IHsgY2FtZWxpemUsIGNhcGl0YWxpemUsIG5vcm1hbGl6ZUNsYXNzLCBub3JtYWxpemVQcm9wcywgbm9ybWFsaXplU3R5bGUsIHRvRGlzcGxheVN0cmluZywgdG9IYW5kbGVyS2V5IH0gZnJvbSAnQHZ1ZS9zaGFyZWQnO1xuXG5jb25zdCBzdGFjayA9IFtdO1xuZnVuY3Rpb24gcHVzaFdhcm5pbmdDb250ZXh0KHZub2RlKSB7XG4gIHN0YWNrLnB1c2godm5vZGUpO1xufVxuZnVuY3Rpb24gcG9wV2FybmluZ0NvbnRleHQoKSB7XG4gIHN0YWNrLnBvcCgpO1xufVxuZnVuY3Rpb24gd2Fybihtc2csIC4uLmFyZ3MpIHtcbiAgaWYgKCEhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKVxuICAgIHJldHVybjtcbiAgcGF1c2VUcmFja2luZygpO1xuICBjb25zdCBpbnN0YW5jZSA9IHN0YWNrLmxlbmd0aCA/IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdLmNvbXBvbmVudCA6IG51bGw7XG4gIGNvbnN0IGFwcFdhcm5IYW5kbGVyID0gaW5zdGFuY2UgJiYgaW5zdGFuY2UuYXBwQ29udGV4dC5jb25maWcud2FybkhhbmRsZXI7XG4gIGNvbnN0IHRyYWNlID0gZ2V0Q29tcG9uZW50VHJhY2UoKTtcbiAgaWYgKGFwcFdhcm5IYW5kbGVyKSB7XG4gICAgY2FsbFdpdGhFcnJvckhhbmRsaW5nKFxuICAgICAgYXBwV2FybkhhbmRsZXIsXG4gICAgICBpbnN0YW5jZSxcbiAgICAgIDExLFxuICAgICAgW1xuICAgICAgICBtc2cgKyBhcmdzLmpvaW4oXCJcIiksXG4gICAgICAgIGluc3RhbmNlICYmIGluc3RhbmNlLnByb3h5LFxuICAgICAgICB0cmFjZS5tYXAoXG4gICAgICAgICAgKHsgdm5vZGUgfSkgPT4gYGF0IDwke2Zvcm1hdENvbXBvbmVudE5hbWUoaW5zdGFuY2UsIHZub2RlLnR5cGUpfT5gXG4gICAgICAgICkuam9pbihcIlxcblwiKSxcbiAgICAgICAgdHJhY2VcbiAgICAgIF1cbiAgICApO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IHdhcm5BcmdzID0gW2BbVnVlIHdhcm5dOiAke21zZ31gLCAuLi5hcmdzXTtcbiAgICBpZiAodHJhY2UubGVuZ3RoICYmIC8vIGF2b2lkIHNwYW1taW5nIGNvbnNvbGUgZHVyaW5nIHRlc3RzXG4gICAgdHJ1ZSkge1xuICAgICAgd2FybkFyZ3MucHVzaChgXG5gLCAuLi5mb3JtYXRUcmFjZSh0cmFjZSkpO1xuICAgIH1cbiAgICBjb25zb2xlLndhcm4oLi4ud2FybkFyZ3MpO1xuICB9XG4gIHJlc2V0VHJhY2tpbmcoKTtcbn1cbmZ1bmN0aW9uIGdldENvbXBvbmVudFRyYWNlKCkge1xuICBsZXQgY3VycmVudFZOb2RlID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV07XG4gIGlmICghY3VycmVudFZOb2RlKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIGNvbnN0IG5vcm1hbGl6ZWRTdGFjayA9IFtdO1xuICB3aGlsZSAoY3VycmVudFZOb2RlKSB7XG4gICAgY29uc3QgbGFzdCA9IG5vcm1hbGl6ZWRTdGFja1swXTtcbiAgICBpZiAobGFzdCAmJiBsYXN0LnZub2RlID09PSBjdXJyZW50Vk5vZGUpIHtcbiAgICAgIGxhc3QucmVjdXJzZUNvdW50Kys7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vcm1hbGl6ZWRTdGFjay5wdXNoKHtcbiAgICAgICAgdm5vZGU6IGN1cnJlbnRWTm9kZSxcbiAgICAgICAgcmVjdXJzZUNvdW50OiAwXG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgcGFyZW50SW5zdGFuY2UgPSBjdXJyZW50Vk5vZGUuY29tcG9uZW50ICYmIGN1cnJlbnRWTm9kZS5jb21wb25lbnQucGFyZW50O1xuICAgIGN1cnJlbnRWTm9kZSA9IHBhcmVudEluc3RhbmNlICYmIHBhcmVudEluc3RhbmNlLnZub2RlO1xuICB9XG4gIHJldHVybiBub3JtYWxpemVkU3RhY2s7XG59XG5mdW5jdGlvbiBmb3JtYXRUcmFjZSh0cmFjZSkge1xuICBjb25zdCBsb2dzID0gW107XG4gIHRyYWNlLmZvckVhY2goKGVudHJ5LCBpKSA9PiB7XG4gICAgbG9ncy5wdXNoKC4uLmkgPT09IDAgPyBbXSA6IFtgXG5gXSwgLi4uZm9ybWF0VHJhY2VFbnRyeShlbnRyeSkpO1xuICB9KTtcbiAgcmV0dXJuIGxvZ3M7XG59XG5mdW5jdGlvbiBmb3JtYXRUcmFjZUVudHJ5KHsgdm5vZGUsIHJlY3Vyc2VDb3VudCB9KSB7XG4gIGNvbnN0IHBvc3RmaXggPSByZWN1cnNlQ291bnQgPiAwID8gYC4uLiAoJHtyZWN1cnNlQ291bnR9IHJlY3Vyc2l2ZSBjYWxscylgIDogYGA7XG4gIGNvbnN0IGlzUm9vdCA9IHZub2RlLmNvbXBvbmVudCA/IHZub2RlLmNvbXBvbmVudC5wYXJlbnQgPT0gbnVsbCA6IGZhbHNlO1xuICBjb25zdCBvcGVuID0gYCBhdCA8JHtmb3JtYXRDb21wb25lbnROYW1lKFxuICAgIHZub2RlLmNvbXBvbmVudCxcbiAgICB2bm9kZS50eXBlLFxuICAgIGlzUm9vdFxuICApfWA7XG4gIGNvbnN0IGNsb3NlID0gYD5gICsgcG9zdGZpeDtcbiAgcmV0dXJuIHZub2RlLnByb3BzID8gW29wZW4sIC4uLmZvcm1hdFByb3BzKHZub2RlLnByb3BzKSwgY2xvc2VdIDogW29wZW4gKyBjbG9zZV07XG59XG5mdW5jdGlvbiBmb3JtYXRQcm9wcyhwcm9wcykge1xuICBjb25zdCByZXMgPSBbXTtcbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHByb3BzKTtcbiAga2V5cy5zbGljZSgwLCAzKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICByZXMucHVzaCguLi5mb3JtYXRQcm9wKGtleSwgcHJvcHNba2V5XSkpO1xuICB9KTtcbiAgaWYgKGtleXMubGVuZ3RoID4gMykge1xuICAgIHJlcy5wdXNoKGAgLi4uYCk7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cbmZ1bmN0aW9uIGZvcm1hdFByb3Aoa2V5LCB2YWx1ZSwgcmF3KSB7XG4gIGlmIChpc1N0cmluZyh2YWx1ZSkpIHtcbiAgICB2YWx1ZSA9IEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcbiAgICByZXR1cm4gcmF3ID8gdmFsdWUgOiBbYCR7a2V5fT0ke3ZhbHVlfWBdO1xuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIiB8fCB0eXBlb2YgdmFsdWUgPT09IFwiYm9vbGVhblwiIHx8IHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gcmF3ID8gdmFsdWUgOiBbYCR7a2V5fT0ke3ZhbHVlfWBdO1xuICB9IGVsc2UgaWYgKGlzUmVmKHZhbHVlKSkge1xuICAgIHZhbHVlID0gZm9ybWF0UHJvcChrZXksIHRvUmF3KHZhbHVlLnZhbHVlKSwgdHJ1ZSk7XG4gICAgcmV0dXJuIHJhdyA/IHZhbHVlIDogW2Ake2tleX09UmVmPGAsIHZhbHVlLCBgPmBdO1xuICB9IGVsc2UgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgcmV0dXJuIFtgJHtrZXl9PWZuJHt2YWx1ZS5uYW1lID8gYDwke3ZhbHVlLm5hbWV9PmAgOiBgYH1gXTtcbiAgfSBlbHNlIHtcbiAgICB2YWx1ZSA9IHRvUmF3KHZhbHVlKTtcbiAgICByZXR1cm4gcmF3ID8gdmFsdWUgOiBbYCR7a2V5fT1gLCB2YWx1ZV07XG4gIH1cbn1cbmZ1bmN0aW9uIGFzc2VydE51bWJlcih2YWwsIHR5cGUpIHtcbiAgaWYgKCEhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKVxuICAgIHJldHVybjtcbiAgaWYgKHZhbCA9PT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuO1xuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgIT09IFwibnVtYmVyXCIpIHtcbiAgICB3YXJuKGAke3R5cGV9IGlzIG5vdCBhIHZhbGlkIG51bWJlciAtIGdvdCAke0pTT04uc3RyaW5naWZ5KHZhbCl9LmApO1xuICB9IGVsc2UgaWYgKGlzTmFOKHZhbCkpIHtcbiAgICB3YXJuKGAke3R5cGV9IGlzIE5hTiAtIHRoZSBkdXJhdGlvbiBleHByZXNzaW9uIG1pZ2h0IGJlIGluY29ycmVjdC5gKTtcbiAgfVxufVxuXG5jb25zdCBFcnJvclR5cGVTdHJpbmdzID0ge1xuICBbXCJzcFwiXTogXCJzZXJ2ZXJQcmVmZXRjaCBob29rXCIsXG4gIFtcImJjXCJdOiBcImJlZm9yZUNyZWF0ZSBob29rXCIsXG4gIFtcImNcIl06IFwiY3JlYXRlZCBob29rXCIsXG4gIFtcImJtXCJdOiBcImJlZm9yZU1vdW50IGhvb2tcIixcbiAgW1wibVwiXTogXCJtb3VudGVkIGhvb2tcIixcbiAgW1wiYnVcIl06IFwiYmVmb3JlVXBkYXRlIGhvb2tcIixcbiAgW1widVwiXTogXCJ1cGRhdGVkXCIsXG4gIFtcImJ1bVwiXTogXCJiZWZvcmVVbm1vdW50IGhvb2tcIixcbiAgW1widW1cIl06IFwidW5tb3VudGVkIGhvb2tcIixcbiAgW1wiYVwiXTogXCJhY3RpdmF0ZWQgaG9va1wiLFxuICBbXCJkYVwiXTogXCJkZWFjdGl2YXRlZCBob29rXCIsXG4gIFtcImVjXCJdOiBcImVycm9yQ2FwdHVyZWQgaG9va1wiLFxuICBbXCJydGNcIl06IFwicmVuZGVyVHJhY2tlZCBob29rXCIsXG4gIFtcInJ0Z1wiXTogXCJyZW5kZXJUcmlnZ2VyZWQgaG9va1wiLFxuICBbMF06IFwic2V0dXAgZnVuY3Rpb25cIixcbiAgWzFdOiBcInJlbmRlciBmdW5jdGlvblwiLFxuICBbMl06IFwid2F0Y2hlciBnZXR0ZXJcIixcbiAgWzNdOiBcIndhdGNoZXIgY2FsbGJhY2tcIixcbiAgWzRdOiBcIndhdGNoZXIgY2xlYW51cCBmdW5jdGlvblwiLFxuICBbNV06IFwibmF0aXZlIGV2ZW50IGhhbmRsZXJcIixcbiAgWzZdOiBcImNvbXBvbmVudCBldmVudCBoYW5kbGVyXCIsXG4gIFs3XTogXCJ2bm9kZSBob29rXCIsXG4gIFs4XTogXCJkaXJlY3RpdmUgaG9va1wiLFxuICBbOV06IFwidHJhbnNpdGlvbiBob29rXCIsXG4gIFsxMF06IFwiYXBwIGVycm9ySGFuZGxlclwiLFxuICBbMTFdOiBcImFwcCB3YXJuSGFuZGxlclwiLFxuICBbMTJdOiBcInJlZiBmdW5jdGlvblwiLFxuICBbMTNdOiBcImFzeW5jIGNvbXBvbmVudCBsb2FkZXJcIixcbiAgWzE0XTogXCJzY2hlZHVsZXIgZmx1c2guIFRoaXMgaXMgbGlrZWx5IGEgVnVlIGludGVybmFscyBidWcuIFBsZWFzZSBvcGVuIGFuIGlzc3VlIGF0IGh0dHBzOi8vbmV3LWlzc3VlLnZ1ZWpzLm9yZy8/cmVwbz12dWVqcy9jb3JlXCJcbn07XG5mdW5jdGlvbiBjYWxsV2l0aEVycm9ySGFuZGxpbmcoZm4sIGluc3RhbmNlLCB0eXBlLCBhcmdzKSB7XG4gIGxldCByZXM7XG4gIHRyeSB7XG4gICAgcmVzID0gYXJncyA/IGZuKC4uLmFyZ3MpIDogZm4oKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgaGFuZGxlRXJyb3IoZXJyLCBpbnN0YW5jZSwgdHlwZSk7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cbmZ1bmN0aW9uIGNhbGxXaXRoQXN5bmNFcnJvckhhbmRsaW5nKGZuLCBpbnN0YW5jZSwgdHlwZSwgYXJncykge1xuICBpZiAoaXNGdW5jdGlvbihmbikpIHtcbiAgICBjb25zdCByZXMgPSBjYWxsV2l0aEVycm9ySGFuZGxpbmcoZm4sIGluc3RhbmNlLCB0eXBlLCBhcmdzKTtcbiAgICBpZiAocmVzICYmIGlzUHJvbWlzZShyZXMpKSB7XG4gICAgICByZXMuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICBoYW5kbGVFcnJvcihlcnIsIGluc3RhbmNlLCB0eXBlKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xuICB9XG4gIGNvbnN0IHZhbHVlcyA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGZuLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFsdWVzLnB1c2goY2FsbFdpdGhBc3luY0Vycm9ySGFuZGxpbmcoZm5baV0sIGluc3RhbmNlLCB0eXBlLCBhcmdzKSk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlcztcbn1cbmZ1bmN0aW9uIGhhbmRsZUVycm9yKGVyciwgaW5zdGFuY2UsIHR5cGUsIHRocm93SW5EZXYgPSB0cnVlKSB7XG4gIGNvbnN0IGNvbnRleHRWTm9kZSA9IGluc3RhbmNlID8gaW5zdGFuY2Uudm5vZGUgOiBudWxsO1xuICBpZiAoaW5zdGFuY2UpIHtcbiAgICBsZXQgY3VyID0gaW5zdGFuY2UucGFyZW50O1xuICAgIGNvbnN0IGV4cG9zZWRJbnN0YW5jZSA9IGluc3RhbmNlLnByb3h5O1xuICAgIGNvbnN0IGVycm9ySW5mbyA9ICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyBFcnJvclR5cGVTdHJpbmdzW3R5cGVdIDogdHlwZTtcbiAgICB3aGlsZSAoY3VyKSB7XG4gICAgICBjb25zdCBlcnJvckNhcHR1cmVkSG9va3MgPSBjdXIuZWM7XG4gICAgICBpZiAoZXJyb3JDYXB0dXJlZEhvb2tzKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZXJyb3JDYXB0dXJlZEhvb2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKGVycm9yQ2FwdHVyZWRIb29rc1tpXShlcnIsIGV4cG9zZWRJbnN0YW5jZSwgZXJyb3JJbmZvKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGN1ciA9IGN1ci5wYXJlbnQ7XG4gICAgfVxuICAgIGNvbnN0IGFwcEVycm9ySGFuZGxlciA9IGluc3RhbmNlLmFwcENvbnRleHQuY29uZmlnLmVycm9ySGFuZGxlcjtcbiAgICBpZiAoYXBwRXJyb3JIYW5kbGVyKSB7XG4gICAgICBjYWxsV2l0aEVycm9ySGFuZGxpbmcoXG4gICAgICAgIGFwcEVycm9ySGFuZGxlcixcbiAgICAgICAgbnVsbCxcbiAgICAgICAgMTAsXG4gICAgICAgIFtlcnIsIGV4cG9zZWRJbnN0YW5jZSwgZXJyb3JJbmZvXVxuICAgICAgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbiAgbG9nRXJyb3IoZXJyLCB0eXBlLCBjb250ZXh0Vk5vZGUsIHRocm93SW5EZXYpO1xufVxuZnVuY3Rpb24gbG9nRXJyb3IoZXJyLCB0eXBlLCBjb250ZXh0Vk5vZGUsIHRocm93SW5EZXYgPSB0cnVlKSB7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgY29uc3QgaW5mbyA9IEVycm9yVHlwZVN0cmluZ3NbdHlwZV07XG4gICAgaWYgKGNvbnRleHRWTm9kZSkge1xuICAgICAgcHVzaFdhcm5pbmdDb250ZXh0KGNvbnRleHRWTm9kZSk7XG4gICAgfVxuICAgIHdhcm4oYFVuaGFuZGxlZCBlcnJvciR7aW5mbyA/IGAgZHVyaW5nIGV4ZWN1dGlvbiBvZiAke2luZm99YCA6IGBgfWApO1xuICAgIGlmIChjb250ZXh0Vk5vZGUpIHtcbiAgICAgIHBvcFdhcm5pbmdDb250ZXh0KCk7XG4gICAgfVxuICAgIGlmICh0aHJvd0luRGV2KSB7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgY29uc29sZS5lcnJvcihlcnIpO1xuICB9XG59XG5cbmxldCBpc0ZsdXNoaW5nID0gZmFsc2U7XG5sZXQgaXNGbHVzaFBlbmRpbmcgPSBmYWxzZTtcbmNvbnN0IHF1ZXVlID0gW107XG5sZXQgZmx1c2hJbmRleCA9IDA7XG5jb25zdCBwZW5kaW5nUG9zdEZsdXNoQ2JzID0gW107XG5sZXQgYWN0aXZlUG9zdEZsdXNoQ2JzID0gbnVsbDtcbmxldCBwb3N0Rmx1c2hJbmRleCA9IDA7XG5jb25zdCByZXNvbHZlZFByb21pc2UgPSAvKiBAX19QVVJFX18gKi8gUHJvbWlzZS5yZXNvbHZlKCk7XG5sZXQgY3VycmVudEZsdXNoUHJvbWlzZSA9IG51bGw7XG5jb25zdCBSRUNVUlNJT05fTElNSVQgPSAxMDA7XG5mdW5jdGlvbiBuZXh0VGljayhmbikge1xuICBjb25zdCBwID0gY3VycmVudEZsdXNoUHJvbWlzZSB8fCByZXNvbHZlZFByb21pc2U7XG4gIHJldHVybiBmbiA/IHAudGhlbih0aGlzID8gZm4uYmluZCh0aGlzKSA6IGZuKSA6IHA7XG59XG5mdW5jdGlvbiBmaW5kSW5zZXJ0aW9uSW5kZXgoaWQpIHtcbiAgbGV0IHN0YXJ0ID0gZmx1c2hJbmRleCArIDE7XG4gIGxldCBlbmQgPSBxdWV1ZS5sZW5ndGg7XG4gIHdoaWxlIChzdGFydCA8IGVuZCkge1xuICAgIGNvbnN0IG1pZGRsZSA9IHN0YXJ0ICsgZW5kID4+PiAxO1xuICAgIGNvbnN0IG1pZGRsZUpvYklkID0gZ2V0SWQocXVldWVbbWlkZGxlXSk7XG4gICAgbWlkZGxlSm9iSWQgPCBpZCA/IHN0YXJ0ID0gbWlkZGxlICsgMSA6IGVuZCA9IG1pZGRsZTtcbiAgfVxuICByZXR1cm4gc3RhcnQ7XG59XG5mdW5jdGlvbiBxdWV1ZUpvYihqb2IpIHtcbiAgaWYgKCFxdWV1ZS5sZW5ndGggfHwgIXF1ZXVlLmluY2x1ZGVzKFxuICAgIGpvYixcbiAgICBpc0ZsdXNoaW5nICYmIGpvYi5hbGxvd1JlY3Vyc2UgPyBmbHVzaEluZGV4ICsgMSA6IGZsdXNoSW5kZXhcbiAgKSkge1xuICAgIGlmIChqb2IuaWQgPT0gbnVsbCkge1xuICAgICAgcXVldWUucHVzaChqb2IpO1xuICAgIH0gZWxzZSB7XG4gICAgICBxdWV1ZS5zcGxpY2UoZmluZEluc2VydGlvbkluZGV4KGpvYi5pZCksIDAsIGpvYik7XG4gICAgfVxuICAgIHF1ZXVlRmx1c2goKTtcbiAgfVxufVxuZnVuY3Rpb24gcXVldWVGbHVzaCgpIHtcbiAgaWYgKCFpc0ZsdXNoaW5nICYmICFpc0ZsdXNoUGVuZGluZykge1xuICAgIGlzRmx1c2hQZW5kaW5nID0gdHJ1ZTtcbiAgICBjdXJyZW50Rmx1c2hQcm9taXNlID0gcmVzb2x2ZWRQcm9taXNlLnRoZW4oZmx1c2hKb2JzKTtcbiAgfVxufVxuZnVuY3Rpb24gaW52YWxpZGF0ZUpvYihqb2IpIHtcbiAgY29uc3QgaSA9IHF1ZXVlLmluZGV4T2Yoam9iKTtcbiAgaWYgKGkgPiBmbHVzaEluZGV4KSB7XG4gICAgcXVldWUuc3BsaWNlKGksIDEpO1xuICB9XG59XG5mdW5jdGlvbiBxdWV1ZVBvc3RGbHVzaENiKGNiKSB7XG4gIGlmICghaXNBcnJheShjYikpIHtcbiAgICBpZiAoIWFjdGl2ZVBvc3RGbHVzaENicyB8fCAhYWN0aXZlUG9zdEZsdXNoQ2JzLmluY2x1ZGVzKFxuICAgICAgY2IsXG4gICAgICBjYi5hbGxvd1JlY3Vyc2UgPyBwb3N0Rmx1c2hJbmRleCArIDEgOiBwb3N0Rmx1c2hJbmRleFxuICAgICkpIHtcbiAgICAgIHBlbmRpbmdQb3N0Rmx1c2hDYnMucHVzaChjYik7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHBlbmRpbmdQb3N0Rmx1c2hDYnMucHVzaCguLi5jYik7XG4gIH1cbiAgcXVldWVGbHVzaCgpO1xufVxuZnVuY3Rpb24gZmx1c2hQcmVGbHVzaENicyhzZWVuLCBpID0gaXNGbHVzaGluZyA/IGZsdXNoSW5kZXggKyAxIDogMCkge1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIHNlZW4gPSBzZWVuIHx8IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIH1cbiAgZm9yICg7IGkgPCBxdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGNiID0gcXVldWVbaV07XG4gICAgaWYgKGNiICYmIGNiLnByZSkge1xuICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgY2hlY2tSZWN1cnNpdmVVcGRhdGVzKHNlZW4sIGNiKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHF1ZXVlLnNwbGljZShpLCAxKTtcbiAgICAgIGktLTtcbiAgICAgIGNiKCk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBmbHVzaFBvc3RGbHVzaENicyhzZWVuKSB7XG4gIGlmIChwZW5kaW5nUG9zdEZsdXNoQ2JzLmxlbmd0aCkge1xuICAgIGNvbnN0IGRlZHVwZWQgPSBbLi4ubmV3IFNldChwZW5kaW5nUG9zdEZsdXNoQ2JzKV07XG4gICAgcGVuZGluZ1Bvc3RGbHVzaENicy5sZW5ndGggPSAwO1xuICAgIGlmIChhY3RpdmVQb3N0Rmx1c2hDYnMpIHtcbiAgICAgIGFjdGl2ZVBvc3RGbHVzaENicy5wdXNoKC4uLmRlZHVwZWQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBhY3RpdmVQb3N0Rmx1c2hDYnMgPSBkZWR1cGVkO1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICBzZWVuID0gc2VlbiB8fCAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIH1cbiAgICBhY3RpdmVQb3N0Rmx1c2hDYnMuc29ydCgoYSwgYikgPT4gZ2V0SWQoYSkgLSBnZXRJZChiKSk7XG4gICAgZm9yIChwb3N0Rmx1c2hJbmRleCA9IDA7IHBvc3RGbHVzaEluZGV4IDwgYWN0aXZlUG9zdEZsdXNoQ2JzLmxlbmd0aDsgcG9zdEZsdXNoSW5kZXgrKykge1xuICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgY2hlY2tSZWN1cnNpdmVVcGRhdGVzKHNlZW4sIGFjdGl2ZVBvc3RGbHVzaENic1twb3N0Rmx1c2hJbmRleF0pKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgYWN0aXZlUG9zdEZsdXNoQ2JzW3Bvc3RGbHVzaEluZGV4XSgpO1xuICAgIH1cbiAgICBhY3RpdmVQb3N0Rmx1c2hDYnMgPSBudWxsO1xuICAgIHBvc3RGbHVzaEluZGV4ID0gMDtcbiAgfVxufVxuY29uc3QgZ2V0SWQgPSAoam9iKSA9PiBqb2IuaWQgPT0gbnVsbCA/IEluZmluaXR5IDogam9iLmlkO1xuY29uc3QgY29tcGFyYXRvciA9IChhLCBiKSA9PiB7XG4gIGNvbnN0IGRpZmYgPSBnZXRJZChhKSAtIGdldElkKGIpO1xuICBpZiAoZGlmZiA9PT0gMCkge1xuICAgIGlmIChhLnByZSAmJiAhYi5wcmUpXG4gICAgICByZXR1cm4gLTE7XG4gICAgaWYgKGIucHJlICYmICFhLnByZSlcbiAgICAgIHJldHVybiAxO1xuICB9XG4gIHJldHVybiBkaWZmO1xufTtcbmZ1bmN0aW9uIGZsdXNoSm9icyhzZWVuKSB7XG4gIGlzRmx1c2hQZW5kaW5nID0gZmFsc2U7XG4gIGlzRmx1c2hpbmcgPSB0cnVlO1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIHNlZW4gPSBzZWVuIHx8IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIH1cbiAgcXVldWUuc29ydChjb21wYXJhdG9yKTtcbiAgY29uc3QgY2hlY2sgPSAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gKGpvYikgPT4gY2hlY2tSZWN1cnNpdmVVcGRhdGVzKHNlZW4sIGpvYikgOiBOT09QO1xuICB0cnkge1xuICAgIGZvciAoZmx1c2hJbmRleCA9IDA7IGZsdXNoSW5kZXggPCBxdWV1ZS5sZW5ndGg7IGZsdXNoSW5kZXgrKykge1xuICAgICAgY29uc3Qgam9iID0gcXVldWVbZmx1c2hJbmRleF07XG4gICAgICBpZiAoam9iICYmIGpvYi5hY3RpdmUgIT09IGZhbHNlKSB7XG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGNoZWNrKGpvYikpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjYWxsV2l0aEVycm9ySGFuZGxpbmcoam9iLCBudWxsLCAxNCk7XG4gICAgICB9XG4gICAgfVxuICB9IGZpbmFsbHkge1xuICAgIGZsdXNoSW5kZXggPSAwO1xuICAgIHF1ZXVlLmxlbmd0aCA9IDA7XG4gICAgZmx1c2hQb3N0Rmx1c2hDYnMoc2Vlbik7XG4gICAgaXNGbHVzaGluZyA9IGZhbHNlO1xuICAgIGN1cnJlbnRGbHVzaFByb21pc2UgPSBudWxsO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggfHwgcGVuZGluZ1Bvc3RGbHVzaENicy5sZW5ndGgpIHtcbiAgICAgIGZsdXNoSm9icyhzZWVuKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGNoZWNrUmVjdXJzaXZlVXBkYXRlcyhzZWVuLCBmbikge1xuICBpZiAoIXNlZW4uaGFzKGZuKSkge1xuICAgIHNlZW4uc2V0KGZuLCAxKTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBjb3VudCA9IHNlZW4uZ2V0KGZuKTtcbiAgICBpZiAoY291bnQgPiBSRUNVUlNJT05fTElNSVQpIHtcbiAgICAgIGNvbnN0IGluc3RhbmNlID0gZm4ub3duZXJJbnN0YW5jZTtcbiAgICAgIGNvbnN0IGNvbXBvbmVudE5hbWUgPSBpbnN0YW5jZSAmJiBnZXRDb21wb25lbnROYW1lKGluc3RhbmNlLnR5cGUpO1xuICAgICAgd2FybihcbiAgICAgICAgYE1heGltdW0gcmVjdXJzaXZlIHVwZGF0ZXMgZXhjZWVkZWQke2NvbXBvbmVudE5hbWUgPyBgIGluIGNvbXBvbmVudCA8JHtjb21wb25lbnROYW1lfT5gIDogYGB9LiBUaGlzIG1lYW5zIHlvdSBoYXZlIGEgcmVhY3RpdmUgZWZmZWN0IHRoYXQgaXMgbXV0YXRpbmcgaXRzIG93biBkZXBlbmRlbmNpZXMgYW5kIHRodXMgcmVjdXJzaXZlbHkgdHJpZ2dlcmluZyBpdHNlbGYuIFBvc3NpYmxlIHNvdXJjZXMgaW5jbHVkZSBjb21wb25lbnQgdGVtcGxhdGUsIHJlbmRlciBmdW5jdGlvbiwgdXBkYXRlZCBob29rIG9yIHdhdGNoZXIgc291cmNlIGZ1bmN0aW9uLmBcbiAgICAgICk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2Vlbi5zZXQoZm4sIGNvdW50ICsgMSk7XG4gICAgfVxuICB9XG59XG5cbmxldCBpc0htclVwZGF0aW5nID0gZmFsc2U7XG5jb25zdCBobXJEaXJ0eUNvbXBvbmVudHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgZ2V0R2xvYmFsVGhpcygpLl9fVlVFX0hNUl9SVU5USU1FX18gPSB7XG4gICAgY3JlYXRlUmVjb3JkOiB0cnlXcmFwKGNyZWF0ZVJlY29yZCksXG4gICAgcmVyZW5kZXI6IHRyeVdyYXAocmVyZW5kZXIpLFxuICAgIHJlbG9hZDogdHJ5V3JhcChyZWxvYWQpXG4gIH07XG59XG5jb25zdCBtYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuZnVuY3Rpb24gcmVnaXN0ZXJITVIoaW5zdGFuY2UpIHtcbiAgY29uc3QgaWQgPSBpbnN0YW5jZS50eXBlLl9faG1ySWQ7XG4gIGxldCByZWNvcmQgPSBtYXAuZ2V0KGlkKTtcbiAgaWYgKCFyZWNvcmQpIHtcbiAgICBjcmVhdGVSZWNvcmQoaWQsIGluc3RhbmNlLnR5cGUpO1xuICAgIHJlY29yZCA9IG1hcC5nZXQoaWQpO1xuICB9XG4gIHJlY29yZC5pbnN0YW5jZXMuYWRkKGluc3RhbmNlKTtcbn1cbmZ1bmN0aW9uIHVucmVnaXN0ZXJITVIoaW5zdGFuY2UpIHtcbiAgbWFwLmdldChpbnN0YW5jZS50eXBlLl9faG1ySWQpLmluc3RhbmNlcy5kZWxldGUoaW5zdGFuY2UpO1xufVxuZnVuY3Rpb24gY3JlYXRlUmVjb3JkKGlkLCBpbml0aWFsRGVmKSB7XG4gIGlmIChtYXAuaGFzKGlkKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBtYXAuc2V0KGlkLCB7XG4gICAgaW5pdGlhbERlZjogbm9ybWFsaXplQ2xhc3NDb21wb25lbnQoaW5pdGlhbERlZiksXG4gICAgaW5zdGFuY2VzOiAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpXG4gIH0pO1xuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZUNsYXNzQ29tcG9uZW50KGNvbXBvbmVudCkge1xuICByZXR1cm4gaXNDbGFzc0NvbXBvbmVudChjb21wb25lbnQpID8gY29tcG9uZW50Ll9fdmNjT3B0cyA6IGNvbXBvbmVudDtcbn1cbmZ1bmN0aW9uIHJlcmVuZGVyKGlkLCBuZXdSZW5kZXIpIHtcbiAgY29uc3QgcmVjb3JkID0gbWFwLmdldChpZCk7XG4gIGlmICghcmVjb3JkKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHJlY29yZC5pbml0aWFsRGVmLnJlbmRlciA9IG5ld1JlbmRlcjtcbiAgWy4uLnJlY29yZC5pbnN0YW5jZXNdLmZvckVhY2goKGluc3RhbmNlKSA9PiB7XG4gICAgaWYgKG5ld1JlbmRlcikge1xuICAgICAgaW5zdGFuY2UucmVuZGVyID0gbmV3UmVuZGVyO1xuICAgICAgbm9ybWFsaXplQ2xhc3NDb21wb25lbnQoaW5zdGFuY2UudHlwZSkucmVuZGVyID0gbmV3UmVuZGVyO1xuICAgIH1cbiAgICBpbnN0YW5jZS5yZW5kZXJDYWNoZSA9IFtdO1xuICAgIGlzSG1yVXBkYXRpbmcgPSB0cnVlO1xuICAgIGluc3RhbmNlLnVwZGF0ZSgpO1xuICAgIGlzSG1yVXBkYXRpbmcgPSBmYWxzZTtcbiAgfSk7XG59XG5mdW5jdGlvbiByZWxvYWQoaWQsIG5ld0NvbXApIHtcbiAgY29uc3QgcmVjb3JkID0gbWFwLmdldChpZCk7XG4gIGlmICghcmVjb3JkKVxuICAgIHJldHVybjtcbiAgbmV3Q29tcCA9IG5vcm1hbGl6ZUNsYXNzQ29tcG9uZW50KG5ld0NvbXApO1xuICB1cGRhdGVDb21wb25lbnREZWYocmVjb3JkLmluaXRpYWxEZWYsIG5ld0NvbXApO1xuICBjb25zdCBpbnN0YW5jZXMgPSBbLi4ucmVjb3JkLmluc3RhbmNlc107XG4gIGZvciAoY29uc3QgaW5zdGFuY2Ugb2YgaW5zdGFuY2VzKSB7XG4gICAgY29uc3Qgb2xkQ29tcCA9IG5vcm1hbGl6ZUNsYXNzQ29tcG9uZW50KGluc3RhbmNlLnR5cGUpO1xuICAgIGlmICghaG1yRGlydHlDb21wb25lbnRzLmhhcyhvbGRDb21wKSkge1xuICAgICAgaWYgKG9sZENvbXAgIT09IHJlY29yZC5pbml0aWFsRGVmKSB7XG4gICAgICAgIHVwZGF0ZUNvbXBvbmVudERlZihvbGRDb21wLCBuZXdDb21wKTtcbiAgICAgIH1cbiAgICAgIGhtckRpcnR5Q29tcG9uZW50cy5hZGQob2xkQ29tcCk7XG4gICAgfVxuICAgIGluc3RhbmNlLmFwcENvbnRleHQucHJvcHNDYWNoZS5kZWxldGUoaW5zdGFuY2UudHlwZSk7XG4gICAgaW5zdGFuY2UuYXBwQ29udGV4dC5lbWl0c0NhY2hlLmRlbGV0ZShpbnN0YW5jZS50eXBlKTtcbiAgICBpbnN0YW5jZS5hcHBDb250ZXh0Lm9wdGlvbnNDYWNoZS5kZWxldGUoaW5zdGFuY2UudHlwZSk7XG4gICAgaWYgKGluc3RhbmNlLmNlUmVsb2FkKSB7XG4gICAgICBobXJEaXJ0eUNvbXBvbmVudHMuYWRkKG9sZENvbXApO1xuICAgICAgaW5zdGFuY2UuY2VSZWxvYWQobmV3Q29tcC5zdHlsZXMpO1xuICAgICAgaG1yRGlydHlDb21wb25lbnRzLmRlbGV0ZShvbGRDb21wKTtcbiAgICB9IGVsc2UgaWYgKGluc3RhbmNlLnBhcmVudCkge1xuICAgICAgcXVldWVKb2IoaW5zdGFuY2UucGFyZW50LnVwZGF0ZSk7XG4gICAgfSBlbHNlIGlmIChpbnN0YW5jZS5hcHBDb250ZXh0LnJlbG9hZCkge1xuICAgICAgaW5zdGFuY2UuYXBwQ29udGV4dC5yZWxvYWQoKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICBcIltITVJdIFJvb3Qgb3IgbWFudWFsbHkgbW91bnRlZCBpbnN0YW5jZSBtb2RpZmllZC4gRnVsbCByZWxvYWQgcmVxdWlyZWQuXCJcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIHF1ZXVlUG9zdEZsdXNoQ2IoKCkgPT4ge1xuICAgIGZvciAoY29uc3QgaW5zdGFuY2Ugb2YgaW5zdGFuY2VzKSB7XG4gICAgICBobXJEaXJ0eUNvbXBvbmVudHMuZGVsZXRlKFxuICAgICAgICBub3JtYWxpemVDbGFzc0NvbXBvbmVudChpbnN0YW5jZS50eXBlKVxuICAgICAgKTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gdXBkYXRlQ29tcG9uZW50RGVmKG9sZENvbXAsIG5ld0NvbXApIHtcbiAgZXh0ZW5kKG9sZENvbXAsIG5ld0NvbXApO1xuICBmb3IgKGNvbnN0IGtleSBpbiBvbGRDb21wKSB7XG4gICAgaWYgKGtleSAhPT0gXCJfX2ZpbGVcIiAmJiAhKGtleSBpbiBuZXdDb21wKSkge1xuICAgICAgZGVsZXRlIG9sZENvbXBba2V5XTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHRyeVdyYXAoZm4pIHtcbiAgcmV0dXJuIChpZCwgYXJnKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBmbihpZCwgYXJnKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICBgW0hNUl0gU29tZXRoaW5nIHdlbnQgd3JvbmcgZHVyaW5nIFZ1ZSBjb21wb25lbnQgaG90LXJlbG9hZC4gRnVsbCByZWxvYWQgcmVxdWlyZWQuYFxuICAgICAgKTtcbiAgICB9XG4gIH07XG59XG5cbmxldCBkZXZ0b29scztcbmxldCBidWZmZXIgPSBbXTtcbmxldCBkZXZ0b29sc05vdEluc3RhbGxlZCA9IGZhbHNlO1xuZnVuY3Rpb24gZW1pdCQxKGV2ZW50LCAuLi5hcmdzKSB7XG4gIGlmIChkZXZ0b29scykge1xuICAgIGRldnRvb2xzLmVtaXQoZXZlbnQsIC4uLmFyZ3MpO1xuICB9IGVsc2UgaWYgKCFkZXZ0b29sc05vdEluc3RhbGxlZCkge1xuICAgIGJ1ZmZlci5wdXNoKHsgZXZlbnQsIGFyZ3MgfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHNldERldnRvb2xzSG9vayhob29rLCB0YXJnZXQpIHtcbiAgdmFyIF9hLCBfYjtcbiAgZGV2dG9vbHMgPSBob29rO1xuICBpZiAoZGV2dG9vbHMpIHtcbiAgICBkZXZ0b29scy5lbmFibGVkID0gdHJ1ZTtcbiAgICBidWZmZXIuZm9yRWFjaCgoeyBldmVudCwgYXJncyB9KSA9PiBkZXZ0b29scy5lbWl0KGV2ZW50LCAuLi5hcmdzKSk7XG4gICAgYnVmZmVyID0gW107XG4gIH0gZWxzZSBpZiAoXG4gICAgLy8gaGFuZGxlIGxhdGUgZGV2dG9vbHMgaW5qZWN0aW9uIC0gb25seSBkbyB0aGlzIGlmIHdlIGFyZSBpbiBhbiBhY3R1YWxcbiAgICAvLyBicm93c2VyIGVudmlyb25tZW50IHRvIGF2b2lkIHRoZSB0aW1lciBoYW5kbGUgc3RhbGxpbmcgdGVzdCBydW5uZXIgZXhpdFxuICAgIC8vICgjNDgxNSlcbiAgICB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIC8vIHNvbWUgZW52cyBtb2NrIHdpbmRvdyBidXQgbm90IGZ1bGx5XG4gICAgd2luZG93LkhUTUxFbGVtZW50ICYmIC8vIGFsc28gZXhjbHVkZSBqc2RvbVxuICAgICEoKF9iID0gKF9hID0gd2luZG93Lm5hdmlnYXRvcikgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnVzZXJBZ2VudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmluY2x1ZGVzKFwianNkb21cIikpXG4gICkge1xuICAgIGNvbnN0IHJlcGxheSA9IHRhcmdldC5fX1ZVRV9ERVZUT09MU19IT09LX1JFUExBWV9fID0gdGFyZ2V0Ll9fVlVFX0RFVlRPT0xTX0hPT0tfUkVQTEFZX18gfHwgW107XG4gICAgcmVwbGF5LnB1c2goKG5ld0hvb2spID0+IHtcbiAgICAgIHNldERldnRvb2xzSG9vayhuZXdIb29rLCB0YXJnZXQpO1xuICAgIH0pO1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgaWYgKCFkZXZ0b29scykge1xuICAgICAgICB0YXJnZXQuX19WVUVfREVWVE9PTFNfSE9PS19SRVBMQVlfXyA9IG51bGw7XG4gICAgICAgIGRldnRvb2xzTm90SW5zdGFsbGVkID0gdHJ1ZTtcbiAgICAgICAgYnVmZmVyID0gW107XG4gICAgICB9XG4gICAgfSwgM2UzKTtcbiAgfSBlbHNlIHtcbiAgICBkZXZ0b29sc05vdEluc3RhbGxlZCA9IHRydWU7XG4gICAgYnVmZmVyID0gW107XG4gIH1cbn1cbmZ1bmN0aW9uIGRldnRvb2xzSW5pdEFwcChhcHAsIHZlcnNpb24pIHtcbiAgZW1pdCQxKFwiYXBwOmluaXRcIiAvKiBBUFBfSU5JVCAqLywgYXBwLCB2ZXJzaW9uLCB7XG4gICAgRnJhZ21lbnQsXG4gICAgVGV4dCxcbiAgICBDb21tZW50LFxuICAgIFN0YXRpY1xuICB9KTtcbn1cbmZ1bmN0aW9uIGRldnRvb2xzVW5tb3VudEFwcChhcHApIHtcbiAgZW1pdCQxKFwiYXBwOnVubW91bnRcIiAvKiBBUFBfVU5NT1VOVCAqLywgYXBwKTtcbn1cbmNvbnN0IGRldnRvb2xzQ29tcG9uZW50QWRkZWQgPSAvKiBAX19QVVJFX18gKi8gY3JlYXRlRGV2dG9vbHNDb21wb25lbnRIb29rKFxuICBcImNvbXBvbmVudDphZGRlZFwiIC8qIENPTVBPTkVOVF9BRERFRCAqL1xuKTtcbmNvbnN0IGRldnRvb2xzQ29tcG9uZW50VXBkYXRlZCA9IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVEZXZ0b29sc0NvbXBvbmVudEhvb2soXCJjb21wb25lbnQ6dXBkYXRlZFwiIC8qIENPTVBPTkVOVF9VUERBVEVEICovKTtcbmNvbnN0IF9kZXZ0b29sc0NvbXBvbmVudFJlbW92ZWQgPSAvKiBAX19QVVJFX18gKi8gY3JlYXRlRGV2dG9vbHNDb21wb25lbnRIb29rKFxuICBcImNvbXBvbmVudDpyZW1vdmVkXCIgLyogQ09NUE9ORU5UX1JFTU9WRUQgKi9cbik7XG5jb25zdCBkZXZ0b29sc0NvbXBvbmVudFJlbW92ZWQgPSAoY29tcG9uZW50KSA9PiB7XG4gIGlmIChkZXZ0b29scyAmJiB0eXBlb2YgZGV2dG9vbHMuY2xlYW51cEJ1ZmZlciA9PT0gXCJmdW5jdGlvblwiICYmIC8vIHJlbW92ZSB0aGUgY29tcG9uZW50IGlmIGl0IHdhc24ndCBidWZmZXJlZFxuICAhZGV2dG9vbHMuY2xlYW51cEJ1ZmZlcihjb21wb25lbnQpKSB7XG4gICAgX2RldnRvb2xzQ29tcG9uZW50UmVtb3ZlZChjb21wb25lbnQpO1xuICB9XG59O1xuZnVuY3Rpb24gY3JlYXRlRGV2dG9vbHNDb21wb25lbnRIb29rKGhvb2spIHtcbiAgcmV0dXJuIChjb21wb25lbnQpID0+IHtcbiAgICBlbWl0JDEoXG4gICAgICBob29rLFxuICAgICAgY29tcG9uZW50LmFwcENvbnRleHQuYXBwLFxuICAgICAgY29tcG9uZW50LnVpZCxcbiAgICAgIGNvbXBvbmVudC5wYXJlbnQgPyBjb21wb25lbnQucGFyZW50LnVpZCA6IHZvaWQgMCxcbiAgICAgIGNvbXBvbmVudFxuICAgICk7XG4gIH07XG59XG5jb25zdCBkZXZ0b29sc1BlcmZTdGFydCA9IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVEZXZ0b29sc1BlcmZvcm1hbmNlSG9vayhcbiAgXCJwZXJmOnN0YXJ0XCIgLyogUEVSRk9STUFOQ0VfU1RBUlQgKi9cbik7XG5jb25zdCBkZXZ0b29sc1BlcmZFbmQgPSAvKiBAX19QVVJFX18gKi8gY3JlYXRlRGV2dG9vbHNQZXJmb3JtYW5jZUhvb2soXG4gIFwicGVyZjplbmRcIiAvKiBQRVJGT1JNQU5DRV9FTkQgKi9cbik7XG5mdW5jdGlvbiBjcmVhdGVEZXZ0b29sc1BlcmZvcm1hbmNlSG9vayhob29rKSB7XG4gIHJldHVybiAoY29tcG9uZW50LCB0eXBlLCB0aW1lKSA9PiB7XG4gICAgZW1pdCQxKGhvb2ssIGNvbXBvbmVudC5hcHBDb250ZXh0LmFwcCwgY29tcG9uZW50LnVpZCwgY29tcG9uZW50LCB0eXBlLCB0aW1lKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGRldnRvb2xzQ29tcG9uZW50RW1pdChjb21wb25lbnQsIGV2ZW50LCBwYXJhbXMpIHtcbiAgZW1pdCQxKFxuICAgIFwiY29tcG9uZW50OmVtaXRcIiAvKiBDT01QT05FTlRfRU1JVCAqLyxcbiAgICBjb21wb25lbnQuYXBwQ29udGV4dC5hcHAsXG4gICAgY29tcG9uZW50LFxuICAgIGV2ZW50LFxuICAgIHBhcmFtc1xuICApO1xufVxuXG5mdW5jdGlvbiBlbWl0KGluc3RhbmNlLCBldmVudCwgLi4ucmF3QXJncykge1xuICBpZiAoaW5zdGFuY2UuaXNVbm1vdW50ZWQpXG4gICAgcmV0dXJuO1xuICBjb25zdCBwcm9wcyA9IGluc3RhbmNlLnZub2RlLnByb3BzIHx8IEVNUFRZX09CSjtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICBjb25zdCB7XG4gICAgICBlbWl0c09wdGlvbnMsXG4gICAgICBwcm9wc09wdGlvbnM6IFtwcm9wc09wdGlvbnNdXG4gICAgfSA9IGluc3RhbmNlO1xuICAgIGlmIChlbWl0c09wdGlvbnMpIHtcbiAgICAgIGlmICghKGV2ZW50IGluIGVtaXRzT3B0aW9ucykgJiYgdHJ1ZSkge1xuICAgICAgICBpZiAoIXByb3BzT3B0aW9ucyB8fCAhKHRvSGFuZGxlcktleShldmVudCkgaW4gcHJvcHNPcHRpb25zKSkge1xuICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICBgQ29tcG9uZW50IGVtaXR0ZWQgZXZlbnQgXCIke2V2ZW50fVwiIGJ1dCBpdCBpcyBuZWl0aGVyIGRlY2xhcmVkIGluIHRoZSBlbWl0cyBvcHRpb24gbm9yIGFzIGFuIFwiJHt0b0hhbmRsZXJLZXkoZXZlbnQpfVwiIHByb3AuYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHZhbGlkYXRvciA9IGVtaXRzT3B0aW9uc1tldmVudF07XG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKHZhbGlkYXRvcikpIHtcbiAgICAgICAgICBjb25zdCBpc1ZhbGlkID0gdmFsaWRhdG9yKC4uLnJhd0FyZ3MpO1xuICAgICAgICAgIGlmICghaXNWYWxpZCkge1xuICAgICAgICAgICAgd2FybihcbiAgICAgICAgICAgICAgYEludmFsaWQgZXZlbnQgYXJndW1lbnRzOiBldmVudCB2YWxpZGF0aW9uIGZhaWxlZCBmb3IgZXZlbnQgXCIke2V2ZW50fVwiLmBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGxldCBhcmdzID0gcmF3QXJncztcbiAgY29uc3QgaXNNb2RlbExpc3RlbmVyID0gZXZlbnQuc3RhcnRzV2l0aChcInVwZGF0ZTpcIik7XG4gIGNvbnN0IG1vZGVsQXJnID0gaXNNb2RlbExpc3RlbmVyICYmIGV2ZW50LnNsaWNlKDcpO1xuICBpZiAobW9kZWxBcmcgJiYgbW9kZWxBcmcgaW4gcHJvcHMpIHtcbiAgICBjb25zdCBtb2RpZmllcnNLZXkgPSBgJHttb2RlbEFyZyA9PT0gXCJtb2RlbFZhbHVlXCIgPyBcIm1vZGVsXCIgOiBtb2RlbEFyZ31Nb2RpZmllcnNgO1xuICAgIGNvbnN0IHsgbnVtYmVyLCB0cmltIH0gPSBwcm9wc1ttb2RpZmllcnNLZXldIHx8IEVNUFRZX09CSjtcbiAgICBpZiAodHJpbSkge1xuICAgICAgYXJncyA9IHJhd0FyZ3MubWFwKChhKSA9PiBpc1N0cmluZyhhKSA/IGEudHJpbSgpIDogYSk7XG4gICAgfVxuICAgIGlmIChudW1iZXIpIHtcbiAgICAgIGFyZ3MgPSByYXdBcmdzLm1hcChsb29zZVRvTnVtYmVyKTtcbiAgICB9XG4gIH1cbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XG4gICAgZGV2dG9vbHNDb21wb25lbnRFbWl0KGluc3RhbmNlLCBldmVudCwgYXJncyk7XG4gIH1cbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICBjb25zdCBsb3dlckNhc2VFdmVudCA9IGV2ZW50LnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKGxvd2VyQ2FzZUV2ZW50ICE9PSBldmVudCAmJiBwcm9wc1t0b0hhbmRsZXJLZXkobG93ZXJDYXNlRXZlbnQpXSkge1xuICAgICAgd2FybihcbiAgICAgICAgYEV2ZW50IFwiJHtsb3dlckNhc2VFdmVudH1cIiBpcyBlbWl0dGVkIGluIGNvbXBvbmVudCAke2Zvcm1hdENvbXBvbmVudE5hbWUoXG4gICAgICAgICAgaW5zdGFuY2UsXG4gICAgICAgICAgaW5zdGFuY2UudHlwZVxuICAgICAgICApfSBidXQgdGhlIGhhbmRsZXIgaXMgcmVnaXN0ZXJlZCBmb3IgXCIke2V2ZW50fVwiLiBOb3RlIHRoYXQgSFRNTCBhdHRyaWJ1dGVzIGFyZSBjYXNlLWluc2Vuc2l0aXZlIGFuZCB5b3UgY2Fubm90IHVzZSB2LW9uIHRvIGxpc3RlbiB0byBjYW1lbENhc2UgZXZlbnRzIHdoZW4gdXNpbmcgaW4tRE9NIHRlbXBsYXRlcy4gWW91IHNob3VsZCBwcm9iYWJseSB1c2UgXCIke2h5cGhlbmF0ZShldmVudCl9XCIgaW5zdGVhZCBvZiBcIiR7ZXZlbnR9XCIuYFxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgbGV0IGhhbmRsZXJOYW1lO1xuICBsZXQgaGFuZGxlciA9IHByb3BzW2hhbmRsZXJOYW1lID0gdG9IYW5kbGVyS2V5KGV2ZW50KV0gfHwgLy8gYWxzbyB0cnkgY2FtZWxDYXNlIGV2ZW50IGhhbmRsZXIgKCMyMjQ5KVxuICBwcm9wc1toYW5kbGVyTmFtZSA9IHRvSGFuZGxlcktleShjYW1lbGl6ZShldmVudCkpXTtcbiAgaWYgKCFoYW5kbGVyICYmIGlzTW9kZWxMaXN0ZW5lcikge1xuICAgIGhhbmRsZXIgPSBwcm9wc1toYW5kbGVyTmFtZSA9IHRvSGFuZGxlcktleShoeXBoZW5hdGUoZXZlbnQpKV07XG4gIH1cbiAgaWYgKGhhbmRsZXIpIHtcbiAgICBjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZyhcbiAgICAgIGhhbmRsZXIsXG4gICAgICBpbnN0YW5jZSxcbiAgICAgIDYsXG4gICAgICBhcmdzXG4gICAgKTtcbiAgfVxuICBjb25zdCBvbmNlSGFuZGxlciA9IHByb3BzW2hhbmRsZXJOYW1lICsgYE9uY2VgXTtcbiAgaWYgKG9uY2VIYW5kbGVyKSB7XG4gICAgaWYgKCFpbnN0YW5jZS5lbWl0dGVkKSB7XG4gICAgICBpbnN0YW5jZS5lbWl0dGVkID0ge307XG4gICAgfSBlbHNlIGlmIChpbnN0YW5jZS5lbWl0dGVkW2hhbmRsZXJOYW1lXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpbnN0YW5jZS5lbWl0dGVkW2hhbmRsZXJOYW1lXSA9IHRydWU7XG4gICAgY2FsbFdpdGhBc3luY0Vycm9ySGFuZGxpbmcoXG4gICAgICBvbmNlSGFuZGxlcixcbiAgICAgIGluc3RhbmNlLFxuICAgICAgNixcbiAgICAgIGFyZ3NcbiAgICApO1xuICB9XG59XG5mdW5jdGlvbiBub3JtYWxpemVFbWl0c09wdGlvbnMoY29tcCwgYXBwQ29udGV4dCwgYXNNaXhpbiA9IGZhbHNlKSB7XG4gIGNvbnN0IGNhY2hlID0gYXBwQ29udGV4dC5lbWl0c0NhY2hlO1xuICBjb25zdCBjYWNoZWQgPSBjYWNoZS5nZXQoY29tcCk7XG4gIGlmIChjYWNoZWQgIT09IHZvaWQgMCkge1xuICAgIHJldHVybiBjYWNoZWQ7XG4gIH1cbiAgY29uc3QgcmF3ID0gY29tcC5lbWl0cztcbiAgbGV0IG5vcm1hbGl6ZWQgPSB7fTtcbiAgbGV0IGhhc0V4dGVuZHMgPSBmYWxzZTtcbiAgaWYgKF9fVlVFX09QVElPTlNfQVBJX18gJiYgIWlzRnVuY3Rpb24oY29tcCkpIHtcbiAgICBjb25zdCBleHRlbmRFbWl0cyA9IChyYXcyKSA9PiB7XG4gICAgICBjb25zdCBub3JtYWxpemVkRnJvbUV4dGVuZCA9IG5vcm1hbGl6ZUVtaXRzT3B0aW9ucyhyYXcyLCBhcHBDb250ZXh0LCB0cnVlKTtcbiAgICAgIGlmIChub3JtYWxpemVkRnJvbUV4dGVuZCkge1xuICAgICAgICBoYXNFeHRlbmRzID0gdHJ1ZTtcbiAgICAgICAgZXh0ZW5kKG5vcm1hbGl6ZWQsIG5vcm1hbGl6ZWRGcm9tRXh0ZW5kKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGlmICghYXNNaXhpbiAmJiBhcHBDb250ZXh0Lm1peGlucy5sZW5ndGgpIHtcbiAgICAgIGFwcENvbnRleHQubWl4aW5zLmZvckVhY2goZXh0ZW5kRW1pdHMpO1xuICAgIH1cbiAgICBpZiAoY29tcC5leHRlbmRzKSB7XG4gICAgICBleHRlbmRFbWl0cyhjb21wLmV4dGVuZHMpO1xuICAgIH1cbiAgICBpZiAoY29tcC5taXhpbnMpIHtcbiAgICAgIGNvbXAubWl4aW5zLmZvckVhY2goZXh0ZW5kRW1pdHMpO1xuICAgIH1cbiAgfVxuICBpZiAoIXJhdyAmJiAhaGFzRXh0ZW5kcykge1xuICAgIGlmIChpc09iamVjdChjb21wKSkge1xuICAgICAgY2FjaGUuc2V0KGNvbXAsIG51bGwpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAoaXNBcnJheShyYXcpKSB7XG4gICAgcmF3LmZvckVhY2goKGtleSkgPT4gbm9ybWFsaXplZFtrZXldID0gbnVsbCk7XG4gIH0gZWxzZSB7XG4gICAgZXh0ZW5kKG5vcm1hbGl6ZWQsIHJhdyk7XG4gIH1cbiAgaWYgKGlzT2JqZWN0KGNvbXApKSB7XG4gICAgY2FjaGUuc2V0KGNvbXAsIG5vcm1hbGl6ZWQpO1xuICB9XG4gIHJldHVybiBub3JtYWxpemVkO1xufVxuZnVuY3Rpb24gaXNFbWl0TGlzdGVuZXIob3B0aW9ucywga2V5KSB7XG4gIGlmICghb3B0aW9ucyB8fCAhaXNPbihrZXkpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGtleSA9IGtleS5zbGljZSgyKS5yZXBsYWNlKC9PbmNlJC8sIFwiXCIpO1xuICByZXR1cm4gaGFzT3duKG9wdGlvbnMsIGtleVswXS50b0xvd2VyQ2FzZSgpICsga2V5LnNsaWNlKDEpKSB8fCBoYXNPd24ob3B0aW9ucywgaHlwaGVuYXRlKGtleSkpIHx8IGhhc093bihvcHRpb25zLCBrZXkpO1xufVxuXG5sZXQgY3VycmVudFJlbmRlcmluZ0luc3RhbmNlID0gbnVsbDtcbmxldCBjdXJyZW50U2NvcGVJZCA9IG51bGw7XG5mdW5jdGlvbiBzZXRDdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UoaW5zdGFuY2UpIHtcbiAgY29uc3QgcHJldiA9IGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZTtcbiAgY3VycmVudFJlbmRlcmluZ0luc3RhbmNlID0gaW5zdGFuY2U7XG4gIGN1cnJlbnRTY29wZUlkID0gaW5zdGFuY2UgJiYgaW5zdGFuY2UudHlwZS5fX3Njb3BlSWQgfHwgbnVsbDtcbiAgcmV0dXJuIHByZXY7XG59XG5mdW5jdGlvbiBwdXNoU2NvcGVJZChpZCkge1xuICBjdXJyZW50U2NvcGVJZCA9IGlkO1xufVxuZnVuY3Rpb24gcG9wU2NvcGVJZCgpIHtcbiAgY3VycmVudFNjb3BlSWQgPSBudWxsO1xufVxuY29uc3Qgd2l0aFNjb3BlSWQgPSAoX2lkKSA9PiB3aXRoQ3R4O1xuZnVuY3Rpb24gd2l0aEN0eChmbiwgY3R4ID0gY3VycmVudFJlbmRlcmluZ0luc3RhbmNlLCBpc05vblNjb3BlZFNsb3QpIHtcbiAgaWYgKCFjdHgpXG4gICAgcmV0dXJuIGZuO1xuICBpZiAoZm4uX24pIHtcbiAgICByZXR1cm4gZm47XG4gIH1cbiAgY29uc3QgcmVuZGVyRm5XaXRoQ29udGV4dCA9ICguLi5hcmdzKSA9PiB7XG4gICAgaWYgKHJlbmRlckZuV2l0aENvbnRleHQuX2QpIHtcbiAgICAgIHNldEJsb2NrVHJhY2tpbmcoLTEpO1xuICAgIH1cbiAgICBjb25zdCBwcmV2SW5zdGFuY2UgPSBzZXRDdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UoY3R4KTtcbiAgICBsZXQgcmVzO1xuICAgIHRyeSB7XG4gICAgICByZXMgPSBmbiguLi5hcmdzKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgc2V0Q3VycmVudFJlbmRlcmluZ0luc3RhbmNlKHByZXZJbnN0YW5jZSk7XG4gICAgICBpZiAocmVuZGVyRm5XaXRoQ29udGV4dC5fZCkge1xuICAgICAgICBzZXRCbG9ja1RyYWNraW5nKDEpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcbiAgICAgIGRldnRvb2xzQ29tcG9uZW50VXBkYXRlZChjdHgpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xuICB9O1xuICByZW5kZXJGbldpdGhDb250ZXh0Ll9uID0gdHJ1ZTtcbiAgcmVuZGVyRm5XaXRoQ29udGV4dC5fYyA9IHRydWU7XG4gIHJlbmRlckZuV2l0aENvbnRleHQuX2QgPSB0cnVlO1xuICByZXR1cm4gcmVuZGVyRm5XaXRoQ29udGV4dDtcbn1cblxubGV0IGFjY2Vzc2VkQXR0cnMgPSBmYWxzZTtcbmZ1bmN0aW9uIG1hcmtBdHRyc0FjY2Vzc2VkKCkge1xuICBhY2Nlc3NlZEF0dHJzID0gdHJ1ZTtcbn1cbmZ1bmN0aW9uIHJlbmRlckNvbXBvbmVudFJvb3QoaW5zdGFuY2UpIHtcbiAgY29uc3Qge1xuICAgIHR5cGU6IENvbXBvbmVudCxcbiAgICB2bm9kZSxcbiAgICBwcm94eSxcbiAgICB3aXRoUHJveHksXG4gICAgcHJvcHMsXG4gICAgcHJvcHNPcHRpb25zOiBbcHJvcHNPcHRpb25zXSxcbiAgICBzbG90cyxcbiAgICBhdHRycyxcbiAgICBlbWl0LFxuICAgIHJlbmRlcixcbiAgICByZW5kZXJDYWNoZSxcbiAgICBkYXRhLFxuICAgIHNldHVwU3RhdGUsXG4gICAgY3R4LFxuICAgIGluaGVyaXRBdHRyc1xuICB9ID0gaW5zdGFuY2U7XG4gIGxldCByZXN1bHQ7XG4gIGxldCBmYWxsdGhyb3VnaEF0dHJzO1xuICBjb25zdCBwcmV2ID0gc2V0Q3VycmVudFJlbmRlcmluZ0luc3RhbmNlKGluc3RhbmNlKTtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICBhY2Nlc3NlZEF0dHJzID0gZmFsc2U7XG4gIH1cbiAgdHJ5IHtcbiAgICBpZiAodm5vZGUuc2hhcGVGbGFnICYgNCkge1xuICAgICAgY29uc3QgcHJveHlUb1VzZSA9IHdpdGhQcm94eSB8fCBwcm94eTtcbiAgICAgIHJlc3VsdCA9IG5vcm1hbGl6ZVZOb2RlKFxuICAgICAgICByZW5kZXIuY2FsbChcbiAgICAgICAgICBwcm94eVRvVXNlLFxuICAgICAgICAgIHByb3h5VG9Vc2UsXG4gICAgICAgICAgcmVuZGVyQ2FjaGUsXG4gICAgICAgICAgcHJvcHMsXG4gICAgICAgICAgc2V0dXBTdGF0ZSxcbiAgICAgICAgICBkYXRhLFxuICAgICAgICAgIGN0eFxuICAgICAgICApXG4gICAgICApO1xuICAgICAgZmFsbHRocm91Z2hBdHRycyA9IGF0dHJzO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCByZW5kZXIyID0gQ29tcG9uZW50O1xuICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgYXR0cnMgPT09IHByb3BzKSB7XG4gICAgICAgIG1hcmtBdHRyc0FjY2Vzc2VkKCk7XG4gICAgICB9XG4gICAgICByZXN1bHQgPSBub3JtYWxpemVWTm9kZShcbiAgICAgICAgcmVuZGVyMi5sZW5ndGggPiAxID8gcmVuZGVyMihcbiAgICAgICAgICBwcm9wcyxcbiAgICAgICAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8ge1xuICAgICAgICAgICAgZ2V0IGF0dHJzKCkge1xuICAgICAgICAgICAgICBtYXJrQXR0cnNBY2Nlc3NlZCgpO1xuICAgICAgICAgICAgICByZXR1cm4gYXR0cnM7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2xvdHMsXG4gICAgICAgICAgICBlbWl0XG4gICAgICAgICAgfSA6IHsgYXR0cnMsIHNsb3RzLCBlbWl0IH1cbiAgICAgICAgKSA6IHJlbmRlcjIoXG4gICAgICAgICAgcHJvcHMsXG4gICAgICAgICAgbnVsbFxuICAgICAgICAgIC8qIHdlIGtub3cgaXQgZG9lc24ndCBuZWVkIGl0ICovXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgICBmYWxsdGhyb3VnaEF0dHJzID0gQ29tcG9uZW50LnByb3BzID8gYXR0cnMgOiBnZXRGdW5jdGlvbmFsRmFsbHRocm91Z2goYXR0cnMpO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgYmxvY2tTdGFjay5sZW5ndGggPSAwO1xuICAgIGhhbmRsZUVycm9yKGVyciwgaW5zdGFuY2UsIDEpO1xuICAgIHJlc3VsdCA9IGNyZWF0ZVZOb2RlKENvbW1lbnQpO1xuICB9XG4gIGxldCByb290ID0gcmVzdWx0O1xuICBsZXQgc2V0Um9vdCA9IHZvaWQgMDtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgcmVzdWx0LnBhdGNoRmxhZyA+IDAgJiYgcmVzdWx0LnBhdGNoRmxhZyAmIDIwNDgpIHtcbiAgICBbcm9vdCwgc2V0Um9vdF0gPSBnZXRDaGlsZFJvb3QocmVzdWx0KTtcbiAgfVxuICBpZiAoZmFsbHRocm91Z2hBdHRycyAmJiBpbmhlcml0QXR0cnMgIT09IGZhbHNlKSB7XG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGZhbGx0aHJvdWdoQXR0cnMpO1xuICAgIGNvbnN0IHsgc2hhcGVGbGFnIH0gPSByb290O1xuICAgIGlmIChrZXlzLmxlbmd0aCkge1xuICAgICAgaWYgKHNoYXBlRmxhZyAmICgxIHwgNikpIHtcbiAgICAgICAgaWYgKHByb3BzT3B0aW9ucyAmJiBrZXlzLnNvbWUoaXNNb2RlbExpc3RlbmVyKSkge1xuICAgICAgICAgIGZhbGx0aHJvdWdoQXR0cnMgPSBmaWx0ZXJNb2RlbExpc3RlbmVycyhcbiAgICAgICAgICAgIGZhbGx0aHJvdWdoQXR0cnMsXG4gICAgICAgICAgICBwcm9wc09wdGlvbnNcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHJvb3QgPSBjbG9uZVZOb2RlKHJvb3QsIGZhbGx0aHJvdWdoQXR0cnMpO1xuICAgICAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICFhY2Nlc3NlZEF0dHJzICYmIHJvb3QudHlwZSAhPT0gQ29tbWVudCkge1xuICAgICAgICBjb25zdCBhbGxBdHRycyA9IE9iamVjdC5rZXlzKGF0dHJzKTtcbiAgICAgICAgY29uc3QgZXZlbnRBdHRycyA9IFtdO1xuICAgICAgICBjb25zdCBleHRyYUF0dHJzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gYWxsQXR0cnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgY29uc3Qga2V5ID0gYWxsQXR0cnNbaV07XG4gICAgICAgICAgaWYgKGlzT24oa2V5KSkge1xuICAgICAgICAgICAgaWYgKCFpc01vZGVsTGlzdGVuZXIoa2V5KSkge1xuICAgICAgICAgICAgICBldmVudEF0dHJzLnB1c2goa2V5WzJdLnRvTG93ZXJDYXNlKCkgKyBrZXkuc2xpY2UoMykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBleHRyYUF0dHJzLnB1c2goa2V5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV4dHJhQXR0cnMubGVuZ3RoKSB7XG4gICAgICAgICAgd2FybihcbiAgICAgICAgICAgIGBFeHRyYW5lb3VzIG5vbi1wcm9wcyBhdHRyaWJ1dGVzICgke2V4dHJhQXR0cnMuam9pbihcIiwgXCIpfSkgd2VyZSBwYXNzZWQgdG8gY29tcG9uZW50IGJ1dCBjb3VsZCBub3QgYmUgYXV0b21hdGljYWxseSBpbmhlcml0ZWQgYmVjYXVzZSBjb21wb25lbnQgcmVuZGVycyBmcmFnbWVudCBvciB0ZXh0IHJvb3Qgbm9kZXMuYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV2ZW50QXR0cnMubGVuZ3RoKSB7XG4gICAgICAgICAgd2FybihcbiAgICAgICAgICAgIGBFeHRyYW5lb3VzIG5vbi1lbWl0cyBldmVudCBsaXN0ZW5lcnMgKCR7ZXZlbnRBdHRycy5qb2luKFwiLCBcIil9KSB3ZXJlIHBhc3NlZCB0byBjb21wb25lbnQgYnV0IGNvdWxkIG5vdCBiZSBhdXRvbWF0aWNhbGx5IGluaGVyaXRlZCBiZWNhdXNlIGNvbXBvbmVudCByZW5kZXJzIGZyYWdtZW50IG9yIHRleHQgcm9vdCBub2Rlcy4gSWYgdGhlIGxpc3RlbmVyIGlzIGludGVuZGVkIHRvIGJlIGEgY29tcG9uZW50IGN1c3RvbSBldmVudCBsaXN0ZW5lciBvbmx5LCBkZWNsYXJlIGl0IHVzaW5nIHRoZSBcImVtaXRzXCIgb3B0aW9uLmBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmICh2bm9kZS5kaXJzKSB7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgIWlzRWxlbWVudFJvb3Qocm9vdCkpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIGBSdW50aW1lIGRpcmVjdGl2ZSB1c2VkIG9uIGNvbXBvbmVudCB3aXRoIG5vbi1lbGVtZW50IHJvb3Qgbm9kZS4gVGhlIGRpcmVjdGl2ZXMgd2lsbCBub3QgZnVuY3Rpb24gYXMgaW50ZW5kZWQuYFxuICAgICAgKTtcbiAgICB9XG4gICAgcm9vdCA9IGNsb25lVk5vZGUocm9vdCk7XG4gICAgcm9vdC5kaXJzID0gcm9vdC5kaXJzID8gcm9vdC5kaXJzLmNvbmNhdCh2bm9kZS5kaXJzKSA6IHZub2RlLmRpcnM7XG4gIH1cbiAgaWYgKHZub2RlLnRyYW5zaXRpb24pIHtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhaXNFbGVtZW50Um9vdChyb290KSkge1xuICAgICAgd2FybihcbiAgICAgICAgYENvbXBvbmVudCBpbnNpZGUgPFRyYW5zaXRpb24+IHJlbmRlcnMgbm9uLWVsZW1lbnQgcm9vdCBub2RlIHRoYXQgY2Fubm90IGJlIGFuaW1hdGVkLmBcbiAgICAgICk7XG4gICAgfVxuICAgIHJvb3QudHJhbnNpdGlvbiA9IHZub2RlLnRyYW5zaXRpb247XG4gIH1cbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgc2V0Um9vdCkge1xuICAgIHNldFJvb3Qocm9vdCk7XG4gIH0gZWxzZSB7XG4gICAgcmVzdWx0ID0gcm9vdDtcbiAgfVxuICBzZXRDdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UocHJldik7XG4gIHJldHVybiByZXN1bHQ7XG59XG5jb25zdCBnZXRDaGlsZFJvb3QgPSAodm5vZGUpID0+IHtcbiAgY29uc3QgcmF3Q2hpbGRyZW4gPSB2bm9kZS5jaGlsZHJlbjtcbiAgY29uc3QgZHluYW1pY0NoaWxkcmVuID0gdm5vZGUuZHluYW1pY0NoaWxkcmVuO1xuICBjb25zdCBjaGlsZFJvb3QgPSBmaWx0ZXJTaW5nbGVSb290KHJhd0NoaWxkcmVuKTtcbiAgaWYgKCFjaGlsZFJvb3QpIHtcbiAgICByZXR1cm4gW3Zub2RlLCB2b2lkIDBdO1xuICB9XG4gIGNvbnN0IGluZGV4ID0gcmF3Q2hpbGRyZW4uaW5kZXhPZihjaGlsZFJvb3QpO1xuICBjb25zdCBkeW5hbWljSW5kZXggPSBkeW5hbWljQ2hpbGRyZW4gPyBkeW5hbWljQ2hpbGRyZW4uaW5kZXhPZihjaGlsZFJvb3QpIDogLTE7XG4gIGNvbnN0IHNldFJvb3QgPSAodXBkYXRlZFJvb3QpID0+IHtcbiAgICByYXdDaGlsZHJlbltpbmRleF0gPSB1cGRhdGVkUm9vdDtcbiAgICBpZiAoZHluYW1pY0NoaWxkcmVuKSB7XG4gICAgICBpZiAoZHluYW1pY0luZGV4ID4gLTEpIHtcbiAgICAgICAgZHluYW1pY0NoaWxkcmVuW2R5bmFtaWNJbmRleF0gPSB1cGRhdGVkUm9vdDtcbiAgICAgIH0gZWxzZSBpZiAodXBkYXRlZFJvb3QucGF0Y2hGbGFnID4gMCkge1xuICAgICAgICB2bm9kZS5keW5hbWljQ2hpbGRyZW4gPSBbLi4uZHluYW1pY0NoaWxkcmVuLCB1cGRhdGVkUm9vdF07XG4gICAgICB9XG4gICAgfVxuICB9O1xuICByZXR1cm4gW25vcm1hbGl6ZVZOb2RlKGNoaWxkUm9vdCksIHNldFJvb3RdO1xufTtcbmZ1bmN0aW9uIGZpbHRlclNpbmdsZVJvb3QoY2hpbGRyZW4pIHtcbiAgbGV0IHNpbmdsZVJvb3Q7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgIGlmIChpc1ZOb2RlKGNoaWxkKSkge1xuICAgICAgaWYgKGNoaWxkLnR5cGUgIT09IENvbW1lbnQgfHwgY2hpbGQuY2hpbGRyZW4gPT09IFwidi1pZlwiKSB7XG4gICAgICAgIGlmIChzaW5nbGVSb290KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNpbmdsZVJvb3QgPSBjaGlsZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG4gIHJldHVybiBzaW5nbGVSb290O1xufVxuY29uc3QgZ2V0RnVuY3Rpb25hbEZhbGx0aHJvdWdoID0gKGF0dHJzKSA9PiB7XG4gIGxldCByZXM7XG4gIGZvciAoY29uc3Qga2V5IGluIGF0dHJzKSB7XG4gICAgaWYgKGtleSA9PT0gXCJjbGFzc1wiIHx8IGtleSA9PT0gXCJzdHlsZVwiIHx8IGlzT24oa2V5KSkge1xuICAgICAgKHJlcyB8fCAocmVzID0ge30pKVtrZXldID0gYXR0cnNba2V5XTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlcztcbn07XG5jb25zdCBmaWx0ZXJNb2RlbExpc3RlbmVycyA9IChhdHRycywgcHJvcHMpID0+IHtcbiAgY29uc3QgcmVzID0ge307XG4gIGZvciAoY29uc3Qga2V5IGluIGF0dHJzKSB7XG4gICAgaWYgKCFpc01vZGVsTGlzdGVuZXIoa2V5KSB8fCAhKGtleS5zbGljZSg5KSBpbiBwcm9wcykpIHtcbiAgICAgIHJlc1trZXldID0gYXR0cnNba2V5XTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlcztcbn07XG5jb25zdCBpc0VsZW1lbnRSb290ID0gKHZub2RlKSA9PiB7XG4gIHJldHVybiB2bm9kZS5zaGFwZUZsYWcgJiAoNiB8IDEpIHx8IHZub2RlLnR5cGUgPT09IENvbW1lbnQ7XG59O1xuZnVuY3Rpb24gc2hvdWxkVXBkYXRlQ29tcG9uZW50KHByZXZWTm9kZSwgbmV4dFZOb2RlLCBvcHRpbWl6ZWQpIHtcbiAgY29uc3QgeyBwcm9wczogcHJldlByb3BzLCBjaGlsZHJlbjogcHJldkNoaWxkcmVuLCBjb21wb25lbnQgfSA9IHByZXZWTm9kZTtcbiAgY29uc3QgeyBwcm9wczogbmV4dFByb3BzLCBjaGlsZHJlbjogbmV4dENoaWxkcmVuLCBwYXRjaEZsYWcgfSA9IG5leHRWTm9kZTtcbiAgY29uc3QgZW1pdHMgPSBjb21wb25lbnQuZW1pdHNPcHRpb25zO1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAocHJldkNoaWxkcmVuIHx8IG5leHRDaGlsZHJlbikgJiYgaXNIbXJVcGRhdGluZykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChuZXh0Vk5vZGUuZGlycyB8fCBuZXh0Vk5vZGUudHJhbnNpdGlvbikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChvcHRpbWl6ZWQgJiYgcGF0Y2hGbGFnID49IDApIHtcbiAgICBpZiAocGF0Y2hGbGFnICYgMTAyNCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChwYXRjaEZsYWcgJiAxNikge1xuICAgICAgaWYgKCFwcmV2UHJvcHMpIHtcbiAgICAgICAgcmV0dXJuICEhbmV4dFByb3BzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGhhc1Byb3BzQ2hhbmdlZChwcmV2UHJvcHMsIG5leHRQcm9wcywgZW1pdHMpO1xuICAgIH0gZWxzZSBpZiAocGF0Y2hGbGFnICYgOCkge1xuICAgICAgY29uc3QgZHluYW1pY1Byb3BzID0gbmV4dFZOb2RlLmR5bmFtaWNQcm9wcztcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZHluYW1pY1Byb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IGR5bmFtaWNQcm9wc1tpXTtcbiAgICAgICAgaWYgKG5leHRQcm9wc1trZXldICE9PSBwcmV2UHJvcHNba2V5XSAmJiAhaXNFbWl0TGlzdGVuZXIoZW1pdHMsIGtleSkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAocHJldkNoaWxkcmVuIHx8IG5leHRDaGlsZHJlbikge1xuICAgICAgaWYgKCFuZXh0Q2hpbGRyZW4gfHwgIW5leHRDaGlsZHJlbi4kc3RhYmxlKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocHJldlByb3BzID09PSBuZXh0UHJvcHMpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCFwcmV2UHJvcHMpIHtcbiAgICAgIHJldHVybiAhIW5leHRQcm9wcztcbiAgICB9XG4gICAgaWYgKCFuZXh0UHJvcHMpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gaGFzUHJvcHNDaGFuZ2VkKHByZXZQcm9wcywgbmV4dFByb3BzLCBlbWl0cyk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gaGFzUHJvcHNDaGFuZ2VkKHByZXZQcm9wcywgbmV4dFByb3BzLCBlbWl0c09wdGlvbnMpIHtcbiAgY29uc3QgbmV4dEtleXMgPSBPYmplY3Qua2V5cyhuZXh0UHJvcHMpO1xuICBpZiAobmV4dEtleXMubGVuZ3RoICE9PSBPYmplY3Qua2V5cyhwcmV2UHJvcHMpLmxlbmd0aCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbmV4dEtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBrZXkgPSBuZXh0S2V5c1tpXTtcbiAgICBpZiAobmV4dFByb3BzW2tleV0gIT09IHByZXZQcm9wc1trZXldICYmICFpc0VtaXRMaXN0ZW5lcihlbWl0c09wdGlvbnMsIGtleSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiB1cGRhdGVIT0NIb3N0RWwoeyB2bm9kZSwgcGFyZW50IH0sIGVsKSB7XG4gIHdoaWxlIChwYXJlbnQgJiYgcGFyZW50LnN1YlRyZWUgPT09IHZub2RlKSB7XG4gICAgKHZub2RlID0gcGFyZW50LnZub2RlKS5lbCA9IGVsO1xuICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XG4gIH1cbn1cblxuY29uc3QgaXNTdXNwZW5zZSA9ICh0eXBlKSA9PiB0eXBlLl9faXNTdXNwZW5zZTtcbmNvbnN0IFN1c3BlbnNlSW1wbCA9IHtcbiAgbmFtZTogXCJTdXNwZW5zZVwiLFxuICAvLyBJbiBvcmRlciB0byBtYWtlIFN1c3BlbnNlIHRyZWUtc2hha2FibGUsIHdlIG5lZWQgdG8gYXZvaWQgaW1wb3J0aW5nIGl0XG4gIC8vIGRpcmVjdGx5IGluIHRoZSByZW5kZXJlci4gVGhlIHJlbmRlcmVyIGNoZWNrcyBmb3IgdGhlIF9faXNTdXNwZW5zZSBmbGFnXG4gIC8vIG9uIGEgdm5vZGUncyB0eXBlIGFuZCBjYWxscyB0aGUgYHByb2Nlc3NgIG1ldGhvZCwgcGFzc2luZyBpbiByZW5kZXJlclxuICAvLyBpbnRlcm5hbHMuXG4gIF9faXNTdXNwZW5zZTogdHJ1ZSxcbiAgcHJvY2VzcyhuMSwgbjIsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQsIHJlbmRlcmVySW50ZXJuYWxzKSB7XG4gICAgaWYgKG4xID09IG51bGwpIHtcbiAgICAgIG1vdW50U3VzcGVuc2UoXG4gICAgICAgIG4yLFxuICAgICAgICBjb250YWluZXIsXG4gICAgICAgIGFuY2hvcixcbiAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgaXNTVkcsXG4gICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgb3B0aW1pemVkLFxuICAgICAgICByZW5kZXJlckludGVybmFsc1xuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGF0Y2hTdXNwZW5zZShcbiAgICAgICAgbjEsXG4gICAgICAgIG4yLFxuICAgICAgICBjb250YWluZXIsXG4gICAgICAgIGFuY2hvcixcbiAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICBpc1NWRyxcbiAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICBvcHRpbWl6ZWQsXG4gICAgICAgIHJlbmRlcmVySW50ZXJuYWxzXG4gICAgICApO1xuICAgIH1cbiAgfSxcbiAgaHlkcmF0ZTogaHlkcmF0ZVN1c3BlbnNlLFxuICBjcmVhdGU6IGNyZWF0ZVN1c3BlbnNlQm91bmRhcnksXG4gIG5vcm1hbGl6ZTogbm9ybWFsaXplU3VzcGVuc2VDaGlsZHJlblxufTtcbmNvbnN0IFN1c3BlbnNlID0gU3VzcGVuc2VJbXBsIDtcbmZ1bmN0aW9uIHRyaWdnZXJFdmVudCh2bm9kZSwgbmFtZSkge1xuICBjb25zdCBldmVudExpc3RlbmVyID0gdm5vZGUucHJvcHMgJiYgdm5vZGUucHJvcHNbbmFtZV07XG4gIGlmIChpc0Z1bmN0aW9uKGV2ZW50TGlzdGVuZXIpKSB7XG4gICAgZXZlbnRMaXN0ZW5lcigpO1xuICB9XG59XG5mdW5jdGlvbiBtb3VudFN1c3BlbnNlKHZub2RlLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkLCByZW5kZXJlckludGVybmFscykge1xuICBjb25zdCB7XG4gICAgcDogcGF0Y2gsXG4gICAgbzogeyBjcmVhdGVFbGVtZW50IH1cbiAgfSA9IHJlbmRlcmVySW50ZXJuYWxzO1xuICBjb25zdCBoaWRkZW5Db250YWluZXIgPSBjcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICBjb25zdCBzdXNwZW5zZSA9IHZub2RlLnN1c3BlbnNlID0gY3JlYXRlU3VzcGVuc2VCb3VuZGFyeShcbiAgICB2bm9kZSxcbiAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgY29udGFpbmVyLFxuICAgIGhpZGRlbkNvbnRhaW5lcixcbiAgICBhbmNob3IsXG4gICAgaXNTVkcsXG4gICAgc2xvdFNjb3BlSWRzLFxuICAgIG9wdGltaXplZCxcbiAgICByZW5kZXJlckludGVybmFsc1xuICApO1xuICBwYXRjaChcbiAgICBudWxsLFxuICAgIHN1c3BlbnNlLnBlbmRpbmdCcmFuY2ggPSB2bm9kZS5zc0NvbnRlbnQsXG4gICAgaGlkZGVuQ29udGFpbmVyLFxuICAgIG51bGwsXG4gICAgcGFyZW50Q29tcG9uZW50LFxuICAgIHN1c3BlbnNlLFxuICAgIGlzU1ZHLFxuICAgIHNsb3RTY29wZUlkc1xuICApO1xuICBpZiAoc3VzcGVuc2UuZGVwcyA+IDApIHtcbiAgICB0cmlnZ2VyRXZlbnQodm5vZGUsIFwib25QZW5kaW5nXCIpO1xuICAgIHRyaWdnZXJFdmVudCh2bm9kZSwgXCJvbkZhbGxiYWNrXCIpO1xuICAgIHBhdGNoKFxuICAgICAgbnVsbCxcbiAgICAgIHZub2RlLnNzRmFsbGJhY2ssXG4gICAgICBjb250YWluZXIsXG4gICAgICBhbmNob3IsXG4gICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICBudWxsLFxuICAgICAgLy8gZmFsbGJhY2sgdHJlZSB3aWxsIG5vdCBoYXZlIHN1c3BlbnNlIGNvbnRleHRcbiAgICAgIGlzU1ZHLFxuICAgICAgc2xvdFNjb3BlSWRzXG4gICAgKTtcbiAgICBzZXRBY3RpdmVCcmFuY2goc3VzcGVuc2UsIHZub2RlLnNzRmFsbGJhY2spO1xuICB9IGVsc2Uge1xuICAgIHN1c3BlbnNlLnJlc29sdmUoZmFsc2UsIHRydWUpO1xuICB9XG59XG5mdW5jdGlvbiBwYXRjaFN1c3BlbnNlKG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkLCB7IHA6IHBhdGNoLCB1bTogdW5tb3VudCwgbzogeyBjcmVhdGVFbGVtZW50IH0gfSkge1xuICBjb25zdCBzdXNwZW5zZSA9IG4yLnN1c3BlbnNlID0gbjEuc3VzcGVuc2U7XG4gIHN1c3BlbnNlLnZub2RlID0gbjI7XG4gIG4yLmVsID0gbjEuZWw7XG4gIGNvbnN0IG5ld0JyYW5jaCA9IG4yLnNzQ29udGVudDtcbiAgY29uc3QgbmV3RmFsbGJhY2sgPSBuMi5zc0ZhbGxiYWNrO1xuICBjb25zdCB7IGFjdGl2ZUJyYW5jaCwgcGVuZGluZ0JyYW5jaCwgaXNJbkZhbGxiYWNrLCBpc0h5ZHJhdGluZyB9ID0gc3VzcGVuc2U7XG4gIGlmIChwZW5kaW5nQnJhbmNoKSB7XG4gICAgc3VzcGVuc2UucGVuZGluZ0JyYW5jaCA9IG5ld0JyYW5jaDtcbiAgICBpZiAoaXNTYW1lVk5vZGVUeXBlKG5ld0JyYW5jaCwgcGVuZGluZ0JyYW5jaCkpIHtcbiAgICAgIHBhdGNoKFxuICAgICAgICBwZW5kaW5nQnJhbmNoLFxuICAgICAgICBuZXdCcmFuY2gsXG4gICAgICAgIHN1c3BlbnNlLmhpZGRlbkNvbnRhaW5lcixcbiAgICAgICAgbnVsbCxcbiAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICBzdXNwZW5zZSxcbiAgICAgICAgaXNTVkcsXG4gICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgb3B0aW1pemVkXG4gICAgICApO1xuICAgICAgaWYgKHN1c3BlbnNlLmRlcHMgPD0gMCkge1xuICAgICAgICBzdXNwZW5zZS5yZXNvbHZlKCk7XG4gICAgICB9IGVsc2UgaWYgKGlzSW5GYWxsYmFjaykge1xuICAgICAgICBwYXRjaChcbiAgICAgICAgICBhY3RpdmVCcmFuY2gsXG4gICAgICAgICAgbmV3RmFsbGJhY2ssXG4gICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgIGFuY2hvcixcbiAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgbnVsbCxcbiAgICAgICAgICAvLyBmYWxsYmFjayB0cmVlIHdpbGwgbm90IGhhdmUgc3VzcGVuc2UgY29udGV4dFxuICAgICAgICAgIGlzU1ZHLFxuICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICAgKTtcbiAgICAgICAgc2V0QWN0aXZlQnJhbmNoKHN1c3BlbnNlLCBuZXdGYWxsYmFjayk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN1c3BlbnNlLnBlbmRpbmdJZCsrO1xuICAgICAgaWYgKGlzSHlkcmF0aW5nKSB7XG4gICAgICAgIHN1c3BlbnNlLmlzSHlkcmF0aW5nID0gZmFsc2U7XG4gICAgICAgIHN1c3BlbnNlLmFjdGl2ZUJyYW5jaCA9IHBlbmRpbmdCcmFuY2g7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB1bm1vdW50KHBlbmRpbmdCcmFuY2gsIHBhcmVudENvbXBvbmVudCwgc3VzcGVuc2UpO1xuICAgICAgfVxuICAgICAgc3VzcGVuc2UuZGVwcyA9IDA7XG4gICAgICBzdXNwZW5zZS5lZmZlY3RzLmxlbmd0aCA9IDA7XG4gICAgICBzdXNwZW5zZS5oaWRkZW5Db250YWluZXIgPSBjcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgaWYgKGlzSW5GYWxsYmFjaykge1xuICAgICAgICBwYXRjaChcbiAgICAgICAgICBudWxsLFxuICAgICAgICAgIG5ld0JyYW5jaCxcbiAgICAgICAgICBzdXNwZW5zZS5oaWRkZW5Db250YWluZXIsXG4gICAgICAgICAgbnVsbCxcbiAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgc3VzcGVuc2UsXG4gICAgICAgICAgaXNTVkcsXG4gICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgIG9wdGltaXplZFxuICAgICAgICApO1xuICAgICAgICBpZiAoc3VzcGVuc2UuZGVwcyA8PSAwKSB7XG4gICAgICAgICAgc3VzcGVuc2UucmVzb2x2ZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhdGNoKFxuICAgICAgICAgICAgYWN0aXZlQnJhbmNoLFxuICAgICAgICAgICAgbmV3RmFsbGJhY2ssXG4gICAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgICBhbmNob3IsXG4gICAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgLy8gZmFsbGJhY2sgdHJlZSB3aWxsIG5vdCBoYXZlIHN1c3BlbnNlIGNvbnRleHRcbiAgICAgICAgICAgIGlzU1ZHLFxuICAgICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgICAgb3B0aW1pemVkXG4gICAgICAgICAgKTtcbiAgICAgICAgICBzZXRBY3RpdmVCcmFuY2goc3VzcGVuc2UsIG5ld0ZhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChhY3RpdmVCcmFuY2ggJiYgaXNTYW1lVk5vZGVUeXBlKG5ld0JyYW5jaCwgYWN0aXZlQnJhbmNoKSkge1xuICAgICAgICBwYXRjaChcbiAgICAgICAgICBhY3RpdmVCcmFuY2gsXG4gICAgICAgICAgbmV3QnJhbmNoLFxuICAgICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgICBhbmNob3IsXG4gICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgIHN1c3BlbnNlLFxuICAgICAgICAgIGlzU1ZHLFxuICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICAgKTtcbiAgICAgICAgc3VzcGVuc2UucmVzb2x2ZSh0cnVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhdGNoKFxuICAgICAgICAgIG51bGwsXG4gICAgICAgICAgbmV3QnJhbmNoLFxuICAgICAgICAgIHN1c3BlbnNlLmhpZGRlbkNvbnRhaW5lcixcbiAgICAgICAgICBudWxsLFxuICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICBzdXNwZW5zZSxcbiAgICAgICAgICBpc1NWRyxcbiAgICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgICAgb3B0aW1pemVkXG4gICAgICAgICk7XG4gICAgICAgIGlmIChzdXNwZW5zZS5kZXBzIDw9IDApIHtcbiAgICAgICAgICBzdXNwZW5zZS5yZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGFjdGl2ZUJyYW5jaCAmJiBpc1NhbWVWTm9kZVR5cGUobmV3QnJhbmNoLCBhY3RpdmVCcmFuY2gpKSB7XG4gICAgICBwYXRjaChcbiAgICAgICAgYWN0aXZlQnJhbmNoLFxuICAgICAgICBuZXdCcmFuY2gsXG4gICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgYW5jaG9yLFxuICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgIHN1c3BlbnNlLFxuICAgICAgICBpc1NWRyxcbiAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICk7XG4gICAgICBzZXRBY3RpdmVCcmFuY2goc3VzcGVuc2UsIG5ld0JyYW5jaCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyaWdnZXJFdmVudChuMiwgXCJvblBlbmRpbmdcIik7XG4gICAgICBzdXNwZW5zZS5wZW5kaW5nQnJhbmNoID0gbmV3QnJhbmNoO1xuICAgICAgc3VzcGVuc2UucGVuZGluZ0lkKys7XG4gICAgICBwYXRjaChcbiAgICAgICAgbnVsbCxcbiAgICAgICAgbmV3QnJhbmNoLFxuICAgICAgICBzdXNwZW5zZS5oaWRkZW5Db250YWluZXIsXG4gICAgICAgIG51bGwsXG4gICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgc3VzcGVuc2UsXG4gICAgICAgIGlzU1ZHLFxuICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgIG9wdGltaXplZFxuICAgICAgKTtcbiAgICAgIGlmIChzdXNwZW5zZS5kZXBzIDw9IDApIHtcbiAgICAgICAgc3VzcGVuc2UucmVzb2x2ZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgeyB0aW1lb3V0LCBwZW5kaW5nSWQgfSA9IHN1c3BlbnNlO1xuICAgICAgICBpZiAodGltZW91dCA+IDApIHtcbiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGlmIChzdXNwZW5zZS5wZW5kaW5nSWQgPT09IHBlbmRpbmdJZCkge1xuICAgICAgICAgICAgICBzdXNwZW5zZS5mYWxsYmFjayhuZXdGYWxsYmFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgdGltZW91dCk7XG4gICAgICAgIH0gZWxzZSBpZiAodGltZW91dCA9PT0gMCkge1xuICAgICAgICAgIHN1c3BlbnNlLmZhbGxiYWNrKG5ld0ZhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxubGV0IGhhc1dhcm5lZCA9IGZhbHNlO1xuZnVuY3Rpb24gY3JlYXRlU3VzcGVuc2VCb3VuZGFyeSh2bm9kZSwgcGFyZW50U3VzcGVuc2UsIHBhcmVudENvbXBvbmVudCwgY29udGFpbmVyLCBoaWRkZW5Db250YWluZXIsIGFuY2hvciwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkLCByZW5kZXJlckludGVybmFscywgaXNIeWRyYXRpbmcgPSBmYWxzZSkge1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiB0cnVlICYmICFoYXNXYXJuZWQpIHtcbiAgICBoYXNXYXJuZWQgPSB0cnVlO1xuICAgIGNvbnNvbGVbY29uc29sZS5pbmZvID8gXCJpbmZvXCIgOiBcImxvZ1wiXShcbiAgICAgIGA8U3VzcGVuc2U+IGlzIGFuIGV4cGVyaW1lbnRhbCBmZWF0dXJlIGFuZCBpdHMgQVBJIHdpbGwgbGlrZWx5IGNoYW5nZS5gXG4gICAgKTtcbiAgfVxuICBjb25zdCB7XG4gICAgcDogcGF0Y2gsXG4gICAgbTogbW92ZSxcbiAgICB1bTogdW5tb3VudCxcbiAgICBuOiBuZXh0LFxuICAgIG86IHsgcGFyZW50Tm9kZSwgcmVtb3ZlIH1cbiAgfSA9IHJlbmRlcmVySW50ZXJuYWxzO1xuICBsZXQgcGFyZW50U3VzcGVuc2VJZDtcbiAgY29uc3QgaXNTdXNwZW5zaWJsZSA9IGlzVk5vZGVTdXNwZW5zaWJsZSh2bm9kZSk7XG4gIGlmIChpc1N1c3BlbnNpYmxlKSB7XG4gICAgaWYgKHBhcmVudFN1c3BlbnNlID09IG51bGwgPyB2b2lkIDAgOiBwYXJlbnRTdXNwZW5zZS5wZW5kaW5nQnJhbmNoKSB7XG4gICAgICBwYXJlbnRTdXNwZW5zZUlkID0gcGFyZW50U3VzcGVuc2UucGVuZGluZ0lkO1xuICAgICAgcGFyZW50U3VzcGVuc2UuZGVwcysrO1xuICAgIH1cbiAgfVxuICBjb25zdCB0aW1lb3V0ID0gdm5vZGUucHJvcHMgPyB0b051bWJlcih2bm9kZS5wcm9wcy50aW1lb3V0KSA6IHZvaWQgMDtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICBhc3NlcnROdW1iZXIodGltZW91dCwgYFN1c3BlbnNlIHRpbWVvdXRgKTtcbiAgfVxuICBjb25zdCBzdXNwZW5zZSA9IHtcbiAgICB2bm9kZSxcbiAgICBwYXJlbnQ6IHBhcmVudFN1c3BlbnNlLFxuICAgIHBhcmVudENvbXBvbmVudCxcbiAgICBpc1NWRyxcbiAgICBjb250YWluZXIsXG4gICAgaGlkZGVuQ29udGFpbmVyLFxuICAgIGFuY2hvcixcbiAgICBkZXBzOiAwLFxuICAgIHBlbmRpbmdJZDogMCxcbiAgICB0aW1lb3V0OiB0eXBlb2YgdGltZW91dCA9PT0gXCJudW1iZXJcIiA/IHRpbWVvdXQgOiAtMSxcbiAgICBhY3RpdmVCcmFuY2g6IG51bGwsXG4gICAgcGVuZGluZ0JyYW5jaDogbnVsbCxcbiAgICBpc0luRmFsbGJhY2s6IHRydWUsXG4gICAgaXNIeWRyYXRpbmcsXG4gICAgaXNVbm1vdW50ZWQ6IGZhbHNlLFxuICAgIGVmZmVjdHM6IFtdLFxuICAgIHJlc29sdmUocmVzdW1lID0gZmFsc2UsIHN5bmMgPSBmYWxzZSkge1xuICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgaWYgKCFyZXN1bWUgJiYgIXN1c3BlbnNlLnBlbmRpbmdCcmFuY2gpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgc3VzcGVuc2UucmVzb2x2ZSgpIGlzIGNhbGxlZCB3aXRob3V0IGEgcGVuZGluZyBicmFuY2guYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN1c3BlbnNlLmlzVW5tb3VudGVkKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYHN1c3BlbnNlLnJlc29sdmUoKSBpcyBjYWxsZWQgb24gYW4gYWxyZWFkeSB1bm1vdW50ZWQgc3VzcGVuc2UgYm91bmRhcnkuYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IHtcbiAgICAgICAgdm5vZGU6IHZub2RlMixcbiAgICAgICAgYWN0aXZlQnJhbmNoLFxuICAgICAgICBwZW5kaW5nQnJhbmNoLFxuICAgICAgICBwZW5kaW5nSWQsXG4gICAgICAgIGVmZmVjdHMsXG4gICAgICAgIHBhcmVudENvbXBvbmVudDogcGFyZW50Q29tcG9uZW50MixcbiAgICAgICAgY29udGFpbmVyOiBjb250YWluZXIyXG4gICAgICB9ID0gc3VzcGVuc2U7XG4gICAgICBpZiAoc3VzcGVuc2UuaXNIeWRyYXRpbmcpIHtcbiAgICAgICAgc3VzcGVuc2UuaXNIeWRyYXRpbmcgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSBpZiAoIXJlc3VtZSkge1xuICAgICAgICBjb25zdCBkZWxheUVudGVyID0gYWN0aXZlQnJhbmNoICYmIHBlbmRpbmdCcmFuY2gudHJhbnNpdGlvbiAmJiBwZW5kaW5nQnJhbmNoLnRyYW5zaXRpb24ubW9kZSA9PT0gXCJvdXQtaW5cIjtcbiAgICAgICAgaWYgKGRlbGF5RW50ZXIpIHtcbiAgICAgICAgICBhY3RpdmVCcmFuY2gudHJhbnNpdGlvbi5hZnRlckxlYXZlID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHBlbmRpbmdJZCA9PT0gc3VzcGVuc2UucGVuZGluZ0lkKSB7XG4gICAgICAgICAgICAgIG1vdmUocGVuZGluZ0JyYW5jaCwgY29udGFpbmVyMiwgYW5jaG9yMiwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgeyBhbmNob3I6IGFuY2hvcjIgfSA9IHN1c3BlbnNlO1xuICAgICAgICBpZiAoYWN0aXZlQnJhbmNoKSB7XG4gICAgICAgICAgYW5jaG9yMiA9IG5leHQoYWN0aXZlQnJhbmNoKTtcbiAgICAgICAgICB1bm1vdW50KGFjdGl2ZUJyYW5jaCwgcGFyZW50Q29tcG9uZW50Miwgc3VzcGVuc2UsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZGVsYXlFbnRlcikge1xuICAgICAgICAgIG1vdmUocGVuZGluZ0JyYW5jaCwgY29udGFpbmVyMiwgYW5jaG9yMiwgMCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHNldEFjdGl2ZUJyYW5jaChzdXNwZW5zZSwgcGVuZGluZ0JyYW5jaCk7XG4gICAgICBzdXNwZW5zZS5wZW5kaW5nQnJhbmNoID0gbnVsbDtcbiAgICAgIHN1c3BlbnNlLmlzSW5GYWxsYmFjayA9IGZhbHNlO1xuICAgICAgbGV0IHBhcmVudCA9IHN1c3BlbnNlLnBhcmVudDtcbiAgICAgIGxldCBoYXNVbnJlc29sdmVkQW5jZXN0b3IgPSBmYWxzZTtcbiAgICAgIHdoaWxlIChwYXJlbnQpIHtcbiAgICAgICAgaWYgKHBhcmVudC5wZW5kaW5nQnJhbmNoKSB7XG4gICAgICAgICAgcGFyZW50LmVmZmVjdHMucHVzaCguLi5lZmZlY3RzKTtcbiAgICAgICAgICBoYXNVbnJlc29sdmVkQW5jZXN0b3IgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XG4gICAgICB9XG4gICAgICBpZiAoIWhhc1VucmVzb2x2ZWRBbmNlc3Rvcikge1xuICAgICAgICBxdWV1ZVBvc3RGbHVzaENiKGVmZmVjdHMpO1xuICAgICAgfVxuICAgICAgc3VzcGVuc2UuZWZmZWN0cyA9IFtdO1xuICAgICAgaWYgKGlzU3VzcGVuc2libGUpIHtcbiAgICAgICAgaWYgKHBhcmVudFN1c3BlbnNlICYmIHBhcmVudFN1c3BlbnNlLnBlbmRpbmdCcmFuY2ggJiYgcGFyZW50U3VzcGVuc2VJZCA9PT0gcGFyZW50U3VzcGVuc2UucGVuZGluZ0lkKSB7XG4gICAgICAgICAgcGFyZW50U3VzcGVuc2UuZGVwcy0tO1xuICAgICAgICAgIGlmIChwYXJlbnRTdXNwZW5zZS5kZXBzID09PSAwICYmICFzeW5jKSB7XG4gICAgICAgICAgICBwYXJlbnRTdXNwZW5zZS5yZXNvbHZlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0cmlnZ2VyRXZlbnQodm5vZGUyLCBcIm9uUmVzb2x2ZVwiKTtcbiAgICB9LFxuICAgIGZhbGxiYWNrKGZhbGxiYWNrVk5vZGUpIHtcbiAgICAgIGlmICghc3VzcGVuc2UucGVuZGluZ0JyYW5jaCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCB7IHZub2RlOiB2bm9kZTIsIGFjdGl2ZUJyYW5jaCwgcGFyZW50Q29tcG9uZW50OiBwYXJlbnRDb21wb25lbnQyLCBjb250YWluZXI6IGNvbnRhaW5lcjIsIGlzU1ZHOiBpc1NWRzIgfSA9IHN1c3BlbnNlO1xuICAgICAgdHJpZ2dlckV2ZW50KHZub2RlMiwgXCJvbkZhbGxiYWNrXCIpO1xuICAgICAgY29uc3QgYW5jaG9yMiA9IG5leHQoYWN0aXZlQnJhbmNoKTtcbiAgICAgIGNvbnN0IG1vdW50RmFsbGJhY2sgPSAoKSA9PiB7XG4gICAgICAgIGlmICghc3VzcGVuc2UuaXNJbkZhbGxiYWNrKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHBhdGNoKFxuICAgICAgICAgIG51bGwsXG4gICAgICAgICAgZmFsbGJhY2tWTm9kZSxcbiAgICAgICAgICBjb250YWluZXIyLFxuICAgICAgICAgIGFuY2hvcjIsXG4gICAgICAgICAgcGFyZW50Q29tcG9uZW50MixcbiAgICAgICAgICBudWxsLFxuICAgICAgICAgIC8vIGZhbGxiYWNrIHRyZWUgd2lsbCBub3QgaGF2ZSBzdXNwZW5zZSBjb250ZXh0XG4gICAgICAgICAgaXNTVkcyLFxuICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICAgKTtcbiAgICAgICAgc2V0QWN0aXZlQnJhbmNoKHN1c3BlbnNlLCBmYWxsYmFja1ZOb2RlKTtcbiAgICAgIH07XG4gICAgICBjb25zdCBkZWxheUVudGVyID0gZmFsbGJhY2tWTm9kZS50cmFuc2l0aW9uICYmIGZhbGxiYWNrVk5vZGUudHJhbnNpdGlvbi5tb2RlID09PSBcIm91dC1pblwiO1xuICAgICAgaWYgKGRlbGF5RW50ZXIpIHtcbiAgICAgICAgYWN0aXZlQnJhbmNoLnRyYW5zaXRpb24uYWZ0ZXJMZWF2ZSA9IG1vdW50RmFsbGJhY2s7XG4gICAgICB9XG4gICAgICBzdXNwZW5zZS5pc0luRmFsbGJhY2sgPSB0cnVlO1xuICAgICAgdW5tb3VudChcbiAgICAgICAgYWN0aXZlQnJhbmNoLFxuICAgICAgICBwYXJlbnRDb21wb25lbnQyLFxuICAgICAgICBudWxsLFxuICAgICAgICAvLyBubyBzdXNwZW5zZSBzbyB1bm1vdW50IGhvb2tzIGZpcmUgbm93XG4gICAgICAgIHRydWVcbiAgICAgICAgLy8gc2hvdWxkUmVtb3ZlXG4gICAgICApO1xuICAgICAgaWYgKCFkZWxheUVudGVyKSB7XG4gICAgICAgIG1vdW50RmFsbGJhY2soKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIG1vdmUoY29udGFpbmVyMiwgYW5jaG9yMiwgdHlwZSkge1xuICAgICAgc3VzcGVuc2UuYWN0aXZlQnJhbmNoICYmIG1vdmUoc3VzcGVuc2UuYWN0aXZlQnJhbmNoLCBjb250YWluZXIyLCBhbmNob3IyLCB0eXBlKTtcbiAgICAgIHN1c3BlbnNlLmNvbnRhaW5lciA9IGNvbnRhaW5lcjI7XG4gICAgfSxcbiAgICBuZXh0KCkge1xuICAgICAgcmV0dXJuIHN1c3BlbnNlLmFjdGl2ZUJyYW5jaCAmJiBuZXh0KHN1c3BlbnNlLmFjdGl2ZUJyYW5jaCk7XG4gICAgfSxcbiAgICByZWdpc3RlckRlcChpbnN0YW5jZSwgc2V0dXBSZW5kZXJFZmZlY3QpIHtcbiAgICAgIGNvbnN0IGlzSW5QZW5kaW5nU3VzcGVuc2UgPSAhIXN1c3BlbnNlLnBlbmRpbmdCcmFuY2g7XG4gICAgICBpZiAoaXNJblBlbmRpbmdTdXNwZW5zZSkge1xuICAgICAgICBzdXNwZW5zZS5kZXBzKys7XG4gICAgICB9XG4gICAgICBjb25zdCBoeWRyYXRlZEVsID0gaW5zdGFuY2Uudm5vZGUuZWw7XG4gICAgICBpbnN0YW5jZS5hc3luY0RlcC5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgIGhhbmRsZUVycm9yKGVyciwgaW5zdGFuY2UsIDApO1xuICAgICAgfSkudGhlbigoYXN5bmNTZXR1cFJlc3VsdCkgPT4ge1xuICAgICAgICBpZiAoaW5zdGFuY2UuaXNVbm1vdW50ZWQgfHwgc3VzcGVuc2UuaXNVbm1vdW50ZWQgfHwgc3VzcGVuc2UucGVuZGluZ0lkICE9PSBpbnN0YW5jZS5zdXNwZW5zZUlkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGluc3RhbmNlLmFzeW5jUmVzb2x2ZWQgPSB0cnVlO1xuICAgICAgICBjb25zdCB7IHZub2RlOiB2bm9kZTIgfSA9IGluc3RhbmNlO1xuICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgIHB1c2hXYXJuaW5nQ29udGV4dCh2bm9kZTIpO1xuICAgICAgICB9XG4gICAgICAgIGhhbmRsZVNldHVwUmVzdWx0KGluc3RhbmNlLCBhc3luY1NldHVwUmVzdWx0LCBmYWxzZSk7XG4gICAgICAgIGlmIChoeWRyYXRlZEVsKSB7XG4gICAgICAgICAgdm5vZGUyLmVsID0gaHlkcmF0ZWRFbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwbGFjZWhvbGRlciA9ICFoeWRyYXRlZEVsICYmIGluc3RhbmNlLnN1YlRyZWUuZWw7XG4gICAgICAgIHNldHVwUmVuZGVyRWZmZWN0KFxuICAgICAgICAgIGluc3RhbmNlLFxuICAgICAgICAgIHZub2RlMixcbiAgICAgICAgICAvLyBjb21wb25lbnQgbWF5IGhhdmUgYmVlbiBtb3ZlZCBiZWZvcmUgcmVzb2x2ZS5cbiAgICAgICAgICAvLyBpZiB0aGlzIGlzIG5vdCBhIGh5ZHJhdGlvbiwgaW5zdGFuY2Uuc3ViVHJlZSB3aWxsIGJlIHRoZSBjb21tZW50XG4gICAgICAgICAgLy8gcGxhY2Vob2xkZXIuXG4gICAgICAgICAgcGFyZW50Tm9kZShoeWRyYXRlZEVsIHx8IGluc3RhbmNlLnN1YlRyZWUuZWwpLFxuICAgICAgICAgIC8vIGFuY2hvciB3aWxsIG5vdCBiZSB1c2VkIGlmIHRoaXMgaXMgaHlkcmF0aW9uLCBzbyBvbmx5IG5lZWQgdG9cbiAgICAgICAgICAvLyBjb25zaWRlciB0aGUgY29tbWVudCBwbGFjZWhvbGRlciBjYXNlLlxuICAgICAgICAgIGh5ZHJhdGVkRWwgPyBudWxsIDogbmV4dChpbnN0YW5jZS5zdWJUcmVlKSxcbiAgICAgICAgICBzdXNwZW5zZSxcbiAgICAgICAgICBpc1NWRyxcbiAgICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKHBsYWNlaG9sZGVyKSB7XG4gICAgICAgICAgcmVtb3ZlKHBsYWNlaG9sZGVyKTtcbiAgICAgICAgfVxuICAgICAgICB1cGRhdGVIT0NIb3N0RWwoaW5zdGFuY2UsIHZub2RlMi5lbCk7XG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgcG9wV2FybmluZ0NvbnRleHQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNJblBlbmRpbmdTdXNwZW5zZSAmJiAtLXN1c3BlbnNlLmRlcHMgPT09IDApIHtcbiAgICAgICAgICBzdXNwZW5zZS5yZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sXG4gICAgdW5tb3VudChwYXJlbnRTdXNwZW5zZTIsIGRvUmVtb3ZlKSB7XG4gICAgICBzdXNwZW5zZS5pc1VubW91bnRlZCA9IHRydWU7XG4gICAgICBpZiAoc3VzcGVuc2UuYWN0aXZlQnJhbmNoKSB7XG4gICAgICAgIHVubW91bnQoXG4gICAgICAgICAgc3VzcGVuc2UuYWN0aXZlQnJhbmNoLFxuICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICBwYXJlbnRTdXNwZW5zZTIsXG4gICAgICAgICAgZG9SZW1vdmVcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdXNwZW5zZS5wZW5kaW5nQnJhbmNoKSB7XG4gICAgICAgIHVubW91bnQoXG4gICAgICAgICAgc3VzcGVuc2UucGVuZGluZ0JyYW5jaCxcbiAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgcGFyZW50U3VzcGVuc2UyLFxuICAgICAgICAgIGRvUmVtb3ZlXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICByZXR1cm4gc3VzcGVuc2U7XG59XG5mdW5jdGlvbiBoeWRyYXRlU3VzcGVuc2Uobm9kZSwgdm5vZGUsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCwgcmVuZGVyZXJJbnRlcm5hbHMsIGh5ZHJhdGVOb2RlKSB7XG4gIGNvbnN0IHN1c3BlbnNlID0gdm5vZGUuc3VzcGVuc2UgPSBjcmVhdGVTdXNwZW5zZUJvdW5kYXJ5KFxuICAgIHZub2RlLFxuICAgIHBhcmVudFN1c3BlbnNlLFxuICAgIHBhcmVudENvbXBvbmVudCxcbiAgICBub2RlLnBhcmVudE5vZGUsXG4gICAgZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSxcbiAgICBudWxsLFxuICAgIGlzU1ZHLFxuICAgIHNsb3RTY29wZUlkcyxcbiAgICBvcHRpbWl6ZWQsXG4gICAgcmVuZGVyZXJJbnRlcm5hbHMsXG4gICAgdHJ1ZVxuICAgIC8qIGh5ZHJhdGluZyAqL1xuICApO1xuICBjb25zdCByZXN1bHQgPSBoeWRyYXRlTm9kZShcbiAgICBub2RlLFxuICAgIHN1c3BlbnNlLnBlbmRpbmdCcmFuY2ggPSB2bm9kZS5zc0NvbnRlbnQsXG4gICAgcGFyZW50Q29tcG9uZW50LFxuICAgIHN1c3BlbnNlLFxuICAgIHNsb3RTY29wZUlkcyxcbiAgICBvcHRpbWl6ZWRcbiAgKTtcbiAgaWYgKHN1c3BlbnNlLmRlcHMgPT09IDApIHtcbiAgICBzdXNwZW5zZS5yZXNvbHZlKGZhbHNlLCB0cnVlKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gbm9ybWFsaXplU3VzcGVuc2VDaGlsZHJlbih2bm9kZSkge1xuICBjb25zdCB7IHNoYXBlRmxhZywgY2hpbGRyZW4gfSA9IHZub2RlO1xuICBjb25zdCBpc1Nsb3RDaGlsZHJlbiA9IHNoYXBlRmxhZyAmIDMyO1xuICB2bm9kZS5zc0NvbnRlbnQgPSBub3JtYWxpemVTdXNwZW5zZVNsb3QoXG4gICAgaXNTbG90Q2hpbGRyZW4gPyBjaGlsZHJlbi5kZWZhdWx0IDogY2hpbGRyZW5cbiAgKTtcbiAgdm5vZGUuc3NGYWxsYmFjayA9IGlzU2xvdENoaWxkcmVuID8gbm9ybWFsaXplU3VzcGVuc2VTbG90KGNoaWxkcmVuLmZhbGxiYWNrKSA6IGNyZWF0ZVZOb2RlKENvbW1lbnQpO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplU3VzcGVuc2VTbG90KHMpIHtcbiAgbGV0IGJsb2NrO1xuICBpZiAoaXNGdW5jdGlvbihzKSkge1xuICAgIGNvbnN0IHRyYWNrQmxvY2sgPSBpc0Jsb2NrVHJlZUVuYWJsZWQgJiYgcy5fYztcbiAgICBpZiAodHJhY2tCbG9jaykge1xuICAgICAgcy5fZCA9IGZhbHNlO1xuICAgICAgb3BlbkJsb2NrKCk7XG4gICAgfVxuICAgIHMgPSBzKCk7XG4gICAgaWYgKHRyYWNrQmxvY2spIHtcbiAgICAgIHMuX2QgPSB0cnVlO1xuICAgICAgYmxvY2sgPSBjdXJyZW50QmxvY2s7XG4gICAgICBjbG9zZUJsb2NrKCk7XG4gICAgfVxuICB9XG4gIGlmIChpc0FycmF5KHMpKSB7XG4gICAgY29uc3Qgc2luZ2xlQ2hpbGQgPSBmaWx0ZXJTaW5nbGVSb290KHMpO1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICFzaW5nbGVDaGlsZCkge1xuICAgICAgd2FybihgPFN1c3BlbnNlPiBzbG90cyBleHBlY3QgYSBzaW5nbGUgcm9vdCBub2RlLmApO1xuICAgIH1cbiAgICBzID0gc2luZ2xlQ2hpbGQ7XG4gIH1cbiAgcyA9IG5vcm1hbGl6ZVZOb2RlKHMpO1xuICBpZiAoYmxvY2sgJiYgIXMuZHluYW1pY0NoaWxkcmVuKSB7XG4gICAgcy5keW5hbWljQ2hpbGRyZW4gPSBibG9jay5maWx0ZXIoKGMpID0+IGMgIT09IHMpO1xuICB9XG4gIHJldHVybiBzO1xufVxuZnVuY3Rpb24gcXVldWVFZmZlY3RXaXRoU3VzcGVuc2UoZm4sIHN1c3BlbnNlKSB7XG4gIGlmIChzdXNwZW5zZSAmJiBzdXNwZW5zZS5wZW5kaW5nQnJhbmNoKSB7XG4gICAgaWYgKGlzQXJyYXkoZm4pKSB7XG4gICAgICBzdXNwZW5zZS5lZmZlY3RzLnB1c2goLi4uZm4pO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdXNwZW5zZS5lZmZlY3RzLnB1c2goZm4pO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBxdWV1ZVBvc3RGbHVzaENiKGZuKTtcbiAgfVxufVxuZnVuY3Rpb24gc2V0QWN0aXZlQnJhbmNoKHN1c3BlbnNlLCBicmFuY2gpIHtcbiAgc3VzcGVuc2UuYWN0aXZlQnJhbmNoID0gYnJhbmNoO1xuICBjb25zdCB7IHZub2RlLCBwYXJlbnRDb21wb25lbnQgfSA9IHN1c3BlbnNlO1xuICBjb25zdCBlbCA9IHZub2RlLmVsID0gYnJhbmNoLmVsO1xuICBpZiAocGFyZW50Q29tcG9uZW50ICYmIHBhcmVudENvbXBvbmVudC5zdWJUcmVlID09PSB2bm9kZSkge1xuICAgIHBhcmVudENvbXBvbmVudC52bm9kZS5lbCA9IGVsO1xuICAgIHVwZGF0ZUhPQ0hvc3RFbChwYXJlbnRDb21wb25lbnQsIGVsKTtcbiAgfVxufVxuZnVuY3Rpb24gaXNWTm9kZVN1c3BlbnNpYmxlKHZub2RlKSB7XG4gIHZhciBfYTtcbiAgcmV0dXJuICgoX2EgPSB2bm9kZS5wcm9wcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnN1c3BlbnNpYmxlKSAhPSBudWxsICYmIHZub2RlLnByb3BzLnN1c3BlbnNpYmxlICE9PSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gd2F0Y2hFZmZlY3QoZWZmZWN0LCBvcHRpb25zKSB7XG4gIHJldHVybiBkb1dhdGNoKGVmZmVjdCwgbnVsbCwgb3B0aW9ucyk7XG59XG5mdW5jdGlvbiB3YXRjaFBvc3RFZmZlY3QoZWZmZWN0LCBvcHRpb25zKSB7XG4gIHJldHVybiBkb1dhdGNoKFxuICAgIGVmZmVjdCxcbiAgICBudWxsLFxuICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyBleHRlbmQoe30sIG9wdGlvbnMsIHsgZmx1c2g6IFwicG9zdFwiIH0pIDogeyBmbHVzaDogXCJwb3N0XCIgfVxuICApO1xufVxuZnVuY3Rpb24gd2F0Y2hTeW5jRWZmZWN0KGVmZmVjdCwgb3B0aW9ucykge1xuICByZXR1cm4gZG9XYXRjaChcbiAgICBlZmZlY3QsXG4gICAgbnVsbCxcbiAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gZXh0ZW5kKHt9LCBvcHRpb25zLCB7IGZsdXNoOiBcInN5bmNcIiB9KSA6IHsgZmx1c2g6IFwic3luY1wiIH1cbiAgKTtcbn1cbmNvbnN0IElOSVRJQUxfV0FUQ0hFUl9WQUxVRSA9IHt9O1xuZnVuY3Rpb24gd2F0Y2goc291cmNlLCBjYiwgb3B0aW9ucykge1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhaXNGdW5jdGlvbihjYikpIHtcbiAgICB3YXJuKFxuICAgICAgYFxcYHdhdGNoKGZuLCBvcHRpb25zPylcXGAgc2lnbmF0dXJlIGhhcyBiZWVuIG1vdmVkIHRvIGEgc2VwYXJhdGUgQVBJLiBVc2UgXFxgd2F0Y2hFZmZlY3QoZm4sIG9wdGlvbnM/KVxcYCBpbnN0ZWFkLiBcXGB3YXRjaFxcYCBub3cgb25seSBzdXBwb3J0cyBcXGB3YXRjaChzb3VyY2UsIGNiLCBvcHRpb25zPykgc2lnbmF0dXJlLmBcbiAgICApO1xuICB9XG4gIHJldHVybiBkb1dhdGNoKHNvdXJjZSwgY2IsIG9wdGlvbnMpO1xufVxuZnVuY3Rpb24gZG9XYXRjaChzb3VyY2UsIGNiLCB7IGltbWVkaWF0ZSwgZGVlcCwgZmx1c2gsIG9uVHJhY2ssIG9uVHJpZ2dlciB9ID0gRU1QVFlfT0JKKSB7XG4gIHZhciBfYTtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgIWNiKSB7XG4gICAgaWYgKGltbWVkaWF0ZSAhPT0gdm9pZCAwKSB7XG4gICAgICB3YXJuKFxuICAgICAgICBgd2F0Y2goKSBcImltbWVkaWF0ZVwiIG9wdGlvbiBpcyBvbmx5IHJlc3BlY3RlZCB3aGVuIHVzaW5nIHRoZSB3YXRjaChzb3VyY2UsIGNhbGxiYWNrLCBvcHRpb25zPykgc2lnbmF0dXJlLmBcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChkZWVwICE9PSB2b2lkIDApIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIGB3YXRjaCgpIFwiZGVlcFwiIG9wdGlvbiBpcyBvbmx5IHJlc3BlY3RlZCB3aGVuIHVzaW5nIHRoZSB3YXRjaChzb3VyY2UsIGNhbGxiYWNrLCBvcHRpb25zPykgc2lnbmF0dXJlLmBcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIGNvbnN0IHdhcm5JbnZhbGlkU291cmNlID0gKHMpID0+IHtcbiAgICB3YXJuKFxuICAgICAgYEludmFsaWQgd2F0Y2ggc291cmNlOiBgLFxuICAgICAgcyxcbiAgICAgIGBBIHdhdGNoIHNvdXJjZSBjYW4gb25seSBiZSBhIGdldHRlci9lZmZlY3QgZnVuY3Rpb24sIGEgcmVmLCBhIHJlYWN0aXZlIG9iamVjdCwgb3IgYW4gYXJyYXkgb2YgdGhlc2UgdHlwZXMuYFxuICAgICk7XG4gIH07XG4gIGNvbnN0IGluc3RhbmNlID0gZ2V0Q3VycmVudFNjb3BlKCkgPT09ICgoX2EgPSBjdXJyZW50SW5zdGFuY2UpID09IG51bGwgPyB2b2lkIDAgOiBfYS5zY29wZSkgPyBjdXJyZW50SW5zdGFuY2UgOiBudWxsO1xuICBsZXQgZ2V0dGVyO1xuICBsZXQgZm9yY2VUcmlnZ2VyID0gZmFsc2U7XG4gIGxldCBpc011bHRpU291cmNlID0gZmFsc2U7XG4gIGlmIChpc1JlZihzb3VyY2UpKSB7XG4gICAgZ2V0dGVyID0gKCkgPT4gc291cmNlLnZhbHVlO1xuICAgIGZvcmNlVHJpZ2dlciA9IGlzU2hhbGxvdyQxKHNvdXJjZSk7XG4gIH0gZWxzZSBpZiAoaXNSZWFjdGl2ZShzb3VyY2UpKSB7XG4gICAgZ2V0dGVyID0gKCkgPT4gc291cmNlO1xuICAgIGRlZXAgPSB0cnVlO1xuICB9IGVsc2UgaWYgKGlzQXJyYXkoc291cmNlKSkge1xuICAgIGlzTXVsdGlTb3VyY2UgPSB0cnVlO1xuICAgIGZvcmNlVHJpZ2dlciA9IHNvdXJjZS5zb21lKChzKSA9PiBpc1JlYWN0aXZlKHMpIHx8IGlzU2hhbGxvdyQxKHMpKTtcbiAgICBnZXR0ZXIgPSAoKSA9PiBzb3VyY2UubWFwKChzKSA9PiB7XG4gICAgICBpZiAoaXNSZWYocykpIHtcbiAgICAgICAgcmV0dXJuIHMudmFsdWU7XG4gICAgICB9IGVsc2UgaWYgKGlzUmVhY3RpdmUocykpIHtcbiAgICAgICAgcmV0dXJuIHRyYXZlcnNlKHMpO1xuICAgICAgfSBlbHNlIGlmIChpc0Z1bmN0aW9uKHMpKSB7XG4gICAgICAgIHJldHVybiBjYWxsV2l0aEVycm9ySGFuZGxpbmcocywgaW5zdGFuY2UsIDIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiB3YXJuSW52YWxpZFNvdXJjZShzKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSBlbHNlIGlmIChpc0Z1bmN0aW9uKHNvdXJjZSkpIHtcbiAgICBpZiAoY2IpIHtcbiAgICAgIGdldHRlciA9ICgpID0+IGNhbGxXaXRoRXJyb3JIYW5kbGluZyhzb3VyY2UsIGluc3RhbmNlLCAyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZ2V0dGVyID0gKCkgPT4ge1xuICAgICAgICBpZiAoaW5zdGFuY2UgJiYgaW5zdGFuY2UuaXNVbm1vdW50ZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNsZWFudXApIHtcbiAgICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNhbGxXaXRoQXN5bmNFcnJvckhhbmRsaW5nKFxuICAgICAgICAgIHNvdXJjZSxcbiAgICAgICAgICBpbnN0YW5jZSxcbiAgICAgICAgICAzLFxuICAgICAgICAgIFtvbkNsZWFudXBdXG4gICAgICAgICk7XG4gICAgICB9O1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBnZXR0ZXIgPSBOT09QO1xuICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgd2FybkludmFsaWRTb3VyY2Uoc291cmNlKTtcbiAgfVxuICBpZiAoY2IgJiYgZGVlcCkge1xuICAgIGNvbnN0IGJhc2VHZXR0ZXIgPSBnZXR0ZXI7XG4gICAgZ2V0dGVyID0gKCkgPT4gdHJhdmVyc2UoYmFzZUdldHRlcigpKTtcbiAgfVxuICBsZXQgY2xlYW51cDtcbiAgbGV0IG9uQ2xlYW51cCA9IChmbikgPT4ge1xuICAgIGNsZWFudXAgPSBlZmZlY3Qub25TdG9wID0gKCkgPT4ge1xuICAgICAgY2FsbFdpdGhFcnJvckhhbmRsaW5nKGZuLCBpbnN0YW5jZSwgNCk7XG4gICAgfTtcbiAgfTtcbiAgbGV0IHNzckNsZWFudXA7XG4gIGlmIChpc0luU1NSQ29tcG9uZW50U2V0dXApIHtcbiAgICBvbkNsZWFudXAgPSBOT09QO1xuICAgIGlmICghY2IpIHtcbiAgICAgIGdldHRlcigpO1xuICAgIH0gZWxzZSBpZiAoaW1tZWRpYXRlKSB7XG4gICAgICBjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZyhjYiwgaW5zdGFuY2UsIDMsIFtcbiAgICAgICAgZ2V0dGVyKCksXG4gICAgICAgIGlzTXVsdGlTb3VyY2UgPyBbXSA6IHZvaWQgMCxcbiAgICAgICAgb25DbGVhbnVwXG4gICAgICBdKTtcbiAgICB9XG4gICAgaWYgKGZsdXNoID09PSBcInN5bmNcIikge1xuICAgICAgY29uc3QgY3R4ID0gdXNlU1NSQ29udGV4dCgpO1xuICAgICAgc3NyQ2xlYW51cCA9IGN0eC5fX3dhdGNoZXJIYW5kbGVzIHx8IChjdHguX193YXRjaGVySGFuZGxlcyA9IFtdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIE5PT1A7XG4gICAgfVxuICB9XG4gIGxldCBvbGRWYWx1ZSA9IGlzTXVsdGlTb3VyY2UgPyBuZXcgQXJyYXkoc291cmNlLmxlbmd0aCkuZmlsbChJTklUSUFMX1dBVENIRVJfVkFMVUUpIDogSU5JVElBTF9XQVRDSEVSX1ZBTFVFO1xuICBjb25zdCBqb2IgPSAoKSA9PiB7XG4gICAgaWYgKCFlZmZlY3QuYWN0aXZlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChjYikge1xuICAgICAgY29uc3QgbmV3VmFsdWUgPSBlZmZlY3QucnVuKCk7XG4gICAgICBpZiAoZGVlcCB8fCBmb3JjZVRyaWdnZXIgfHwgKGlzTXVsdGlTb3VyY2UgPyBuZXdWYWx1ZS5zb21lKFxuICAgICAgICAodiwgaSkgPT4gaGFzQ2hhbmdlZCh2LCBvbGRWYWx1ZVtpXSlcbiAgICAgICkgOiBoYXNDaGFuZ2VkKG5ld1ZhbHVlLCBvbGRWYWx1ZSkpIHx8IGZhbHNlKSB7XG4gICAgICAgIGlmIChjbGVhbnVwKSB7XG4gICAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICB9XG4gICAgICAgIGNhbGxXaXRoQXN5bmNFcnJvckhhbmRsaW5nKGNiLCBpbnN0YW5jZSwgMywgW1xuICAgICAgICAgIG5ld1ZhbHVlLFxuICAgICAgICAgIC8vIHBhc3MgdW5kZWZpbmVkIGFzIHRoZSBvbGQgdmFsdWUgd2hlbiBpdCdzIGNoYW5nZWQgZm9yIHRoZSBmaXJzdCB0aW1lXG4gICAgICAgICAgb2xkVmFsdWUgPT09IElOSVRJQUxfV0FUQ0hFUl9WQUxVRSA/IHZvaWQgMCA6IGlzTXVsdGlTb3VyY2UgJiYgb2xkVmFsdWVbMF0gPT09IElOSVRJQUxfV0FUQ0hFUl9WQUxVRSA/IFtdIDogb2xkVmFsdWUsXG4gICAgICAgICAgb25DbGVhbnVwXG4gICAgICAgIF0pO1xuICAgICAgICBvbGRWYWx1ZSA9IG5ld1ZhbHVlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBlZmZlY3QucnVuKCk7XG4gICAgfVxuICB9O1xuICBqb2IuYWxsb3dSZWN1cnNlID0gISFjYjtcbiAgbGV0IHNjaGVkdWxlcjtcbiAgaWYgKGZsdXNoID09PSBcInN5bmNcIikge1xuICAgIHNjaGVkdWxlciA9IGpvYjtcbiAgfSBlbHNlIGlmIChmbHVzaCA9PT0gXCJwb3N0XCIpIHtcbiAgICBzY2hlZHVsZXIgPSAoKSA9PiBxdWV1ZVBvc3RSZW5kZXJFZmZlY3Qoam9iLCBpbnN0YW5jZSAmJiBpbnN0YW5jZS5zdXNwZW5zZSk7XG4gIH0gZWxzZSB7XG4gICAgam9iLnByZSA9IHRydWU7XG4gICAgaWYgKGluc3RhbmNlKVxuICAgICAgam9iLmlkID0gaW5zdGFuY2UudWlkO1xuICAgIHNjaGVkdWxlciA9ICgpID0+IHF1ZXVlSm9iKGpvYik7XG4gIH1cbiAgY29uc3QgZWZmZWN0ID0gbmV3IFJlYWN0aXZlRWZmZWN0KGdldHRlciwgc2NoZWR1bGVyKTtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICBlZmZlY3Qub25UcmFjayA9IG9uVHJhY2s7XG4gICAgZWZmZWN0Lm9uVHJpZ2dlciA9IG9uVHJpZ2dlcjtcbiAgfVxuICBpZiAoY2IpIHtcbiAgICBpZiAoaW1tZWRpYXRlKSB7XG4gICAgICBqb2IoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb2xkVmFsdWUgPSBlZmZlY3QucnVuKCk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGZsdXNoID09PSBcInBvc3RcIikge1xuICAgIHF1ZXVlUG9zdFJlbmRlckVmZmVjdChcbiAgICAgIGVmZmVjdC5ydW4uYmluZChlZmZlY3QpLFxuICAgICAgaW5zdGFuY2UgJiYgaW5zdGFuY2Uuc3VzcGVuc2VcbiAgICApO1xuICB9IGVsc2Uge1xuICAgIGVmZmVjdC5ydW4oKTtcbiAgfVxuICBjb25zdCB1bndhdGNoID0gKCkgPT4ge1xuICAgIGVmZmVjdC5zdG9wKCk7XG4gICAgaWYgKGluc3RhbmNlICYmIGluc3RhbmNlLnNjb3BlKSB7XG4gICAgICByZW1vdmUoaW5zdGFuY2Uuc2NvcGUuZWZmZWN0cywgZWZmZWN0KTtcbiAgICB9XG4gIH07XG4gIGlmIChzc3JDbGVhbnVwKVxuICAgIHNzckNsZWFudXAucHVzaCh1bndhdGNoKTtcbiAgcmV0dXJuIHVud2F0Y2g7XG59XG5mdW5jdGlvbiBpbnN0YW5jZVdhdGNoKHNvdXJjZSwgdmFsdWUsIG9wdGlvbnMpIHtcbiAgY29uc3QgcHVibGljVGhpcyA9IHRoaXMucHJveHk7XG4gIGNvbnN0IGdldHRlciA9IGlzU3RyaW5nKHNvdXJjZSkgPyBzb3VyY2UuaW5jbHVkZXMoXCIuXCIpID8gY3JlYXRlUGF0aEdldHRlcihwdWJsaWNUaGlzLCBzb3VyY2UpIDogKCkgPT4gcHVibGljVGhpc1tzb3VyY2VdIDogc291cmNlLmJpbmQocHVibGljVGhpcywgcHVibGljVGhpcyk7XG4gIGxldCBjYjtcbiAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgY2IgPSB2YWx1ZTtcbiAgfSBlbHNlIHtcbiAgICBjYiA9IHZhbHVlLmhhbmRsZXI7XG4gICAgb3B0aW9ucyA9IHZhbHVlO1xuICB9XG4gIGNvbnN0IGN1ciA9IGN1cnJlbnRJbnN0YW5jZTtcbiAgc2V0Q3VycmVudEluc3RhbmNlKHRoaXMpO1xuICBjb25zdCByZXMgPSBkb1dhdGNoKGdldHRlciwgY2IuYmluZChwdWJsaWNUaGlzKSwgb3B0aW9ucyk7XG4gIGlmIChjdXIpIHtcbiAgICBzZXRDdXJyZW50SW5zdGFuY2UoY3VyKTtcbiAgfSBlbHNlIHtcbiAgICB1bnNldEN1cnJlbnRJbnN0YW5jZSgpO1xuICB9XG4gIHJldHVybiByZXM7XG59XG5mdW5jdGlvbiBjcmVhdGVQYXRoR2V0dGVyKGN0eCwgcGF0aCkge1xuICBjb25zdCBzZWdtZW50cyA9IHBhdGguc3BsaXQoXCIuXCIpO1xuICByZXR1cm4gKCkgPT4ge1xuICAgIGxldCBjdXIgPSBjdHg7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWdtZW50cy5sZW5ndGggJiYgY3VyOyBpKyspIHtcbiAgICAgIGN1ciA9IGN1cltzZWdtZW50c1tpXV07XG4gICAgfVxuICAgIHJldHVybiBjdXI7XG4gIH07XG59XG5mdW5jdGlvbiB0cmF2ZXJzZSh2YWx1ZSwgc2Vlbikge1xuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSB8fCB2YWx1ZVtcIl9fdl9za2lwXCJdKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHNlZW4gPSBzZWVuIHx8IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIGlmIChzZWVuLmhhcyh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgc2Vlbi5hZGQodmFsdWUpO1xuICBpZiAoaXNSZWYodmFsdWUpKSB7XG4gICAgdHJhdmVyc2UodmFsdWUudmFsdWUsIHNlZW4pO1xuICB9IGVsc2UgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgdHJhdmVyc2UodmFsdWVbaV0sIHNlZW4pO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc1NldCh2YWx1ZSkgfHwgaXNNYXAodmFsdWUpKSB7XG4gICAgdmFsdWUuZm9yRWFjaCgodikgPT4ge1xuICAgICAgdHJhdmVyc2Uodiwgc2Vlbik7XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAoaXNQbGFpbk9iamVjdCh2YWx1ZSkpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiB2YWx1ZSkge1xuICAgICAgdHJhdmVyc2UodmFsdWVba2V5XSwgc2Vlbik7XG4gICAgfVxuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVEaXJlY3RpdmVOYW1lKG5hbWUpIHtcbiAgaWYgKGlzQnVpbHRJbkRpcmVjdGl2ZShuYW1lKSkge1xuICAgIHdhcm4oXCJEbyBub3QgdXNlIGJ1aWx0LWluIGRpcmVjdGl2ZSBpZHMgYXMgY3VzdG9tIGRpcmVjdGl2ZSBpZDogXCIgKyBuYW1lKTtcbiAgfVxufVxuZnVuY3Rpb24gd2l0aERpcmVjdGl2ZXModm5vZGUsIGRpcmVjdGl2ZXMpIHtcbiAgY29uc3QgaW50ZXJuYWxJbnN0YW5jZSA9IGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZTtcbiAgaWYgKGludGVybmFsSW5zdGFuY2UgPT09IG51bGwpIHtcbiAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHdhcm4oYHdpdGhEaXJlY3RpdmVzIGNhbiBvbmx5IGJlIHVzZWQgaW5zaWRlIHJlbmRlciBmdW5jdGlvbnMuYCk7XG4gICAgcmV0dXJuIHZub2RlO1xuICB9XG4gIGNvbnN0IGluc3RhbmNlID0gZ2V0RXhwb3NlUHJveHkoaW50ZXJuYWxJbnN0YW5jZSkgfHwgaW50ZXJuYWxJbnN0YW5jZS5wcm94eTtcbiAgY29uc3QgYmluZGluZ3MgPSB2bm9kZS5kaXJzIHx8ICh2bm9kZS5kaXJzID0gW10pO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGRpcmVjdGl2ZXMubGVuZ3RoOyBpKyspIHtcbiAgICBsZXQgW2RpciwgdmFsdWUsIGFyZywgbW9kaWZpZXJzID0gRU1QVFlfT0JKXSA9IGRpcmVjdGl2ZXNbaV07XG4gICAgaWYgKGRpcikge1xuICAgICAgaWYgKGlzRnVuY3Rpb24oZGlyKSkge1xuICAgICAgICBkaXIgPSB7XG4gICAgICAgICAgbW91bnRlZDogZGlyLFxuICAgICAgICAgIHVwZGF0ZWQ6IGRpclxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgaWYgKGRpci5kZWVwKSB7XG4gICAgICAgIHRyYXZlcnNlKHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGJpbmRpbmdzLnB1c2goe1xuICAgICAgICBkaXIsXG4gICAgICAgIGluc3RhbmNlLFxuICAgICAgICB2YWx1ZSxcbiAgICAgICAgb2xkVmFsdWU6IHZvaWQgMCxcbiAgICAgICAgYXJnLFxuICAgICAgICBtb2RpZmllcnNcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdm5vZGU7XG59XG5mdW5jdGlvbiBpbnZva2VEaXJlY3RpdmVIb29rKHZub2RlLCBwcmV2Vk5vZGUsIGluc3RhbmNlLCBuYW1lKSB7XG4gIGNvbnN0IGJpbmRpbmdzID0gdm5vZGUuZGlycztcbiAgY29uc3Qgb2xkQmluZGluZ3MgPSBwcmV2Vk5vZGUgJiYgcHJldlZOb2RlLmRpcnM7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYmluZGluZ3MubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBiaW5kaW5nID0gYmluZGluZ3NbaV07XG4gICAgaWYgKG9sZEJpbmRpbmdzKSB7XG4gICAgICBiaW5kaW5nLm9sZFZhbHVlID0gb2xkQmluZGluZ3NbaV0udmFsdWU7XG4gICAgfVxuICAgIGxldCBob29rID0gYmluZGluZy5kaXJbbmFtZV07XG4gICAgaWYgKGhvb2spIHtcbiAgICAgIHBhdXNlVHJhY2tpbmcoKTtcbiAgICAgIGNhbGxXaXRoQXN5bmNFcnJvckhhbmRsaW5nKGhvb2ssIGluc3RhbmNlLCA4LCBbXG4gICAgICAgIHZub2RlLmVsLFxuICAgICAgICBiaW5kaW5nLFxuICAgICAgICB2bm9kZSxcbiAgICAgICAgcHJldlZOb2RlXG4gICAgICBdKTtcbiAgICAgIHJlc2V0VHJhY2tpbmcoKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdXNlVHJhbnNpdGlvblN0YXRlKCkge1xuICBjb25zdCBzdGF0ZSA9IHtcbiAgICBpc01vdW50ZWQ6IGZhbHNlLFxuICAgIGlzTGVhdmluZzogZmFsc2UsXG4gICAgaXNVbm1vdW50aW5nOiBmYWxzZSxcbiAgICBsZWF2aW5nVk5vZGVzOiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpXG4gIH07XG4gIG9uTW91bnRlZCgoKSA9PiB7XG4gICAgc3RhdGUuaXNNb3VudGVkID0gdHJ1ZTtcbiAgfSk7XG4gIG9uQmVmb3JlVW5tb3VudCgoKSA9PiB7XG4gICAgc3RhdGUuaXNVbm1vdW50aW5nID0gdHJ1ZTtcbiAgfSk7XG4gIHJldHVybiBzdGF0ZTtcbn1cbmNvbnN0IFRyYW5zaXRpb25Ib29rVmFsaWRhdG9yID0gW0Z1bmN0aW9uLCBBcnJheV07XG5jb25zdCBCYXNlVHJhbnNpdGlvblByb3BzVmFsaWRhdG9ycyA9IHtcbiAgbW9kZTogU3RyaW5nLFxuICBhcHBlYXI6IEJvb2xlYW4sXG4gIHBlcnNpc3RlZDogQm9vbGVhbixcbiAgLy8gZW50ZXJcbiAgb25CZWZvcmVFbnRlcjogVHJhbnNpdGlvbkhvb2tWYWxpZGF0b3IsXG4gIG9uRW50ZXI6IFRyYW5zaXRpb25Ib29rVmFsaWRhdG9yLFxuICBvbkFmdGVyRW50ZXI6IFRyYW5zaXRpb25Ib29rVmFsaWRhdG9yLFxuICBvbkVudGVyQ2FuY2VsbGVkOiBUcmFuc2l0aW9uSG9va1ZhbGlkYXRvcixcbiAgLy8gbGVhdmVcbiAgb25CZWZvcmVMZWF2ZTogVHJhbnNpdGlvbkhvb2tWYWxpZGF0b3IsXG4gIG9uTGVhdmU6IFRyYW5zaXRpb25Ib29rVmFsaWRhdG9yLFxuICBvbkFmdGVyTGVhdmU6IFRyYW5zaXRpb25Ib29rVmFsaWRhdG9yLFxuICBvbkxlYXZlQ2FuY2VsbGVkOiBUcmFuc2l0aW9uSG9va1ZhbGlkYXRvcixcbiAgLy8gYXBwZWFyXG4gIG9uQmVmb3JlQXBwZWFyOiBUcmFuc2l0aW9uSG9va1ZhbGlkYXRvcixcbiAgb25BcHBlYXI6IFRyYW5zaXRpb25Ib29rVmFsaWRhdG9yLFxuICBvbkFmdGVyQXBwZWFyOiBUcmFuc2l0aW9uSG9va1ZhbGlkYXRvcixcbiAgb25BcHBlYXJDYW5jZWxsZWQ6IFRyYW5zaXRpb25Ib29rVmFsaWRhdG9yXG59O1xuY29uc3QgQmFzZVRyYW5zaXRpb25JbXBsID0ge1xuICBuYW1lOiBgQmFzZVRyYW5zaXRpb25gLFxuICBwcm9wczogQmFzZVRyYW5zaXRpb25Qcm9wc1ZhbGlkYXRvcnMsXG4gIHNldHVwKHByb3BzLCB7IHNsb3RzIH0pIHtcbiAgICBjb25zdCBpbnN0YW5jZSA9IGdldEN1cnJlbnRJbnN0YW5jZSgpO1xuICAgIGNvbnN0IHN0YXRlID0gdXNlVHJhbnNpdGlvblN0YXRlKCk7XG4gICAgbGV0IHByZXZUcmFuc2l0aW9uS2V5O1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBjb25zdCBjaGlsZHJlbiA9IHNsb3RzLmRlZmF1bHQgJiYgZ2V0VHJhbnNpdGlvblJhd0NoaWxkcmVuKHNsb3RzLmRlZmF1bHQoKSwgdHJ1ZSk7XG4gICAgICBpZiAoIWNoaWxkcmVuIHx8ICFjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbGV0IGNoaWxkID0gY2hpbGRyZW5bMF07XG4gICAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoID4gMSkge1xuICAgICAgICBsZXQgaGFzRm91bmQgPSBmYWxzZTtcbiAgICAgICAgZm9yIChjb25zdCBjIG9mIGNoaWxkcmVuKSB7XG4gICAgICAgICAgaWYgKGMudHlwZSAhPT0gQ29tbWVudCkge1xuICAgICAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgaGFzRm91bmQpIHtcbiAgICAgICAgICAgICAgd2FybihcbiAgICAgICAgICAgICAgICBcIjx0cmFuc2l0aW9uPiBjYW4gb25seSBiZSB1c2VkIG9uIGEgc2luZ2xlIGVsZW1lbnQgb3IgY29tcG9uZW50LiBVc2UgPHRyYW5zaXRpb24tZ3JvdXA+IGZvciBsaXN0cy5cIlxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNoaWxkID0gYztcbiAgICAgICAgICAgIGhhc0ZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmICghISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSlcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCByYXdQcm9wcyA9IHRvUmF3KHByb3BzKTtcbiAgICAgIGNvbnN0IHsgbW9kZSB9ID0gcmF3UHJvcHM7XG4gICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBtb2RlICYmIG1vZGUgIT09IFwiaW4tb3V0XCIgJiYgbW9kZSAhPT0gXCJvdXQtaW5cIiAmJiBtb2RlICE9PSBcImRlZmF1bHRcIikge1xuICAgICAgICB3YXJuKGBpbnZhbGlkIDx0cmFuc2l0aW9uPiBtb2RlOiAke21vZGV9YCk7XG4gICAgICB9XG4gICAgICBpZiAoc3RhdGUuaXNMZWF2aW5nKSB7XG4gICAgICAgIHJldHVybiBlbXB0eVBsYWNlaG9sZGVyKGNoaWxkKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGlubmVyQ2hpbGQgPSBnZXRLZWVwQWxpdmVDaGlsZChjaGlsZCk7XG4gICAgICBpZiAoIWlubmVyQ2hpbGQpIHtcbiAgICAgICAgcmV0dXJuIGVtcHR5UGxhY2Vob2xkZXIoY2hpbGQpO1xuICAgICAgfVxuICAgICAgY29uc3QgZW50ZXJIb29rcyA9IHJlc29sdmVUcmFuc2l0aW9uSG9va3MoXG4gICAgICAgIGlubmVyQ2hpbGQsXG4gICAgICAgIHJhd1Byb3BzLFxuICAgICAgICBzdGF0ZSxcbiAgICAgICAgaW5zdGFuY2VcbiAgICAgICk7XG4gICAgICBzZXRUcmFuc2l0aW9uSG9va3MoaW5uZXJDaGlsZCwgZW50ZXJIb29rcyk7XG4gICAgICBjb25zdCBvbGRDaGlsZCA9IGluc3RhbmNlLnN1YlRyZWU7XG4gICAgICBjb25zdCBvbGRJbm5lckNoaWxkID0gb2xkQ2hpbGQgJiYgZ2V0S2VlcEFsaXZlQ2hpbGQob2xkQ2hpbGQpO1xuICAgICAgbGV0IHRyYW5zaXRpb25LZXlDaGFuZ2VkID0gZmFsc2U7XG4gICAgICBjb25zdCB7IGdldFRyYW5zaXRpb25LZXkgfSA9IGlubmVyQ2hpbGQudHlwZTtcbiAgICAgIGlmIChnZXRUcmFuc2l0aW9uS2V5KSB7XG4gICAgICAgIGNvbnN0IGtleSA9IGdldFRyYW5zaXRpb25LZXkoKTtcbiAgICAgICAgaWYgKHByZXZUcmFuc2l0aW9uS2V5ID09PSB2b2lkIDApIHtcbiAgICAgICAgICBwcmV2VHJhbnNpdGlvbktleSA9IGtleTtcbiAgICAgICAgfSBlbHNlIGlmIChrZXkgIT09IHByZXZUcmFuc2l0aW9uS2V5KSB7XG4gICAgICAgICAgcHJldlRyYW5zaXRpb25LZXkgPSBrZXk7XG4gICAgICAgICAgdHJhbnNpdGlvbktleUNoYW5nZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAob2xkSW5uZXJDaGlsZCAmJiBvbGRJbm5lckNoaWxkLnR5cGUgIT09IENvbW1lbnQgJiYgKCFpc1NhbWVWTm9kZVR5cGUoaW5uZXJDaGlsZCwgb2xkSW5uZXJDaGlsZCkgfHwgdHJhbnNpdGlvbktleUNoYW5nZWQpKSB7XG4gICAgICAgIGNvbnN0IGxlYXZpbmdIb29rcyA9IHJlc29sdmVUcmFuc2l0aW9uSG9va3MoXG4gICAgICAgICAgb2xkSW5uZXJDaGlsZCxcbiAgICAgICAgICByYXdQcm9wcyxcbiAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICBpbnN0YW5jZVxuICAgICAgICApO1xuICAgICAgICBzZXRUcmFuc2l0aW9uSG9va3Mob2xkSW5uZXJDaGlsZCwgbGVhdmluZ0hvb2tzKTtcbiAgICAgICAgaWYgKG1vZGUgPT09IFwib3V0LWluXCIpIHtcbiAgICAgICAgICBzdGF0ZS5pc0xlYXZpbmcgPSB0cnVlO1xuICAgICAgICAgIGxlYXZpbmdIb29rcy5hZnRlckxlYXZlID0gKCkgPT4ge1xuICAgICAgICAgICAgc3RhdGUuaXNMZWF2aW5nID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoaW5zdGFuY2UudXBkYXRlLmFjdGl2ZSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgaW5zdGFuY2UudXBkYXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgICByZXR1cm4gZW1wdHlQbGFjZWhvbGRlcihjaGlsZCk7XG4gICAgICAgIH0gZWxzZSBpZiAobW9kZSA9PT0gXCJpbi1vdXRcIiAmJiBpbm5lckNoaWxkLnR5cGUgIT09IENvbW1lbnQpIHtcbiAgICAgICAgICBsZWF2aW5nSG9va3MuZGVsYXlMZWF2ZSA9IChlbCwgZWFybHlSZW1vdmUsIGRlbGF5ZWRMZWF2ZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbGVhdmluZ1ZOb2Rlc0NhY2hlID0gZ2V0TGVhdmluZ05vZGVzRm9yVHlwZShcbiAgICAgICAgICAgICAgc3RhdGUsXG4gICAgICAgICAgICAgIG9sZElubmVyQ2hpbGRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBsZWF2aW5nVk5vZGVzQ2FjaGVbU3RyaW5nKG9sZElubmVyQ2hpbGQua2V5KV0gPSBvbGRJbm5lckNoaWxkO1xuICAgICAgICAgICAgZWwuX2xlYXZlQ2IgPSAoKSA9PiB7XG4gICAgICAgICAgICAgIGVhcmx5UmVtb3ZlKCk7XG4gICAgICAgICAgICAgIGVsLl9sZWF2ZUNiID0gdm9pZCAwO1xuICAgICAgICAgICAgICBkZWxldGUgZW50ZXJIb29rcy5kZWxheWVkTGVhdmU7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZW50ZXJIb29rcy5kZWxheWVkTGVhdmUgPSBkZWxheWVkTGVhdmU7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGNoaWxkO1xuICAgIH07XG4gIH1cbn07XG5jb25zdCBCYXNlVHJhbnNpdGlvbiA9IEJhc2VUcmFuc2l0aW9uSW1wbDtcbmZ1bmN0aW9uIGdldExlYXZpbmdOb2Rlc0ZvclR5cGUoc3RhdGUsIHZub2RlKSB7XG4gIGNvbnN0IHsgbGVhdmluZ1ZOb2RlcyB9ID0gc3RhdGU7XG4gIGxldCBsZWF2aW5nVk5vZGVzQ2FjaGUgPSBsZWF2aW5nVk5vZGVzLmdldCh2bm9kZS50eXBlKTtcbiAgaWYgKCFsZWF2aW5nVk5vZGVzQ2FjaGUpIHtcbiAgICBsZWF2aW5nVk5vZGVzQ2FjaGUgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBsZWF2aW5nVk5vZGVzLnNldCh2bm9kZS50eXBlLCBsZWF2aW5nVk5vZGVzQ2FjaGUpO1xuICB9XG4gIHJldHVybiBsZWF2aW5nVk5vZGVzQ2FjaGU7XG59XG5mdW5jdGlvbiByZXNvbHZlVHJhbnNpdGlvbkhvb2tzKHZub2RlLCBwcm9wcywgc3RhdGUsIGluc3RhbmNlKSB7XG4gIGNvbnN0IHtcbiAgICBhcHBlYXIsXG4gICAgbW9kZSxcbiAgICBwZXJzaXN0ZWQgPSBmYWxzZSxcbiAgICBvbkJlZm9yZUVudGVyLFxuICAgIG9uRW50ZXIsXG4gICAgb25BZnRlckVudGVyLFxuICAgIG9uRW50ZXJDYW5jZWxsZWQsXG4gICAgb25CZWZvcmVMZWF2ZSxcbiAgICBvbkxlYXZlLFxuICAgIG9uQWZ0ZXJMZWF2ZSxcbiAgICBvbkxlYXZlQ2FuY2VsbGVkLFxuICAgIG9uQmVmb3JlQXBwZWFyLFxuICAgIG9uQXBwZWFyLFxuICAgIG9uQWZ0ZXJBcHBlYXIsXG4gICAgb25BcHBlYXJDYW5jZWxsZWRcbiAgfSA9IHByb3BzO1xuICBjb25zdCBrZXkgPSBTdHJpbmcodm5vZGUua2V5KTtcbiAgY29uc3QgbGVhdmluZ1ZOb2Rlc0NhY2hlID0gZ2V0TGVhdmluZ05vZGVzRm9yVHlwZShzdGF0ZSwgdm5vZGUpO1xuICBjb25zdCBjYWxsSG9vayA9IChob29rLCBhcmdzKSA9PiB7XG4gICAgaG9vayAmJiBjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZyhcbiAgICAgIGhvb2ssXG4gICAgICBpbnN0YW5jZSxcbiAgICAgIDksXG4gICAgICBhcmdzXG4gICAgKTtcbiAgfTtcbiAgY29uc3QgY2FsbEFzeW5jSG9vayA9IChob29rLCBhcmdzKSA9PiB7XG4gICAgY29uc3QgZG9uZSA9IGFyZ3NbMV07XG4gICAgY2FsbEhvb2soaG9vaywgYXJncyk7XG4gICAgaWYgKGlzQXJyYXkoaG9vaykpIHtcbiAgICAgIGlmIChob29rLmV2ZXJ5KChob29rMikgPT4gaG9vazIubGVuZ3RoIDw9IDEpKVxuICAgICAgICBkb25lKCk7XG4gICAgfSBlbHNlIGlmIChob29rLmxlbmd0aCA8PSAxKSB7XG4gICAgICBkb25lKCk7XG4gICAgfVxuICB9O1xuICBjb25zdCBob29rcyA9IHtcbiAgICBtb2RlLFxuICAgIHBlcnNpc3RlZCxcbiAgICBiZWZvcmVFbnRlcihlbCkge1xuICAgICAgbGV0IGhvb2sgPSBvbkJlZm9yZUVudGVyO1xuICAgICAgaWYgKCFzdGF0ZS5pc01vdW50ZWQpIHtcbiAgICAgICAgaWYgKGFwcGVhcikge1xuICAgICAgICAgIGhvb2sgPSBvbkJlZm9yZUFwcGVhciB8fCBvbkJlZm9yZUVudGVyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGVsLl9sZWF2ZUNiKSB7XG4gICAgICAgIGVsLl9sZWF2ZUNiKFxuICAgICAgICAgIHRydWVcbiAgICAgICAgICAvKiBjYW5jZWxsZWQgKi9cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGxlYXZpbmdWTm9kZSA9IGxlYXZpbmdWTm9kZXNDYWNoZVtrZXldO1xuICAgICAgaWYgKGxlYXZpbmdWTm9kZSAmJiBpc1NhbWVWTm9kZVR5cGUodm5vZGUsIGxlYXZpbmdWTm9kZSkgJiYgbGVhdmluZ1ZOb2RlLmVsLl9sZWF2ZUNiKSB7XG4gICAgICAgIGxlYXZpbmdWTm9kZS5lbC5fbGVhdmVDYigpO1xuICAgICAgfVxuICAgICAgY2FsbEhvb2soaG9vaywgW2VsXSk7XG4gICAgfSxcbiAgICBlbnRlcihlbCkge1xuICAgICAgbGV0IGhvb2sgPSBvbkVudGVyO1xuICAgICAgbGV0IGFmdGVySG9vayA9IG9uQWZ0ZXJFbnRlcjtcbiAgICAgIGxldCBjYW5jZWxIb29rID0gb25FbnRlckNhbmNlbGxlZDtcbiAgICAgIGlmICghc3RhdGUuaXNNb3VudGVkKSB7XG4gICAgICAgIGlmIChhcHBlYXIpIHtcbiAgICAgICAgICBob29rID0gb25BcHBlYXIgfHwgb25FbnRlcjtcbiAgICAgICAgICBhZnRlckhvb2sgPSBvbkFmdGVyQXBwZWFyIHx8IG9uQWZ0ZXJFbnRlcjtcbiAgICAgICAgICBjYW5jZWxIb29rID0gb25BcHBlYXJDYW5jZWxsZWQgfHwgb25FbnRlckNhbmNlbGxlZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGxldCBjYWxsZWQgPSBmYWxzZTtcbiAgICAgIGNvbnN0IGRvbmUgPSBlbC5fZW50ZXJDYiA9IChjYW5jZWxsZWQpID0+IHtcbiAgICAgICAgaWYgKGNhbGxlZClcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNhbGxlZCA9IHRydWU7XG4gICAgICAgIGlmIChjYW5jZWxsZWQpIHtcbiAgICAgICAgICBjYWxsSG9vayhjYW5jZWxIb29rLCBbZWxdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjYWxsSG9vayhhZnRlckhvb2ssIFtlbF0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChob29rcy5kZWxheWVkTGVhdmUpIHtcbiAgICAgICAgICBob29rcy5kZWxheWVkTGVhdmUoKTtcbiAgICAgICAgfVxuICAgICAgICBlbC5fZW50ZXJDYiA9IHZvaWQgMDtcbiAgICAgIH07XG4gICAgICBpZiAoaG9vaykge1xuICAgICAgICBjYWxsQXN5bmNIb29rKGhvb2ssIFtlbCwgZG9uZV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZG9uZSgpO1xuICAgICAgfVxuICAgIH0sXG4gICAgbGVhdmUoZWwsIHJlbW92ZSkge1xuICAgICAgY29uc3Qga2V5MiA9IFN0cmluZyh2bm9kZS5rZXkpO1xuICAgICAgaWYgKGVsLl9lbnRlckNiKSB7XG4gICAgICAgIGVsLl9lbnRlckNiKFxuICAgICAgICAgIHRydWVcbiAgICAgICAgICAvKiBjYW5jZWxsZWQgKi9cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdGF0ZS5pc1VubW91bnRpbmcpIHtcbiAgICAgICAgcmV0dXJuIHJlbW92ZSgpO1xuICAgICAgfVxuICAgICAgY2FsbEhvb2sob25CZWZvcmVMZWF2ZSwgW2VsXSk7XG4gICAgICBsZXQgY2FsbGVkID0gZmFsc2U7XG4gICAgICBjb25zdCBkb25lID0gZWwuX2xlYXZlQ2IgPSAoY2FuY2VsbGVkKSA9PiB7XG4gICAgICAgIGlmIChjYWxsZWQpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjYWxsZWQgPSB0cnVlO1xuICAgICAgICByZW1vdmUoKTtcbiAgICAgICAgaWYgKGNhbmNlbGxlZCkge1xuICAgICAgICAgIGNhbGxIb29rKG9uTGVhdmVDYW5jZWxsZWQsIFtlbF0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNhbGxIb29rKG9uQWZ0ZXJMZWF2ZSwgW2VsXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWwuX2xlYXZlQ2IgPSB2b2lkIDA7XG4gICAgICAgIGlmIChsZWF2aW5nVk5vZGVzQ2FjaGVba2V5Ml0gPT09IHZub2RlKSB7XG4gICAgICAgICAgZGVsZXRlIGxlYXZpbmdWTm9kZXNDYWNoZVtrZXkyXTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGxlYXZpbmdWTm9kZXNDYWNoZVtrZXkyXSA9IHZub2RlO1xuICAgICAgaWYgKG9uTGVhdmUpIHtcbiAgICAgICAgY2FsbEFzeW5jSG9vayhvbkxlYXZlLCBbZWwsIGRvbmVdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRvbmUoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGNsb25lKHZub2RlMikge1xuICAgICAgcmV0dXJuIHJlc29sdmVUcmFuc2l0aW9uSG9va3Modm5vZGUyLCBwcm9wcywgc3RhdGUsIGluc3RhbmNlKTtcbiAgICB9XG4gIH07XG4gIHJldHVybiBob29rcztcbn1cbmZ1bmN0aW9uIGVtcHR5UGxhY2Vob2xkZXIodm5vZGUpIHtcbiAgaWYgKGlzS2VlcEFsaXZlKHZub2RlKSkge1xuICAgIHZub2RlID0gY2xvbmVWTm9kZSh2bm9kZSk7XG4gICAgdm5vZGUuY2hpbGRyZW4gPSBudWxsO1xuICAgIHJldHVybiB2bm9kZTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0S2VlcEFsaXZlQ2hpbGQodm5vZGUpIHtcbiAgcmV0dXJuIGlzS2VlcEFsaXZlKHZub2RlKSA/IHZub2RlLmNoaWxkcmVuID8gdm5vZGUuY2hpbGRyZW5bMF0gOiB2b2lkIDAgOiB2bm9kZTtcbn1cbmZ1bmN0aW9uIHNldFRyYW5zaXRpb25Ib29rcyh2bm9kZSwgaG9va3MpIHtcbiAgaWYgKHZub2RlLnNoYXBlRmxhZyAmIDYgJiYgdm5vZGUuY29tcG9uZW50KSB7XG4gICAgc2V0VHJhbnNpdGlvbkhvb2tzKHZub2RlLmNvbXBvbmVudC5zdWJUcmVlLCBob29rcyk7XG4gIH0gZWxzZSBpZiAodm5vZGUuc2hhcGVGbGFnICYgMTI4KSB7XG4gICAgdm5vZGUuc3NDb250ZW50LnRyYW5zaXRpb24gPSBob29rcy5jbG9uZSh2bm9kZS5zc0NvbnRlbnQpO1xuICAgIHZub2RlLnNzRmFsbGJhY2sudHJhbnNpdGlvbiA9IGhvb2tzLmNsb25lKHZub2RlLnNzRmFsbGJhY2spO1xuICB9IGVsc2Uge1xuICAgIHZub2RlLnRyYW5zaXRpb24gPSBob29rcztcbiAgfVxufVxuZnVuY3Rpb24gZ2V0VHJhbnNpdGlvblJhd0NoaWxkcmVuKGNoaWxkcmVuLCBrZWVwQ29tbWVudCA9IGZhbHNlLCBwYXJlbnRLZXkpIHtcbiAgbGV0IHJldCA9IFtdO1xuICBsZXQga2V5ZWRGcmFnbWVudENvdW50ID0gMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIGxldCBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgIGNvbnN0IGtleSA9IHBhcmVudEtleSA9PSBudWxsID8gY2hpbGQua2V5IDogU3RyaW5nKHBhcmVudEtleSkgKyBTdHJpbmcoY2hpbGQua2V5ICE9IG51bGwgPyBjaGlsZC5rZXkgOiBpKTtcbiAgICBpZiAoY2hpbGQudHlwZSA9PT0gRnJhZ21lbnQpIHtcbiAgICAgIGlmIChjaGlsZC5wYXRjaEZsYWcgJiAxMjgpXG4gICAgICAgIGtleWVkRnJhZ21lbnRDb3VudCsrO1xuICAgICAgcmV0ID0gcmV0LmNvbmNhdChcbiAgICAgICAgZ2V0VHJhbnNpdGlvblJhd0NoaWxkcmVuKGNoaWxkLmNoaWxkcmVuLCBrZWVwQ29tbWVudCwga2V5KVxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKGtlZXBDb21tZW50IHx8IGNoaWxkLnR5cGUgIT09IENvbW1lbnQpIHtcbiAgICAgIHJldC5wdXNoKGtleSAhPSBudWxsID8gY2xvbmVWTm9kZShjaGlsZCwgeyBrZXkgfSkgOiBjaGlsZCk7XG4gICAgfVxuICB9XG4gIGlmIChrZXllZEZyYWdtZW50Q291bnQgPiAxKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXQubGVuZ3RoOyBpKyspIHtcbiAgICAgIHJldFtpXS5wYXRjaEZsYWcgPSAtMjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gZGVmaW5lQ29tcG9uZW50KG9wdGlvbnMsIGV4dHJhT3B0aW9ucykge1xuICByZXR1cm4gaXNGdW5jdGlvbihvcHRpb25zKSA/IChcbiAgICAvLyAjODMyNjogZXh0ZW5kIGNhbGwgYW5kIG9wdGlvbnMubmFtZSBhY2Nlc3MgYXJlIGNvbnNpZGVyZWQgc2lkZS1lZmZlY3RzXG4gICAgLy8gYnkgUm9sbHVwLCBzbyB3ZSBoYXZlIHRvIHdyYXAgaXQgaW4gYSBwdXJlLWFubm90YXRlZCBJSUZFLlxuICAgIC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gZXh0ZW5kKHsgbmFtZTogb3B0aW9ucy5uYW1lIH0sIGV4dHJhT3B0aW9ucywgeyBzZXR1cDogb3B0aW9ucyB9KSkoKVxuICApIDogb3B0aW9ucztcbn1cblxuY29uc3QgaXNBc3luY1dyYXBwZXIgPSAoaSkgPT4gISFpLnR5cGUuX19hc3luY0xvYWRlcjtcbmZ1bmN0aW9uIGRlZmluZUFzeW5jQ29tcG9uZW50KHNvdXJjZSkge1xuICBpZiAoaXNGdW5jdGlvbihzb3VyY2UpKSB7XG4gICAgc291cmNlID0geyBsb2FkZXI6IHNvdXJjZSB9O1xuICB9XG4gIGNvbnN0IHtcbiAgICBsb2FkZXIsXG4gICAgbG9hZGluZ0NvbXBvbmVudCxcbiAgICBlcnJvckNvbXBvbmVudCxcbiAgICBkZWxheSA9IDIwMCxcbiAgICB0aW1lb3V0LFxuICAgIC8vIHVuZGVmaW5lZCA9IG5ldmVyIHRpbWVzIG91dFxuICAgIHN1c3BlbnNpYmxlID0gdHJ1ZSxcbiAgICBvbkVycm9yOiB1c2VyT25FcnJvclxuICB9ID0gc291cmNlO1xuICBsZXQgcGVuZGluZ1JlcXVlc3QgPSBudWxsO1xuICBsZXQgcmVzb2x2ZWRDb21wO1xuICBsZXQgcmV0cmllcyA9IDA7XG4gIGNvbnN0IHJldHJ5ID0gKCkgPT4ge1xuICAgIHJldHJpZXMrKztcbiAgICBwZW5kaW5nUmVxdWVzdCA9IG51bGw7XG4gICAgcmV0dXJuIGxvYWQoKTtcbiAgfTtcbiAgY29uc3QgbG9hZCA9ICgpID0+IHtcbiAgICBsZXQgdGhpc1JlcXVlc3Q7XG4gICAgcmV0dXJuIHBlbmRpbmdSZXF1ZXN0IHx8ICh0aGlzUmVxdWVzdCA9IHBlbmRpbmdSZXF1ZXN0ID0gbG9hZGVyKCkuY2F0Y2goKGVycikgPT4ge1xuICAgICAgZXJyID0gZXJyIGluc3RhbmNlb2YgRXJyb3IgPyBlcnIgOiBuZXcgRXJyb3IoU3RyaW5nKGVycikpO1xuICAgICAgaWYgKHVzZXJPbkVycm9yKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgY29uc3QgdXNlclJldHJ5ID0gKCkgPT4gcmVzb2x2ZShyZXRyeSgpKTtcbiAgICAgICAgICBjb25zdCB1c2VyRmFpbCA9ICgpID0+IHJlamVjdChlcnIpO1xuICAgICAgICAgIHVzZXJPbkVycm9yKGVyciwgdXNlclJldHJ5LCB1c2VyRmFpbCwgcmV0cmllcyArIDEpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH1cbiAgICB9KS50aGVuKChjb21wKSA9PiB7XG4gICAgICBpZiAodGhpc1JlcXVlc3QgIT09IHBlbmRpbmdSZXF1ZXN0ICYmIHBlbmRpbmdSZXF1ZXN0KSB7XG4gICAgICAgIHJldHVybiBwZW5kaW5nUmVxdWVzdDtcbiAgICAgIH1cbiAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICFjb21wKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgYEFzeW5jIGNvbXBvbmVudCBsb2FkZXIgcmVzb2x2ZWQgdG8gdW5kZWZpbmVkLiBJZiB5b3UgYXJlIHVzaW5nIHJldHJ5KCksIG1ha2Ugc3VyZSB0byByZXR1cm4gaXRzIHJldHVybiB2YWx1ZS5gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAoY29tcCAmJiAoY29tcC5fX2VzTW9kdWxlIHx8IGNvbXBbU3ltYm9sLnRvU3RyaW5nVGFnXSA9PT0gXCJNb2R1bGVcIikpIHtcbiAgICAgICAgY29tcCA9IGNvbXAuZGVmYXVsdDtcbiAgICAgIH1cbiAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGNvbXAgJiYgIWlzT2JqZWN0KGNvbXApICYmICFpc0Z1bmN0aW9uKGNvbXApKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBhc3luYyBjb21wb25lbnQgbG9hZCByZXN1bHQ6ICR7Y29tcH1gKTtcbiAgICAgIH1cbiAgICAgIHJlc29sdmVkQ29tcCA9IGNvbXA7XG4gICAgICByZXR1cm4gY29tcDtcbiAgICB9KSk7XG4gIH07XG4gIHJldHVybiBkZWZpbmVDb21wb25lbnQoe1xuICAgIG5hbWU6IFwiQXN5bmNDb21wb25lbnRXcmFwcGVyXCIsXG4gICAgX19hc3luY0xvYWRlcjogbG9hZCxcbiAgICBnZXQgX19hc3luY1Jlc29sdmVkKCkge1xuICAgICAgcmV0dXJuIHJlc29sdmVkQ29tcDtcbiAgICB9LFxuICAgIHNldHVwKCkge1xuICAgICAgY29uc3QgaW5zdGFuY2UgPSBjdXJyZW50SW5zdGFuY2U7XG4gICAgICBpZiAocmVzb2x2ZWRDb21wKSB7XG4gICAgICAgIHJldHVybiAoKSA9PiBjcmVhdGVJbm5lckNvbXAocmVzb2x2ZWRDb21wLCBpbnN0YW5jZSk7XG4gICAgICB9XG4gICAgICBjb25zdCBvbkVycm9yID0gKGVycikgPT4ge1xuICAgICAgICBwZW5kaW5nUmVxdWVzdCA9IG51bGw7XG4gICAgICAgIGhhbmRsZUVycm9yKFxuICAgICAgICAgIGVycixcbiAgICAgICAgICBpbnN0YW5jZSxcbiAgICAgICAgICAxMyxcbiAgICAgICAgICAhZXJyb3JDb21wb25lbnRcbiAgICAgICAgICAvKiBkbyBub3QgdGhyb3cgaW4gZGV2IGlmIHVzZXIgcHJvdmlkZWQgZXJyb3IgY29tcG9uZW50ICovXG4gICAgICAgICk7XG4gICAgICB9O1xuICAgICAgaWYgKHN1c3BlbnNpYmxlICYmIGluc3RhbmNlLnN1c3BlbnNlIHx8IGlzSW5TU1JDb21wb25lbnRTZXR1cCkge1xuICAgICAgICByZXR1cm4gbG9hZCgpLnRoZW4oKGNvbXApID0+IHtcbiAgICAgICAgICByZXR1cm4gKCkgPT4gY3JlYXRlSW5uZXJDb21wKGNvbXAsIGluc3RhbmNlKTtcbiAgICAgICAgfSkuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgIG9uRXJyb3IoZXJyKTtcbiAgICAgICAgICByZXR1cm4gKCkgPT4gZXJyb3JDb21wb25lbnQgPyBjcmVhdGVWTm9kZShlcnJvckNvbXBvbmVudCwge1xuICAgICAgICAgICAgZXJyb3I6IGVyclxuICAgICAgICAgIH0pIDogbnVsbDtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBjb25zdCBsb2FkZWQgPSByZWYoZmFsc2UpO1xuICAgICAgY29uc3QgZXJyb3IgPSByZWYoKTtcbiAgICAgIGNvbnN0IGRlbGF5ZWQgPSByZWYoISFkZWxheSk7XG4gICAgICBpZiAoZGVsYXkpIHtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgZGVsYXllZC52YWx1ZSA9IGZhbHNlO1xuICAgICAgICB9LCBkZWxheSk7XG4gICAgICB9XG4gICAgICBpZiAodGltZW91dCAhPSBudWxsKSB7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIGlmICghbG9hZGVkLnZhbHVlICYmICFlcnJvci52YWx1ZSkge1xuICAgICAgICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9yKFxuICAgICAgICAgICAgICBgQXN5bmMgY29tcG9uZW50IHRpbWVkIG91dCBhZnRlciAke3RpbWVvdXR9bXMuYFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIG9uRXJyb3IoZXJyKTtcbiAgICAgICAgICAgIGVycm9yLnZhbHVlID0gZXJyO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgdGltZW91dCk7XG4gICAgICB9XG4gICAgICBsb2FkKCkudGhlbigoKSA9PiB7XG4gICAgICAgIGxvYWRlZC52YWx1ZSA9IHRydWU7XG4gICAgICAgIGlmIChpbnN0YW5jZS5wYXJlbnQgJiYgaXNLZWVwQWxpdmUoaW5zdGFuY2UucGFyZW50LnZub2RlKSkge1xuICAgICAgICAgIHF1ZXVlSm9iKGluc3RhbmNlLnBhcmVudC51cGRhdGUpO1xuICAgICAgICB9XG4gICAgICB9KS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgIG9uRXJyb3IoZXJyKTtcbiAgICAgICAgZXJyb3IudmFsdWUgPSBlcnI7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGlmIChsb2FkZWQudmFsdWUgJiYgcmVzb2x2ZWRDb21wKSB7XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZUlubmVyQ29tcChyZXNvbHZlZENvbXAsIGluc3RhbmNlKTtcbiAgICAgICAgfSBlbHNlIGlmIChlcnJvci52YWx1ZSAmJiBlcnJvckNvbXBvbmVudCkge1xuICAgICAgICAgIHJldHVybiBjcmVhdGVWTm9kZShlcnJvckNvbXBvbmVudCwge1xuICAgICAgICAgICAgZXJyb3I6IGVycm9yLnZhbHVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAobG9hZGluZ0NvbXBvbmVudCAmJiAhZGVsYXllZC52YWx1ZSkge1xuICAgICAgICAgIHJldHVybiBjcmVhdGVWTm9kZShsb2FkaW5nQ29tcG9uZW50KTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gY3JlYXRlSW5uZXJDb21wKGNvbXAsIHBhcmVudCkge1xuICBjb25zdCB7IHJlZjogcmVmMiwgcHJvcHMsIGNoaWxkcmVuLCBjZSB9ID0gcGFyZW50LnZub2RlO1xuICBjb25zdCB2bm9kZSA9IGNyZWF0ZVZOb2RlKGNvbXAsIHByb3BzLCBjaGlsZHJlbik7XG4gIHZub2RlLnJlZiA9IHJlZjI7XG4gIHZub2RlLmNlID0gY2U7XG4gIGRlbGV0ZSBwYXJlbnQudm5vZGUuY2U7XG4gIHJldHVybiB2bm9kZTtcbn1cblxuY29uc3QgaXNLZWVwQWxpdmUgPSAodm5vZGUpID0+IHZub2RlLnR5cGUuX19pc0tlZXBBbGl2ZTtcbmNvbnN0IEtlZXBBbGl2ZUltcGwgPSB7XG4gIG5hbWU6IGBLZWVwQWxpdmVgLFxuICAvLyBNYXJrZXIgZm9yIHNwZWNpYWwgaGFuZGxpbmcgaW5zaWRlIHRoZSByZW5kZXJlci4gV2UgYXJlIG5vdCB1c2luZyBhID09PVxuICAvLyBjaGVjayBkaXJlY3RseSBvbiBLZWVwQWxpdmUgaW4gdGhlIHJlbmRlcmVyLCBiZWNhdXNlIGltcG9ydGluZyBpdCBkaXJlY3RseVxuICAvLyB3b3VsZCBwcmV2ZW50IGl0IGZyb20gYmVpbmcgdHJlZS1zaGFrZW4uXG4gIF9faXNLZWVwQWxpdmU6IHRydWUsXG4gIHByb3BzOiB7XG4gICAgaW5jbHVkZTogW1N0cmluZywgUmVnRXhwLCBBcnJheV0sXG4gICAgZXhjbHVkZTogW1N0cmluZywgUmVnRXhwLCBBcnJheV0sXG4gICAgbWF4OiBbU3RyaW5nLCBOdW1iZXJdXG4gIH0sXG4gIHNldHVwKHByb3BzLCB7IHNsb3RzIH0pIHtcbiAgICBjb25zdCBpbnN0YW5jZSA9IGdldEN1cnJlbnRJbnN0YW5jZSgpO1xuICAgIGNvbnN0IHNoYXJlZENvbnRleHQgPSBpbnN0YW5jZS5jdHg7XG4gICAgaWYgKCFzaGFyZWRDb250ZXh0LnJlbmRlcmVyKSB7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBjb25zdCBjaGlsZHJlbiA9IHNsb3RzLmRlZmF1bHQgJiYgc2xvdHMuZGVmYXVsdCgpO1xuICAgICAgICByZXR1cm4gY2hpbGRyZW4gJiYgY2hpbGRyZW4ubGVuZ3RoID09PSAxID8gY2hpbGRyZW5bMF0gOiBjaGlsZHJlbjtcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IGNhY2hlID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICBjb25zdCBrZXlzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICBsZXQgY3VycmVudCA9IG51bGw7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XG4gICAgICBpbnN0YW5jZS5fX3ZfY2FjaGUgPSBjYWNoZTtcbiAgICB9XG4gICAgY29uc3QgcGFyZW50U3VzcGVuc2UgPSBpbnN0YW5jZS5zdXNwZW5zZTtcbiAgICBjb25zdCB7XG4gICAgICByZW5kZXJlcjoge1xuICAgICAgICBwOiBwYXRjaCxcbiAgICAgICAgbTogbW92ZSxcbiAgICAgICAgdW06IF91bm1vdW50LFxuICAgICAgICBvOiB7IGNyZWF0ZUVsZW1lbnQgfVxuICAgICAgfVxuICAgIH0gPSBzaGFyZWRDb250ZXh0O1xuICAgIGNvbnN0IHN0b3JhZ2VDb250YWluZXIgPSBjcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIHNoYXJlZENvbnRleHQuYWN0aXZhdGUgPSAodm5vZGUsIGNvbnRhaW5lciwgYW5jaG9yLCBpc1NWRywgb3B0aW1pemVkKSA9PiB7XG4gICAgICBjb25zdCBpbnN0YW5jZTIgPSB2bm9kZS5jb21wb25lbnQ7XG4gICAgICBtb3ZlKHZub2RlLCBjb250YWluZXIsIGFuY2hvciwgMCwgcGFyZW50U3VzcGVuc2UpO1xuICAgICAgcGF0Y2goXG4gICAgICAgIGluc3RhbmNlMi52bm9kZSxcbiAgICAgICAgdm5vZGUsXG4gICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgYW5jaG9yLFxuICAgICAgICBpbnN0YW5jZTIsXG4gICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICBpc1NWRyxcbiAgICAgICAgdm5vZGUuc2xvdFNjb3BlSWRzLFxuICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICk7XG4gICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpbnN0YW5jZTIuaXNEZWFjdGl2YXRlZCA9IGZhbHNlO1xuICAgICAgICBpZiAoaW5zdGFuY2UyLmEpIHtcbiAgICAgICAgICBpbnZva2VBcnJheUZucyhpbnN0YW5jZTIuYSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgdm5vZGVIb29rID0gdm5vZGUucHJvcHMgJiYgdm5vZGUucHJvcHMub25Wbm9kZU1vdW50ZWQ7XG4gICAgICAgIGlmICh2bm9kZUhvb2spIHtcbiAgICAgICAgICBpbnZva2VWTm9kZUhvb2sodm5vZGVIb29rLCBpbnN0YW5jZTIucGFyZW50LCB2bm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH0sIHBhcmVudFN1c3BlbnNlKTtcbiAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykge1xuICAgICAgICBkZXZ0b29sc0NvbXBvbmVudEFkZGVkKGluc3RhbmNlMik7XG4gICAgICB9XG4gICAgfTtcbiAgICBzaGFyZWRDb250ZXh0LmRlYWN0aXZhdGUgPSAodm5vZGUpID0+IHtcbiAgICAgIGNvbnN0IGluc3RhbmNlMiA9IHZub2RlLmNvbXBvbmVudDtcbiAgICAgIG1vdmUodm5vZGUsIHN0b3JhZ2VDb250YWluZXIsIG51bGwsIDEsIHBhcmVudFN1c3BlbnNlKTtcbiAgICAgIHF1ZXVlUG9zdFJlbmRlckVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmIChpbnN0YW5jZTIuZGEpIHtcbiAgICAgICAgICBpbnZva2VBcnJheUZucyhpbnN0YW5jZTIuZGEpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZub2RlSG9vayA9IHZub2RlLnByb3BzICYmIHZub2RlLnByb3BzLm9uVm5vZGVVbm1vdW50ZWQ7XG4gICAgICAgIGlmICh2bm9kZUhvb2spIHtcbiAgICAgICAgICBpbnZva2VWTm9kZUhvb2sodm5vZGVIb29rLCBpbnN0YW5jZTIucGFyZW50LCB2bm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaW5zdGFuY2UyLmlzRGVhY3RpdmF0ZWQgPSB0cnVlO1xuICAgICAgfSwgcGFyZW50U3VzcGVuc2UpO1xuICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XG4gICAgICAgIGRldnRvb2xzQ29tcG9uZW50QWRkZWQoaW5zdGFuY2UyKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGZ1bmN0aW9uIHVubW91bnQodm5vZGUpIHtcbiAgICAgIHJlc2V0U2hhcGVGbGFnKHZub2RlKTtcbiAgICAgIF91bm1vdW50KHZub2RlLCBpbnN0YW5jZSwgcGFyZW50U3VzcGVuc2UsIHRydWUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwcnVuZUNhY2hlKGZpbHRlcikge1xuICAgICAgY2FjaGUuZm9yRWFjaCgodm5vZGUsIGtleSkgPT4ge1xuICAgICAgICBjb25zdCBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZSh2bm9kZS50eXBlKTtcbiAgICAgICAgaWYgKG5hbWUgJiYgKCFmaWx0ZXIgfHwgIWZpbHRlcihuYW1lKSkpIHtcbiAgICAgICAgICBwcnVuZUNhY2hlRW50cnkoa2V5KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBydW5lQ2FjaGVFbnRyeShrZXkpIHtcbiAgICAgIGNvbnN0IGNhY2hlZCA9IGNhY2hlLmdldChrZXkpO1xuICAgICAgaWYgKCFjdXJyZW50IHx8ICFpc1NhbWVWTm9kZVR5cGUoY2FjaGVkLCBjdXJyZW50KSkge1xuICAgICAgICB1bm1vdW50KGNhY2hlZCk7XG4gICAgICB9IGVsc2UgaWYgKGN1cnJlbnQpIHtcbiAgICAgICAgcmVzZXRTaGFwZUZsYWcoY3VycmVudCk7XG4gICAgICB9XG4gICAgICBjYWNoZS5kZWxldGUoa2V5KTtcbiAgICAgIGtleXMuZGVsZXRlKGtleSk7XG4gICAgfVxuICAgIHdhdGNoKFxuICAgICAgKCkgPT4gW3Byb3BzLmluY2x1ZGUsIHByb3BzLmV4Y2x1ZGVdLFxuICAgICAgKFtpbmNsdWRlLCBleGNsdWRlXSkgPT4ge1xuICAgICAgICBpbmNsdWRlICYmIHBydW5lQ2FjaGUoKG5hbWUpID0+IG1hdGNoZXMoaW5jbHVkZSwgbmFtZSkpO1xuICAgICAgICBleGNsdWRlICYmIHBydW5lQ2FjaGUoKG5hbWUpID0+ICFtYXRjaGVzKGV4Y2x1ZGUsIG5hbWUpKTtcbiAgICAgIH0sXG4gICAgICAvLyBwcnVuZSBwb3N0LXJlbmRlciBhZnRlciBgY3VycmVudGAgaGFzIGJlZW4gdXBkYXRlZFxuICAgICAgeyBmbHVzaDogXCJwb3N0XCIsIGRlZXA6IHRydWUgfVxuICAgICk7XG4gICAgbGV0IHBlbmRpbmdDYWNoZUtleSA9IG51bGw7XG4gICAgY29uc3QgY2FjaGVTdWJ0cmVlID0gKCkgPT4ge1xuICAgICAgaWYgKHBlbmRpbmdDYWNoZUtleSAhPSBudWxsKSB7XG4gICAgICAgIGNhY2hlLnNldChwZW5kaW5nQ2FjaGVLZXksIGdldElubmVyQ2hpbGQoaW5zdGFuY2Uuc3ViVHJlZSkpO1xuICAgICAgfVxuICAgIH07XG4gICAgb25Nb3VudGVkKGNhY2hlU3VidHJlZSk7XG4gICAgb25VcGRhdGVkKGNhY2hlU3VidHJlZSk7XG4gICAgb25CZWZvcmVVbm1vdW50KCgpID0+IHtcbiAgICAgIGNhY2hlLmZvckVhY2goKGNhY2hlZCkgPT4ge1xuICAgICAgICBjb25zdCB7IHN1YlRyZWUsIHN1c3BlbnNlIH0gPSBpbnN0YW5jZTtcbiAgICAgICAgY29uc3Qgdm5vZGUgPSBnZXRJbm5lckNoaWxkKHN1YlRyZWUpO1xuICAgICAgICBpZiAoY2FjaGVkLnR5cGUgPT09IHZub2RlLnR5cGUgJiYgY2FjaGVkLmtleSA9PT0gdm5vZGUua2V5KSB7XG4gICAgICAgICAgcmVzZXRTaGFwZUZsYWcodm5vZGUpO1xuICAgICAgICAgIGNvbnN0IGRhID0gdm5vZGUuY29tcG9uZW50LmRhO1xuICAgICAgICAgIGRhICYmIHF1ZXVlUG9zdFJlbmRlckVmZmVjdChkYSwgc3VzcGVuc2UpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB1bm1vdW50KGNhY2hlZCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgcGVuZGluZ0NhY2hlS2V5ID0gbnVsbDtcbiAgICAgIGlmICghc2xvdHMuZGVmYXVsdCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNoaWxkcmVuID0gc2xvdHMuZGVmYXVsdCgpO1xuICAgICAgY29uc3QgcmF3Vk5vZGUgPSBjaGlsZHJlblswXTtcbiAgICAgIGlmIChjaGlsZHJlbi5sZW5ndGggPiAxKSB7XG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgd2FybihgS2VlcEFsaXZlIHNob3VsZCBjb250YWluIGV4YWN0bHkgb25lIGNvbXBvbmVudCBjaGlsZC5gKTtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50ID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIGNoaWxkcmVuO1xuICAgICAgfSBlbHNlIGlmICghaXNWTm9kZShyYXdWTm9kZSkgfHwgIShyYXdWTm9kZS5zaGFwZUZsYWcgJiA0KSAmJiAhKHJhd1ZOb2RlLnNoYXBlRmxhZyAmIDEyOCkpIHtcbiAgICAgICAgY3VycmVudCA9IG51bGw7XG4gICAgICAgIHJldHVybiByYXdWTm9kZTtcbiAgICAgIH1cbiAgICAgIGxldCB2bm9kZSA9IGdldElubmVyQ2hpbGQocmF3Vk5vZGUpO1xuICAgICAgY29uc3QgY29tcCA9IHZub2RlLnR5cGU7XG4gICAgICBjb25zdCBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShcbiAgICAgICAgaXNBc3luY1dyYXBwZXIodm5vZGUpID8gdm5vZGUudHlwZS5fX2FzeW5jUmVzb2x2ZWQgfHwge30gOiBjb21wXG4gICAgICApO1xuICAgICAgY29uc3QgeyBpbmNsdWRlLCBleGNsdWRlLCBtYXggfSA9IHByb3BzO1xuICAgICAgaWYgKGluY2x1ZGUgJiYgKCFuYW1lIHx8ICFtYXRjaGVzKGluY2x1ZGUsIG5hbWUpKSB8fCBleGNsdWRlICYmIG5hbWUgJiYgbWF0Y2hlcyhleGNsdWRlLCBuYW1lKSkge1xuICAgICAgICBjdXJyZW50ID0gdm5vZGU7XG4gICAgICAgIHJldHVybiByYXdWTm9kZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGtleSA9IHZub2RlLmtleSA9PSBudWxsID8gY29tcCA6IHZub2RlLmtleTtcbiAgICAgIGNvbnN0IGNhY2hlZFZOb2RlID0gY2FjaGUuZ2V0KGtleSk7XG4gICAgICBpZiAodm5vZGUuZWwpIHtcbiAgICAgICAgdm5vZGUgPSBjbG9uZVZOb2RlKHZub2RlKTtcbiAgICAgICAgaWYgKHJhd1ZOb2RlLnNoYXBlRmxhZyAmIDEyOCkge1xuICAgICAgICAgIHJhd1ZOb2RlLnNzQ29udGVudCA9IHZub2RlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBwZW5kaW5nQ2FjaGVLZXkgPSBrZXk7XG4gICAgICBpZiAoY2FjaGVkVk5vZGUpIHtcbiAgICAgICAgdm5vZGUuZWwgPSBjYWNoZWRWTm9kZS5lbDtcbiAgICAgICAgdm5vZGUuY29tcG9uZW50ID0gY2FjaGVkVk5vZGUuY29tcG9uZW50O1xuICAgICAgICBpZiAodm5vZGUudHJhbnNpdGlvbikge1xuICAgICAgICAgIHNldFRyYW5zaXRpb25Ib29rcyh2bm9kZSwgdm5vZGUudHJhbnNpdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgdm5vZGUuc2hhcGVGbGFnIHw9IDUxMjtcbiAgICAgICAga2V5cy5kZWxldGUoa2V5KTtcbiAgICAgICAga2V5cy5hZGQoa2V5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGtleXMuYWRkKGtleSk7XG4gICAgICAgIGlmIChtYXggJiYga2V5cy5zaXplID4gcGFyc2VJbnQobWF4LCAxMCkpIHtcbiAgICAgICAgICBwcnVuZUNhY2hlRW50cnkoa2V5cy52YWx1ZXMoKS5uZXh0KCkudmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2bm9kZS5zaGFwZUZsYWcgfD0gMjU2O1xuICAgICAgY3VycmVudCA9IHZub2RlO1xuICAgICAgcmV0dXJuIGlzU3VzcGVuc2UocmF3Vk5vZGUudHlwZSkgPyByYXdWTm9kZSA6IHZub2RlO1xuICAgIH07XG4gIH1cbn07XG5jb25zdCBLZWVwQWxpdmUgPSBLZWVwQWxpdmVJbXBsO1xuZnVuY3Rpb24gbWF0Y2hlcyhwYXR0ZXJuLCBuYW1lKSB7XG4gIGlmIChpc0FycmF5KHBhdHRlcm4pKSB7XG4gICAgcmV0dXJuIHBhdHRlcm4uc29tZSgocCkgPT4gbWF0Y2hlcyhwLCBuYW1lKSk7XG4gIH0gZWxzZSBpZiAoaXNTdHJpbmcocGF0dGVybikpIHtcbiAgICByZXR1cm4gcGF0dGVybi5zcGxpdChcIixcIikuaW5jbHVkZXMobmFtZSk7XG4gIH0gZWxzZSBpZiAoaXNSZWdFeHAocGF0dGVybikpIHtcbiAgICByZXR1cm4gcGF0dGVybi50ZXN0KG5hbWUpO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIG9uQWN0aXZhdGVkKGhvb2ssIHRhcmdldCkge1xuICByZWdpc3RlcktlZXBBbGl2ZUhvb2soaG9vaywgXCJhXCIsIHRhcmdldCk7XG59XG5mdW5jdGlvbiBvbkRlYWN0aXZhdGVkKGhvb2ssIHRhcmdldCkge1xuICByZWdpc3RlcktlZXBBbGl2ZUhvb2soaG9vaywgXCJkYVwiLCB0YXJnZXQpO1xufVxuZnVuY3Rpb24gcmVnaXN0ZXJLZWVwQWxpdmVIb29rKGhvb2ssIHR5cGUsIHRhcmdldCA9IGN1cnJlbnRJbnN0YW5jZSkge1xuICBjb25zdCB3cmFwcGVkSG9vayA9IGhvb2suX193ZGMgfHwgKGhvb2suX193ZGMgPSAoKSA9PiB7XG4gICAgbGV0IGN1cnJlbnQgPSB0YXJnZXQ7XG4gICAgd2hpbGUgKGN1cnJlbnQpIHtcbiAgICAgIGlmIChjdXJyZW50LmlzRGVhY3RpdmF0ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY3VycmVudCA9IGN1cnJlbnQucGFyZW50O1xuICAgIH1cbiAgICByZXR1cm4gaG9vaygpO1xuICB9KTtcbiAgaW5qZWN0SG9vayh0eXBlLCB3cmFwcGVkSG9vaywgdGFyZ2V0KTtcbiAgaWYgKHRhcmdldCkge1xuICAgIGxldCBjdXJyZW50ID0gdGFyZ2V0LnBhcmVudDtcbiAgICB3aGlsZSAoY3VycmVudCAmJiBjdXJyZW50LnBhcmVudCkge1xuICAgICAgaWYgKGlzS2VlcEFsaXZlKGN1cnJlbnQucGFyZW50LnZub2RlKSkge1xuICAgICAgICBpbmplY3RUb0tlZXBBbGl2ZVJvb3Qod3JhcHBlZEhvb2ssIHR5cGUsIHRhcmdldCwgY3VycmVudCk7XG4gICAgICB9XG4gICAgICBjdXJyZW50ID0gY3VycmVudC5wYXJlbnQ7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBpbmplY3RUb0tlZXBBbGl2ZVJvb3QoaG9vaywgdHlwZSwgdGFyZ2V0LCBrZWVwQWxpdmVSb290KSB7XG4gIGNvbnN0IGluamVjdGVkID0gaW5qZWN0SG9vayhcbiAgICB0eXBlLFxuICAgIGhvb2ssXG4gICAga2VlcEFsaXZlUm9vdCxcbiAgICB0cnVlXG4gICAgLyogcHJlcGVuZCAqL1xuICApO1xuICBvblVubW91bnRlZCgoKSA9PiB7XG4gICAgcmVtb3ZlKGtlZXBBbGl2ZVJvb3RbdHlwZV0sIGluamVjdGVkKTtcbiAgfSwgdGFyZ2V0KTtcbn1cbmZ1bmN0aW9uIHJlc2V0U2hhcGVGbGFnKHZub2RlKSB7XG4gIHZub2RlLnNoYXBlRmxhZyAmPSB+MjU2O1xuICB2bm9kZS5zaGFwZUZsYWcgJj0gfjUxMjtcbn1cbmZ1bmN0aW9uIGdldElubmVyQ2hpbGQodm5vZGUpIHtcbiAgcmV0dXJuIHZub2RlLnNoYXBlRmxhZyAmIDEyOCA/IHZub2RlLnNzQ29udGVudCA6IHZub2RlO1xufVxuXG5mdW5jdGlvbiBpbmplY3RIb29rKHR5cGUsIGhvb2ssIHRhcmdldCA9IGN1cnJlbnRJbnN0YW5jZSwgcHJlcGVuZCA9IGZhbHNlKSB7XG4gIGlmICh0YXJnZXQpIHtcbiAgICBjb25zdCBob29rcyA9IHRhcmdldFt0eXBlXSB8fCAodGFyZ2V0W3R5cGVdID0gW10pO1xuICAgIGNvbnN0IHdyYXBwZWRIb29rID0gaG9vay5fX3dlaCB8fCAoaG9vay5fX3dlaCA9ICguLi5hcmdzKSA9PiB7XG4gICAgICBpZiAodGFyZ2V0LmlzVW5tb3VudGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHBhdXNlVHJhY2tpbmcoKTtcbiAgICAgIHNldEN1cnJlbnRJbnN0YW5jZSh0YXJnZXQpO1xuICAgICAgY29uc3QgcmVzID0gY2FsbFdpdGhBc3luY0Vycm9ySGFuZGxpbmcoaG9vaywgdGFyZ2V0LCB0eXBlLCBhcmdzKTtcbiAgICAgIHVuc2V0Q3VycmVudEluc3RhbmNlKCk7XG4gICAgICByZXNldFRyYWNraW5nKCk7XG4gICAgICByZXR1cm4gcmVzO1xuICAgIH0pO1xuICAgIGlmIChwcmVwZW5kKSB7XG4gICAgICBob29rcy51bnNoaWZ0KHdyYXBwZWRIb29rKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaG9va3MucHVzaCh3cmFwcGVkSG9vayk7XG4gICAgfVxuICAgIHJldHVybiB3cmFwcGVkSG9vaztcbiAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgY29uc3QgYXBpTmFtZSA9IHRvSGFuZGxlcktleShFcnJvclR5cGVTdHJpbmdzW3R5cGVdLnJlcGxhY2UoLyBob29rJC8sIFwiXCIpKTtcbiAgICB3YXJuKFxuICAgICAgYCR7YXBpTmFtZX0gaXMgY2FsbGVkIHdoZW4gdGhlcmUgaXMgbm8gYWN0aXZlIGNvbXBvbmVudCBpbnN0YW5jZSB0byBiZSBhc3NvY2lhdGVkIHdpdGguIExpZmVjeWNsZSBpbmplY3Rpb24gQVBJcyBjYW4gb25seSBiZSB1c2VkIGR1cmluZyBleGVjdXRpb24gb2Ygc2V0dXAoKS5gICsgKGAgSWYgeW91IGFyZSB1c2luZyBhc3luYyBzZXR1cCgpLCBtYWtlIHN1cmUgdG8gcmVnaXN0ZXIgbGlmZWN5Y2xlIGhvb2tzIGJlZm9yZSB0aGUgZmlyc3QgYXdhaXQgc3RhdGVtZW50LmAgKVxuICAgICk7XG4gIH1cbn1cbmNvbnN0IGNyZWF0ZUhvb2sgPSAobGlmZWN5Y2xlKSA9PiAoaG9vaywgdGFyZ2V0ID0gY3VycmVudEluc3RhbmNlKSA9PiAoXG4gIC8vIHBvc3QtY3JlYXRlIGxpZmVjeWNsZSByZWdpc3RyYXRpb25zIGFyZSBub29wcyBkdXJpbmcgU1NSIChleGNlcHQgZm9yIHNlcnZlclByZWZldGNoKVxuICAoIWlzSW5TU1JDb21wb25lbnRTZXR1cCB8fCBsaWZlY3ljbGUgPT09IFwic3BcIikgJiYgaW5qZWN0SG9vayhsaWZlY3ljbGUsICguLi5hcmdzKSA9PiBob29rKC4uLmFyZ3MpLCB0YXJnZXQpXG4pO1xuY29uc3Qgb25CZWZvcmVNb3VudCA9IGNyZWF0ZUhvb2soXCJibVwiKTtcbmNvbnN0IG9uTW91bnRlZCA9IGNyZWF0ZUhvb2soXCJtXCIpO1xuY29uc3Qgb25CZWZvcmVVcGRhdGUgPSBjcmVhdGVIb29rKFwiYnVcIik7XG5jb25zdCBvblVwZGF0ZWQgPSBjcmVhdGVIb29rKFwidVwiKTtcbmNvbnN0IG9uQmVmb3JlVW5tb3VudCA9IGNyZWF0ZUhvb2soXCJidW1cIik7XG5jb25zdCBvblVubW91bnRlZCA9IGNyZWF0ZUhvb2soXCJ1bVwiKTtcbmNvbnN0IG9uU2VydmVyUHJlZmV0Y2ggPSBjcmVhdGVIb29rKFwic3BcIik7XG5jb25zdCBvblJlbmRlclRyaWdnZXJlZCA9IGNyZWF0ZUhvb2soXG4gIFwicnRnXCJcbik7XG5jb25zdCBvblJlbmRlclRyYWNrZWQgPSBjcmVhdGVIb29rKFxuICBcInJ0Y1wiXG4pO1xuZnVuY3Rpb24gb25FcnJvckNhcHR1cmVkKGhvb2ssIHRhcmdldCA9IGN1cnJlbnRJbnN0YW5jZSkge1xuICBpbmplY3RIb29rKFwiZWNcIiwgaG9vaywgdGFyZ2V0KTtcbn1cblxuY29uc3QgQ09NUE9ORU5UUyA9IFwiY29tcG9uZW50c1wiO1xuY29uc3QgRElSRUNUSVZFUyA9IFwiZGlyZWN0aXZlc1wiO1xuZnVuY3Rpb24gcmVzb2x2ZUNvbXBvbmVudChuYW1lLCBtYXliZVNlbGZSZWZlcmVuY2UpIHtcbiAgcmV0dXJuIHJlc29sdmVBc3NldChDT01QT05FTlRTLCBuYW1lLCB0cnVlLCBtYXliZVNlbGZSZWZlcmVuY2UpIHx8IG5hbWU7XG59XG5jb25zdCBOVUxMX0RZTkFNSUNfQ09NUE9ORU5UID0gU3ltYm9sLmZvcihcInYtbmRjXCIpO1xuZnVuY3Rpb24gcmVzb2x2ZUR5bmFtaWNDb21wb25lbnQoY29tcG9uZW50KSB7XG4gIGlmIChpc1N0cmluZyhjb21wb25lbnQpKSB7XG4gICAgcmV0dXJuIHJlc29sdmVBc3NldChDT01QT05FTlRTLCBjb21wb25lbnQsIGZhbHNlKSB8fCBjb21wb25lbnQ7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGNvbXBvbmVudCB8fCBOVUxMX0RZTkFNSUNfQ09NUE9ORU5UO1xuICB9XG59XG5mdW5jdGlvbiByZXNvbHZlRGlyZWN0aXZlKG5hbWUpIHtcbiAgcmV0dXJuIHJlc29sdmVBc3NldChESVJFQ1RJVkVTLCBuYW1lKTtcbn1cbmZ1bmN0aW9uIHJlc29sdmVBc3NldCh0eXBlLCBuYW1lLCB3YXJuTWlzc2luZyA9IHRydWUsIG1heWJlU2VsZlJlZmVyZW5jZSA9IGZhbHNlKSB7XG4gIGNvbnN0IGluc3RhbmNlID0gY3VycmVudFJlbmRlcmluZ0luc3RhbmNlIHx8IGN1cnJlbnRJbnN0YW5jZTtcbiAgaWYgKGluc3RhbmNlKSB7XG4gICAgY29uc3QgQ29tcG9uZW50ID0gaW5zdGFuY2UudHlwZTtcbiAgICBpZiAodHlwZSA9PT0gQ09NUE9ORU5UUykge1xuICAgICAgY29uc3Qgc2VsZk5hbWUgPSBnZXRDb21wb25lbnROYW1lKFxuICAgICAgICBDb21wb25lbnQsXG4gICAgICAgIGZhbHNlXG4gICAgICAgIC8qIGRvIG5vdCBpbmNsdWRlIGluZmVycmVkIG5hbWUgdG8gYXZvaWQgYnJlYWtpbmcgZXhpc3RpbmcgY29kZSAqL1xuICAgICAgKTtcbiAgICAgIGlmIChzZWxmTmFtZSAmJiAoc2VsZk5hbWUgPT09IG5hbWUgfHwgc2VsZk5hbWUgPT09IGNhbWVsaXplKG5hbWUpIHx8IHNlbGZOYW1lID09PSBjYXBpdGFsaXplKGNhbWVsaXplKG5hbWUpKSkpIHtcbiAgICAgICAgcmV0dXJuIENvbXBvbmVudDtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgcmVzID0gKFxuICAgICAgLy8gbG9jYWwgcmVnaXN0cmF0aW9uXG4gICAgICAvLyBjaGVjayBpbnN0YW5jZVt0eXBlXSBmaXJzdCB3aGljaCBpcyByZXNvbHZlZCBmb3Igb3B0aW9ucyBBUElcbiAgICAgIHJlc29sdmUoaW5zdGFuY2VbdHlwZV0gfHwgQ29tcG9uZW50W3R5cGVdLCBuYW1lKSB8fCAvLyBnbG9iYWwgcmVnaXN0cmF0aW9uXG4gICAgICByZXNvbHZlKGluc3RhbmNlLmFwcENvbnRleHRbdHlwZV0sIG5hbWUpXG4gICAgKTtcbiAgICBpZiAoIXJlcyAmJiBtYXliZVNlbGZSZWZlcmVuY2UpIHtcbiAgICAgIHJldHVybiBDb21wb25lbnQ7XG4gICAgfVxuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHdhcm5NaXNzaW5nICYmICFyZXMpIHtcbiAgICAgIGNvbnN0IGV4dHJhID0gdHlwZSA9PT0gQ09NUE9ORU5UUyA/IGBcbklmIHRoaXMgaXMgYSBuYXRpdmUgY3VzdG9tIGVsZW1lbnQsIG1ha2Ugc3VyZSB0byBleGNsdWRlIGl0IGZyb20gY29tcG9uZW50IHJlc29sdXRpb24gdmlhIGNvbXBpbGVyT3B0aW9ucy5pc0N1c3RvbUVsZW1lbnQuYCA6IGBgO1xuICAgICAgd2FybihgRmFpbGVkIHRvIHJlc29sdmUgJHt0eXBlLnNsaWNlKDAsIC0xKX06ICR7bmFtZX0ke2V4dHJhfWApO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xuICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICB3YXJuKFxuICAgICAgYHJlc29sdmUke2NhcGl0YWxpemUodHlwZS5zbGljZSgwLCAtMSkpfSBjYW4gb25seSBiZSB1c2VkIGluIHJlbmRlcigpIG9yIHNldHVwKCkuYFxuICAgICk7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlc29sdmUocmVnaXN0cnksIG5hbWUpIHtcbiAgcmV0dXJuIHJlZ2lzdHJ5ICYmIChyZWdpc3RyeVtuYW1lXSB8fCByZWdpc3RyeVtjYW1lbGl6ZShuYW1lKV0gfHwgcmVnaXN0cnlbY2FwaXRhbGl6ZShjYW1lbGl6ZShuYW1lKSldKTtcbn1cblxuZnVuY3Rpb24gcmVuZGVyTGlzdChzb3VyY2UsIHJlbmRlckl0ZW0sIGNhY2hlLCBpbmRleCkge1xuICBsZXQgcmV0O1xuICBjb25zdCBjYWNoZWQgPSBjYWNoZSAmJiBjYWNoZVtpbmRleF07XG4gIGlmIChpc0FycmF5KHNvdXJjZSkgfHwgaXNTdHJpbmcoc291cmNlKSkge1xuICAgIHJldCA9IG5ldyBBcnJheShzb3VyY2UubGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMCwgbCA9IHNvdXJjZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHJldFtpXSA9IHJlbmRlckl0ZW0oc291cmNlW2ldLCBpLCB2b2lkIDAsIGNhY2hlZCAmJiBjYWNoZWRbaV0pO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2Ygc291cmNlID09PSBcIm51bWJlclwiKSB7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgIU51bWJlci5pc0ludGVnZXIoc291cmNlKSkge1xuICAgICAgd2FybihgVGhlIHYtZm9yIHJhbmdlIGV4cGVjdCBhbiBpbnRlZ2VyIHZhbHVlIGJ1dCBnb3QgJHtzb3VyY2V9LmApO1xuICAgIH1cbiAgICByZXQgPSBuZXcgQXJyYXkoc291cmNlKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNvdXJjZTsgaSsrKSB7XG4gICAgICByZXRbaV0gPSByZW5kZXJJdGVtKGkgKyAxLCBpLCB2b2lkIDAsIGNhY2hlZCAmJiBjYWNoZWRbaV0pO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc09iamVjdChzb3VyY2UpKSB7XG4gICAgaWYgKHNvdXJjZVtTeW1ib2wuaXRlcmF0b3JdKSB7XG4gICAgICByZXQgPSBBcnJheS5mcm9tKFxuICAgICAgICBzb3VyY2UsXG4gICAgICAgIChpdGVtLCBpKSA9PiByZW5kZXJJdGVtKGl0ZW0sIGksIHZvaWQgMCwgY2FjaGVkICYmIGNhY2hlZFtpXSlcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuICAgICAgcmV0ID0gbmV3IEFycmF5KGtleXMubGVuZ3RoKTtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBsID0ga2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgY29uc3Qga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgcmV0W2ldID0gcmVuZGVySXRlbShzb3VyY2Vba2V5XSwga2V5LCBpLCBjYWNoZWQgJiYgY2FjaGVkW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmV0ID0gW107XG4gIH1cbiAgaWYgKGNhY2hlKSB7XG4gICAgY2FjaGVbaW5kZXhdID0gcmV0O1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVNsb3RzKHNsb3RzLCBkeW5hbWljU2xvdHMpIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBkeW5hbWljU2xvdHMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBzbG90ID0gZHluYW1pY1Nsb3RzW2ldO1xuICAgIGlmIChpc0FycmF5KHNsb3QpKSB7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHNsb3QubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgc2xvdHNbc2xvdFtqXS5uYW1lXSA9IHNsb3Rbal0uZm47XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChzbG90KSB7XG4gICAgICBzbG90c1tzbG90Lm5hbWVdID0gc2xvdC5rZXkgPyAoLi4uYXJncykgPT4ge1xuICAgICAgICBjb25zdCByZXMgPSBzbG90LmZuKC4uLmFyZ3MpO1xuICAgICAgICBpZiAocmVzKVxuICAgICAgICAgIHJlcy5rZXkgPSBzbG90LmtleTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgIH0gOiBzbG90LmZuO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc2xvdHM7XG59XG5cbmZ1bmN0aW9uIHJlbmRlclNsb3Qoc2xvdHMsIG5hbWUsIHByb3BzID0ge30sIGZhbGxiYWNrLCBub1Nsb3R0ZWQpIHtcbiAgaWYgKGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZS5pc0NFIHx8IGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZS5wYXJlbnQgJiYgaXNBc3luY1dyYXBwZXIoY3VycmVudFJlbmRlcmluZ0luc3RhbmNlLnBhcmVudCkgJiYgY3VycmVudFJlbmRlcmluZ0luc3RhbmNlLnBhcmVudC5pc0NFKSB7XG4gICAgaWYgKG5hbWUgIT09IFwiZGVmYXVsdFwiKVxuICAgICAgcHJvcHMubmFtZSA9IG5hbWU7XG4gICAgcmV0dXJuIGNyZWF0ZVZOb2RlKFwic2xvdFwiLCBwcm9wcywgZmFsbGJhY2sgJiYgZmFsbGJhY2soKSk7XG4gIH1cbiAgbGV0IHNsb3QgPSBzbG90c1tuYW1lXTtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgc2xvdCAmJiBzbG90Lmxlbmd0aCA+IDEpIHtcbiAgICB3YXJuKFxuICAgICAgYFNTUi1vcHRpbWl6ZWQgc2xvdCBmdW5jdGlvbiBkZXRlY3RlZCBpbiBhIG5vbi1TU1Itb3B0aW1pemVkIHJlbmRlciBmdW5jdGlvbi4gWW91IG5lZWQgdG8gbWFyayB0aGlzIGNvbXBvbmVudCB3aXRoICRkeW5hbWljLXNsb3RzIGluIHRoZSBwYXJlbnQgdGVtcGxhdGUuYFxuICAgICk7XG4gICAgc2xvdCA9ICgpID0+IFtdO1xuICB9XG4gIGlmIChzbG90ICYmIHNsb3QuX2MpIHtcbiAgICBzbG90Ll9kID0gZmFsc2U7XG4gIH1cbiAgb3BlbkJsb2NrKCk7XG4gIGNvbnN0IHZhbGlkU2xvdENvbnRlbnQgPSBzbG90ICYmIGVuc3VyZVZhbGlkVk5vZGUoc2xvdChwcm9wcykpO1xuICBjb25zdCByZW5kZXJlZCA9IGNyZWF0ZUJsb2NrKFxuICAgIEZyYWdtZW50LFxuICAgIHtcbiAgICAgIGtleTogcHJvcHMua2V5IHx8IC8vIHNsb3QgY29udGVudCBhcnJheSBvZiBhIGR5bmFtaWMgY29uZGl0aW9uYWwgc2xvdCBtYXkgaGF2ZSBhIGJyYW5jaFxuICAgICAgLy8ga2V5IGF0dGFjaGVkIGluIHRoZSBgY3JlYXRlU2xvdHNgIGhlbHBlciwgcmVzcGVjdCB0aGF0XG4gICAgICB2YWxpZFNsb3RDb250ZW50ICYmIHZhbGlkU2xvdENvbnRlbnQua2V5IHx8IGBfJHtuYW1lfWBcbiAgICB9LFxuICAgIHZhbGlkU2xvdENvbnRlbnQgfHwgKGZhbGxiYWNrID8gZmFsbGJhY2soKSA6IFtdKSxcbiAgICB2YWxpZFNsb3RDb250ZW50ICYmIHNsb3RzLl8gPT09IDEgPyA2NCA6IC0yXG4gICk7XG4gIGlmICghbm9TbG90dGVkICYmIHJlbmRlcmVkLnNjb3BlSWQpIHtcbiAgICByZW5kZXJlZC5zbG90U2NvcGVJZHMgPSBbcmVuZGVyZWQuc2NvcGVJZCArIFwiLXNcIl07XG4gIH1cbiAgaWYgKHNsb3QgJiYgc2xvdC5fYykge1xuICAgIHNsb3QuX2QgPSB0cnVlO1xuICB9XG4gIHJldHVybiByZW5kZXJlZDtcbn1cbmZ1bmN0aW9uIGVuc3VyZVZhbGlkVk5vZGUodm5vZGVzKSB7XG4gIHJldHVybiB2bm9kZXMuc29tZSgoY2hpbGQpID0+IHtcbiAgICBpZiAoIWlzVk5vZGUoY2hpbGQpKVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgaWYgKGNoaWxkLnR5cGUgPT09IENvbW1lbnQpXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKGNoaWxkLnR5cGUgPT09IEZyYWdtZW50ICYmICFlbnN1cmVWYWxpZFZOb2RlKGNoaWxkLmNoaWxkcmVuKSlcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSkgPyB2bm9kZXMgOiBudWxsO1xufVxuXG5mdW5jdGlvbiB0b0hhbmRsZXJzKG9iaiwgcHJlc2VydmVDYXNlSWZOZWNlc3NhcnkpIHtcbiAgY29uc3QgcmV0ID0ge307XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICFpc09iamVjdChvYmopKSB7XG4gICAgd2Fybihgdi1vbiB3aXRoIG5vIGFyZ3VtZW50IGV4cGVjdHMgYW4gb2JqZWN0IHZhbHVlLmApO1xuICAgIHJldHVybiByZXQ7XG4gIH1cbiAgZm9yIChjb25zdCBrZXkgaW4gb2JqKSB7XG4gICAgcmV0W3ByZXNlcnZlQ2FzZUlmTmVjZXNzYXJ5ICYmIC9bQS1aXS8udGVzdChrZXkpID8gYG9uOiR7a2V5fWAgOiB0b0hhbmRsZXJLZXkoa2V5KV0gPSBvYmpba2V5XTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG5jb25zdCBnZXRQdWJsaWNJbnN0YW5jZSA9IChpKSA9PiB7XG4gIGlmICghaSlcbiAgICByZXR1cm4gbnVsbDtcbiAgaWYgKGlzU3RhdGVmdWxDb21wb25lbnQoaSkpXG4gICAgcmV0dXJuIGdldEV4cG9zZVByb3h5KGkpIHx8IGkucHJveHk7XG4gIHJldHVybiBnZXRQdWJsaWNJbnN0YW5jZShpLnBhcmVudCk7XG59O1xuY29uc3QgcHVibGljUHJvcGVydGllc01hcCA9IChcbiAgLy8gTW92ZSBQVVJFIG1hcmtlciB0byBuZXcgbGluZSB0byB3b3JrYXJvdW5kIGNvbXBpbGVyIGRpc2NhcmRpbmcgaXRcbiAgLy8gZHVlIHRvIHR5cGUgYW5ub3RhdGlvblxuICAvKiBAX19QVVJFX18gKi8gZXh0ZW5kKC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpLCB7XG4gICAgJDogKGkpID0+IGksXG4gICAgJGVsOiAoaSkgPT4gaS52bm9kZS5lbCxcbiAgICAkZGF0YTogKGkpID0+IGkuZGF0YSxcbiAgICAkcHJvcHM6IChpKSA9PiAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gc2hhbGxvd1JlYWRvbmx5KGkucHJvcHMpIDogaS5wcm9wcyxcbiAgICAkYXR0cnM6IChpKSA9PiAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gc2hhbGxvd1JlYWRvbmx5KGkuYXR0cnMpIDogaS5hdHRycyxcbiAgICAkc2xvdHM6IChpKSA9PiAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gc2hhbGxvd1JlYWRvbmx5KGkuc2xvdHMpIDogaS5zbG90cyxcbiAgICAkcmVmczogKGkpID0+ICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyBzaGFsbG93UmVhZG9ubHkoaS5yZWZzKSA6IGkucmVmcyxcbiAgICAkcGFyZW50OiAoaSkgPT4gZ2V0UHVibGljSW5zdGFuY2UoaS5wYXJlbnQpLFxuICAgICRyb290OiAoaSkgPT4gZ2V0UHVibGljSW5zdGFuY2UoaS5yb290KSxcbiAgICAkZW1pdDogKGkpID0+IGkuZW1pdCxcbiAgICAkb3B0aW9uczogKGkpID0+IF9fVlVFX09QVElPTlNfQVBJX18gPyByZXNvbHZlTWVyZ2VkT3B0aW9ucyhpKSA6IGkudHlwZSxcbiAgICAkZm9yY2VVcGRhdGU6IChpKSA9PiBpLmYgfHwgKGkuZiA9ICgpID0+IHF1ZXVlSm9iKGkudXBkYXRlKSksXG4gICAgJG5leHRUaWNrOiAoaSkgPT4gaS5uIHx8IChpLm4gPSBuZXh0VGljay5iaW5kKGkucHJveHkpKSxcbiAgICAkd2F0Y2g6IChpKSA9PiBfX1ZVRV9PUFRJT05TX0FQSV9fID8gaW5zdGFuY2VXYXRjaC5iaW5kKGkpIDogTk9PUFxuICB9KVxuKTtcbmNvbnN0IGlzUmVzZXJ2ZWRQcmVmaXggPSAoa2V5KSA9PiBrZXkgPT09IFwiX1wiIHx8IGtleSA9PT0gXCIkXCI7XG5jb25zdCBoYXNTZXR1cEJpbmRpbmcgPSAoc3RhdGUsIGtleSkgPT4gc3RhdGUgIT09IEVNUFRZX09CSiAmJiAhc3RhdGUuX19pc1NjcmlwdFNldHVwICYmIGhhc093bihzdGF0ZSwga2V5KTtcbmNvbnN0IFB1YmxpY0luc3RhbmNlUHJveHlIYW5kbGVycyA9IHtcbiAgZ2V0KHsgXzogaW5zdGFuY2UgfSwga2V5KSB7XG4gICAgY29uc3QgeyBjdHgsIHNldHVwU3RhdGUsIGRhdGEsIHByb3BzLCBhY2Nlc3NDYWNoZSwgdHlwZSwgYXBwQ29udGV4dCB9ID0gaW5zdGFuY2U7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYga2V5ID09PSBcIl9faXNWdWVcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGxldCBub3JtYWxpemVkUHJvcHM7XG4gICAgaWYgKGtleVswXSAhPT0gXCIkXCIpIHtcbiAgICAgIGNvbnN0IG4gPSBhY2Nlc3NDYWNoZVtrZXldO1xuICAgICAgaWYgKG4gIT09IHZvaWQgMCkge1xuICAgICAgICBzd2l0Y2ggKG4pIHtcbiAgICAgICAgICBjYXNlIDEgLyogU0VUVVAgKi86XG4gICAgICAgICAgICByZXR1cm4gc2V0dXBTdGF0ZVtrZXldO1xuICAgICAgICAgIGNhc2UgMiAvKiBEQVRBICovOlxuICAgICAgICAgICAgcmV0dXJuIGRhdGFba2V5XTtcbiAgICAgICAgICBjYXNlIDQgLyogQ09OVEVYVCAqLzpcbiAgICAgICAgICAgIHJldHVybiBjdHhba2V5XTtcbiAgICAgICAgICBjYXNlIDMgLyogUFJPUFMgKi86XG4gICAgICAgICAgICByZXR1cm4gcHJvcHNba2V5XTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChoYXNTZXR1cEJpbmRpbmcoc2V0dXBTdGF0ZSwga2V5KSkge1xuICAgICAgICBhY2Nlc3NDYWNoZVtrZXldID0gMSAvKiBTRVRVUCAqLztcbiAgICAgICAgcmV0dXJuIHNldHVwU3RhdGVba2V5XTtcbiAgICAgIH0gZWxzZSBpZiAoZGF0YSAhPT0gRU1QVFlfT0JKICYmIGhhc093bihkYXRhLCBrZXkpKSB7XG4gICAgICAgIGFjY2Vzc0NhY2hlW2tleV0gPSAyIC8qIERBVEEgKi87XG4gICAgICAgIHJldHVybiBkYXRhW2tleV07XG4gICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAvLyBvbmx5IGNhY2hlIG90aGVyIHByb3BlcnRpZXMgd2hlbiBpbnN0YW5jZSBoYXMgZGVjbGFyZWQgKHRodXMgc3RhYmxlKVxuICAgICAgICAvLyBwcm9wc1xuICAgICAgICAobm9ybWFsaXplZFByb3BzID0gaW5zdGFuY2UucHJvcHNPcHRpb25zWzBdKSAmJiBoYXNPd24obm9ybWFsaXplZFByb3BzLCBrZXkpXG4gICAgICApIHtcbiAgICAgICAgYWNjZXNzQ2FjaGVba2V5XSA9IDMgLyogUFJPUFMgKi87XG4gICAgICAgIHJldHVybiBwcm9wc1trZXldO1xuICAgICAgfSBlbHNlIGlmIChjdHggIT09IEVNUFRZX09CSiAmJiBoYXNPd24oY3R4LCBrZXkpKSB7XG4gICAgICAgIGFjY2Vzc0NhY2hlW2tleV0gPSA0IC8qIENPTlRFWFQgKi87XG4gICAgICAgIHJldHVybiBjdHhba2V5XTtcbiAgICAgIH0gZWxzZSBpZiAoIV9fVlVFX09QVElPTlNfQVBJX18gfHwgc2hvdWxkQ2FjaGVBY2Nlc3MpIHtcbiAgICAgICAgYWNjZXNzQ2FjaGVba2V5XSA9IDAgLyogT1RIRVIgKi87XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHB1YmxpY0dldHRlciA9IHB1YmxpY1Byb3BlcnRpZXNNYXBba2V5XTtcbiAgICBsZXQgY3NzTW9kdWxlLCBnbG9iYWxQcm9wZXJ0aWVzO1xuICAgIGlmIChwdWJsaWNHZXR0ZXIpIHtcbiAgICAgIGlmIChrZXkgPT09IFwiJGF0dHJzXCIpIHtcbiAgICAgICAgdHJhY2soaW5zdGFuY2UsIFwiZ2V0XCIsIGtleSk7XG4gICAgICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgbWFya0F0dHJzQWNjZXNzZWQoKTtcbiAgICAgIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBrZXkgPT09IFwiJHNsb3RzXCIpIHtcbiAgICAgICAgdHJhY2soaW5zdGFuY2UsIFwiZ2V0XCIsIGtleSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcHVibGljR2V0dGVyKGluc3RhbmNlKTtcbiAgICB9IGVsc2UgaWYgKFxuICAgICAgLy8gY3NzIG1vZHVsZSAoaW5qZWN0ZWQgYnkgdnVlLWxvYWRlcilcbiAgICAgIChjc3NNb2R1bGUgPSB0eXBlLl9fY3NzTW9kdWxlcykgJiYgKGNzc01vZHVsZSA9IGNzc01vZHVsZVtrZXldKVxuICAgICkge1xuICAgICAgcmV0dXJuIGNzc01vZHVsZTtcbiAgICB9IGVsc2UgaWYgKGN0eCAhPT0gRU1QVFlfT0JKICYmIGhhc093bihjdHgsIGtleSkpIHtcbiAgICAgIGFjY2Vzc0NhY2hlW2tleV0gPSA0IC8qIENPTlRFWFQgKi87XG4gICAgICByZXR1cm4gY3R4W2tleV07XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIC8vIGdsb2JhbCBwcm9wZXJ0aWVzXG4gICAgICBnbG9iYWxQcm9wZXJ0aWVzID0gYXBwQ29udGV4dC5jb25maWcuZ2xvYmFsUHJvcGVydGllcywgaGFzT3duKGdsb2JhbFByb3BlcnRpZXMsIGtleSlcbiAgICApIHtcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuIGdsb2JhbFByb3BlcnRpZXNba2V5XTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgY3VycmVudFJlbmRlcmluZ0luc3RhbmNlICYmICghaXNTdHJpbmcoa2V5KSB8fCAvLyAjMTA5MSBhdm9pZCBpbnRlcm5hbCBpc1JlZi9pc1ZOb2RlIGNoZWNrcyBvbiBjb21wb25lbnQgaW5zdGFuY2UgbGVhZGluZ1xuICAgIC8vIHRvIGluZmluaXRlIHdhcm5pbmcgbG9vcFxuICAgIGtleS5pbmRleE9mKFwiX192XCIpICE9PSAwKSkge1xuICAgICAgaWYgKGRhdGEgIT09IEVNUFRZX09CSiAmJiBpc1Jlc2VydmVkUHJlZml4KGtleVswXSkgJiYgaGFzT3duKGRhdGEsIGtleSkpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBgUHJvcGVydHkgJHtKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICAgIGtleVxuICAgICAgICAgICl9IG11c3QgYmUgYWNjZXNzZWQgdmlhICRkYXRhIGJlY2F1c2UgaXQgc3RhcnRzIHdpdGggYSByZXNlcnZlZCBjaGFyYWN0ZXIgKFwiJFwiIG9yIFwiX1wiKSBhbmQgaXMgbm90IHByb3hpZWQgb24gdGhlIHJlbmRlciBjb250ZXh0LmBcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSBpZiAoaW5zdGFuY2UgPT09IGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIGBQcm9wZXJ0eSAke0pTT04uc3RyaW5naWZ5KGtleSl9IHdhcyBhY2Nlc3NlZCBkdXJpbmcgcmVuZGVyIGJ1dCBpcyBub3QgZGVmaW5lZCBvbiBpbnN0YW5jZS5gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBzZXQoeyBfOiBpbnN0YW5jZSB9LCBrZXksIHZhbHVlKSB7XG4gICAgY29uc3QgeyBkYXRhLCBzZXR1cFN0YXRlLCBjdHggfSA9IGluc3RhbmNlO1xuICAgIGlmIChoYXNTZXR1cEJpbmRpbmcoc2V0dXBTdGF0ZSwga2V5KSkge1xuICAgICAgc2V0dXBTdGF0ZVtrZXldID0gdmFsdWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgc2V0dXBTdGF0ZS5fX2lzU2NyaXB0U2V0dXAgJiYgaGFzT3duKHNldHVwU3RhdGUsIGtleSkpIHtcbiAgICAgIHdhcm4oYENhbm5vdCBtdXRhdGUgPHNjcmlwdCBzZXR1cD4gYmluZGluZyBcIiR7a2V5fVwiIGZyb20gT3B0aW9ucyBBUEkuYCk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIGlmIChkYXRhICE9PSBFTVBUWV9PQkogJiYgaGFzT3duKGRhdGEsIGtleSkpIHtcbiAgICAgIGRhdGFba2V5XSA9IHZhbHVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmIChoYXNPd24oaW5zdGFuY2UucHJvcHMsIGtleSkpIHtcbiAgICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgd2FybihgQXR0ZW1wdGluZyB0byBtdXRhdGUgcHJvcCBcIiR7a2V5fVwiLiBQcm9wcyBhcmUgcmVhZG9ubHkuYCk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChrZXlbMF0gPT09IFwiJFwiICYmIGtleS5zbGljZSgxKSBpbiBpbnN0YW5jZSkge1xuICAgICAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiB3YXJuKFxuICAgICAgICBgQXR0ZW1wdGluZyB0byBtdXRhdGUgcHVibGljIHByb3BlcnR5IFwiJHtrZXl9XCIuIFByb3BlcnRpZXMgc3RhcnRpbmcgd2l0aCAkIGFyZSByZXNlcnZlZCBhbmQgcmVhZG9ubHkuYFxuICAgICAgKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYga2V5IGluIGluc3RhbmNlLmFwcENvbnRleHQuY29uZmlnLmdsb2JhbFByb3BlcnRpZXMpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN0eCwga2V5LCB7XG4gICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgdmFsdWVcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdHhba2V5XSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSxcbiAgaGFzKHtcbiAgICBfOiB7IGRhdGEsIHNldHVwU3RhdGUsIGFjY2Vzc0NhY2hlLCBjdHgsIGFwcENvbnRleHQsIHByb3BzT3B0aW9ucyB9XG4gIH0sIGtleSkge1xuICAgIGxldCBub3JtYWxpemVkUHJvcHM7XG4gICAgcmV0dXJuICEhYWNjZXNzQ2FjaGVba2V5XSB8fCBkYXRhICE9PSBFTVBUWV9PQkogJiYgaGFzT3duKGRhdGEsIGtleSkgfHwgaGFzU2V0dXBCaW5kaW5nKHNldHVwU3RhdGUsIGtleSkgfHwgKG5vcm1hbGl6ZWRQcm9wcyA9IHByb3BzT3B0aW9uc1swXSkgJiYgaGFzT3duKG5vcm1hbGl6ZWRQcm9wcywga2V5KSB8fCBoYXNPd24oY3R4LCBrZXkpIHx8IGhhc093bihwdWJsaWNQcm9wZXJ0aWVzTWFwLCBrZXkpIHx8IGhhc093bihhcHBDb250ZXh0LmNvbmZpZy5nbG9iYWxQcm9wZXJ0aWVzLCBrZXkpO1xuICB9LFxuICBkZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgZGVzY3JpcHRvcikge1xuICAgIGlmIChkZXNjcmlwdG9yLmdldCAhPSBudWxsKSB7XG4gICAgICB0YXJnZXQuXy5hY2Nlc3NDYWNoZVtrZXldID0gMDtcbiAgICB9IGVsc2UgaWYgKGhhc093bihkZXNjcmlwdG9yLCBcInZhbHVlXCIpKSB7XG4gICAgICB0aGlzLnNldCh0YXJnZXQsIGtleSwgZGVzY3JpcHRvci52YWx1ZSwgbnVsbCk7XG4gICAgfVxuICAgIHJldHVybiBSZWZsZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBkZXNjcmlwdG9yKTtcbiAgfVxufTtcbmlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHRydWUpIHtcbiAgUHVibGljSW5zdGFuY2VQcm94eUhhbmRsZXJzLm93bktleXMgPSAodGFyZ2V0KSA9PiB7XG4gICAgd2FybihcbiAgICAgIGBBdm9pZCBhcHAgbG9naWMgdGhhdCByZWxpZXMgb24gZW51bWVyYXRpbmcga2V5cyBvbiBhIGNvbXBvbmVudCBpbnN0YW5jZS4gVGhlIGtleXMgd2lsbCBiZSBlbXB0eSBpbiBwcm9kdWN0aW9uIG1vZGUgdG8gYXZvaWQgcGVyZm9ybWFuY2Ugb3ZlcmhlYWQuYFxuICAgICk7XG4gICAgcmV0dXJuIFJlZmxlY3Qub3duS2V5cyh0YXJnZXQpO1xuICB9O1xufVxuY29uc3QgUnVudGltZUNvbXBpbGVkUHVibGljSW5zdGFuY2VQcm94eUhhbmRsZXJzID0gLyogQF9fUFVSRV9fICovIGV4dGVuZChcbiAge30sXG4gIFB1YmxpY0luc3RhbmNlUHJveHlIYW5kbGVycyxcbiAge1xuICAgIGdldCh0YXJnZXQsIGtleSkge1xuICAgICAgaWYgKGtleSA9PT0gU3ltYm9sLnVuc2NvcGFibGVzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBQdWJsaWNJbnN0YW5jZVByb3h5SGFuZGxlcnMuZ2V0KHRhcmdldCwga2V5LCB0YXJnZXQpO1xuICAgIH0sXG4gICAgaGFzKF8sIGtleSkge1xuICAgICAgY29uc3QgaGFzID0ga2V5WzBdICE9PSBcIl9cIiAmJiAhaXNHbG9iYWxseVdoaXRlbGlzdGVkKGtleSk7XG4gICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhaGFzICYmIFB1YmxpY0luc3RhbmNlUHJveHlIYW5kbGVycy5oYXMoXywga2V5KSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIGBQcm9wZXJ0eSAke0pTT04uc3RyaW5naWZ5KFxuICAgICAgICAgICAga2V5XG4gICAgICAgICAgKX0gc2hvdWxkIG5vdCBzdGFydCB3aXRoIF8gd2hpY2ggaXMgYSByZXNlcnZlZCBwcmVmaXggZm9yIFZ1ZSBpbnRlcm5hbHMuYFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGhhcztcbiAgICB9XG4gIH1cbik7XG5mdW5jdGlvbiBjcmVhdGVEZXZSZW5kZXJDb250ZXh0KGluc3RhbmNlKSB7XG4gIGNvbnN0IHRhcmdldCA9IHt9O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBgX2AsIHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgZ2V0OiAoKSA9PiBpbnN0YW5jZVxuICB9KTtcbiAgT2JqZWN0LmtleXMocHVibGljUHJvcGVydGllc01hcCkuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCB7XG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIGdldDogKCkgPT4gcHVibGljUHJvcGVydGllc01hcFtrZXldKGluc3RhbmNlKSxcbiAgICAgIC8vIGludGVyY2VwdGVkIGJ5IHRoZSBwcm94eSBzbyBubyBuZWVkIGZvciBpbXBsZW1lbnRhdGlvbixcbiAgICAgIC8vIGJ1dCBuZWVkZWQgdG8gcHJldmVudCBzZXQgZXJyb3JzXG4gICAgICBzZXQ6IE5PT1BcbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiB0YXJnZXQ7XG59XG5mdW5jdGlvbiBleHBvc2VQcm9wc09uUmVuZGVyQ29udGV4dChpbnN0YW5jZSkge1xuICBjb25zdCB7XG4gICAgY3R4LFxuICAgIHByb3BzT3B0aW9uczogW3Byb3BzT3B0aW9uc11cbiAgfSA9IGluc3RhbmNlO1xuICBpZiAocHJvcHNPcHRpb25zKSB7XG4gICAgT2JqZWN0LmtleXMocHJvcHNPcHRpb25zKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdHgsIGtleSwge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGdldDogKCkgPT4gaW5zdGFuY2UucHJvcHNba2V5XSxcbiAgICAgICAgc2V0OiBOT09QXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gZXhwb3NlU2V0dXBTdGF0ZU9uUmVuZGVyQ29udGV4dChpbnN0YW5jZSkge1xuICBjb25zdCB7IGN0eCwgc2V0dXBTdGF0ZSB9ID0gaW5zdGFuY2U7XG4gIE9iamVjdC5rZXlzKHRvUmF3KHNldHVwU3RhdGUpKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICBpZiAoIXNldHVwU3RhdGUuX19pc1NjcmlwdFNldHVwKSB7XG4gICAgICBpZiAoaXNSZXNlcnZlZFByZWZpeChrZXlbMF0pKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgYHNldHVwKCkgcmV0dXJuIHByb3BlcnR5ICR7SlNPTi5zdHJpbmdpZnkoXG4gICAgICAgICAgICBrZXlcbiAgICAgICAgICApfSBzaG91bGQgbm90IHN0YXJ0IHdpdGggXCIkXCIgb3IgXCJfXCIgd2hpY2ggYXJlIHJlc2VydmVkIHByZWZpeGVzIGZvciBWdWUgaW50ZXJuYWxzLmBcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN0eCwga2V5LCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiAoKSA9PiBzZXR1cFN0YXRlW2tleV0sXG4gICAgICAgIHNldDogTk9PUFxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbn1cblxuY29uc3Qgd2FyblJ1bnRpbWVVc2FnZSA9IChtZXRob2QpID0+IHdhcm4oXG4gIGAke21ldGhvZH0oKSBpcyBhIGNvbXBpbGVyLWhpbnQgaGVscGVyIHRoYXQgaXMgb25seSB1c2FibGUgaW5zaWRlIDxzY3JpcHQgc2V0dXA+IG9mIGEgc2luZ2xlIGZpbGUgY29tcG9uZW50LiBJdHMgYXJndW1lbnRzIHNob3VsZCBiZSBjb21waWxlZCBhd2F5IGFuZCBwYXNzaW5nIGl0IGF0IHJ1bnRpbWUgaGFzIG5vIGVmZmVjdC5gXG4pO1xuZnVuY3Rpb24gZGVmaW5lUHJvcHMoKSB7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgd2FyblJ1bnRpbWVVc2FnZShgZGVmaW5lUHJvcHNgKTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGRlZmluZUVtaXRzKCkge1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIHdhcm5SdW50aW1lVXNhZ2UoYGRlZmluZUVtaXRzYCk7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBkZWZpbmVFeHBvc2UoZXhwb3NlZCkge1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIHdhcm5SdW50aW1lVXNhZ2UoYGRlZmluZUV4cG9zZWApO1xuICB9XG59XG5mdW5jdGlvbiBkZWZpbmVPcHRpb25zKG9wdGlvbnMpIHtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICB3YXJuUnVudGltZVVzYWdlKGBkZWZpbmVPcHRpb25zYCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGRlZmluZVNsb3RzKCkge1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIHdhcm5SdW50aW1lVXNhZ2UoYGRlZmluZVNsb3RzYCk7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBkZWZpbmVNb2RlbCgpIHtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICB3YXJuUnVudGltZVVzYWdlKFwiZGVmaW5lTW9kZWxcIik7XG4gIH1cbn1cbmZ1bmN0aW9uIHdpdGhEZWZhdWx0cyhwcm9wcywgZGVmYXVsdHMpIHtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICB3YXJuUnVudGltZVVzYWdlKGB3aXRoRGVmYXVsdHNgKTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIHVzZVNsb3RzKCkge1xuICByZXR1cm4gZ2V0Q29udGV4dCgpLnNsb3RzO1xufVxuZnVuY3Rpb24gdXNlQXR0cnMoKSB7XG4gIHJldHVybiBnZXRDb250ZXh0KCkuYXR0cnM7XG59XG5mdW5jdGlvbiB1c2VNb2RlbChwcm9wcywgbmFtZSwgb3B0aW9ucykge1xuICBjb25zdCBpID0gZ2V0Q3VycmVudEluc3RhbmNlKCk7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICFpKSB7XG4gICAgd2FybihgdXNlTW9kZWwoKSBjYWxsZWQgd2l0aG91dCBhY3RpdmUgaW5zdGFuY2UuYCk7XG4gICAgcmV0dXJuIHJlZigpO1xuICB9XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICFpLnByb3BzT3B0aW9uc1swXVtuYW1lXSkge1xuICAgIHdhcm4oYHVzZU1vZGVsKCkgY2FsbGVkIHdpdGggcHJvcCBcIiR7bmFtZX1cIiB3aGljaCBpcyBub3QgZGVjbGFyZWQuYCk7XG4gICAgcmV0dXJuIHJlZigpO1xuICB9XG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMubG9jYWwpIHtcbiAgICBjb25zdCBwcm94eSA9IHJlZihwcm9wc1tuYW1lXSk7XG4gICAgd2F0Y2goXG4gICAgICAoKSA9PiBwcm9wc1tuYW1lXSxcbiAgICAgICh2KSA9PiBwcm94eS52YWx1ZSA9IHZcbiAgICApO1xuICAgIHdhdGNoKHByb3h5LCAodmFsdWUpID0+IHtcbiAgICAgIGlmICh2YWx1ZSAhPT0gcHJvcHNbbmFtZV0pIHtcbiAgICAgICAgaS5lbWl0KGB1cGRhdGU6JHtuYW1lfWAsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcHJveHk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIF9fdl9pc1JlZjogdHJ1ZSxcbiAgICAgIGdldCB2YWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIHByb3BzW25hbWVdO1xuICAgICAgfSxcbiAgICAgIHNldCB2YWx1ZSh2YWx1ZSkge1xuICAgICAgICBpLmVtaXQoYHVwZGF0ZToke25hbWV9YCwgdmFsdWUpO1xuICAgICAgfVxuICAgIH07XG4gIH1cbn1cbmZ1bmN0aW9uIGdldENvbnRleHQoKSB7XG4gIGNvbnN0IGkgPSBnZXRDdXJyZW50SW5zdGFuY2UoKTtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgIWkpIHtcbiAgICB3YXJuKGB1c2VDb250ZXh0KCkgY2FsbGVkIHdpdGhvdXQgYWN0aXZlIGluc3RhbmNlLmApO1xuICB9XG4gIHJldHVybiBpLnNldHVwQ29udGV4dCB8fCAoaS5zZXR1cENvbnRleHQgPSBjcmVhdGVTZXR1cENvbnRleHQoaSkpO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplUHJvcHNPckVtaXRzKHByb3BzKSB7XG4gIHJldHVybiBpc0FycmF5KHByb3BzKSA/IHByb3BzLnJlZHVjZShcbiAgICAobm9ybWFsaXplZCwgcCkgPT4gKG5vcm1hbGl6ZWRbcF0gPSBudWxsLCBub3JtYWxpemVkKSxcbiAgICB7fVxuICApIDogcHJvcHM7XG59XG5mdW5jdGlvbiBtZXJnZURlZmF1bHRzKHJhdywgZGVmYXVsdHMpIHtcbiAgY29uc3QgcHJvcHMgPSBub3JtYWxpemVQcm9wc09yRW1pdHMocmF3KTtcbiAgZm9yIChjb25zdCBrZXkgaW4gZGVmYXVsdHMpIHtcbiAgICBpZiAoa2V5LnN0YXJ0c1dpdGgoXCJfX3NraXBcIikpXG4gICAgICBjb250aW51ZTtcbiAgICBsZXQgb3B0ID0gcHJvcHNba2V5XTtcbiAgICBpZiAob3B0KSB7XG4gICAgICBpZiAoaXNBcnJheShvcHQpIHx8IGlzRnVuY3Rpb24ob3B0KSkge1xuICAgICAgICBvcHQgPSBwcm9wc1trZXldID0geyB0eXBlOiBvcHQsIGRlZmF1bHQ6IGRlZmF1bHRzW2tleV0gfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9wdC5kZWZhdWx0ID0gZGVmYXVsdHNba2V5XTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG9wdCA9PT0gbnVsbCkge1xuICAgICAgb3B0ID0gcHJvcHNba2V5XSA9IHsgZGVmYXVsdDogZGVmYXVsdHNba2V5XSB9O1xuICAgIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgd2FybihgcHJvcHMgZGVmYXVsdCBrZXkgXCIke2tleX1cIiBoYXMgbm8gY29ycmVzcG9uZGluZyBkZWNsYXJhdGlvbi5gKTtcbiAgICB9XG4gICAgaWYgKG9wdCAmJiBkZWZhdWx0c1tgX19za2lwXyR7a2V5fWBdKSB7XG4gICAgICBvcHQuc2tpcEZhY3RvcnkgPSB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcHJvcHM7XG59XG5mdW5jdGlvbiBtZXJnZU1vZGVscyhhLCBiKSB7XG4gIGlmICghYSB8fCAhYilcbiAgICByZXR1cm4gYSB8fCBiO1xuICBpZiAoaXNBcnJheShhKSAmJiBpc0FycmF5KGIpKVxuICAgIHJldHVybiBhLmNvbmNhdChiKTtcbiAgcmV0dXJuIGV4dGVuZCh7fSwgbm9ybWFsaXplUHJvcHNPckVtaXRzKGEpLCBub3JtYWxpemVQcm9wc09yRW1pdHMoYikpO1xufVxuZnVuY3Rpb24gY3JlYXRlUHJvcHNSZXN0UHJveHkocHJvcHMsIGV4Y2x1ZGVkS2V5cykge1xuICBjb25zdCByZXQgPSB7fTtcbiAgZm9yIChjb25zdCBrZXkgaW4gcHJvcHMpIHtcbiAgICBpZiAoIWV4Y2x1ZGVkS2V5cy5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocmV0LCBrZXksIHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiAoKSA9PiBwcm9wc1trZXldXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cbmZ1bmN0aW9uIHdpdGhBc3luY0NvbnRleHQoZ2V0QXdhaXRhYmxlKSB7XG4gIGNvbnN0IGN0eCA9IGdldEN1cnJlbnRJbnN0YW5jZSgpO1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhY3R4KSB7XG4gICAgd2FybihcbiAgICAgIGB3aXRoQXN5bmNDb250ZXh0IGNhbGxlZCB3aXRob3V0IGFjdGl2ZSBjdXJyZW50IGluc3RhbmNlLiBUaGlzIGlzIGxpa2VseSBhIGJ1Zy5gXG4gICAgKTtcbiAgfVxuICBsZXQgYXdhaXRhYmxlID0gZ2V0QXdhaXRhYmxlKCk7XG4gIHVuc2V0Q3VycmVudEluc3RhbmNlKCk7XG4gIGlmIChpc1Byb21pc2UoYXdhaXRhYmxlKSkge1xuICAgIGF3YWl0YWJsZSA9IGF3YWl0YWJsZS5jYXRjaCgoZSkgPT4ge1xuICAgICAgc2V0Q3VycmVudEluc3RhbmNlKGN0eCk7XG4gICAgICB0aHJvdyBlO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBbYXdhaXRhYmxlLCAoKSA9PiBzZXRDdXJyZW50SW5zdGFuY2UoY3R4KV07XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUR1cGxpY2F0ZUNoZWNrZXIoKSB7XG4gIGNvbnN0IGNhY2hlID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHJldHVybiAodHlwZSwga2V5KSA9PiB7XG4gICAgaWYgKGNhY2hlW2tleV0pIHtcbiAgICAgIHdhcm4oYCR7dHlwZX0gcHJvcGVydHkgXCIke2tleX1cIiBpcyBhbHJlYWR5IGRlZmluZWQgaW4gJHtjYWNoZVtrZXldfS5gKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2FjaGVba2V5XSA9IHR5cGU7XG4gICAgfVxuICB9O1xufVxubGV0IHNob3VsZENhY2hlQWNjZXNzID0gdHJ1ZTtcbmZ1bmN0aW9uIGFwcGx5T3B0aW9ucyhpbnN0YW5jZSkge1xuICBjb25zdCBvcHRpb25zID0gcmVzb2x2ZU1lcmdlZE9wdGlvbnMoaW5zdGFuY2UpO1xuICBjb25zdCBwdWJsaWNUaGlzID0gaW5zdGFuY2UucHJveHk7XG4gIGNvbnN0IGN0eCA9IGluc3RhbmNlLmN0eDtcbiAgc2hvdWxkQ2FjaGVBY2Nlc3MgPSBmYWxzZTtcbiAgaWYgKG9wdGlvbnMuYmVmb3JlQ3JlYXRlKSB7XG4gICAgY2FsbEhvb2sob3B0aW9ucy5iZWZvcmVDcmVhdGUsIGluc3RhbmNlLCBcImJjXCIpO1xuICB9XG4gIGNvbnN0IHtcbiAgICAvLyBzdGF0ZVxuICAgIGRhdGE6IGRhdGFPcHRpb25zLFxuICAgIGNvbXB1dGVkOiBjb21wdXRlZE9wdGlvbnMsXG4gICAgbWV0aG9kcyxcbiAgICB3YXRjaDogd2F0Y2hPcHRpb25zLFxuICAgIHByb3ZpZGU6IHByb3ZpZGVPcHRpb25zLFxuICAgIGluamVjdDogaW5qZWN0T3B0aW9ucyxcbiAgICAvLyBsaWZlY3ljbGVcbiAgICBjcmVhdGVkLFxuICAgIGJlZm9yZU1vdW50LFxuICAgIG1vdW50ZWQsXG4gICAgYmVmb3JlVXBkYXRlLFxuICAgIHVwZGF0ZWQsXG4gICAgYWN0aXZhdGVkLFxuICAgIGRlYWN0aXZhdGVkLFxuICAgIGJlZm9yZURlc3Ryb3ksXG4gICAgYmVmb3JlVW5tb3VudCxcbiAgICBkZXN0cm95ZWQsXG4gICAgdW5tb3VudGVkLFxuICAgIHJlbmRlcixcbiAgICByZW5kZXJUcmFja2VkLFxuICAgIHJlbmRlclRyaWdnZXJlZCxcbiAgICBlcnJvckNhcHR1cmVkLFxuICAgIHNlcnZlclByZWZldGNoLFxuICAgIC8vIHB1YmxpYyBBUElcbiAgICBleHBvc2UsXG4gICAgaW5oZXJpdEF0dHJzLFxuICAgIC8vIGFzc2V0c1xuICAgIGNvbXBvbmVudHMsXG4gICAgZGlyZWN0aXZlcyxcbiAgICBmaWx0ZXJzXG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCBjaGVja0R1cGxpY2F0ZVByb3BlcnRpZXMgPSAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gY3JlYXRlRHVwbGljYXRlQ2hlY2tlcigpIDogbnVsbDtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICBjb25zdCBbcHJvcHNPcHRpb25zXSA9IGluc3RhbmNlLnByb3BzT3B0aW9ucztcbiAgICBpZiAocHJvcHNPcHRpb25zKSB7XG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiBwcm9wc09wdGlvbnMpIHtcbiAgICAgICAgY2hlY2tEdXBsaWNhdGVQcm9wZXJ0aWVzKFwiUHJvcHNcIiAvKiBQUk9QUyAqLywga2V5KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKGluamVjdE9wdGlvbnMpIHtcbiAgICByZXNvbHZlSW5qZWN0aW9ucyhpbmplY3RPcHRpb25zLCBjdHgsIGNoZWNrRHVwbGljYXRlUHJvcGVydGllcyk7XG4gIH1cbiAgaWYgKG1ldGhvZHMpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBtZXRob2RzKSB7XG4gICAgICBjb25zdCBtZXRob2RIYW5kbGVyID0gbWV0aG9kc1trZXldO1xuICAgICAgaWYgKGlzRnVuY3Rpb24obWV0aG9kSGFuZGxlcikpIHtcbiAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3R4LCBrZXksIHtcbiAgICAgICAgICAgIHZhbHVlOiBtZXRob2RIYW5kbGVyLmJpbmQocHVibGljVGhpcyksXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjdHhba2V5XSA9IG1ldGhvZEhhbmRsZXIuYmluZChwdWJsaWNUaGlzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgIGNoZWNrRHVwbGljYXRlUHJvcGVydGllcyhcIk1ldGhvZHNcIiAvKiBNRVRIT0RTICovLCBrZXkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBgTWV0aG9kIFwiJHtrZXl9XCIgaGFzIHR5cGUgXCIke3R5cGVvZiBtZXRob2RIYW5kbGVyfVwiIGluIHRoZSBjb21wb25lbnQgZGVmaW5pdGlvbi4gRGlkIHlvdSByZWZlcmVuY2UgdGhlIGZ1bmN0aW9uIGNvcnJlY3RseT9gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChkYXRhT3B0aW9ucykge1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICFpc0Z1bmN0aW9uKGRhdGFPcHRpb25zKSkge1xuICAgICAgd2FybihcbiAgICAgICAgYFRoZSBkYXRhIG9wdGlvbiBtdXN0IGJlIGEgZnVuY3Rpb24uIFBsYWluIG9iamVjdCB1c2FnZSBpcyBubyBsb25nZXIgc3VwcG9ydGVkLmBcbiAgICAgICk7XG4gICAgfVxuICAgIGNvbnN0IGRhdGEgPSBkYXRhT3B0aW9ucy5jYWxsKHB1YmxpY1RoaXMsIHB1YmxpY1RoaXMpO1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGlzUHJvbWlzZShkYXRhKSkge1xuICAgICAgd2FybihcbiAgICAgICAgYGRhdGEoKSByZXR1cm5lZCBhIFByb21pc2UgLSBub3RlIGRhdGEoKSBjYW5ub3QgYmUgYXN5bmM7IElmIHlvdSBpbnRlbmQgdG8gcGVyZm9ybSBkYXRhIGZldGNoaW5nIGJlZm9yZSBjb21wb25lbnQgcmVuZGVycywgdXNlIGFzeW5jIHNldHVwKCkgKyA8U3VzcGVuc2U+LmBcbiAgICAgICk7XG4gICAgfVxuICAgIGlmICghaXNPYmplY3QoZGF0YSkpIHtcbiAgICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgd2FybihgZGF0YSgpIHNob3VsZCByZXR1cm4gYW4gb2JqZWN0LmApO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbnN0YW5jZS5kYXRhID0gcmVhY3RpdmUoZGF0YSk7XG4gICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBkYXRhKSB7XG4gICAgICAgICAgY2hlY2tEdXBsaWNhdGVQcm9wZXJ0aWVzKFwiRGF0YVwiIC8qIERBVEEgKi8sIGtleSk7XG4gICAgICAgICAgaWYgKCFpc1Jlc2VydmVkUHJlZml4KGtleVswXSkpIHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdHgsIGtleSwge1xuICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgIGdldDogKCkgPT4gZGF0YVtrZXldLFxuICAgICAgICAgICAgICBzZXQ6IE5PT1BcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBzaG91bGRDYWNoZUFjY2VzcyA9IHRydWU7XG4gIGlmIChjb21wdXRlZE9wdGlvbnMpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBjb21wdXRlZE9wdGlvbnMpIHtcbiAgICAgIGNvbnN0IG9wdCA9IGNvbXB1dGVkT3B0aW9uc1trZXldO1xuICAgICAgY29uc3QgZ2V0ID0gaXNGdW5jdGlvbihvcHQpID8gb3B0LmJpbmQocHVibGljVGhpcywgcHVibGljVGhpcykgOiBpc0Z1bmN0aW9uKG9wdC5nZXQpID8gb3B0LmdldC5iaW5kKHB1YmxpY1RoaXMsIHB1YmxpY1RoaXMpIDogTk9PUDtcbiAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGdldCA9PT0gTk9PUCkge1xuICAgICAgICB3YXJuKGBDb21wdXRlZCBwcm9wZXJ0eSBcIiR7a2V5fVwiIGhhcyBubyBnZXR0ZXIuYCk7XG4gICAgICB9XG4gICAgICBjb25zdCBzZXQgPSAhaXNGdW5jdGlvbihvcHQpICYmIGlzRnVuY3Rpb24ob3B0LnNldCkgPyBvcHQuc2V0LmJpbmQocHVibGljVGhpcykgOiAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gKCkgPT4ge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIGBXcml0ZSBvcGVyYXRpb24gZmFpbGVkOiBjb21wdXRlZCBwcm9wZXJ0eSBcIiR7a2V5fVwiIGlzIHJlYWRvbmx5LmBcbiAgICAgICAgKTtcbiAgICAgIH0gOiBOT09QO1xuICAgICAgY29uc3QgYyA9IGNvbXB1dGVkKHtcbiAgICAgICAgZ2V0LFxuICAgICAgICBzZXRcbiAgICAgIH0pO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN0eCwga2V5LCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiAoKSA9PiBjLnZhbHVlLFxuICAgICAgICBzZXQ6ICh2KSA9PiBjLnZhbHVlID0gdlxuICAgICAgfSk7XG4gICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICBjaGVja0R1cGxpY2F0ZVByb3BlcnRpZXMoXCJDb21wdXRlZFwiIC8qIENPTVBVVEVEICovLCBrZXkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAod2F0Y2hPcHRpb25zKSB7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gd2F0Y2hPcHRpb25zKSB7XG4gICAgICBjcmVhdGVXYXRjaGVyKHdhdGNoT3B0aW9uc1trZXldLCBjdHgsIHB1YmxpY1RoaXMsIGtleSk7XG4gICAgfVxuICB9XG4gIGlmIChwcm92aWRlT3B0aW9ucykge1xuICAgIGNvbnN0IHByb3ZpZGVzID0gaXNGdW5jdGlvbihwcm92aWRlT3B0aW9ucykgPyBwcm92aWRlT3B0aW9ucy5jYWxsKHB1YmxpY1RoaXMpIDogcHJvdmlkZU9wdGlvbnM7XG4gICAgUmVmbGVjdC5vd25LZXlzKHByb3ZpZGVzKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgIHByb3ZpZGUoa2V5LCBwcm92aWRlc1trZXldKTtcbiAgICB9KTtcbiAgfVxuICBpZiAoY3JlYXRlZCkge1xuICAgIGNhbGxIb29rKGNyZWF0ZWQsIGluc3RhbmNlLCBcImNcIik7XG4gIH1cbiAgZnVuY3Rpb24gcmVnaXN0ZXJMaWZlY3ljbGVIb29rKHJlZ2lzdGVyLCBob29rKSB7XG4gICAgaWYgKGlzQXJyYXkoaG9vaykpIHtcbiAgICAgIGhvb2suZm9yRWFjaCgoX2hvb2spID0+IHJlZ2lzdGVyKF9ob29rLmJpbmQocHVibGljVGhpcykpKTtcbiAgICB9IGVsc2UgaWYgKGhvb2spIHtcbiAgICAgIHJlZ2lzdGVyKGhvb2suYmluZChwdWJsaWNUaGlzKSk7XG4gICAgfVxuICB9XG4gIHJlZ2lzdGVyTGlmZWN5Y2xlSG9vayhvbkJlZm9yZU1vdW50LCBiZWZvcmVNb3VudCk7XG4gIHJlZ2lzdGVyTGlmZWN5Y2xlSG9vayhvbk1vdW50ZWQsIG1vdW50ZWQpO1xuICByZWdpc3RlckxpZmVjeWNsZUhvb2sob25CZWZvcmVVcGRhdGUsIGJlZm9yZVVwZGF0ZSk7XG4gIHJlZ2lzdGVyTGlmZWN5Y2xlSG9vayhvblVwZGF0ZWQsIHVwZGF0ZWQpO1xuICByZWdpc3RlckxpZmVjeWNsZUhvb2sob25BY3RpdmF0ZWQsIGFjdGl2YXRlZCk7XG4gIHJlZ2lzdGVyTGlmZWN5Y2xlSG9vayhvbkRlYWN0aXZhdGVkLCBkZWFjdGl2YXRlZCk7XG4gIHJlZ2lzdGVyTGlmZWN5Y2xlSG9vayhvbkVycm9yQ2FwdHVyZWQsIGVycm9yQ2FwdHVyZWQpO1xuICByZWdpc3RlckxpZmVjeWNsZUhvb2sob25SZW5kZXJUcmFja2VkLCByZW5kZXJUcmFja2VkKTtcbiAgcmVnaXN0ZXJMaWZlY3ljbGVIb29rKG9uUmVuZGVyVHJpZ2dlcmVkLCByZW5kZXJUcmlnZ2VyZWQpO1xuICByZWdpc3RlckxpZmVjeWNsZUhvb2sob25CZWZvcmVVbm1vdW50LCBiZWZvcmVVbm1vdW50KTtcbiAgcmVnaXN0ZXJMaWZlY3ljbGVIb29rKG9uVW5tb3VudGVkLCB1bm1vdW50ZWQpO1xuICByZWdpc3RlckxpZmVjeWNsZUhvb2sob25TZXJ2ZXJQcmVmZXRjaCwgc2VydmVyUHJlZmV0Y2gpO1xuICBpZiAoaXNBcnJheShleHBvc2UpKSB7XG4gICAgaWYgKGV4cG9zZS5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IGV4cG9zZWQgPSBpbnN0YW5jZS5leHBvc2VkIHx8IChpbnN0YW5jZS5leHBvc2VkID0ge30pO1xuICAgICAgZXhwb3NlLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3NlZCwga2V5LCB7XG4gICAgICAgICAgZ2V0OiAoKSA9PiBwdWJsaWNUaGlzW2tleV0sXG4gICAgICAgICAgc2V0OiAodmFsKSA9PiBwdWJsaWNUaGlzW2tleV0gPSB2YWxcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKCFpbnN0YW5jZS5leHBvc2VkKSB7XG4gICAgICBpbnN0YW5jZS5leHBvc2VkID0ge307XG4gICAgfVxuICB9XG4gIGlmIChyZW5kZXIgJiYgaW5zdGFuY2UucmVuZGVyID09PSBOT09QKSB7XG4gICAgaW5zdGFuY2UucmVuZGVyID0gcmVuZGVyO1xuICB9XG4gIGlmIChpbmhlcml0QXR0cnMgIT0gbnVsbCkge1xuICAgIGluc3RhbmNlLmluaGVyaXRBdHRycyA9IGluaGVyaXRBdHRycztcbiAgfVxuICBpZiAoY29tcG9uZW50cylcbiAgICBpbnN0YW5jZS5jb21wb25lbnRzID0gY29tcG9uZW50cztcbiAgaWYgKGRpcmVjdGl2ZXMpXG4gICAgaW5zdGFuY2UuZGlyZWN0aXZlcyA9IGRpcmVjdGl2ZXM7XG59XG5mdW5jdGlvbiByZXNvbHZlSW5qZWN0aW9ucyhpbmplY3RPcHRpb25zLCBjdHgsIGNoZWNrRHVwbGljYXRlUHJvcGVydGllcyA9IE5PT1ApIHtcbiAgaWYgKGlzQXJyYXkoaW5qZWN0T3B0aW9ucykpIHtcbiAgICBpbmplY3RPcHRpb25zID0gbm9ybWFsaXplSW5qZWN0KGluamVjdE9wdGlvbnMpO1xuICB9XG4gIGZvciAoY29uc3Qga2V5IGluIGluamVjdE9wdGlvbnMpIHtcbiAgICBjb25zdCBvcHQgPSBpbmplY3RPcHRpb25zW2tleV07XG4gICAgbGV0IGluamVjdGVkO1xuICAgIGlmIChpc09iamVjdChvcHQpKSB7XG4gICAgICBpZiAoXCJkZWZhdWx0XCIgaW4gb3B0KSB7XG4gICAgICAgIGluamVjdGVkID0gaW5qZWN0KFxuICAgICAgICAgIG9wdC5mcm9tIHx8IGtleSxcbiAgICAgICAgICBvcHQuZGVmYXVsdCxcbiAgICAgICAgICB0cnVlXG4gICAgICAgICAgLyogdHJlYXQgZGVmYXVsdCBmdW5jdGlvbiBhcyBmYWN0b3J5ICovXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbmplY3RlZCA9IGluamVjdChvcHQuZnJvbSB8fCBrZXkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpbmplY3RlZCA9IGluamVjdChvcHQpO1xuICAgIH1cbiAgICBpZiAoaXNSZWYoaW5qZWN0ZWQpKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3R4LCBrZXksIHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6ICgpID0+IGluamVjdGVkLnZhbHVlLFxuICAgICAgICBzZXQ6ICh2KSA9PiBpbmplY3RlZC52YWx1ZSA9IHZcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdHhba2V5XSA9IGluamVjdGVkO1xuICAgIH1cbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgY2hlY2tEdXBsaWNhdGVQcm9wZXJ0aWVzKFwiSW5qZWN0XCIgLyogSU5KRUNUICovLCBrZXkpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gY2FsbEhvb2soaG9vaywgaW5zdGFuY2UsIHR5cGUpIHtcbiAgY2FsbFdpdGhBc3luY0Vycm9ySGFuZGxpbmcoXG4gICAgaXNBcnJheShob29rKSA/IGhvb2subWFwKChoKSA9PiBoLmJpbmQoaW5zdGFuY2UucHJveHkpKSA6IGhvb2suYmluZChpbnN0YW5jZS5wcm94eSksXG4gICAgaW5zdGFuY2UsXG4gICAgdHlwZVxuICApO1xufVxuZnVuY3Rpb24gY3JlYXRlV2F0Y2hlcihyYXcsIGN0eCwgcHVibGljVGhpcywga2V5KSB7XG4gIGNvbnN0IGdldHRlciA9IGtleS5pbmNsdWRlcyhcIi5cIikgPyBjcmVhdGVQYXRoR2V0dGVyKHB1YmxpY1RoaXMsIGtleSkgOiAoKSA9PiBwdWJsaWNUaGlzW2tleV07XG4gIGlmIChpc1N0cmluZyhyYXcpKSB7XG4gICAgY29uc3QgaGFuZGxlciA9IGN0eFtyYXddO1xuICAgIGlmIChpc0Z1bmN0aW9uKGhhbmRsZXIpKSB7XG4gICAgICB3YXRjaChnZXR0ZXIsIGhhbmRsZXIpO1xuICAgIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgd2FybihgSW52YWxpZCB3YXRjaCBoYW5kbGVyIHNwZWNpZmllZCBieSBrZXkgXCIke3Jhd31cImAsIGhhbmRsZXIpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc0Z1bmN0aW9uKHJhdykpIHtcbiAgICB3YXRjaChnZXR0ZXIsIHJhdy5iaW5kKHB1YmxpY1RoaXMpKTtcbiAgfSBlbHNlIGlmIChpc09iamVjdChyYXcpKSB7XG4gICAgaWYgKGlzQXJyYXkocmF3KSkge1xuICAgICAgcmF3LmZvckVhY2goKHIpID0+IGNyZWF0ZVdhdGNoZXIociwgY3R4LCBwdWJsaWNUaGlzLCBrZXkpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgaGFuZGxlciA9IGlzRnVuY3Rpb24ocmF3LmhhbmRsZXIpID8gcmF3LmhhbmRsZXIuYmluZChwdWJsaWNUaGlzKSA6IGN0eFtyYXcuaGFuZGxlcl07XG4gICAgICBpZiAoaXNGdW5jdGlvbihoYW5kbGVyKSkge1xuICAgICAgICB3YXRjaChnZXR0ZXIsIGhhbmRsZXIsIHJhdyk7XG4gICAgICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgd2FybihgSW52YWxpZCB3YXRjaCBoYW5kbGVyIHNwZWNpZmllZCBieSBrZXkgXCIke3Jhdy5oYW5kbGVyfVwiYCwgaGFuZGxlcik7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICB3YXJuKGBJbnZhbGlkIHdhdGNoIG9wdGlvbjogXCIke2tleX1cImAsIHJhdyk7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlc29sdmVNZXJnZWRPcHRpb25zKGluc3RhbmNlKSB7XG4gIGNvbnN0IGJhc2UgPSBpbnN0YW5jZS50eXBlO1xuICBjb25zdCB7IG1peGlucywgZXh0ZW5kczogZXh0ZW5kc09wdGlvbnMgfSA9IGJhc2U7XG4gIGNvbnN0IHtcbiAgICBtaXhpbnM6IGdsb2JhbE1peGlucyxcbiAgICBvcHRpb25zQ2FjaGU6IGNhY2hlLFxuICAgIGNvbmZpZzogeyBvcHRpb25NZXJnZVN0cmF0ZWdpZXMgfVxuICB9ID0gaW5zdGFuY2UuYXBwQ29udGV4dDtcbiAgY29uc3QgY2FjaGVkID0gY2FjaGUuZ2V0KGJhc2UpO1xuICBsZXQgcmVzb2x2ZWQ7XG4gIGlmIChjYWNoZWQpIHtcbiAgICByZXNvbHZlZCA9IGNhY2hlZDtcbiAgfSBlbHNlIGlmICghZ2xvYmFsTWl4aW5zLmxlbmd0aCAmJiAhbWl4aW5zICYmICFleHRlbmRzT3B0aW9ucykge1xuICAgIHtcbiAgICAgIHJlc29sdmVkID0gYmFzZTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmVzb2x2ZWQgPSB7fTtcbiAgICBpZiAoZ2xvYmFsTWl4aW5zLmxlbmd0aCkge1xuICAgICAgZ2xvYmFsTWl4aW5zLmZvckVhY2goXG4gICAgICAgIChtKSA9PiBtZXJnZU9wdGlvbnMocmVzb2x2ZWQsIG0sIG9wdGlvbk1lcmdlU3RyYXRlZ2llcywgdHJ1ZSlcbiAgICAgICk7XG4gICAgfVxuICAgIG1lcmdlT3B0aW9ucyhyZXNvbHZlZCwgYmFzZSwgb3B0aW9uTWVyZ2VTdHJhdGVnaWVzKTtcbiAgfVxuICBpZiAoaXNPYmplY3QoYmFzZSkpIHtcbiAgICBjYWNoZS5zZXQoYmFzZSwgcmVzb2x2ZWQpO1xuICB9XG4gIHJldHVybiByZXNvbHZlZDtcbn1cbmZ1bmN0aW9uIG1lcmdlT3B0aW9ucyh0bywgZnJvbSwgc3RyYXRzLCBhc01peGluID0gZmFsc2UpIHtcbiAgY29uc3QgeyBtaXhpbnMsIGV4dGVuZHM6IGV4dGVuZHNPcHRpb25zIH0gPSBmcm9tO1xuICBpZiAoZXh0ZW5kc09wdGlvbnMpIHtcbiAgICBtZXJnZU9wdGlvbnModG8sIGV4dGVuZHNPcHRpb25zLCBzdHJhdHMsIHRydWUpO1xuICB9XG4gIGlmIChtaXhpbnMpIHtcbiAgICBtaXhpbnMuZm9yRWFjaChcbiAgICAgIChtKSA9PiBtZXJnZU9wdGlvbnModG8sIG0sIHN0cmF0cywgdHJ1ZSlcbiAgICApO1xuICB9XG4gIGZvciAoY29uc3Qga2V5IGluIGZyb20pIHtcbiAgICBpZiAoYXNNaXhpbiAmJiBrZXkgPT09IFwiZXhwb3NlXCIpIHtcbiAgICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgd2FybihcbiAgICAgICAgYFwiZXhwb3NlXCIgb3B0aW9uIGlzIGlnbm9yZWQgd2hlbiBkZWNsYXJlZCBpbiBtaXhpbnMgb3IgZXh0ZW5kcy4gSXQgc2hvdWxkIG9ubHkgYmUgZGVjbGFyZWQgaW4gdGhlIGJhc2UgY29tcG9uZW50IGl0c2VsZi5gXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBzdHJhdCA9IGludGVybmFsT3B0aW9uTWVyZ2VTdHJhdHNba2V5XSB8fCBzdHJhdHMgJiYgc3RyYXRzW2tleV07XG4gICAgICB0b1trZXldID0gc3RyYXQgPyBzdHJhdCh0b1trZXldLCBmcm9tW2tleV0pIDogZnJvbVtrZXldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdG87XG59XG5jb25zdCBpbnRlcm5hbE9wdGlvbk1lcmdlU3RyYXRzID0ge1xuICBkYXRhOiBtZXJnZURhdGFGbixcbiAgcHJvcHM6IG1lcmdlRW1pdHNPclByb3BzT3B0aW9ucyxcbiAgZW1pdHM6IG1lcmdlRW1pdHNPclByb3BzT3B0aW9ucyxcbiAgLy8gb2JqZWN0c1xuICBtZXRob2RzOiBtZXJnZU9iamVjdE9wdGlvbnMsXG4gIGNvbXB1dGVkOiBtZXJnZU9iamVjdE9wdGlvbnMsXG4gIC8vIGxpZmVjeWNsZVxuICBiZWZvcmVDcmVhdGU6IG1lcmdlQXNBcnJheSxcbiAgY3JlYXRlZDogbWVyZ2VBc0FycmF5LFxuICBiZWZvcmVNb3VudDogbWVyZ2VBc0FycmF5LFxuICBtb3VudGVkOiBtZXJnZUFzQXJyYXksXG4gIGJlZm9yZVVwZGF0ZTogbWVyZ2VBc0FycmF5LFxuICB1cGRhdGVkOiBtZXJnZUFzQXJyYXksXG4gIGJlZm9yZURlc3Ryb3k6IG1lcmdlQXNBcnJheSxcbiAgYmVmb3JlVW5tb3VudDogbWVyZ2VBc0FycmF5LFxuICBkZXN0cm95ZWQ6IG1lcmdlQXNBcnJheSxcbiAgdW5tb3VudGVkOiBtZXJnZUFzQXJyYXksXG4gIGFjdGl2YXRlZDogbWVyZ2VBc0FycmF5LFxuICBkZWFjdGl2YXRlZDogbWVyZ2VBc0FycmF5LFxuICBlcnJvckNhcHR1cmVkOiBtZXJnZUFzQXJyYXksXG4gIHNlcnZlclByZWZldGNoOiBtZXJnZUFzQXJyYXksXG4gIC8vIGFzc2V0c1xuICBjb21wb25lbnRzOiBtZXJnZU9iamVjdE9wdGlvbnMsXG4gIGRpcmVjdGl2ZXM6IG1lcmdlT2JqZWN0T3B0aW9ucyxcbiAgLy8gd2F0Y2hcbiAgd2F0Y2g6IG1lcmdlV2F0Y2hPcHRpb25zLFxuICAvLyBwcm92aWRlIC8gaW5qZWN0XG4gIHByb3ZpZGU6IG1lcmdlRGF0YUZuLFxuICBpbmplY3Q6IG1lcmdlSW5qZWN0XG59O1xuZnVuY3Rpb24gbWVyZ2VEYXRhRm4odG8sIGZyb20pIHtcbiAgaWYgKCFmcm9tKSB7XG4gICAgcmV0dXJuIHRvO1xuICB9XG4gIGlmICghdG8pIHtcbiAgICByZXR1cm4gZnJvbTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24gbWVyZ2VkRGF0YUZuKCkge1xuICAgIHJldHVybiAoZXh0ZW5kKShcbiAgICAgIGlzRnVuY3Rpb24odG8pID8gdG8uY2FsbCh0aGlzLCB0aGlzKSA6IHRvLFxuICAgICAgaXNGdW5jdGlvbihmcm9tKSA/IGZyb20uY2FsbCh0aGlzLCB0aGlzKSA6IGZyb21cbiAgICApO1xuICB9O1xufVxuZnVuY3Rpb24gbWVyZ2VJbmplY3QodG8sIGZyb20pIHtcbiAgcmV0dXJuIG1lcmdlT2JqZWN0T3B0aW9ucyhub3JtYWxpemVJbmplY3QodG8pLCBub3JtYWxpemVJbmplY3QoZnJvbSkpO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplSW5qZWN0KHJhdykge1xuICBpZiAoaXNBcnJheShyYXcpKSB7XG4gICAgY29uc3QgcmVzID0ge307XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByYXcubGVuZ3RoOyBpKyspIHtcbiAgICAgIHJlc1tyYXdbaV1dID0gcmF3W2ldO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xuICB9XG4gIHJldHVybiByYXc7XG59XG5mdW5jdGlvbiBtZXJnZUFzQXJyYXkodG8sIGZyb20pIHtcbiAgcmV0dXJuIHRvID8gWy4uLm5ldyBTZXQoW10uY29uY2F0KHRvLCBmcm9tKSldIDogZnJvbTtcbn1cbmZ1bmN0aW9uIG1lcmdlT2JqZWN0T3B0aW9ucyh0bywgZnJvbSkge1xuICByZXR1cm4gdG8gPyBleHRlbmQoLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCksIHRvLCBmcm9tKSA6IGZyb207XG59XG5mdW5jdGlvbiBtZXJnZUVtaXRzT3JQcm9wc09wdGlvbnModG8sIGZyb20pIHtcbiAgaWYgKHRvKSB7XG4gICAgaWYgKGlzQXJyYXkodG8pICYmIGlzQXJyYXkoZnJvbSkpIHtcbiAgICAgIHJldHVybiBbLi4uLyogQF9fUFVSRV9fICovIG5ldyBTZXQoWy4uLnRvLCAuLi5mcm9tXSldO1xuICAgIH1cbiAgICByZXR1cm4gZXh0ZW5kKFxuICAgICAgLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCksXG4gICAgICBub3JtYWxpemVQcm9wc09yRW1pdHModG8pLFxuICAgICAgbm9ybWFsaXplUHJvcHNPckVtaXRzKGZyb20gIT0gbnVsbCA/IGZyb20gOiB7fSlcbiAgICApO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmcm9tO1xuICB9XG59XG5mdW5jdGlvbiBtZXJnZVdhdGNoT3B0aW9ucyh0bywgZnJvbSkge1xuICBpZiAoIXRvKVxuICAgIHJldHVybiBmcm9tO1xuICBpZiAoIWZyb20pXG4gICAgcmV0dXJuIHRvO1xuICBjb25zdCBtZXJnZWQgPSBleHRlbmQoLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCksIHRvKTtcbiAgZm9yIChjb25zdCBrZXkgaW4gZnJvbSkge1xuICAgIG1lcmdlZFtrZXldID0gbWVyZ2VBc0FycmF5KHRvW2tleV0sIGZyb21ba2V5XSk7XG4gIH1cbiAgcmV0dXJuIG1lcmdlZDtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQXBwQ29udGV4dCgpIHtcbiAgcmV0dXJuIHtcbiAgICBhcHA6IG51bGwsXG4gICAgY29uZmlnOiB7XG4gICAgICBpc05hdGl2ZVRhZzogTk8sXG4gICAgICBwZXJmb3JtYW5jZTogZmFsc2UsXG4gICAgICBnbG9iYWxQcm9wZXJ0aWVzOiB7fSxcbiAgICAgIG9wdGlvbk1lcmdlU3RyYXRlZ2llczoge30sXG4gICAgICBlcnJvckhhbmRsZXI6IHZvaWQgMCxcbiAgICAgIHdhcm5IYW5kbGVyOiB2b2lkIDAsXG4gICAgICBjb21waWxlck9wdGlvbnM6IHt9XG4gICAgfSxcbiAgICBtaXhpbnM6IFtdLFxuICAgIGNvbXBvbmVudHM6IHt9LFxuICAgIGRpcmVjdGl2ZXM6IHt9LFxuICAgIHByb3ZpZGVzOiAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKSxcbiAgICBvcHRpb25zQ2FjaGU6IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpLFxuICAgIHByb3BzQ2FjaGU6IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpLFxuICAgIGVtaXRzQ2FjaGU6IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpXG4gIH07XG59XG5sZXQgdWlkJDEgPSAwO1xuZnVuY3Rpb24gY3JlYXRlQXBwQVBJKHJlbmRlciwgaHlkcmF0ZSkge1xuICByZXR1cm4gZnVuY3Rpb24gY3JlYXRlQXBwKHJvb3RDb21wb25lbnQsIHJvb3RQcm9wcyA9IG51bGwpIHtcbiAgICBpZiAoIWlzRnVuY3Rpb24ocm9vdENvbXBvbmVudCkpIHtcbiAgICAgIHJvb3RDb21wb25lbnQgPSBleHRlbmQoe30sIHJvb3RDb21wb25lbnQpO1xuICAgIH1cbiAgICBpZiAocm9vdFByb3BzICE9IG51bGwgJiYgIWlzT2JqZWN0KHJvb3RQcm9wcykpIHtcbiAgICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgd2Fybihgcm9vdCBwcm9wcyBwYXNzZWQgdG8gYXBwLm1vdW50KCkgbXVzdCBiZSBhbiBvYmplY3QuYCk7XG4gICAgICByb290UHJvcHMgPSBudWxsO1xuICAgIH1cbiAgICBjb25zdCBjb250ZXh0ID0gY3JlYXRlQXBwQ29udGV4dCgpO1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29udGV4dC5jb25maWcsIFwidW53cmFwSW5qZWN0ZWRSZWZcIiwge1xuICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0sXG4gICAgICAgIHNldCgpIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgYGFwcC5jb25maWcudW53cmFwSW5qZWN0ZWRSZWYgaGFzIGJlZW4gZGVwcmVjYXRlZC4gMy4zIG5vdyBhbGF3eXMgdW53cmFwcyBpbmplY3RlZCByZWZzIGluIE9wdGlvbnMgQVBJLmBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgaW5zdGFsbGVkUGx1Z2lucyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgbGV0IGlzTW91bnRlZCA9IGZhbHNlO1xuICAgIGNvbnN0IGFwcCA9IGNvbnRleHQuYXBwID0ge1xuICAgICAgX3VpZDogdWlkJDErKyxcbiAgICAgIF9jb21wb25lbnQ6IHJvb3RDb21wb25lbnQsXG4gICAgICBfcHJvcHM6IHJvb3RQcm9wcyxcbiAgICAgIF9jb250YWluZXI6IG51bGwsXG4gICAgICBfY29udGV4dDogY29udGV4dCxcbiAgICAgIF9pbnN0YW5jZTogbnVsbCxcbiAgICAgIHZlcnNpb24sXG4gICAgICBnZXQgY29uZmlnKCkge1xuICAgICAgICByZXR1cm4gY29udGV4dC5jb25maWc7XG4gICAgICB9LFxuICAgICAgc2V0IGNvbmZpZyh2KSB7XG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgd2FybihcbiAgICAgICAgICAgIGBhcHAuY29uZmlnIGNhbm5vdCBiZSByZXBsYWNlZC4gTW9kaWZ5IGluZGl2aWR1YWwgb3B0aW9ucyBpbnN0ZWFkLmBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdXNlKHBsdWdpbiwgLi4ub3B0aW9ucykge1xuICAgICAgICBpZiAoaW5zdGFsbGVkUGx1Z2lucy5oYXMocGx1Z2luKSkge1xuICAgICAgICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgd2FybihgUGx1Z2luIGhhcyBhbHJlYWR5IGJlZW4gYXBwbGllZCB0byB0YXJnZXQgYXBwLmApO1xuICAgICAgICB9IGVsc2UgaWYgKHBsdWdpbiAmJiBpc0Z1bmN0aW9uKHBsdWdpbi5pbnN0YWxsKSkge1xuICAgICAgICAgIGluc3RhbGxlZFBsdWdpbnMuYWRkKHBsdWdpbik7XG4gICAgICAgICAgcGx1Z2luLmluc3RhbGwoYXBwLCAuLi5vcHRpb25zKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0Z1bmN0aW9uKHBsdWdpbikpIHtcbiAgICAgICAgICBpbnN0YWxsZWRQbHVnaW5zLmFkZChwbHVnaW4pO1xuICAgICAgICAgIHBsdWdpbihhcHAsIC4uLm9wdGlvbnMpO1xuICAgICAgICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgYEEgcGx1Z2luIG11c3QgZWl0aGVyIGJlIGEgZnVuY3Rpb24gb3IgYW4gb2JqZWN0IHdpdGggYW4gXCJpbnN0YWxsXCIgZnVuY3Rpb24uYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFwcDtcbiAgICAgIH0sXG4gICAgICBtaXhpbihtaXhpbikge1xuICAgICAgICBpZiAoX19WVUVfT1BUSU9OU19BUElfXykge1xuICAgICAgICAgIGlmICghY29udGV4dC5taXhpbnMuaW5jbHVkZXMobWl4aW4pKSB7XG4gICAgICAgICAgICBjb250ZXh0Lm1peGlucy5wdXNoKG1peGluKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAgIFwiTWl4aW4gaGFzIGFscmVhZHkgYmVlbiBhcHBsaWVkIHRvIHRhcmdldCBhcHBcIiArIChtaXhpbi5uYW1lID8gYDogJHttaXhpbi5uYW1lfWAgOiBcIlwiKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgIHdhcm4oXCJNaXhpbnMgYXJlIG9ubHkgYXZhaWxhYmxlIGluIGJ1aWxkcyBzdXBwb3J0aW5nIE9wdGlvbnMgQVBJXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcHA7XG4gICAgICB9LFxuICAgICAgY29tcG9uZW50KG5hbWUsIGNvbXBvbmVudCkge1xuICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgIHZhbGlkYXRlQ29tcG9uZW50TmFtZShuYW1lLCBjb250ZXh0LmNvbmZpZyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjb21wb25lbnQpIHtcbiAgICAgICAgICByZXR1cm4gY29udGV4dC5jb21wb25lbnRzW25hbWVdO1xuICAgICAgICB9XG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGNvbnRleHQuY29tcG9uZW50c1tuYW1lXSkge1xuICAgICAgICAgIHdhcm4oYENvbXBvbmVudCBcIiR7bmFtZX1cIiBoYXMgYWxyZWFkeSBiZWVuIHJlZ2lzdGVyZWQgaW4gdGFyZ2V0IGFwcC5gKTtcbiAgICAgICAgfVxuICAgICAgICBjb250ZXh0LmNvbXBvbmVudHNbbmFtZV0gPSBjb21wb25lbnQ7XG4gICAgICAgIHJldHVybiBhcHA7XG4gICAgICB9LFxuICAgICAgZGlyZWN0aXZlKG5hbWUsIGRpcmVjdGl2ZSkge1xuICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgIHZhbGlkYXRlRGlyZWN0aXZlTmFtZShuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWRpcmVjdGl2ZSkge1xuICAgICAgICAgIHJldHVybiBjb250ZXh0LmRpcmVjdGl2ZXNbbmFtZV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgY29udGV4dC5kaXJlY3RpdmVzW25hbWVdKSB7XG4gICAgICAgICAgd2FybihgRGlyZWN0aXZlIFwiJHtuYW1lfVwiIGhhcyBhbHJlYWR5IGJlZW4gcmVnaXN0ZXJlZCBpbiB0YXJnZXQgYXBwLmApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRleHQuZGlyZWN0aXZlc1tuYW1lXSA9IGRpcmVjdGl2ZTtcbiAgICAgICAgcmV0dXJuIGFwcDtcbiAgICAgIH0sXG4gICAgICBtb3VudChyb290Q29udGFpbmVyLCBpc0h5ZHJhdGUsIGlzU1ZHKSB7XG4gICAgICAgIGlmICghaXNNb3VudGVkKSB7XG4gICAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgcm9vdENvbnRhaW5lci5fX3Z1ZV9hcHBfXykge1xuICAgICAgICAgICAgd2FybihcbiAgICAgICAgICAgICAgYFRoZXJlIGlzIGFscmVhZHkgYW4gYXBwIGluc3RhbmNlIG1vdW50ZWQgb24gdGhlIGhvc3QgY29udGFpbmVyLlxuIElmIHlvdSB3YW50IHRvIG1vdW50IGFub3RoZXIgYXBwIG9uIHRoZSBzYW1lIGhvc3QgY29udGFpbmVyLCB5b3UgbmVlZCB0byB1bm1vdW50IHRoZSBwcmV2aW91cyBhcHAgYnkgY2FsbGluZyBcXGBhcHAudW5tb3VudCgpXFxgIGZpcnN0LmBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHZub2RlID0gY3JlYXRlVk5vZGUoXG4gICAgICAgICAgICByb290Q29tcG9uZW50LFxuICAgICAgICAgICAgcm9vdFByb3BzXG4gICAgICAgICAgKTtcbiAgICAgICAgICB2bm9kZS5hcHBDb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgICAgY29udGV4dC5yZWxvYWQgPSAoKSA9PiB7XG4gICAgICAgICAgICAgIHJlbmRlcihjbG9uZVZOb2RlKHZub2RlKSwgcm9vdENvbnRhaW5lciwgaXNTVkcpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzSHlkcmF0ZSAmJiBoeWRyYXRlKSB7XG4gICAgICAgICAgICBoeWRyYXRlKHZub2RlLCByb290Q29udGFpbmVyKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVuZGVyKHZub2RlLCByb290Q29udGFpbmVyLCBpc1NWRyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlzTW91bnRlZCA9IHRydWU7XG4gICAgICAgICAgYXBwLl9jb250YWluZXIgPSByb290Q29udGFpbmVyO1xuICAgICAgICAgIHJvb3RDb250YWluZXIuX192dWVfYXBwX18gPSBhcHA7XG4gICAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XG4gICAgICAgICAgICBhcHAuX2luc3RhbmNlID0gdm5vZGUuY29tcG9uZW50O1xuICAgICAgICAgICAgZGV2dG9vbHNJbml0QXBwKGFwcCwgdmVyc2lvbik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBnZXRFeHBvc2VQcm94eSh2bm9kZS5jb21wb25lbnQpIHx8IHZub2RlLmNvbXBvbmVudC5wcm94eTtcbiAgICAgICAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgd2FybihcbiAgICAgICAgICAgIGBBcHAgaGFzIGFscmVhZHkgYmVlbiBtb3VudGVkLlxuSWYgeW91IHdhbnQgdG8gcmVtb3VudCB0aGUgc2FtZSBhcHAsIG1vdmUgeW91ciBhcHAgY3JlYXRpb24gbG9naWMgaW50byBhIGZhY3RvcnkgZnVuY3Rpb24gYW5kIGNyZWF0ZSBmcmVzaCBhcHAgaW5zdGFuY2VzIGZvciBlYWNoIG1vdW50IC0gZS5nLiBcXGBjb25zdCBjcmVhdGVNeUFwcCA9ICgpID0+IGNyZWF0ZUFwcChBcHApXFxgYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB1bm1vdW50KCkge1xuICAgICAgICBpZiAoaXNNb3VudGVkKSB7XG4gICAgICAgICAgcmVuZGVyKG51bGwsIGFwcC5fY29udGFpbmVyKTtcbiAgICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcbiAgICAgICAgICAgIGFwcC5faW5zdGFuY2UgPSBudWxsO1xuICAgICAgICAgICAgZGV2dG9vbHNVbm1vdW50QXBwKGFwcCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRlbGV0ZSBhcHAuX2NvbnRhaW5lci5fX3Z1ZV9hcHBfXztcbiAgICAgICAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgd2FybihgQ2Fubm90IHVubW91bnQgYW4gYXBwIHRoYXQgaXMgbm90IG1vdW50ZWQuYCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBwcm92aWRlKGtleSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYga2V5IGluIGNvbnRleHQucHJvdmlkZXMpIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgYEFwcCBhbHJlYWR5IHByb3ZpZGVzIHByb3BlcnR5IHdpdGgga2V5IFwiJHtTdHJpbmcoa2V5KX1cIi4gSXQgd2lsbCBiZSBvdmVyd3JpdHRlbiB3aXRoIHRoZSBuZXcgdmFsdWUuYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgY29udGV4dC5wcm92aWRlc1trZXldID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBhcHA7XG4gICAgICB9LFxuICAgICAgcnVuV2l0aENvbnRleHQoZm4pIHtcbiAgICAgICAgY3VycmVudEFwcCA9IGFwcDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gZm4oKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBjdXJyZW50QXBwID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIGFwcDtcbiAgfTtcbn1cbmxldCBjdXJyZW50QXBwID0gbnVsbDtcblxuZnVuY3Rpb24gcHJvdmlkZShrZXksIHZhbHVlKSB7XG4gIGlmICghY3VycmVudEluc3RhbmNlKSB7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgIHdhcm4oYHByb3ZpZGUoKSBjYW4gb25seSBiZSB1c2VkIGluc2lkZSBzZXR1cCgpLmApO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBsZXQgcHJvdmlkZXMgPSBjdXJyZW50SW5zdGFuY2UucHJvdmlkZXM7XG4gICAgY29uc3QgcGFyZW50UHJvdmlkZXMgPSBjdXJyZW50SW5zdGFuY2UucGFyZW50ICYmIGN1cnJlbnRJbnN0YW5jZS5wYXJlbnQucHJvdmlkZXM7XG4gICAgaWYgKHBhcmVudFByb3ZpZGVzID09PSBwcm92aWRlcykge1xuICAgICAgcHJvdmlkZXMgPSBjdXJyZW50SW5zdGFuY2UucHJvdmlkZXMgPSBPYmplY3QuY3JlYXRlKHBhcmVudFByb3ZpZGVzKTtcbiAgICB9XG4gICAgcHJvdmlkZXNba2V5XSA9IHZhbHVlO1xuICB9XG59XG5mdW5jdGlvbiBpbmplY3Qoa2V5LCBkZWZhdWx0VmFsdWUsIHRyZWF0RGVmYXVsdEFzRmFjdG9yeSA9IGZhbHNlKSB7XG4gIGNvbnN0IGluc3RhbmNlID0gY3VycmVudEluc3RhbmNlIHx8IGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZTtcbiAgaWYgKGluc3RhbmNlIHx8IGN1cnJlbnRBcHApIHtcbiAgICBjb25zdCBwcm92aWRlcyA9IGluc3RhbmNlID8gaW5zdGFuY2UucGFyZW50ID09IG51bGwgPyBpbnN0YW5jZS52bm9kZS5hcHBDb250ZXh0ICYmIGluc3RhbmNlLnZub2RlLmFwcENvbnRleHQucHJvdmlkZXMgOiBpbnN0YW5jZS5wYXJlbnQucHJvdmlkZXMgOiBjdXJyZW50QXBwLl9jb250ZXh0LnByb3ZpZGVzO1xuICAgIGlmIChwcm92aWRlcyAmJiBrZXkgaW4gcHJvdmlkZXMpIHtcbiAgICAgIHJldHVybiBwcm92aWRlc1trZXldO1xuICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgIHJldHVybiB0cmVhdERlZmF1bHRBc0ZhY3RvcnkgJiYgaXNGdW5jdGlvbihkZWZhdWx0VmFsdWUpID8gZGVmYXVsdFZhbHVlLmNhbGwoaW5zdGFuY2UgJiYgaW5zdGFuY2UucHJveHkpIDogZGVmYXVsdFZhbHVlO1xuICAgIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgd2FybihgaW5qZWN0aW9uIFwiJHtTdHJpbmcoa2V5KX1cIiBub3QgZm91bmQuYCk7XG4gICAgfVxuICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICB3YXJuKGBpbmplY3QoKSBjYW4gb25seSBiZSB1c2VkIGluc2lkZSBzZXR1cCgpIG9yIGZ1bmN0aW9uYWwgY29tcG9uZW50cy5gKTtcbiAgfVxufVxuZnVuY3Rpb24gaGFzSW5qZWN0aW9uQ29udGV4dCgpIHtcbiAgcmV0dXJuICEhKGN1cnJlbnRJbnN0YW5jZSB8fCBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UgfHwgY3VycmVudEFwcCk7XG59XG5cbmZ1bmN0aW9uIGluaXRQcm9wcyhpbnN0YW5jZSwgcmF3UHJvcHMsIGlzU3RhdGVmdWwsIGlzU1NSID0gZmFsc2UpIHtcbiAgY29uc3QgcHJvcHMgPSB7fTtcbiAgY29uc3QgYXR0cnMgPSB7fTtcbiAgZGVmKGF0dHJzLCBJbnRlcm5hbE9iamVjdEtleSwgMSk7XG4gIGluc3RhbmNlLnByb3BzRGVmYXVsdHMgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgc2V0RnVsbFByb3BzKGluc3RhbmNlLCByYXdQcm9wcywgcHJvcHMsIGF0dHJzKTtcbiAgZm9yIChjb25zdCBrZXkgaW4gaW5zdGFuY2UucHJvcHNPcHRpb25zWzBdKSB7XG4gICAgaWYgKCEoa2V5IGluIHByb3BzKSkge1xuICAgICAgcHJvcHNba2V5XSA9IHZvaWQgMDtcbiAgICB9XG4gIH1cbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICB2YWxpZGF0ZVByb3BzKHJhd1Byb3BzIHx8IHt9LCBwcm9wcywgaW5zdGFuY2UpO1xuICB9XG4gIGlmIChpc1N0YXRlZnVsKSB7XG4gICAgaW5zdGFuY2UucHJvcHMgPSBpc1NTUiA/IHByb3BzIDogc2hhbGxvd1JlYWN0aXZlKHByb3BzKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoIWluc3RhbmNlLnR5cGUucHJvcHMpIHtcbiAgICAgIGluc3RhbmNlLnByb3BzID0gYXR0cnM7XG4gICAgfSBlbHNlIHtcbiAgICAgIGluc3RhbmNlLnByb3BzID0gcHJvcHM7XG4gICAgfVxuICB9XG4gIGluc3RhbmNlLmF0dHJzID0gYXR0cnM7XG59XG5mdW5jdGlvbiBpc0luSG1yQ29udGV4dChpbnN0YW5jZSkge1xuICB3aGlsZSAoaW5zdGFuY2UpIHtcbiAgICBpZiAoaW5zdGFuY2UudHlwZS5fX2htcklkKVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgaW5zdGFuY2UgPSBpbnN0YW5jZS5wYXJlbnQ7XG4gIH1cbn1cbmZ1bmN0aW9uIHVwZGF0ZVByb3BzKGluc3RhbmNlLCByYXdQcm9wcywgcmF3UHJldlByb3BzLCBvcHRpbWl6ZWQpIHtcbiAgY29uc3Qge1xuICAgIHByb3BzLFxuICAgIGF0dHJzLFxuICAgIHZub2RlOiB7IHBhdGNoRmxhZyB9XG4gIH0gPSBpbnN0YW5jZTtcbiAgY29uc3QgcmF3Q3VycmVudFByb3BzID0gdG9SYXcocHJvcHMpO1xuICBjb25zdCBbb3B0aW9uc10gPSBpbnN0YW5jZS5wcm9wc09wdGlvbnM7XG4gIGxldCBoYXNBdHRyc0NoYW5nZWQgPSBmYWxzZTtcbiAgaWYgKFxuICAgIC8vIGFsd2F5cyBmb3JjZSBmdWxsIGRpZmYgaW4gZGV2XG4gICAgLy8gLSAjMTk0MiBpZiBobXIgaXMgZW5hYmxlZCB3aXRoIHNmYyBjb21wb25lbnRcbiAgICAvLyAtIHZpdGUjODcyIG5vbi1zZmMgY29tcG9uZW50IHVzZWQgYnkgc2ZjIGNvbXBvbmVudFxuICAgICEoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBpc0luSG1yQ29udGV4dChpbnN0YW5jZSkpICYmIChvcHRpbWl6ZWQgfHwgcGF0Y2hGbGFnID4gMCkgJiYgIShwYXRjaEZsYWcgJiAxNilcbiAgKSB7XG4gICAgaWYgKHBhdGNoRmxhZyAmIDgpIHtcbiAgICAgIGNvbnN0IHByb3BzVG9VcGRhdGUgPSBpbnN0YW5jZS52bm9kZS5keW5hbWljUHJvcHM7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByb3BzVG9VcGRhdGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IGtleSA9IHByb3BzVG9VcGRhdGVbaV07XG4gICAgICAgIGlmIChpc0VtaXRMaXN0ZW5lcihpbnN0YW5jZS5lbWl0c09wdGlvbnMsIGtleSkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2YWx1ZSA9IHJhd1Byb3BzW2tleV07XG4gICAgICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgICAgaWYgKGhhc093bihhdHRycywga2V5KSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlICE9PSBhdHRyc1trZXldKSB7XG4gICAgICAgICAgICAgIGF0dHJzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgaGFzQXR0cnNDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgY2FtZWxpemVkS2V5ID0gY2FtZWxpemUoa2V5KTtcbiAgICAgICAgICAgIHByb3BzW2NhbWVsaXplZEtleV0gPSByZXNvbHZlUHJvcFZhbHVlKFxuICAgICAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgICAgICByYXdDdXJyZW50UHJvcHMsXG4gICAgICAgICAgICAgIGNhbWVsaXplZEtleSxcbiAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgIGluc3RhbmNlLFxuICAgICAgICAgICAgICBmYWxzZVxuICAgICAgICAgICAgICAvKiBpc0Fic2VudCAqL1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHZhbHVlICE9PSBhdHRyc1trZXldKSB7XG4gICAgICAgICAgICBhdHRyc1trZXldID0gdmFsdWU7XG4gICAgICAgICAgICBoYXNBdHRyc0NoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoc2V0RnVsbFByb3BzKGluc3RhbmNlLCByYXdQcm9wcywgcHJvcHMsIGF0dHJzKSkge1xuICAgICAgaGFzQXR0cnNDaGFuZ2VkID0gdHJ1ZTtcbiAgICB9XG4gICAgbGV0IGtlYmFiS2V5O1xuICAgIGZvciAoY29uc3Qga2V5IGluIHJhd0N1cnJlbnRQcm9wcykge1xuICAgICAgaWYgKCFyYXdQcm9wcyB8fCAvLyBmb3IgY2FtZWxDYXNlXG4gICAgICAhaGFzT3duKHJhd1Byb3BzLCBrZXkpICYmIC8vIGl0J3MgcG9zc2libGUgdGhlIG9yaWdpbmFsIHByb3BzIHdhcyBwYXNzZWQgaW4gYXMga2ViYWItY2FzZVxuICAgICAgLy8gYW5kIGNvbnZlcnRlZCB0byBjYW1lbENhc2UgKCM5NTUpXG4gICAgICAoKGtlYmFiS2V5ID0gaHlwaGVuYXRlKGtleSkpID09PSBrZXkgfHwgIWhhc093bihyYXdQcm9wcywga2ViYWJLZXkpKSkge1xuICAgICAgICBpZiAob3B0aW9ucykge1xuICAgICAgICAgIGlmIChyYXdQcmV2UHJvcHMgJiYgLy8gZm9yIGNhbWVsQ2FzZVxuICAgICAgICAgIChyYXdQcmV2UHJvcHNba2V5XSAhPT0gdm9pZCAwIHx8IC8vIGZvciBrZWJhYi1jYXNlXG4gICAgICAgICAgcmF3UHJldlByb3BzW2tlYmFiS2V5XSAhPT0gdm9pZCAwKSkge1xuICAgICAgICAgICAgcHJvcHNba2V5XSA9IHJlc29sdmVQcm9wVmFsdWUoXG4gICAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgICAgIHJhd0N1cnJlbnRQcm9wcyxcbiAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICB2b2lkIDAsXG4gICAgICAgICAgICAgIGluc3RhbmNlLFxuICAgICAgICAgICAgICB0cnVlXG4gICAgICAgICAgICAgIC8qIGlzQWJzZW50ICovXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWxldGUgcHJvcHNba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoYXR0cnMgIT09IHJhd0N1cnJlbnRQcm9wcykge1xuICAgICAgZm9yIChjb25zdCBrZXkgaW4gYXR0cnMpIHtcbiAgICAgICAgaWYgKCFyYXdQcm9wcyB8fCAhaGFzT3duKHJhd1Byb3BzLCBrZXkpICYmIHRydWUpIHtcbiAgICAgICAgICBkZWxldGUgYXR0cnNba2V5XTtcbiAgICAgICAgICBoYXNBdHRyc0NoYW5nZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChoYXNBdHRyc0NoYW5nZWQpIHtcbiAgICB0cmlnZ2VyKGluc3RhbmNlLCBcInNldFwiLCBcIiRhdHRyc1wiKTtcbiAgfVxuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIHZhbGlkYXRlUHJvcHMocmF3UHJvcHMgfHwge30sIHByb3BzLCBpbnN0YW5jZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHNldEZ1bGxQcm9wcyhpbnN0YW5jZSwgcmF3UHJvcHMsIHByb3BzLCBhdHRycykge1xuICBjb25zdCBbb3B0aW9ucywgbmVlZENhc3RLZXlzXSA9IGluc3RhbmNlLnByb3BzT3B0aW9ucztcbiAgbGV0IGhhc0F0dHJzQ2hhbmdlZCA9IGZhbHNlO1xuICBsZXQgcmF3Q2FzdFZhbHVlcztcbiAgaWYgKHJhd1Byb3BzKSB7XG4gICAgZm9yIChsZXQga2V5IGluIHJhd1Byb3BzKSB7XG4gICAgICBpZiAoaXNSZXNlcnZlZFByb3Aoa2V5KSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHZhbHVlID0gcmF3UHJvcHNba2V5XTtcbiAgICAgIGxldCBjYW1lbEtleTtcbiAgICAgIGlmIChvcHRpb25zICYmIGhhc093bihvcHRpb25zLCBjYW1lbEtleSA9IGNhbWVsaXplKGtleSkpKSB7XG4gICAgICAgIGlmICghbmVlZENhc3RLZXlzIHx8ICFuZWVkQ2FzdEtleXMuaW5jbHVkZXMoY2FtZWxLZXkpKSB7XG4gICAgICAgICAgcHJvcHNbY2FtZWxLZXldID0gdmFsdWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgKHJhd0Nhc3RWYWx1ZXMgfHwgKHJhd0Nhc3RWYWx1ZXMgPSB7fSkpW2NhbWVsS2V5XSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKCFpc0VtaXRMaXN0ZW5lcihpbnN0YW5jZS5lbWl0c09wdGlvbnMsIGtleSkpIHtcbiAgICAgICAgaWYgKCEoa2V5IGluIGF0dHJzKSB8fCB2YWx1ZSAhPT0gYXR0cnNba2V5XSkge1xuICAgICAgICAgIGF0dHJzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICBoYXNBdHRyc0NoYW5nZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChuZWVkQ2FzdEtleXMpIHtcbiAgICBjb25zdCByYXdDdXJyZW50UHJvcHMgPSB0b1Jhdyhwcm9wcyk7XG4gICAgY29uc3QgY2FzdFZhbHVlcyA9IHJhd0Nhc3RWYWx1ZXMgfHwgRU1QVFlfT0JKO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmVlZENhc3RLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBrZXkgPSBuZWVkQ2FzdEtleXNbaV07XG4gICAgICBwcm9wc1trZXldID0gcmVzb2x2ZVByb3BWYWx1ZShcbiAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgcmF3Q3VycmVudFByb3BzLFxuICAgICAgICBrZXksXG4gICAgICAgIGNhc3RWYWx1ZXNba2V5XSxcbiAgICAgICAgaW5zdGFuY2UsXG4gICAgICAgICFoYXNPd24oY2FzdFZhbHVlcywga2V5KVxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGhhc0F0dHJzQ2hhbmdlZDtcbn1cbmZ1bmN0aW9uIHJlc29sdmVQcm9wVmFsdWUob3B0aW9ucywgcHJvcHMsIGtleSwgdmFsdWUsIGluc3RhbmNlLCBpc0Fic2VudCkge1xuICBjb25zdCBvcHQgPSBvcHRpb25zW2tleV07XG4gIGlmIChvcHQgIT0gbnVsbCkge1xuICAgIGNvbnN0IGhhc0RlZmF1bHQgPSBoYXNPd24ob3B0LCBcImRlZmF1bHRcIik7XG4gICAgaWYgKGhhc0RlZmF1bHQgJiYgdmFsdWUgPT09IHZvaWQgMCkge1xuICAgICAgY29uc3QgZGVmYXVsdFZhbHVlID0gb3B0LmRlZmF1bHQ7XG4gICAgICBpZiAob3B0LnR5cGUgIT09IEZ1bmN0aW9uICYmICFvcHQuc2tpcEZhY3RvcnkgJiYgaXNGdW5jdGlvbihkZWZhdWx0VmFsdWUpKSB7XG4gICAgICAgIGNvbnN0IHsgcHJvcHNEZWZhdWx0cyB9ID0gaW5zdGFuY2U7XG4gICAgICAgIGlmIChrZXkgaW4gcHJvcHNEZWZhdWx0cykge1xuICAgICAgICAgIHZhbHVlID0gcHJvcHNEZWZhdWx0c1trZXldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNldEN1cnJlbnRJbnN0YW5jZShpbnN0YW5jZSk7XG4gICAgICAgICAgdmFsdWUgPSBwcm9wc0RlZmF1bHRzW2tleV0gPSBkZWZhdWx0VmFsdWUuY2FsbChcbiAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICBwcm9wc1xuICAgICAgICAgICk7XG4gICAgICAgICAgdW5zZXRDdXJyZW50SW5zdGFuY2UoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWUgPSBkZWZhdWx0VmFsdWU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChvcHRbMCAvKiBzaG91bGRDYXN0ICovXSkge1xuICAgICAgaWYgKGlzQWJzZW50ICYmICFoYXNEZWZhdWx0KSB7XG4gICAgICAgIHZhbHVlID0gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKG9wdFsxIC8qIHNob3VsZENhc3RUcnVlICovXSAmJiAodmFsdWUgPT09IFwiXCIgfHwgdmFsdWUgPT09IGh5cGhlbmF0ZShrZXkpKSkge1xuICAgICAgICB2YWx1ZSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZVByb3BzT3B0aW9ucyhjb21wLCBhcHBDb250ZXh0LCBhc01peGluID0gZmFsc2UpIHtcbiAgY29uc3QgY2FjaGUgPSBhcHBDb250ZXh0LnByb3BzQ2FjaGU7XG4gIGNvbnN0IGNhY2hlZCA9IGNhY2hlLmdldChjb21wKTtcbiAgaWYgKGNhY2hlZCkge1xuICAgIHJldHVybiBjYWNoZWQ7XG4gIH1cbiAgY29uc3QgcmF3ID0gY29tcC5wcm9wcztcbiAgY29uc3Qgbm9ybWFsaXplZCA9IHt9O1xuICBjb25zdCBuZWVkQ2FzdEtleXMgPSBbXTtcbiAgbGV0IGhhc0V4dGVuZHMgPSBmYWxzZTtcbiAgaWYgKF9fVlVFX09QVElPTlNfQVBJX18gJiYgIWlzRnVuY3Rpb24oY29tcCkpIHtcbiAgICBjb25zdCBleHRlbmRQcm9wcyA9IChyYXcyKSA9PiB7XG4gICAgICBoYXNFeHRlbmRzID0gdHJ1ZTtcbiAgICAgIGNvbnN0IFtwcm9wcywga2V5c10gPSBub3JtYWxpemVQcm9wc09wdGlvbnMocmF3MiwgYXBwQ29udGV4dCwgdHJ1ZSk7XG4gICAgICBleHRlbmQobm9ybWFsaXplZCwgcHJvcHMpO1xuICAgICAgaWYgKGtleXMpXG4gICAgICAgIG5lZWRDYXN0S2V5cy5wdXNoKC4uLmtleXMpO1xuICAgIH07XG4gICAgaWYgKCFhc01peGluICYmIGFwcENvbnRleHQubWl4aW5zLmxlbmd0aCkge1xuICAgICAgYXBwQ29udGV4dC5taXhpbnMuZm9yRWFjaChleHRlbmRQcm9wcyk7XG4gICAgfVxuICAgIGlmIChjb21wLmV4dGVuZHMpIHtcbiAgICAgIGV4dGVuZFByb3BzKGNvbXAuZXh0ZW5kcyk7XG4gICAgfVxuICAgIGlmIChjb21wLm1peGlucykge1xuICAgICAgY29tcC5taXhpbnMuZm9yRWFjaChleHRlbmRQcm9wcyk7XG4gICAgfVxuICB9XG4gIGlmICghcmF3ICYmICFoYXNFeHRlbmRzKSB7XG4gICAgaWYgKGlzT2JqZWN0KGNvbXApKSB7XG4gICAgICBjYWNoZS5zZXQoY29tcCwgRU1QVFlfQVJSKTtcbiAgICB9XG4gICAgcmV0dXJuIEVNUFRZX0FSUjtcbiAgfVxuICBpZiAoaXNBcnJheShyYXcpKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByYXcubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICFpc1N0cmluZyhyYXdbaV0pKSB7XG4gICAgICAgIHdhcm4oYHByb3BzIG11c3QgYmUgc3RyaW5ncyB3aGVuIHVzaW5nIGFycmF5IHN5bnRheC5gLCByYXdbaV0pO1xuICAgICAgfVxuICAgICAgY29uc3Qgbm9ybWFsaXplZEtleSA9IGNhbWVsaXplKHJhd1tpXSk7XG4gICAgICBpZiAodmFsaWRhdGVQcm9wTmFtZShub3JtYWxpemVkS2V5KSkge1xuICAgICAgICBub3JtYWxpemVkW25vcm1hbGl6ZWRLZXldID0gRU1QVFlfT0JKO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChyYXcpIHtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhaXNPYmplY3QocmF3KSkge1xuICAgICAgd2FybihgaW52YWxpZCBwcm9wcyBvcHRpb25zYCwgcmF3KTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBrZXkgaW4gcmF3KSB7XG4gICAgICBjb25zdCBub3JtYWxpemVkS2V5ID0gY2FtZWxpemUoa2V5KTtcbiAgICAgIGlmICh2YWxpZGF0ZVByb3BOYW1lKG5vcm1hbGl6ZWRLZXkpKSB7XG4gICAgICAgIGNvbnN0IG9wdCA9IHJhd1trZXldO1xuICAgICAgICBjb25zdCBwcm9wID0gbm9ybWFsaXplZFtub3JtYWxpemVkS2V5XSA9IGlzQXJyYXkob3B0KSB8fCBpc0Z1bmN0aW9uKG9wdCkgPyB7IHR5cGU6IG9wdCB9IDogZXh0ZW5kKHt9LCBvcHQpO1xuICAgICAgICBpZiAocHJvcCkge1xuICAgICAgICAgIGNvbnN0IGJvb2xlYW5JbmRleCA9IGdldFR5cGVJbmRleChCb29sZWFuLCBwcm9wLnR5cGUpO1xuICAgICAgICAgIGNvbnN0IHN0cmluZ0luZGV4ID0gZ2V0VHlwZUluZGV4KFN0cmluZywgcHJvcC50eXBlKTtcbiAgICAgICAgICBwcm9wWzAgLyogc2hvdWxkQ2FzdCAqL10gPSBib29sZWFuSW5kZXggPiAtMTtcbiAgICAgICAgICBwcm9wWzEgLyogc2hvdWxkQ2FzdFRydWUgKi9dID0gc3RyaW5nSW5kZXggPCAwIHx8IGJvb2xlYW5JbmRleCA8IHN0cmluZ0luZGV4O1xuICAgICAgICAgIGlmIChib29sZWFuSW5kZXggPiAtMSB8fCBoYXNPd24ocHJvcCwgXCJkZWZhdWx0XCIpKSB7XG4gICAgICAgICAgICBuZWVkQ2FzdEtleXMucHVzaChub3JtYWxpemVkS2V5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY29uc3QgcmVzID0gW25vcm1hbGl6ZWQsIG5lZWRDYXN0S2V5c107XG4gIGlmIChpc09iamVjdChjb21wKSkge1xuICAgIGNhY2hlLnNldChjb21wLCByZXMpO1xuICB9XG4gIHJldHVybiByZXM7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BOYW1lKGtleSkge1xuICBpZiAoa2V5WzBdICE9PSBcIiRcIikge1xuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICB3YXJuKGBJbnZhbGlkIHByb3AgbmFtZTogXCIke2tleX1cIiBpcyBhIHJlc2VydmVkIHByb3BlcnR5LmApO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGdldFR5cGUoY3Rvcikge1xuICBjb25zdCBtYXRjaCA9IGN0b3IgJiYgY3Rvci50b1N0cmluZygpLm1hdGNoKC9eXFxzKihmdW5jdGlvbnxjbGFzcykgKFxcdyspLyk7XG4gIHJldHVybiBtYXRjaCA/IG1hdGNoWzJdIDogY3RvciA9PT0gbnVsbCA/IFwibnVsbFwiIDogXCJcIjtcbn1cbmZ1bmN0aW9uIGlzU2FtZVR5cGUoYSwgYikge1xuICByZXR1cm4gZ2V0VHlwZShhKSA9PT0gZ2V0VHlwZShiKTtcbn1cbmZ1bmN0aW9uIGdldFR5cGVJbmRleCh0eXBlLCBleHBlY3RlZFR5cGVzKSB7XG4gIGlmIChpc0FycmF5KGV4cGVjdGVkVHlwZXMpKSB7XG4gICAgcmV0dXJuIGV4cGVjdGVkVHlwZXMuZmluZEluZGV4KCh0KSA9PiBpc1NhbWVUeXBlKHQsIHR5cGUpKTtcbiAgfSBlbHNlIGlmIChpc0Z1bmN0aW9uKGV4cGVjdGVkVHlwZXMpKSB7XG4gICAgcmV0dXJuIGlzU2FtZVR5cGUoZXhwZWN0ZWRUeXBlcywgdHlwZSkgPyAwIDogLTE7XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wcyhyYXdQcm9wcywgcHJvcHMsIGluc3RhbmNlKSB7XG4gIGNvbnN0IHJlc29sdmVkVmFsdWVzID0gdG9SYXcocHJvcHMpO1xuICBjb25zdCBvcHRpb25zID0gaW5zdGFuY2UucHJvcHNPcHRpb25zWzBdO1xuICBmb3IgKGNvbnN0IGtleSBpbiBvcHRpb25zKSB7XG4gICAgbGV0IG9wdCA9IG9wdGlvbnNba2V5XTtcbiAgICBpZiAob3B0ID09IG51bGwpXG4gICAgICBjb250aW51ZTtcbiAgICB2YWxpZGF0ZVByb3AoXG4gICAgICBrZXksXG4gICAgICByZXNvbHZlZFZhbHVlc1trZXldLFxuICAgICAgb3B0LFxuICAgICAgIWhhc093bihyYXdQcm9wcywga2V5KSAmJiAhaGFzT3duKHJhd1Byb3BzLCBoeXBoZW5hdGUoa2V5KSlcbiAgICApO1xuICB9XG59XG5mdW5jdGlvbiB2YWxpZGF0ZVByb3AobmFtZSwgdmFsdWUsIHByb3AsIGlzQWJzZW50KSB7XG4gIGNvbnN0IHsgdHlwZSwgcmVxdWlyZWQsIHZhbGlkYXRvciwgc2tpcENoZWNrIH0gPSBwcm9wO1xuICBpZiAocmVxdWlyZWQgJiYgaXNBYnNlbnQpIHtcbiAgICB3YXJuKCdNaXNzaW5nIHJlcXVpcmVkIHByb3A6IFwiJyArIG5hbWUgKyAnXCInKTtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHZhbHVlID09IG51bGwgJiYgIXJlcXVpcmVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICh0eXBlICE9IG51bGwgJiYgdHlwZSAhPT0gdHJ1ZSAmJiAhc2tpcENoZWNrKSB7XG4gICAgbGV0IGlzVmFsaWQgPSBmYWxzZTtcbiAgICBjb25zdCB0eXBlcyA9IGlzQXJyYXkodHlwZSkgPyB0eXBlIDogW3R5cGVdO1xuICAgIGNvbnN0IGV4cGVjdGVkVHlwZXMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHR5cGVzLmxlbmd0aCAmJiAhaXNWYWxpZDsgaSsrKSB7XG4gICAgICBjb25zdCB7IHZhbGlkLCBleHBlY3RlZFR5cGUgfSA9IGFzc2VydFR5cGUodmFsdWUsIHR5cGVzW2ldKTtcbiAgICAgIGV4cGVjdGVkVHlwZXMucHVzaChleHBlY3RlZFR5cGUgfHwgXCJcIik7XG4gICAgICBpc1ZhbGlkID0gdmFsaWQ7XG4gICAgfVxuICAgIGlmICghaXNWYWxpZCkge1xuICAgICAgd2FybihnZXRJbnZhbGlkVHlwZU1lc3NhZ2UobmFtZSwgdmFsdWUsIGV4cGVjdGVkVHlwZXMpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbiAgaWYgKHZhbGlkYXRvciAmJiAhdmFsaWRhdG9yKHZhbHVlKSkge1xuICAgIHdhcm4oJ0ludmFsaWQgcHJvcDogY3VzdG9tIHZhbGlkYXRvciBjaGVjayBmYWlsZWQgZm9yIHByb3AgXCInICsgbmFtZSArICdcIi4nKTtcbiAgfVxufVxuY29uc3QgaXNTaW1wbGVUeXBlID0gLyogQF9fUFVSRV9fICovIG1ha2VNYXAoXG4gIFwiU3RyaW5nLE51bWJlcixCb29sZWFuLEZ1bmN0aW9uLFN5bWJvbCxCaWdJbnRcIlxuKTtcbmZ1bmN0aW9uIGFzc2VydFR5cGUodmFsdWUsIHR5cGUpIHtcbiAgbGV0IHZhbGlkO1xuICBjb25zdCBleHBlY3RlZFR5cGUgPSBnZXRUeXBlKHR5cGUpO1xuICBpZiAoaXNTaW1wbGVUeXBlKGV4cGVjdGVkVHlwZSkpIHtcbiAgICBjb25zdCB0ID0gdHlwZW9mIHZhbHVlO1xuICAgIHZhbGlkID0gdCA9PT0gZXhwZWN0ZWRUeXBlLnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKCF2YWxpZCAmJiB0ID09PSBcIm9iamVjdFwiKSB7XG4gICAgICB2YWxpZCA9IHZhbHVlIGluc3RhbmNlb2YgdHlwZTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZXhwZWN0ZWRUeXBlID09PSBcIk9iamVjdFwiKSB7XG4gICAgdmFsaWQgPSBpc09iamVjdCh2YWx1ZSk7XG4gIH0gZWxzZSBpZiAoZXhwZWN0ZWRUeXBlID09PSBcIkFycmF5XCIpIHtcbiAgICB2YWxpZCA9IGlzQXJyYXkodmFsdWUpO1xuICB9IGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gXCJudWxsXCIpIHtcbiAgICB2YWxpZCA9IHZhbHVlID09PSBudWxsO1xuICB9IGVsc2Uge1xuICAgIHZhbGlkID0gdmFsdWUgaW5zdGFuY2VvZiB0eXBlO1xuICB9XG4gIHJldHVybiB7XG4gICAgdmFsaWQsXG4gICAgZXhwZWN0ZWRUeXBlXG4gIH07XG59XG5mdW5jdGlvbiBnZXRJbnZhbGlkVHlwZU1lc3NhZ2UobmFtZSwgdmFsdWUsIGV4cGVjdGVkVHlwZXMpIHtcbiAgbGV0IG1lc3NhZ2UgPSBgSW52YWxpZCBwcm9wOiB0eXBlIGNoZWNrIGZhaWxlZCBmb3IgcHJvcCBcIiR7bmFtZX1cIi4gRXhwZWN0ZWQgJHtleHBlY3RlZFR5cGVzLm1hcChjYXBpdGFsaXplKS5qb2luKFwiIHwgXCIpfWA7XG4gIGNvbnN0IGV4cGVjdGVkVHlwZSA9IGV4cGVjdGVkVHlwZXNbMF07XG4gIGNvbnN0IHJlY2VpdmVkVHlwZSA9IHRvUmF3VHlwZSh2YWx1ZSk7XG4gIGNvbnN0IGV4cGVjdGVkVmFsdWUgPSBzdHlsZVZhbHVlKHZhbHVlLCBleHBlY3RlZFR5cGUpO1xuICBjb25zdCByZWNlaXZlZFZhbHVlID0gc3R5bGVWYWx1ZSh2YWx1ZSwgcmVjZWl2ZWRUeXBlKTtcbiAgaWYgKGV4cGVjdGVkVHlwZXMubGVuZ3RoID09PSAxICYmIGlzRXhwbGljYWJsZShleHBlY3RlZFR5cGUpICYmICFpc0Jvb2xlYW4oZXhwZWN0ZWRUeXBlLCByZWNlaXZlZFR5cGUpKSB7XG4gICAgbWVzc2FnZSArPSBgIHdpdGggdmFsdWUgJHtleHBlY3RlZFZhbHVlfWA7XG4gIH1cbiAgbWVzc2FnZSArPSBgLCBnb3QgJHtyZWNlaXZlZFR5cGV9IGA7XG4gIGlmIChpc0V4cGxpY2FibGUocmVjZWl2ZWRUeXBlKSkge1xuICAgIG1lc3NhZ2UgKz0gYHdpdGggdmFsdWUgJHtyZWNlaXZlZFZhbHVlfS5gO1xuICB9XG4gIHJldHVybiBtZXNzYWdlO1xufVxuZnVuY3Rpb24gc3R5bGVWYWx1ZSh2YWx1ZSwgdHlwZSkge1xuICBpZiAodHlwZSA9PT0gXCJTdHJpbmdcIikge1xuICAgIHJldHVybiBgXCIke3ZhbHVlfVwiYDtcbiAgfSBlbHNlIGlmICh0eXBlID09PSBcIk51bWJlclwiKSB7XG4gICAgcmV0dXJuIGAke051bWJlcih2YWx1ZSl9YDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYCR7dmFsdWV9YDtcbiAgfVxufVxuZnVuY3Rpb24gaXNFeHBsaWNhYmxlKHR5cGUpIHtcbiAgY29uc3QgZXhwbGljaXRUeXBlcyA9IFtcInN0cmluZ1wiLCBcIm51bWJlclwiLCBcImJvb2xlYW5cIl07XG4gIHJldHVybiBleHBsaWNpdFR5cGVzLnNvbWUoKGVsZW0pID0+IHR5cGUudG9Mb3dlckNhc2UoKSA9PT0gZWxlbSk7XG59XG5mdW5jdGlvbiBpc0Jvb2xlYW4oLi4uYXJncykge1xuICByZXR1cm4gYXJncy5zb21lKChlbGVtKSA9PiBlbGVtLnRvTG93ZXJDYXNlKCkgPT09IFwiYm9vbGVhblwiKTtcbn1cblxuY29uc3QgaXNJbnRlcm5hbEtleSA9IChrZXkpID0+IGtleVswXSA9PT0gXCJfXCIgfHwga2V5ID09PSBcIiRzdGFibGVcIjtcbmNvbnN0IG5vcm1hbGl6ZVNsb3RWYWx1ZSA9ICh2YWx1ZSkgPT4gaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZS5tYXAobm9ybWFsaXplVk5vZGUpIDogW25vcm1hbGl6ZVZOb2RlKHZhbHVlKV07XG5jb25zdCBub3JtYWxpemVTbG90ID0gKGtleSwgcmF3U2xvdCwgY3R4KSA9PiB7XG4gIGlmIChyYXdTbG90Ll9uKSB7XG4gICAgcmV0dXJuIHJhd1Nsb3Q7XG4gIH1cbiAgY29uc3Qgbm9ybWFsaXplZCA9IHdpdGhDdHgoKC4uLmFyZ3MpID0+IHtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBjdXJyZW50SW5zdGFuY2UpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIGBTbG90IFwiJHtrZXl9XCIgaW52b2tlZCBvdXRzaWRlIG9mIHRoZSByZW5kZXIgZnVuY3Rpb246IHRoaXMgd2lsbCBub3QgdHJhY2sgZGVwZW5kZW5jaWVzIHVzZWQgaW4gdGhlIHNsb3QuIEludm9rZSB0aGUgc2xvdCBmdW5jdGlvbiBpbnNpZGUgdGhlIHJlbmRlciBmdW5jdGlvbiBpbnN0ZWFkLmBcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBub3JtYWxpemVTbG90VmFsdWUocmF3U2xvdCguLi5hcmdzKSk7XG4gIH0sIGN0eCk7XG4gIG5vcm1hbGl6ZWQuX2MgPSBmYWxzZTtcbiAgcmV0dXJuIG5vcm1hbGl6ZWQ7XG59O1xuY29uc3Qgbm9ybWFsaXplT2JqZWN0U2xvdHMgPSAocmF3U2xvdHMsIHNsb3RzLCBpbnN0YW5jZSkgPT4ge1xuICBjb25zdCBjdHggPSByYXdTbG90cy5fY3R4O1xuICBmb3IgKGNvbnN0IGtleSBpbiByYXdTbG90cykge1xuICAgIGlmIChpc0ludGVybmFsS2V5KGtleSkpXG4gICAgICBjb250aW51ZTtcbiAgICBjb25zdCB2YWx1ZSA9IHJhd1Nsb3RzW2tleV07XG4gICAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgICBzbG90c1trZXldID0gbm9ybWFsaXplU2xvdChrZXksIHZhbHVlLCBjdHgpO1xuICAgIH0gZWxzZSBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgdHJ1ZSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIGBOb24tZnVuY3Rpb24gdmFsdWUgZW5jb3VudGVyZWQgZm9yIHNsb3QgXCIke2tleX1cIi4gUHJlZmVyIGZ1bmN0aW9uIHNsb3RzIGZvciBiZXR0ZXIgcGVyZm9ybWFuY2UuYFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgY29uc3Qgbm9ybWFsaXplZCA9IG5vcm1hbGl6ZVNsb3RWYWx1ZSh2YWx1ZSk7XG4gICAgICBzbG90c1trZXldID0gKCkgPT4gbm9ybWFsaXplZDtcbiAgICB9XG4gIH1cbn07XG5jb25zdCBub3JtYWxpemVWTm9kZVNsb3RzID0gKGluc3RhbmNlLCBjaGlsZHJlbikgPT4ge1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhaXNLZWVwQWxpdmUoaW5zdGFuY2Uudm5vZGUpICYmIHRydWUpIHtcbiAgICB3YXJuKFxuICAgICAgYE5vbi1mdW5jdGlvbiB2YWx1ZSBlbmNvdW50ZXJlZCBmb3IgZGVmYXVsdCBzbG90LiBQcmVmZXIgZnVuY3Rpb24gc2xvdHMgZm9yIGJldHRlciBwZXJmb3JtYW5jZS5gXG4gICAgKTtcbiAgfVxuICBjb25zdCBub3JtYWxpemVkID0gbm9ybWFsaXplU2xvdFZhbHVlKGNoaWxkcmVuKTtcbiAgaW5zdGFuY2Uuc2xvdHMuZGVmYXVsdCA9ICgpID0+IG5vcm1hbGl6ZWQ7XG59O1xuY29uc3QgaW5pdFNsb3RzID0gKGluc3RhbmNlLCBjaGlsZHJlbikgPT4ge1xuICBpZiAoaW5zdGFuY2Uudm5vZGUuc2hhcGVGbGFnICYgMzIpIHtcbiAgICBjb25zdCB0eXBlID0gY2hpbGRyZW4uXztcbiAgICBpZiAodHlwZSkge1xuICAgICAgaW5zdGFuY2Uuc2xvdHMgPSB0b1JhdyhjaGlsZHJlbik7XG4gICAgICBkZWYoY2hpbGRyZW4sIFwiX1wiLCB0eXBlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9ybWFsaXplT2JqZWN0U2xvdHMoXG4gICAgICAgIGNoaWxkcmVuLFxuICAgICAgICBpbnN0YW5jZS5zbG90cyA9IHt9KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaW5zdGFuY2Uuc2xvdHMgPSB7fTtcbiAgICBpZiAoY2hpbGRyZW4pIHtcbiAgICAgIG5vcm1hbGl6ZVZOb2RlU2xvdHMoaW5zdGFuY2UsIGNoaWxkcmVuKTtcbiAgICB9XG4gIH1cbiAgZGVmKGluc3RhbmNlLnNsb3RzLCBJbnRlcm5hbE9iamVjdEtleSwgMSk7XG59O1xuY29uc3QgdXBkYXRlU2xvdHMgPSAoaW5zdGFuY2UsIGNoaWxkcmVuLCBvcHRpbWl6ZWQpID0+IHtcbiAgY29uc3QgeyB2bm9kZSwgc2xvdHMgfSA9IGluc3RhbmNlO1xuICBsZXQgbmVlZERlbGV0aW9uQ2hlY2sgPSB0cnVlO1xuICBsZXQgZGVsZXRpb25Db21wYXJpc29uVGFyZ2V0ID0gRU1QVFlfT0JKO1xuICBpZiAodm5vZGUuc2hhcGVGbGFnICYgMzIpIHtcbiAgICBjb25zdCB0eXBlID0gY2hpbGRyZW4uXztcbiAgICBpZiAodHlwZSkge1xuICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgaXNIbXJVcGRhdGluZykge1xuICAgICAgICBleHRlbmQoc2xvdHMsIGNoaWxkcmVuKTtcbiAgICAgICAgdHJpZ2dlcihpbnN0YW5jZSwgXCJzZXRcIiwgXCIkc2xvdHNcIik7XG4gICAgICB9IGVsc2UgaWYgKG9wdGltaXplZCAmJiB0eXBlID09PSAxKSB7XG4gICAgICAgIG5lZWREZWxldGlvbkNoZWNrID0gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBleHRlbmQoc2xvdHMsIGNoaWxkcmVuKTtcbiAgICAgICAgaWYgKCFvcHRpbWl6ZWQgJiYgdHlwZSA9PT0gMSkge1xuICAgICAgICAgIGRlbGV0ZSBzbG90cy5fO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG5lZWREZWxldGlvbkNoZWNrID0gIWNoaWxkcmVuLiRzdGFibGU7XG4gICAgICBub3JtYWxpemVPYmplY3RTbG90cyhjaGlsZHJlbiwgc2xvdHMpO1xuICAgIH1cbiAgICBkZWxldGlvbkNvbXBhcmlzb25UYXJnZXQgPSBjaGlsZHJlbjtcbiAgfSBlbHNlIGlmIChjaGlsZHJlbikge1xuICAgIG5vcm1hbGl6ZVZOb2RlU2xvdHMoaW5zdGFuY2UsIGNoaWxkcmVuKTtcbiAgICBkZWxldGlvbkNvbXBhcmlzb25UYXJnZXQgPSB7IGRlZmF1bHQ6IDEgfTtcbiAgfVxuICBpZiAobmVlZERlbGV0aW9uQ2hlY2spIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBzbG90cykge1xuICAgICAgaWYgKCFpc0ludGVybmFsS2V5KGtleSkgJiYgIShrZXkgaW4gZGVsZXRpb25Db21wYXJpc29uVGFyZ2V0KSkge1xuICAgICAgICBkZWxldGUgc2xvdHNba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHNldFJlZihyYXdSZWYsIG9sZFJhd1JlZiwgcGFyZW50U3VzcGVuc2UsIHZub2RlLCBpc1VubW91bnQgPSBmYWxzZSkge1xuICBpZiAoaXNBcnJheShyYXdSZWYpKSB7XG4gICAgcmF3UmVmLmZvckVhY2goXG4gICAgICAociwgaSkgPT4gc2V0UmVmKFxuICAgICAgICByLFxuICAgICAgICBvbGRSYXdSZWYgJiYgKGlzQXJyYXkob2xkUmF3UmVmKSA/IG9sZFJhd1JlZltpXSA6IG9sZFJhd1JlZiksXG4gICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICB2bm9kZSxcbiAgICAgICAgaXNVbm1vdW50XG4gICAgICApXG4gICAgKTtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGlzQXN5bmNXcmFwcGVyKHZub2RlKSAmJiAhaXNVbm1vdW50KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHJlZlZhbHVlID0gdm5vZGUuc2hhcGVGbGFnICYgNCA/IGdldEV4cG9zZVByb3h5KHZub2RlLmNvbXBvbmVudCkgfHwgdm5vZGUuY29tcG9uZW50LnByb3h5IDogdm5vZGUuZWw7XG4gIGNvbnN0IHZhbHVlID0gaXNVbm1vdW50ID8gbnVsbCA6IHJlZlZhbHVlO1xuICBjb25zdCB7IGk6IG93bmVyLCByOiByZWYgfSA9IHJhd1JlZjtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgIW93bmVyKSB7XG4gICAgd2FybihcbiAgICAgIGBNaXNzaW5nIHJlZiBvd25lciBjb250ZXh0LiByZWYgY2Fubm90IGJlIHVzZWQgb24gaG9pc3RlZCB2bm9kZXMuIEEgdm5vZGUgd2l0aCByZWYgbXVzdCBiZSBjcmVhdGVkIGluc2lkZSB0aGUgcmVuZGVyIGZ1bmN0aW9uLmBcbiAgICApO1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBvbGRSZWYgPSBvbGRSYXdSZWYgJiYgb2xkUmF3UmVmLnI7XG4gIGNvbnN0IHJlZnMgPSBvd25lci5yZWZzID09PSBFTVBUWV9PQkogPyBvd25lci5yZWZzID0ge30gOiBvd25lci5yZWZzO1xuICBjb25zdCBzZXR1cFN0YXRlID0gb3duZXIuc2V0dXBTdGF0ZTtcbiAgaWYgKG9sZFJlZiAhPSBudWxsICYmIG9sZFJlZiAhPT0gcmVmKSB7XG4gICAgaWYgKGlzU3RyaW5nKG9sZFJlZikpIHtcbiAgICAgIHJlZnNbb2xkUmVmXSA9IG51bGw7XG4gICAgICBpZiAoaGFzT3duKHNldHVwU3RhdGUsIG9sZFJlZikpIHtcbiAgICAgICAgc2V0dXBTdGF0ZVtvbGRSZWZdID0gbnVsbDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzUmVmKG9sZFJlZikpIHtcbiAgICAgIG9sZFJlZi52YWx1ZSA9IG51bGw7XG4gICAgfVxuICB9XG4gIGlmIChpc0Z1bmN0aW9uKHJlZikpIHtcbiAgICBjYWxsV2l0aEVycm9ySGFuZGxpbmcocmVmLCBvd25lciwgMTIsIFt2YWx1ZSwgcmVmc10pO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IF9pc1N0cmluZyA9IGlzU3RyaW5nKHJlZik7XG4gICAgY29uc3QgX2lzUmVmID0gaXNSZWYocmVmKTtcbiAgICBpZiAoX2lzU3RyaW5nIHx8IF9pc1JlZikge1xuICAgICAgY29uc3QgZG9TZXQgPSAoKSA9PiB7XG4gICAgICAgIGlmIChyYXdSZWYuZikge1xuICAgICAgICAgIGNvbnN0IGV4aXN0aW5nID0gX2lzU3RyaW5nID8gaGFzT3duKHNldHVwU3RhdGUsIHJlZikgPyBzZXR1cFN0YXRlW3JlZl0gOiByZWZzW3JlZl0gOiByZWYudmFsdWU7XG4gICAgICAgICAgaWYgKGlzVW5tb3VudCkge1xuICAgICAgICAgICAgaXNBcnJheShleGlzdGluZykgJiYgcmVtb3ZlKGV4aXN0aW5nLCByZWZWYWx1ZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghaXNBcnJheShleGlzdGluZykpIHtcbiAgICAgICAgICAgICAgaWYgKF9pc1N0cmluZykge1xuICAgICAgICAgICAgICAgIHJlZnNbcmVmXSA9IFtyZWZWYWx1ZV07XG4gICAgICAgICAgICAgICAgaWYgKGhhc093bihzZXR1cFN0YXRlLCByZWYpKSB7XG4gICAgICAgICAgICAgICAgICBzZXR1cFN0YXRlW3JlZl0gPSByZWZzW3JlZl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlZi52YWx1ZSA9IFtyZWZWYWx1ZV07XG4gICAgICAgICAgICAgICAgaWYgKHJhd1JlZi5rKVxuICAgICAgICAgICAgICAgICAgcmVmc1tyYXdSZWYua10gPSByZWYudmFsdWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIWV4aXN0aW5nLmluY2x1ZGVzKHJlZlZhbHVlKSkge1xuICAgICAgICAgICAgICBleGlzdGluZy5wdXNoKHJlZlZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoX2lzU3RyaW5nKSB7XG4gICAgICAgICAgcmVmc1tyZWZdID0gdmFsdWU7XG4gICAgICAgICAgaWYgKGhhc093bihzZXR1cFN0YXRlLCByZWYpKSB7XG4gICAgICAgICAgICBzZXR1cFN0YXRlW3JlZl0gPSB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoX2lzUmVmKSB7XG4gICAgICAgICAgcmVmLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgaWYgKHJhd1JlZi5rKVxuICAgICAgICAgICAgcmVmc1tyYXdSZWYua10gPSB2YWx1ZTtcbiAgICAgICAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgd2FybihcIkludmFsaWQgdGVtcGxhdGUgcmVmIHR5cGU6XCIsIHJlZiwgYCgke3R5cGVvZiByZWZ9KWApO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIGRvU2V0LmlkID0gLTE7XG4gICAgICAgIHF1ZXVlUG9zdFJlbmRlckVmZmVjdChkb1NldCwgcGFyZW50U3VzcGVuc2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZG9TZXQoKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgIHdhcm4oXCJJbnZhbGlkIHRlbXBsYXRlIHJlZiB0eXBlOlwiLCByZWYsIGAoJHt0eXBlb2YgcmVmfSlgKTtcbiAgICB9XG4gIH1cbn1cblxubGV0IGhhc01pc21hdGNoID0gZmFsc2U7XG5jb25zdCBpc1NWR0NvbnRhaW5lciA9IChjb250YWluZXIpID0+IC9zdmcvLnRlc3QoY29udGFpbmVyLm5hbWVzcGFjZVVSSSkgJiYgY29udGFpbmVyLnRhZ05hbWUgIT09IFwiZm9yZWlnbk9iamVjdFwiO1xuY29uc3QgaXNDb21tZW50ID0gKG5vZGUpID0+IG5vZGUubm9kZVR5cGUgPT09IDggLyogQ09NTUVOVCAqLztcbmZ1bmN0aW9uIGNyZWF0ZUh5ZHJhdGlvbkZ1bmN0aW9ucyhyZW5kZXJlckludGVybmFscykge1xuICBjb25zdCB7XG4gICAgbXQ6IG1vdW50Q29tcG9uZW50LFxuICAgIHA6IHBhdGNoLFxuICAgIG86IHtcbiAgICAgIHBhdGNoUHJvcCxcbiAgICAgIGNyZWF0ZVRleHQsXG4gICAgICBuZXh0U2libGluZyxcbiAgICAgIHBhcmVudE5vZGUsXG4gICAgICByZW1vdmUsXG4gICAgICBpbnNlcnQsXG4gICAgICBjcmVhdGVDb21tZW50XG4gICAgfVxuICB9ID0gcmVuZGVyZXJJbnRlcm5hbHM7XG4gIGNvbnN0IGh5ZHJhdGUgPSAodm5vZGUsIGNvbnRhaW5lcikgPT4ge1xuICAgIGlmICghY29udGFpbmVyLmhhc0NoaWxkTm9kZXMoKSkge1xuICAgICAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiB3YXJuKFxuICAgICAgICBgQXR0ZW1wdGluZyB0byBoeWRyYXRlIGV4aXN0aW5nIG1hcmt1cCBidXQgY29udGFpbmVyIGlzIGVtcHR5LiBQZXJmb3JtaW5nIGZ1bGwgbW91bnQgaW5zdGVhZC5gXG4gICAgICApO1xuICAgICAgcGF0Y2gobnVsbCwgdm5vZGUsIGNvbnRhaW5lcik7XG4gICAgICBmbHVzaFBvc3RGbHVzaENicygpO1xuICAgICAgY29udGFpbmVyLl92bm9kZSA9IHZub2RlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBoYXNNaXNtYXRjaCA9IGZhbHNlO1xuICAgIGh5ZHJhdGVOb2RlKGNvbnRhaW5lci5maXJzdENoaWxkLCB2bm9kZSwgbnVsbCwgbnVsbCwgbnVsbCk7XG4gICAgZmx1c2hQb3N0Rmx1c2hDYnMoKTtcbiAgICBjb250YWluZXIuX3Zub2RlID0gdm5vZGU7XG4gICAgaWYgKGhhc01pc21hdGNoICYmIHRydWUpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEh5ZHJhdGlvbiBjb21wbGV0ZWQgYnV0IGNvbnRhaW5zIG1pc21hdGNoZXMuYCk7XG4gICAgfVxuICB9O1xuICBjb25zdCBoeWRyYXRlTm9kZSA9IChub2RlLCB2bm9kZSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQgPSBmYWxzZSkgPT4ge1xuICAgIGNvbnN0IGlzRnJhZ21lbnRTdGFydCA9IGlzQ29tbWVudChub2RlKSAmJiBub2RlLmRhdGEgPT09IFwiW1wiO1xuICAgIGNvbnN0IG9uTWlzbWF0Y2ggPSAoKSA9PiBoYW5kbGVNaXNtYXRjaChcbiAgICAgIG5vZGUsXG4gICAgICB2bm9kZSxcbiAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgaXNGcmFnbWVudFN0YXJ0XG4gICAgKTtcbiAgICBjb25zdCB7IHR5cGUsIHJlZiwgc2hhcGVGbGFnLCBwYXRjaEZsYWcgfSA9IHZub2RlO1xuICAgIGxldCBkb21UeXBlID0gbm9kZS5ub2RlVHlwZTtcbiAgICB2bm9kZS5lbCA9IG5vZGU7XG4gICAgaWYgKHBhdGNoRmxhZyA9PT0gLTIpIHtcbiAgICAgIG9wdGltaXplZCA9IGZhbHNlO1xuICAgICAgdm5vZGUuZHluYW1pY0NoaWxkcmVuID0gbnVsbDtcbiAgICB9XG4gICAgbGV0IG5leHROb2RlID0gbnVsbDtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgVGV4dDpcbiAgICAgICAgaWYgKGRvbVR5cGUgIT09IDMgLyogVEVYVCAqLykge1xuICAgICAgICAgIGlmICh2bm9kZS5jaGlsZHJlbiA9PT0gXCJcIikge1xuICAgICAgICAgICAgaW5zZXJ0KHZub2RlLmVsID0gY3JlYXRlVGV4dChcIlwiKSwgcGFyZW50Tm9kZShub2RlKSwgbm9kZSk7XG4gICAgICAgICAgICBuZXh0Tm9kZSA9IG5vZGU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5leHROb2RlID0gb25NaXNtYXRjaCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAobm9kZS5kYXRhICE9PSB2bm9kZS5jaGlsZHJlbikge1xuICAgICAgICAgICAgaGFzTWlzbWF0Y2ggPSB0cnVlO1xuICAgICAgICAgICAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiB3YXJuKFxuICAgICAgICAgICAgICBgSHlkcmF0aW9uIHRleHQgbWlzbWF0Y2g6XG4tIENsaWVudDogJHtKU09OLnN0cmluZ2lmeShub2RlLmRhdGEpfVxuLSBTZXJ2ZXI6ICR7SlNPTi5zdHJpbmdpZnkodm5vZGUuY2hpbGRyZW4pfWBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBub2RlLmRhdGEgPSB2bm9kZS5jaGlsZHJlbjtcbiAgICAgICAgICB9XG4gICAgICAgICAgbmV4dE5vZGUgPSBuZXh0U2libGluZyhub2RlKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgQ29tbWVudDpcbiAgICAgICAgaWYgKGRvbVR5cGUgIT09IDggLyogQ09NTUVOVCAqLyB8fCBpc0ZyYWdtZW50U3RhcnQpIHtcbiAgICAgICAgICBuZXh0Tm9kZSA9IG9uTWlzbWF0Y2goKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXh0Tm9kZSA9IG5leHRTaWJsaW5nKG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBTdGF0aWM6XG4gICAgICAgIGlmIChpc0ZyYWdtZW50U3RhcnQpIHtcbiAgICAgICAgICBub2RlID0gbmV4dFNpYmxpbmcobm9kZSk7XG4gICAgICAgICAgZG9tVHlwZSA9IG5vZGUubm9kZVR5cGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRvbVR5cGUgPT09IDEgLyogRUxFTUVOVCAqLyB8fCBkb21UeXBlID09PSAzIC8qIFRFWFQgKi8pIHtcbiAgICAgICAgICBuZXh0Tm9kZSA9IG5vZGU7XG4gICAgICAgICAgY29uc3QgbmVlZFRvQWRvcHRDb250ZW50ID0gIXZub2RlLmNoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZub2RlLnN0YXRpY0NvdW50OyBpKyspIHtcbiAgICAgICAgICAgIGlmIChuZWVkVG9BZG9wdENvbnRlbnQpXG4gICAgICAgICAgICAgIHZub2RlLmNoaWxkcmVuICs9IG5leHROb2RlLm5vZGVUeXBlID09PSAxIC8qIEVMRU1FTlQgKi8gPyBuZXh0Tm9kZS5vdXRlckhUTUwgOiBuZXh0Tm9kZS5kYXRhO1xuICAgICAgICAgICAgaWYgKGkgPT09IHZub2RlLnN0YXRpY0NvdW50IC0gMSkge1xuICAgICAgICAgICAgICB2bm9kZS5hbmNob3IgPSBuZXh0Tm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5leHROb2RlID0gbmV4dFNpYmxpbmcobmV4dE5vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gaXNGcmFnbWVudFN0YXJ0ID8gbmV4dFNpYmxpbmcobmV4dE5vZGUpIDogbmV4dE5vZGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb25NaXNtYXRjaCgpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBGcmFnbWVudDpcbiAgICAgICAgaWYgKCFpc0ZyYWdtZW50U3RhcnQpIHtcbiAgICAgICAgICBuZXh0Tm9kZSA9IG9uTWlzbWF0Y2goKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXh0Tm9kZSA9IGh5ZHJhdGVGcmFnbWVudChcbiAgICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgICB2bm9kZSxcbiAgICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgICAgb3B0aW1pemVkXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChzaGFwZUZsYWcgJiAxKSB7XG4gICAgICAgICAgaWYgKGRvbVR5cGUgIT09IDEgLyogRUxFTUVOVCAqLyB8fCB2bm9kZS50eXBlLnRvTG93ZXJDYXNlKCkgIT09IG5vZGUudGFnTmFtZS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICAgICBuZXh0Tm9kZSA9IG9uTWlzbWF0Y2goKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV4dE5vZGUgPSBoeWRyYXRlRWxlbWVudChcbiAgICAgICAgICAgICAgbm9kZSxcbiAgICAgICAgICAgICAgdm5vZGUsXG4gICAgICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICAgICAgb3B0aW1pemVkXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChzaGFwZUZsYWcgJiA2KSB7XG4gICAgICAgICAgdm5vZGUuc2xvdFNjb3BlSWRzID0gc2xvdFNjb3BlSWRzO1xuICAgICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IHBhcmVudE5vZGUobm9kZSk7XG4gICAgICAgICAgbW91bnRDb21wb25lbnQoXG4gICAgICAgICAgICB2bm9kZSxcbiAgICAgICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICAgIGlzU1ZHQ29udGFpbmVyKGNvbnRhaW5lciksXG4gICAgICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICAgICApO1xuICAgICAgICAgIG5leHROb2RlID0gaXNGcmFnbWVudFN0YXJ0ID8gbG9jYXRlQ2xvc2luZ0FzeW5jQW5jaG9yKG5vZGUpIDogbmV4dFNpYmxpbmcobm9kZSk7XG4gICAgICAgICAgaWYgKG5leHROb2RlICYmIGlzQ29tbWVudChuZXh0Tm9kZSkgJiYgbmV4dE5vZGUuZGF0YSA9PT0gXCJ0ZWxlcG9ydCBlbmRcIikge1xuICAgICAgICAgICAgbmV4dE5vZGUgPSBuZXh0U2libGluZyhuZXh0Tm9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc0FzeW5jV3JhcHBlcih2bm9kZSkpIHtcbiAgICAgICAgICAgIGxldCBzdWJUcmVlO1xuICAgICAgICAgICAgaWYgKGlzRnJhZ21lbnRTdGFydCkge1xuICAgICAgICAgICAgICBzdWJUcmVlID0gY3JlYXRlVk5vZGUoRnJhZ21lbnQpO1xuICAgICAgICAgICAgICBzdWJUcmVlLmFuY2hvciA9IG5leHROb2RlID8gbmV4dE5vZGUucHJldmlvdXNTaWJsaW5nIDogY29udGFpbmVyLmxhc3RDaGlsZDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHN1YlRyZWUgPSBub2RlLm5vZGVUeXBlID09PSAzID8gY3JlYXRlVGV4dFZOb2RlKFwiXCIpIDogY3JlYXRlVk5vZGUoXCJkaXZcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdWJUcmVlLmVsID0gbm9kZTtcbiAgICAgICAgICAgIHZub2RlLmNvbXBvbmVudC5zdWJUcmVlID0gc3ViVHJlZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoc2hhcGVGbGFnICYgNjQpIHtcbiAgICAgICAgICBpZiAoZG9tVHlwZSAhPT0gOCAvKiBDT01NRU5UICovKSB7XG4gICAgICAgICAgICBuZXh0Tm9kZSA9IG9uTWlzbWF0Y2goKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV4dE5vZGUgPSB2bm9kZS50eXBlLmh5ZHJhdGUoXG4gICAgICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgICAgIHZub2RlLFxuICAgICAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgICAgICAgIG9wdGltaXplZCxcbiAgICAgICAgICAgICAgcmVuZGVyZXJJbnRlcm5hbHMsXG4gICAgICAgICAgICAgIGh5ZHJhdGVDaGlsZHJlblxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoc2hhcGVGbGFnICYgMTI4KSB7XG4gICAgICAgICAgbmV4dE5vZGUgPSB2bm9kZS50eXBlLmh5ZHJhdGUoXG4gICAgICAgICAgICBub2RlLFxuICAgICAgICAgICAgdm5vZGUsXG4gICAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICAgIGlzU1ZHQ29udGFpbmVyKHBhcmVudE5vZGUobm9kZSkpLFxuICAgICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgICAgb3B0aW1pemVkLFxuICAgICAgICAgICAgcmVuZGVyZXJJbnRlcm5hbHMsXG4gICAgICAgICAgICBoeWRyYXRlTm9kZVxuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgIHdhcm4oXCJJbnZhbGlkIEhvc3RWTm9kZSB0eXBlOlwiLCB0eXBlLCBgKCR7dHlwZW9mIHR5cGV9KWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChyZWYgIT0gbnVsbCkge1xuICAgICAgc2V0UmVmKHJlZiwgbnVsbCwgcGFyZW50U3VzcGVuc2UsIHZub2RlKTtcbiAgICB9XG4gICAgcmV0dXJuIG5leHROb2RlO1xuICB9O1xuICBjb25zdCBoeWRyYXRlRWxlbWVudCA9IChlbCwgdm5vZGUsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKSA9PiB7XG4gICAgb3B0aW1pemVkID0gb3B0aW1pemVkIHx8ICEhdm5vZGUuZHluYW1pY0NoaWxkcmVuO1xuICAgIGNvbnN0IHsgdHlwZSwgcHJvcHMsIHBhdGNoRmxhZywgc2hhcGVGbGFnLCBkaXJzIH0gPSB2bm9kZTtcbiAgICBjb25zdCBmb3JjZVBhdGNoVmFsdWUgPSB0eXBlID09PSBcImlucHV0XCIgJiYgZGlycyB8fCB0eXBlID09PSBcIm9wdGlvblwiO1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHx8IGZvcmNlUGF0Y2hWYWx1ZSB8fCBwYXRjaEZsYWcgIT09IC0xKSB7XG4gICAgICBpZiAoZGlycykge1xuICAgICAgICBpbnZva2VEaXJlY3RpdmVIb29rKHZub2RlLCBudWxsLCBwYXJlbnRDb21wb25lbnQsIFwiY3JlYXRlZFwiKTtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9wcykge1xuICAgICAgICBpZiAoZm9yY2VQYXRjaFZhbHVlIHx8ICFvcHRpbWl6ZWQgfHwgcGF0Y2hGbGFnICYgKDE2IHwgMzIpKSB7XG4gICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcHJvcHMpIHtcbiAgICAgICAgICAgIGlmIChmb3JjZVBhdGNoVmFsdWUgJiYga2V5LmVuZHNXaXRoKFwidmFsdWVcIikgfHwgaXNPbihrZXkpICYmICFpc1Jlc2VydmVkUHJvcChrZXkpKSB7XG4gICAgICAgICAgICAgIHBhdGNoUHJvcChcbiAgICAgICAgICAgICAgICBlbCxcbiAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICBwcm9wc1trZXldLFxuICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgICAgIHZvaWQgMCxcbiAgICAgICAgICAgICAgICBwYXJlbnRDb21wb25lbnRcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAocHJvcHMub25DbGljaykge1xuICAgICAgICAgIHBhdGNoUHJvcChcbiAgICAgICAgICAgIGVsLFxuICAgICAgICAgICAgXCJvbkNsaWNrXCIsXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgcHJvcHMub25DbGljayxcbiAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgdm9pZCAwLFxuICAgICAgICAgICAgcGFyZW50Q29tcG9uZW50XG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbGV0IHZub2RlSG9va3M7XG4gICAgICBpZiAodm5vZGVIb29rcyA9IHByb3BzICYmIHByb3BzLm9uVm5vZGVCZWZvcmVNb3VudCkge1xuICAgICAgICBpbnZva2VWTm9kZUhvb2sodm5vZGVIb29rcywgcGFyZW50Q29tcG9uZW50LCB2bm9kZSk7XG4gICAgICB9XG4gICAgICBpZiAoZGlycykge1xuICAgICAgICBpbnZva2VEaXJlY3RpdmVIb29rKHZub2RlLCBudWxsLCBwYXJlbnRDb21wb25lbnQsIFwiYmVmb3JlTW91bnRcIik7XG4gICAgICB9XG4gICAgICBpZiAoKHZub2RlSG9va3MgPSBwcm9wcyAmJiBwcm9wcy5vblZub2RlTW91bnRlZCkgfHwgZGlycykge1xuICAgICAgICBxdWV1ZUVmZmVjdFdpdGhTdXNwZW5zZSgoKSA9PiB7XG4gICAgICAgICAgdm5vZGVIb29rcyAmJiBpbnZva2VWTm9kZUhvb2sodm5vZGVIb29rcywgcGFyZW50Q29tcG9uZW50LCB2bm9kZSk7XG4gICAgICAgICAgZGlycyAmJiBpbnZva2VEaXJlY3RpdmVIb29rKHZub2RlLCBudWxsLCBwYXJlbnRDb21wb25lbnQsIFwibW91bnRlZFwiKTtcbiAgICAgICAgfSwgcGFyZW50U3VzcGVuc2UpO1xuICAgICAgfVxuICAgICAgaWYgKHNoYXBlRmxhZyAmIDE2ICYmIC8vIHNraXAgaWYgZWxlbWVudCBoYXMgaW5uZXJIVE1MIC8gdGV4dENvbnRlbnRcbiAgICAgICEocHJvcHMgJiYgKHByb3BzLmlubmVySFRNTCB8fCBwcm9wcy50ZXh0Q29udGVudCkpKSB7XG4gICAgICAgIGxldCBuZXh0ID0gaHlkcmF0ZUNoaWxkcmVuKFxuICAgICAgICAgIGVsLmZpcnN0Q2hpbGQsXG4gICAgICAgICAgdm5vZGUsXG4gICAgICAgICAgZWwsXG4gICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICAgKTtcbiAgICAgICAgbGV0IGhhc1dhcm5lZCA9IGZhbHNlO1xuICAgICAgICB3aGlsZSAobmV4dCkge1xuICAgICAgICAgIGhhc01pc21hdGNoID0gdHJ1ZTtcbiAgICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhaGFzV2FybmVkKSB7XG4gICAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgICBgSHlkcmF0aW9uIGNoaWxkcmVuIG1pc21hdGNoIGluIDwke3Zub2RlLnR5cGV9Pjogc2VydmVyIHJlbmRlcmVkIGVsZW1lbnQgY29udGFpbnMgbW9yZSBjaGlsZCBub2RlcyB0aGFuIGNsaWVudCB2ZG9tLmBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBoYXNXYXJuZWQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBjdXIgPSBuZXh0O1xuICAgICAgICAgIG5leHQgPSBuZXh0Lm5leHRTaWJsaW5nO1xuICAgICAgICAgIHJlbW92ZShjdXIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHNoYXBlRmxhZyAmIDgpIHtcbiAgICAgICAgaWYgKGVsLnRleHRDb250ZW50ICE9PSB2bm9kZS5jaGlsZHJlbikge1xuICAgICAgICAgIGhhc01pc21hdGNoID0gdHJ1ZTtcbiAgICAgICAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHdhcm4oXG4gICAgICAgICAgICBgSHlkcmF0aW9uIHRleHQgY29udGVudCBtaXNtYXRjaCBpbiA8JHt2bm9kZS50eXBlfT46XG4tIENsaWVudDogJHtlbC50ZXh0Q29udGVudH1cbi0gU2VydmVyOiAke3Zub2RlLmNoaWxkcmVufWBcbiAgICAgICAgICApO1xuICAgICAgICAgIGVsLnRleHRDb250ZW50ID0gdm5vZGUuY2hpbGRyZW47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGVsLm5leHRTaWJsaW5nO1xuICB9O1xuICBjb25zdCBoeWRyYXRlQ2hpbGRyZW4gPSAobm9kZSwgcGFyZW50Vk5vZGUsIGNvbnRhaW5lciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpID0+IHtcbiAgICBvcHRpbWl6ZWQgPSBvcHRpbWl6ZWQgfHwgISFwYXJlbnRWTm9kZS5keW5hbWljQ2hpbGRyZW47XG4gICAgY29uc3QgY2hpbGRyZW4gPSBwYXJlbnRWTm9kZS5jaGlsZHJlbjtcbiAgICBjb25zdCBsID0gY2hpbGRyZW4ubGVuZ3RoO1xuICAgIGxldCBoYXNXYXJuZWQgPSBmYWxzZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgY29uc3Qgdm5vZGUgPSBvcHRpbWl6ZWQgPyBjaGlsZHJlbltpXSA6IGNoaWxkcmVuW2ldID0gbm9ybWFsaXplVk5vZGUoY2hpbGRyZW5baV0pO1xuICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgbm9kZSA9IGh5ZHJhdGVOb2RlKFxuICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgdm5vZGUsXG4gICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSBpZiAodm5vZGUudHlwZSA9PT0gVGV4dCAmJiAhdm5vZGUuY2hpbGRyZW4pIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBoYXNNaXNtYXRjaCA9IHRydWU7XG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICFoYXNXYXJuZWQpIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgYEh5ZHJhdGlvbiBjaGlsZHJlbiBtaXNtYXRjaCBpbiA8JHtjb250YWluZXIudGFnTmFtZS50b0xvd2VyQ2FzZSgpfT46IHNlcnZlciByZW5kZXJlZCBlbGVtZW50IGNvbnRhaW5zIGZld2VyIGNoaWxkIG5vZGVzIHRoYW4gY2xpZW50IHZkb20uYFxuICAgICAgICAgICk7XG4gICAgICAgICAgaGFzV2FybmVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBwYXRjaChcbiAgICAgICAgICBudWxsLFxuICAgICAgICAgIHZub2RlLFxuICAgICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgICBudWxsLFxuICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICBpc1NWR0NvbnRhaW5lcihjb250YWluZXIpLFxuICAgICAgICAgIHNsb3RTY29wZUlkc1xuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbm9kZTtcbiAgfTtcbiAgY29uc3QgaHlkcmF0ZUZyYWdtZW50ID0gKG5vZGUsIHZub2RlLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCkgPT4ge1xuICAgIGNvbnN0IHsgc2xvdFNjb3BlSWRzOiBmcmFnbWVudFNsb3RTY29wZUlkcyB9ID0gdm5vZGU7XG4gICAgaWYgKGZyYWdtZW50U2xvdFNjb3BlSWRzKSB7XG4gICAgICBzbG90U2NvcGVJZHMgPSBzbG90U2NvcGVJZHMgPyBzbG90U2NvcGVJZHMuY29uY2F0KGZyYWdtZW50U2xvdFNjb3BlSWRzKSA6IGZyYWdtZW50U2xvdFNjb3BlSWRzO1xuICAgIH1cbiAgICBjb25zdCBjb250YWluZXIgPSBwYXJlbnROb2RlKG5vZGUpO1xuICAgIGNvbnN0IG5leHQgPSBoeWRyYXRlQ2hpbGRyZW4oXG4gICAgICBuZXh0U2libGluZyhub2RlKSxcbiAgICAgIHZub2RlLFxuICAgICAgY29udGFpbmVyLFxuICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICBzbG90U2NvcGVJZHMsXG4gICAgICBvcHRpbWl6ZWRcbiAgICApO1xuICAgIGlmIChuZXh0ICYmIGlzQ29tbWVudChuZXh0KSAmJiBuZXh0LmRhdGEgPT09IFwiXVwiKSB7XG4gICAgICByZXR1cm4gbmV4dFNpYmxpbmcodm5vZGUuYW5jaG9yID0gbmV4dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGhhc01pc21hdGNoID0gdHJ1ZTtcbiAgICAgIGluc2VydCh2bm9kZS5hbmNob3IgPSBjcmVhdGVDb21tZW50KGBdYCksIGNvbnRhaW5lciwgbmV4dCk7XG4gICAgICByZXR1cm4gbmV4dDtcbiAgICB9XG4gIH07XG4gIGNvbnN0IGhhbmRsZU1pc21hdGNoID0gKG5vZGUsIHZub2RlLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBzbG90U2NvcGVJZHMsIGlzRnJhZ21lbnQpID0+IHtcbiAgICBoYXNNaXNtYXRjaCA9IHRydWU7XG4gICAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiB3YXJuKFxuICAgICAgYEh5ZHJhdGlvbiBub2RlIG1pc21hdGNoOlxuLSBDbGllbnQgdm5vZGU6YCxcbiAgICAgIHZub2RlLnR5cGUsXG4gICAgICBgXG4tIFNlcnZlciByZW5kZXJlZCBET006YCxcbiAgICAgIG5vZGUsXG4gICAgICBub2RlLm5vZGVUeXBlID09PSAzIC8qIFRFWFQgKi8gPyBgKHRleHQpYCA6IGlzQ29tbWVudChub2RlKSAmJiBub2RlLmRhdGEgPT09IFwiW1wiID8gYChzdGFydCBvZiBmcmFnbWVudClgIDogYGBcbiAgICApO1xuICAgIHZub2RlLmVsID0gbnVsbDtcbiAgICBpZiAoaXNGcmFnbWVudCkge1xuICAgICAgY29uc3QgZW5kID0gbG9jYXRlQ2xvc2luZ0FzeW5jQW5jaG9yKG5vZGUpO1xuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgY29uc3QgbmV4dDIgPSBuZXh0U2libGluZyhub2RlKTtcbiAgICAgICAgaWYgKG5leHQyICYmIG5leHQyICE9PSBlbmQpIHtcbiAgICAgICAgICByZW1vdmUobmV4dDIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IG5leHQgPSBuZXh0U2libGluZyhub2RlKTtcbiAgICBjb25zdCBjb250YWluZXIgPSBwYXJlbnROb2RlKG5vZGUpO1xuICAgIHJlbW92ZShub2RlKTtcbiAgICBwYXRjaChcbiAgICAgIG51bGwsXG4gICAgICB2bm9kZSxcbiAgICAgIGNvbnRhaW5lcixcbiAgICAgIG5leHQsXG4gICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgIGlzU1ZHQ29udGFpbmVyKGNvbnRhaW5lciksXG4gICAgICBzbG90U2NvcGVJZHNcbiAgICApO1xuICAgIHJldHVybiBuZXh0O1xuICB9O1xuICBjb25zdCBsb2NhdGVDbG9zaW5nQXN5bmNBbmNob3IgPSAobm9kZSkgPT4ge1xuICAgIGxldCBtYXRjaCA9IDA7XG4gICAgd2hpbGUgKG5vZGUpIHtcbiAgICAgIG5vZGUgPSBuZXh0U2libGluZyhub2RlKTtcbiAgICAgIGlmIChub2RlICYmIGlzQ29tbWVudChub2RlKSkge1xuICAgICAgICBpZiAobm9kZS5kYXRhID09PSBcIltcIilcbiAgICAgICAgICBtYXRjaCsrO1xuICAgICAgICBpZiAobm9kZS5kYXRhID09PSBcIl1cIikge1xuICAgICAgICAgIGlmIChtYXRjaCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIG5leHRTaWJsaW5nKG5vZGUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtYXRjaC0tO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbm9kZTtcbiAgfTtcbiAgcmV0dXJuIFtoeWRyYXRlLCBoeWRyYXRlTm9kZV07XG59XG5cbmxldCBzdXBwb3J0ZWQ7XG5sZXQgcGVyZjtcbmZ1bmN0aW9uIHN0YXJ0TWVhc3VyZShpbnN0YW5jZSwgdHlwZSkge1xuICBpZiAoaW5zdGFuY2UuYXBwQ29udGV4dC5jb25maWcucGVyZm9ybWFuY2UgJiYgaXNTdXBwb3J0ZWQoKSkge1xuICAgIHBlcmYubWFyayhgdnVlLSR7dHlwZX0tJHtpbnN0YW5jZS51aWR9YCk7XG4gIH1cbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XG4gICAgZGV2dG9vbHNQZXJmU3RhcnQoaW5zdGFuY2UsIHR5cGUsIGlzU3VwcG9ydGVkKCkgPyBwZXJmLm5vdygpIDogRGF0ZS5ub3coKSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGVuZE1lYXN1cmUoaW5zdGFuY2UsIHR5cGUpIHtcbiAgaWYgKGluc3RhbmNlLmFwcENvbnRleHQuY29uZmlnLnBlcmZvcm1hbmNlICYmIGlzU3VwcG9ydGVkKCkpIHtcbiAgICBjb25zdCBzdGFydFRhZyA9IGB2dWUtJHt0eXBlfS0ke2luc3RhbmNlLnVpZH1gO1xuICAgIGNvbnN0IGVuZFRhZyA9IHN0YXJ0VGFnICsgYDplbmRgO1xuICAgIHBlcmYubWFyayhlbmRUYWcpO1xuICAgIHBlcmYubWVhc3VyZShcbiAgICAgIGA8JHtmb3JtYXRDb21wb25lbnROYW1lKGluc3RhbmNlLCBpbnN0YW5jZS50eXBlKX0+ICR7dHlwZX1gLFxuICAgICAgc3RhcnRUYWcsXG4gICAgICBlbmRUYWdcbiAgICApO1xuICAgIHBlcmYuY2xlYXJNYXJrcyhzdGFydFRhZyk7XG4gICAgcGVyZi5jbGVhck1hcmtzKGVuZFRhZyk7XG4gIH1cbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XG4gICAgZGV2dG9vbHNQZXJmRW5kKGluc3RhbmNlLCB0eXBlLCBpc1N1cHBvcnRlZCgpID8gcGVyZi5ub3coKSA6IERhdGUubm93KCkpO1xuICB9XG59XG5mdW5jdGlvbiBpc1N1cHBvcnRlZCgpIHtcbiAgaWYgKHN1cHBvcnRlZCAhPT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuIHN1cHBvcnRlZDtcbiAgfVxuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cucGVyZm9ybWFuY2UpIHtcbiAgICBzdXBwb3J0ZWQgPSB0cnVlO1xuICAgIHBlcmYgPSB3aW5kb3cucGVyZm9ybWFuY2U7XG4gIH0gZWxzZSB7XG4gICAgc3VwcG9ydGVkID0gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHN1cHBvcnRlZDtcbn1cblxuZnVuY3Rpb24gaW5pdEZlYXR1cmVGbGFncygpIHtcbiAgY29uc3QgbmVlZFdhcm4gPSBbXTtcbiAgaWYgKHR5cGVvZiBfX1ZVRV9PUFRJT05TX0FQSV9fICE9PSBcImJvb2xlYW5cIikge1xuICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgbmVlZFdhcm4ucHVzaChgX19WVUVfT1BUSU9OU19BUElfX2ApO1xuICAgIGdldEdsb2JhbFRoaXMoKS5fX1ZVRV9PUFRJT05TX0FQSV9fID0gdHJ1ZTtcbiAgfVxuICBpZiAodHlwZW9mIF9fVlVFX1BST0RfREVWVE9PTFNfXyAhPT0gXCJib29sZWFuXCIpIHtcbiAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIG5lZWRXYXJuLnB1c2goYF9fVlVFX1BST0RfREVWVE9PTFNfX2ApO1xuICAgIGdldEdsb2JhbFRoaXMoKS5fX1ZVRV9QUk9EX0RFVlRPT0xTX18gPSBmYWxzZTtcbiAgfVxuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBuZWVkV2Fybi5sZW5ndGgpIHtcbiAgICBjb25zdCBtdWx0aSA9IG5lZWRXYXJuLmxlbmd0aCA+IDE7XG4gICAgY29uc29sZS53YXJuKFxuICAgICAgYEZlYXR1cmUgZmxhZyR7bXVsdGkgPyBgc2AgOiBgYH0gJHtuZWVkV2Fybi5qb2luKFwiLCBcIil9ICR7bXVsdGkgPyBgYXJlYCA6IGBpc2B9IG5vdCBleHBsaWNpdGx5IGRlZmluZWQuIFlvdSBhcmUgcnVubmluZyB0aGUgZXNtLWJ1bmRsZXIgYnVpbGQgb2YgVnVlLCB3aGljaCBleHBlY3RzIHRoZXNlIGNvbXBpbGUtdGltZSBmZWF0dXJlIGZsYWdzIHRvIGJlIGdsb2JhbGx5IGluamVjdGVkIHZpYSB0aGUgYnVuZGxlciBjb25maWcgaW4gb3JkZXIgdG8gZ2V0IGJldHRlciB0cmVlLXNoYWtpbmcgaW4gdGhlIHByb2R1Y3Rpb24gYnVuZGxlLlxuXG5Gb3IgbW9yZSBkZXRhaWxzLCBzZWUgaHR0cHM6Ly9saW5rLnZ1ZWpzLm9yZy9mZWF0dXJlLWZsYWdzLmBcbiAgICApO1xuICB9XG59XG5cbmNvbnN0IHF1ZXVlUG9zdFJlbmRlckVmZmVjdCA9IHF1ZXVlRWZmZWN0V2l0aFN1c3BlbnNlIDtcbmZ1bmN0aW9uIGNyZWF0ZVJlbmRlcmVyKG9wdGlvbnMpIHtcbiAgcmV0dXJuIGJhc2VDcmVhdGVSZW5kZXJlcihvcHRpb25zKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUh5ZHJhdGlvblJlbmRlcmVyKG9wdGlvbnMpIHtcbiAgcmV0dXJuIGJhc2VDcmVhdGVSZW5kZXJlcihvcHRpb25zLCBjcmVhdGVIeWRyYXRpb25GdW5jdGlvbnMpO1xufVxuZnVuY3Rpb24gYmFzZUNyZWF0ZVJlbmRlcmVyKG9wdGlvbnMsIGNyZWF0ZUh5ZHJhdGlvbkZucykge1xuICB7XG4gICAgaW5pdEZlYXR1cmVGbGFncygpO1xuICB9XG4gIGNvbnN0IHRhcmdldCA9IGdldEdsb2JhbFRoaXMoKTtcbiAgdGFyZ2V0Ll9fVlVFX18gPSB0cnVlO1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcbiAgICBzZXREZXZ0b29sc0hvb2sodGFyZ2V0Ll9fVlVFX0RFVlRPT0xTX0dMT0JBTF9IT09LX18sIHRhcmdldCk7XG4gIH1cbiAgY29uc3Qge1xuICAgIGluc2VydDogaG9zdEluc2VydCxcbiAgICByZW1vdmU6IGhvc3RSZW1vdmUsXG4gICAgcGF0Y2hQcm9wOiBob3N0UGF0Y2hQcm9wLFxuICAgIGNyZWF0ZUVsZW1lbnQ6IGhvc3RDcmVhdGVFbGVtZW50LFxuICAgIGNyZWF0ZVRleHQ6IGhvc3RDcmVhdGVUZXh0LFxuICAgIGNyZWF0ZUNvbW1lbnQ6IGhvc3RDcmVhdGVDb21tZW50LFxuICAgIHNldFRleHQ6IGhvc3RTZXRUZXh0LFxuICAgIHNldEVsZW1lbnRUZXh0OiBob3N0U2V0RWxlbWVudFRleHQsXG4gICAgcGFyZW50Tm9kZTogaG9zdFBhcmVudE5vZGUsXG4gICAgbmV4dFNpYmxpbmc6IGhvc3ROZXh0U2libGluZyxcbiAgICBzZXRTY29wZUlkOiBob3N0U2V0U2NvcGVJZCA9IE5PT1AsXG4gICAgaW5zZXJ0U3RhdGljQ29udGVudDogaG9zdEluc2VydFN0YXRpY0NvbnRlbnRcbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IHBhdGNoID0gKG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IgPSBudWxsLCBwYXJlbnRDb21wb25lbnQgPSBudWxsLCBwYXJlbnRTdXNwZW5zZSA9IG51bGwsIGlzU1ZHID0gZmFsc2UsIHNsb3RTY29wZUlkcyA9IG51bGwsIG9wdGltaXplZCA9ICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgaXNIbXJVcGRhdGluZyA/IGZhbHNlIDogISFuMi5keW5hbWljQ2hpbGRyZW4pID0+IHtcbiAgICBpZiAobjEgPT09IG4yKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChuMSAmJiAhaXNTYW1lVk5vZGVUeXBlKG4xLCBuMikpIHtcbiAgICAgIGFuY2hvciA9IGdldE5leHRIb3N0Tm9kZShuMSk7XG4gICAgICB1bm1vdW50KG4xLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCB0cnVlKTtcbiAgICAgIG4xID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKG4yLnBhdGNoRmxhZyA9PT0gLTIpIHtcbiAgICAgIG9wdGltaXplZCA9IGZhbHNlO1xuICAgICAgbjIuZHluYW1pY0NoaWxkcmVuID0gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgeyB0eXBlLCByZWYsIHNoYXBlRmxhZyB9ID0gbjI7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlIFRleHQ6XG4gICAgICAgIHByb2Nlc3NUZXh0KG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgQ29tbWVudDpcbiAgICAgICAgcHJvY2Vzc0NvbW1lbnROb2RlKG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgU3RhdGljOlxuICAgICAgICBpZiAobjEgPT0gbnVsbCkge1xuICAgICAgICAgIG1vdW50U3RhdGljTm9kZShuMiwgY29udGFpbmVyLCBhbmNob3IsIGlzU1ZHKTtcbiAgICAgICAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgcGF0Y2hTdGF0aWNOb2RlKG4xLCBuMiwgY29udGFpbmVyLCBpc1NWRyk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEZyYWdtZW50OlxuICAgICAgICBwcm9jZXNzRnJhZ21lbnQoXG4gICAgICAgICAgbjEsXG4gICAgICAgICAgbjIsXG4gICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgIGFuY2hvcixcbiAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgaXNTVkcsXG4gICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgIG9wdGltaXplZFxuICAgICAgICApO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChzaGFwZUZsYWcgJiAxKSB7XG4gICAgICAgICAgcHJvY2Vzc0VsZW1lbnQoXG4gICAgICAgICAgICBuMSxcbiAgICAgICAgICAgIG4yLFxuICAgICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgICAgYW5jaG9yLFxuICAgICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgICBpc1NWRyxcbiAgICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICAgIG9wdGltaXplZFxuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSBpZiAoc2hhcGVGbGFnICYgNikge1xuICAgICAgICAgIHByb2Nlc3NDb21wb25lbnQoXG4gICAgICAgICAgICBuMSxcbiAgICAgICAgICAgIG4yLFxuICAgICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgICAgYW5jaG9yLFxuICAgICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgICBpc1NWRyxcbiAgICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICAgIG9wdGltaXplZFxuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSBpZiAoc2hhcGVGbGFnICYgNjQpIHtcbiAgICAgICAgICB0eXBlLnByb2Nlc3MoXG4gICAgICAgICAgICBuMSxcbiAgICAgICAgICAgIG4yLFxuICAgICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgICAgYW5jaG9yLFxuICAgICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgICBpc1NWRyxcbiAgICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICAgIG9wdGltaXplZCxcbiAgICAgICAgICAgIGludGVybmFsc1xuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSBpZiAoc2hhcGVGbGFnICYgMTI4KSB7XG4gICAgICAgICAgdHlwZS5wcm9jZXNzKFxuICAgICAgICAgICAgbjEsXG4gICAgICAgICAgICBuMixcbiAgICAgICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgICAgIGFuY2hvcixcbiAgICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgICAgaXNTVkcsXG4gICAgICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgICAgICBvcHRpbWl6ZWQsXG4gICAgICAgICAgICBpbnRlcm5hbHNcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICB3YXJuKFwiSW52YWxpZCBWTm9kZSB0eXBlOlwiLCB0eXBlLCBgKCR7dHlwZW9mIHR5cGV9KWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChyZWYgIT0gbnVsbCAmJiBwYXJlbnRDb21wb25lbnQpIHtcbiAgICAgIHNldFJlZihyZWYsIG4xICYmIG4xLnJlZiwgcGFyZW50U3VzcGVuc2UsIG4yIHx8IG4xLCAhbjIpO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgcHJvY2Vzc1RleHQgPSAobjEsIG4yLCBjb250YWluZXIsIGFuY2hvcikgPT4ge1xuICAgIGlmIChuMSA9PSBudWxsKSB7XG4gICAgICBob3N0SW5zZXJ0KFxuICAgICAgICBuMi5lbCA9IGhvc3RDcmVhdGVUZXh0KG4yLmNoaWxkcmVuKSxcbiAgICAgICAgY29udGFpbmVyLFxuICAgICAgICBhbmNob3JcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGVsID0gbjIuZWwgPSBuMS5lbDtcbiAgICAgIGlmIChuMi5jaGlsZHJlbiAhPT0gbjEuY2hpbGRyZW4pIHtcbiAgICAgICAgaG9zdFNldFRleHQoZWwsIG4yLmNoaWxkcmVuKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIGNvbnN0IHByb2Nlc3NDb21tZW50Tm9kZSA9IChuMSwgbjIsIGNvbnRhaW5lciwgYW5jaG9yKSA9PiB7XG4gICAgaWYgKG4xID09IG51bGwpIHtcbiAgICAgIGhvc3RJbnNlcnQoXG4gICAgICAgIG4yLmVsID0gaG9zdENyZWF0ZUNvbW1lbnQobjIuY2hpbGRyZW4gfHwgXCJcIiksXG4gICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgYW5jaG9yXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBuMi5lbCA9IG4xLmVsO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgbW91bnRTdGF0aWNOb2RlID0gKG4yLCBjb250YWluZXIsIGFuY2hvciwgaXNTVkcpID0+IHtcbiAgICBbbjIuZWwsIG4yLmFuY2hvcl0gPSBob3N0SW5zZXJ0U3RhdGljQ29udGVudChcbiAgICAgIG4yLmNoaWxkcmVuLFxuICAgICAgY29udGFpbmVyLFxuICAgICAgYW5jaG9yLFxuICAgICAgaXNTVkcsXG4gICAgICBuMi5lbCxcbiAgICAgIG4yLmFuY2hvclxuICAgICk7XG4gIH07XG4gIGNvbnN0IHBhdGNoU3RhdGljTm9kZSA9IChuMSwgbjIsIGNvbnRhaW5lciwgaXNTVkcpID0+IHtcbiAgICBpZiAobjIuY2hpbGRyZW4gIT09IG4xLmNoaWxkcmVuKSB7XG4gICAgICBjb25zdCBhbmNob3IgPSBob3N0TmV4dFNpYmxpbmcobjEuYW5jaG9yKTtcbiAgICAgIHJlbW92ZVN0YXRpY05vZGUobjEpO1xuICAgICAgW24yLmVsLCBuMi5hbmNob3JdID0gaG9zdEluc2VydFN0YXRpY0NvbnRlbnQoXG4gICAgICAgIG4yLmNoaWxkcmVuLFxuICAgICAgICBjb250YWluZXIsXG4gICAgICAgIGFuY2hvcixcbiAgICAgICAgaXNTVkdcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG4yLmVsID0gbjEuZWw7XG4gICAgICBuMi5hbmNob3IgPSBuMS5hbmNob3I7XG4gICAgfVxuICB9O1xuICBjb25zdCBtb3ZlU3RhdGljTm9kZSA9ICh7IGVsLCBhbmNob3IgfSwgY29udGFpbmVyLCBuZXh0U2libGluZykgPT4ge1xuICAgIGxldCBuZXh0O1xuICAgIHdoaWxlIChlbCAmJiBlbCAhPT0gYW5jaG9yKSB7XG4gICAgICBuZXh0ID0gaG9zdE5leHRTaWJsaW5nKGVsKTtcbiAgICAgIGhvc3RJbnNlcnQoZWwsIGNvbnRhaW5lciwgbmV4dFNpYmxpbmcpO1xuICAgICAgZWwgPSBuZXh0O1xuICAgIH1cbiAgICBob3N0SW5zZXJ0KGFuY2hvciwgY29udGFpbmVyLCBuZXh0U2libGluZyk7XG4gIH07XG4gIGNvbnN0IHJlbW92ZVN0YXRpY05vZGUgPSAoeyBlbCwgYW5jaG9yIH0pID0+IHtcbiAgICBsZXQgbmV4dDtcbiAgICB3aGlsZSAoZWwgJiYgZWwgIT09IGFuY2hvcikge1xuICAgICAgbmV4dCA9IGhvc3ROZXh0U2libGluZyhlbCk7XG4gICAgICBob3N0UmVtb3ZlKGVsKTtcbiAgICAgIGVsID0gbmV4dDtcbiAgICB9XG4gICAgaG9zdFJlbW92ZShhbmNob3IpO1xuICB9O1xuICBjb25zdCBwcm9jZXNzRWxlbWVudCA9IChuMSwgbjIsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpID0+IHtcbiAgICBpc1NWRyA9IGlzU1ZHIHx8IG4yLnR5cGUgPT09IFwic3ZnXCI7XG4gICAgaWYgKG4xID09IG51bGwpIHtcbiAgICAgIG1vdW50RWxlbWVudChcbiAgICAgICAgbjIsXG4gICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgYW5jaG9yLFxuICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICBpc1NWRyxcbiAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhdGNoRWxlbWVudChcbiAgICAgICAgbjEsXG4gICAgICAgIG4yLFxuICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICBpc1NWRyxcbiAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICk7XG4gICAgfVxuICB9O1xuICBjb25zdCBtb3VudEVsZW1lbnQgPSAodm5vZGUsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpID0+IHtcbiAgICBsZXQgZWw7XG4gICAgbGV0IHZub2RlSG9vaztcbiAgICBjb25zdCB7IHR5cGUsIHByb3BzLCBzaGFwZUZsYWcsIHRyYW5zaXRpb24sIGRpcnMgfSA9IHZub2RlO1xuICAgIGVsID0gdm5vZGUuZWwgPSBob3N0Q3JlYXRlRWxlbWVudChcbiAgICAgIHZub2RlLnR5cGUsXG4gICAgICBpc1NWRyxcbiAgICAgIHByb3BzICYmIHByb3BzLmlzLFxuICAgICAgcHJvcHNcbiAgICApO1xuICAgIGlmIChzaGFwZUZsYWcgJiA4KSB7XG4gICAgICBob3N0U2V0RWxlbWVudFRleHQoZWwsIHZub2RlLmNoaWxkcmVuKTtcbiAgICB9IGVsc2UgaWYgKHNoYXBlRmxhZyAmIDE2KSB7XG4gICAgICBtb3VudENoaWxkcmVuKFxuICAgICAgICB2bm9kZS5jaGlsZHJlbixcbiAgICAgICAgZWwsXG4gICAgICAgIG51bGwsXG4gICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgIGlzU1ZHICYmIHR5cGUgIT09IFwiZm9yZWlnbk9iamVjdFwiLFxuICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgIG9wdGltaXplZFxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKGRpcnMpIHtcbiAgICAgIGludm9rZURpcmVjdGl2ZUhvb2sodm5vZGUsIG51bGwsIHBhcmVudENvbXBvbmVudCwgXCJjcmVhdGVkXCIpO1xuICAgIH1cbiAgICBzZXRTY29wZUlkKGVsLCB2bm9kZSwgdm5vZGUuc2NvcGVJZCwgc2xvdFNjb3BlSWRzLCBwYXJlbnRDb21wb25lbnQpO1xuICAgIGlmIChwcm9wcykge1xuICAgICAgZm9yIChjb25zdCBrZXkgaW4gcHJvcHMpIHtcbiAgICAgICAgaWYgKGtleSAhPT0gXCJ2YWx1ZVwiICYmICFpc1Jlc2VydmVkUHJvcChrZXkpKSB7XG4gICAgICAgICAgaG9zdFBhdGNoUHJvcChcbiAgICAgICAgICAgIGVsLFxuICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgIHByb3BzW2tleV0sXG4gICAgICAgICAgICBpc1NWRyxcbiAgICAgICAgICAgIHZub2RlLmNoaWxkcmVuLFxuICAgICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgICB1bm1vdW50Q2hpbGRyZW5cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoXCJ2YWx1ZVwiIGluIHByb3BzKSB7XG4gICAgICAgIGhvc3RQYXRjaFByb3AoZWwsIFwidmFsdWVcIiwgbnVsbCwgcHJvcHMudmFsdWUpO1xuICAgICAgfVxuICAgICAgaWYgKHZub2RlSG9vayA9IHByb3BzLm9uVm5vZGVCZWZvcmVNb3VudCkge1xuICAgICAgICBpbnZva2VWTm9kZUhvb2sodm5vZGVIb29rLCBwYXJlbnRDb21wb25lbnQsIHZub2RlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWwsIFwiX192bm9kZVwiLCB7XG4gICAgICAgIHZhbHVlOiB2bm9kZSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2VcbiAgICAgIH0pO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsLCBcIl9fdnVlUGFyZW50Q29tcG9uZW50XCIsIHtcbiAgICAgICAgdmFsdWU6IHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2VcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoZGlycykge1xuICAgICAgaW52b2tlRGlyZWN0aXZlSG9vayh2bm9kZSwgbnVsbCwgcGFyZW50Q29tcG9uZW50LCBcImJlZm9yZU1vdW50XCIpO1xuICAgIH1cbiAgICBjb25zdCBuZWVkQ2FsbFRyYW5zaXRpb25Ib29rcyA9ICghcGFyZW50U3VzcGVuc2UgfHwgcGFyZW50U3VzcGVuc2UgJiYgIXBhcmVudFN1c3BlbnNlLnBlbmRpbmdCcmFuY2gpICYmIHRyYW5zaXRpb24gJiYgIXRyYW5zaXRpb24ucGVyc2lzdGVkO1xuICAgIGlmIChuZWVkQ2FsbFRyYW5zaXRpb25Ib29rcykge1xuICAgICAgdHJhbnNpdGlvbi5iZWZvcmVFbnRlcihlbCk7XG4gICAgfVxuICAgIGhvc3RJbnNlcnQoZWwsIGNvbnRhaW5lciwgYW5jaG9yKTtcbiAgICBpZiAoKHZub2RlSG9vayA9IHByb3BzICYmIHByb3BzLm9uVm5vZGVNb3VudGVkKSB8fCBuZWVkQ2FsbFRyYW5zaXRpb25Ib29rcyB8fCBkaXJzKSB7XG4gICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QoKCkgPT4ge1xuICAgICAgICB2bm9kZUhvb2sgJiYgaW52b2tlVk5vZGVIb29rKHZub2RlSG9vaywgcGFyZW50Q29tcG9uZW50LCB2bm9kZSk7XG4gICAgICAgIG5lZWRDYWxsVHJhbnNpdGlvbkhvb2tzICYmIHRyYW5zaXRpb24uZW50ZXIoZWwpO1xuICAgICAgICBkaXJzICYmIGludm9rZURpcmVjdGl2ZUhvb2sodm5vZGUsIG51bGwsIHBhcmVudENvbXBvbmVudCwgXCJtb3VudGVkXCIpO1xuICAgICAgfSwgcGFyZW50U3VzcGVuc2UpO1xuICAgIH1cbiAgfTtcbiAgY29uc3Qgc2V0U2NvcGVJZCA9IChlbCwgdm5vZGUsIHNjb3BlSWQsIHNsb3RTY29wZUlkcywgcGFyZW50Q29tcG9uZW50KSA9PiB7XG4gICAgaWYgKHNjb3BlSWQpIHtcbiAgICAgIGhvc3RTZXRTY29wZUlkKGVsLCBzY29wZUlkKTtcbiAgICB9XG4gICAgaWYgKHNsb3RTY29wZUlkcykge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzbG90U2NvcGVJZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaG9zdFNldFNjb3BlSWQoZWwsIHNsb3RTY29wZUlkc1tpXSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChwYXJlbnRDb21wb25lbnQpIHtcbiAgICAgIGxldCBzdWJUcmVlID0gcGFyZW50Q29tcG9uZW50LnN1YlRyZWU7XG4gICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBzdWJUcmVlLnBhdGNoRmxhZyA+IDAgJiYgc3ViVHJlZS5wYXRjaEZsYWcgJiAyMDQ4KSB7XG4gICAgICAgIHN1YlRyZWUgPSBmaWx0ZXJTaW5nbGVSb290KHN1YlRyZWUuY2hpbGRyZW4pIHx8IHN1YlRyZWU7XG4gICAgICB9XG4gICAgICBpZiAodm5vZGUgPT09IHN1YlRyZWUpIHtcbiAgICAgICAgY29uc3QgcGFyZW50Vk5vZGUgPSBwYXJlbnRDb21wb25lbnQudm5vZGU7XG4gICAgICAgIHNldFNjb3BlSWQoXG4gICAgICAgICAgZWwsXG4gICAgICAgICAgcGFyZW50Vk5vZGUsXG4gICAgICAgICAgcGFyZW50Vk5vZGUuc2NvcGVJZCxcbiAgICAgICAgICBwYXJlbnRWTm9kZS5zbG90U2NvcGVJZHMsXG4gICAgICAgICAgcGFyZW50Q29tcG9uZW50LnBhcmVudFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgY29uc3QgbW91bnRDaGlsZHJlbiA9IChjaGlsZHJlbiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCwgc3RhcnQgPSAwKSA9PiB7XG4gICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGNoaWxkID0gY2hpbGRyZW5baV0gPSBvcHRpbWl6ZWQgPyBjbG9uZUlmTW91bnRlZChjaGlsZHJlbltpXSkgOiBub3JtYWxpemVWTm9kZShjaGlsZHJlbltpXSk7XG4gICAgICBwYXRjaChcbiAgICAgICAgbnVsbCxcbiAgICAgICAgY2hpbGQsXG4gICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgYW5jaG9yLFxuICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICBpc1NWRyxcbiAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICk7XG4gICAgfVxuICB9O1xuICBjb25zdCBwYXRjaEVsZW1lbnQgPSAobjEsIG4yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpID0+IHtcbiAgICBjb25zdCBlbCA9IG4yLmVsID0gbjEuZWw7XG4gICAgbGV0IHsgcGF0Y2hGbGFnLCBkeW5hbWljQ2hpbGRyZW4sIGRpcnMgfSA9IG4yO1xuICAgIHBhdGNoRmxhZyB8PSBuMS5wYXRjaEZsYWcgJiAxNjtcbiAgICBjb25zdCBvbGRQcm9wcyA9IG4xLnByb3BzIHx8IEVNUFRZX09CSjtcbiAgICBjb25zdCBuZXdQcm9wcyA9IG4yLnByb3BzIHx8IEVNUFRZX09CSjtcbiAgICBsZXQgdm5vZGVIb29rO1xuICAgIHBhcmVudENvbXBvbmVudCAmJiB0b2dnbGVSZWN1cnNlKHBhcmVudENvbXBvbmVudCwgZmFsc2UpO1xuICAgIGlmICh2bm9kZUhvb2sgPSBuZXdQcm9wcy5vblZub2RlQmVmb3JlVXBkYXRlKSB7XG4gICAgICBpbnZva2VWTm9kZUhvb2sodm5vZGVIb29rLCBwYXJlbnRDb21wb25lbnQsIG4yLCBuMSk7XG4gICAgfVxuICAgIGlmIChkaXJzKSB7XG4gICAgICBpbnZva2VEaXJlY3RpdmVIb29rKG4yLCBuMSwgcGFyZW50Q29tcG9uZW50LCBcImJlZm9yZVVwZGF0ZVwiKTtcbiAgICB9XG4gICAgcGFyZW50Q29tcG9uZW50ICYmIHRvZ2dsZVJlY3Vyc2UocGFyZW50Q29tcG9uZW50LCB0cnVlKTtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBpc0htclVwZGF0aW5nKSB7XG4gICAgICBwYXRjaEZsYWcgPSAwO1xuICAgICAgb3B0aW1pemVkID0gZmFsc2U7XG4gICAgICBkeW5hbWljQ2hpbGRyZW4gPSBudWxsO1xuICAgIH1cbiAgICBjb25zdCBhcmVDaGlsZHJlblNWRyA9IGlzU1ZHICYmIG4yLnR5cGUgIT09IFwiZm9yZWlnbk9iamVjdFwiO1xuICAgIGlmIChkeW5hbWljQ2hpbGRyZW4pIHtcbiAgICAgIHBhdGNoQmxvY2tDaGlsZHJlbihcbiAgICAgICAgbjEuZHluYW1pY0NoaWxkcmVuLFxuICAgICAgICBkeW5hbWljQ2hpbGRyZW4sXG4gICAgICAgIGVsLFxuICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICBhcmVDaGlsZHJlblNWRyxcbiAgICAgICAgc2xvdFNjb3BlSWRzXG4gICAgICApO1xuICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgdHJhdmVyc2VTdGF0aWNDaGlsZHJlbihuMSwgbjIpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIW9wdGltaXplZCkge1xuICAgICAgcGF0Y2hDaGlsZHJlbihcbiAgICAgICAgbjEsXG4gICAgICAgIG4yLFxuICAgICAgICBlbCxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgYXJlQ2hpbGRyZW5TVkcsXG4gICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgZmFsc2VcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChwYXRjaEZsYWcgPiAwKSB7XG4gICAgICBpZiAocGF0Y2hGbGFnICYgMTYpIHtcbiAgICAgICAgcGF0Y2hQcm9wcyhcbiAgICAgICAgICBlbCxcbiAgICAgICAgICBuMixcbiAgICAgICAgICBvbGRQcm9wcyxcbiAgICAgICAgICBuZXdQcm9wcyxcbiAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgaXNTVkdcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChwYXRjaEZsYWcgJiAyKSB7XG4gICAgICAgICAgaWYgKG9sZFByb3BzLmNsYXNzICE9PSBuZXdQcm9wcy5jbGFzcykge1xuICAgICAgICAgICAgaG9zdFBhdGNoUHJvcChlbCwgXCJjbGFzc1wiLCBudWxsLCBuZXdQcm9wcy5jbGFzcywgaXNTVkcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocGF0Y2hGbGFnICYgNCkge1xuICAgICAgICAgIGhvc3RQYXRjaFByb3AoZWwsIFwic3R5bGVcIiwgb2xkUHJvcHMuc3R5bGUsIG5ld1Byb3BzLnN0eWxlLCBpc1NWRyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhdGNoRmxhZyAmIDgpIHtcbiAgICAgICAgICBjb25zdCBwcm9wc1RvVXBkYXRlID0gbjIuZHluYW1pY1Byb3BzO1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJvcHNUb1VwZGF0ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gcHJvcHNUb1VwZGF0ZVtpXTtcbiAgICAgICAgICAgIGNvbnN0IHByZXYgPSBvbGRQcm9wc1trZXldO1xuICAgICAgICAgICAgY29uc3QgbmV4dCA9IG5ld1Byb3BzW2tleV07XG4gICAgICAgICAgICBpZiAobmV4dCAhPT0gcHJldiB8fCBrZXkgPT09IFwidmFsdWVcIikge1xuICAgICAgICAgICAgICBob3N0UGF0Y2hQcm9wKFxuICAgICAgICAgICAgICAgIGVsLFxuICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICBwcmV2LFxuICAgICAgICAgICAgICAgIG5leHQsXG4gICAgICAgICAgICAgICAgaXNTVkcsXG4gICAgICAgICAgICAgICAgbjEuY2hpbGRyZW4sXG4gICAgICAgICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgICAgICAgIHVubW91bnRDaGlsZHJlblxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHBhdGNoRmxhZyAmIDEpIHtcbiAgICAgICAgaWYgKG4xLmNoaWxkcmVuICE9PSBuMi5jaGlsZHJlbikge1xuICAgICAgICAgIGhvc3RTZXRFbGVtZW50VGV4dChlbCwgbjIuY2hpbGRyZW4pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghb3B0aW1pemVkICYmIGR5bmFtaWNDaGlsZHJlbiA9PSBudWxsKSB7XG4gICAgICBwYXRjaFByb3BzKFxuICAgICAgICBlbCxcbiAgICAgICAgbjIsXG4gICAgICAgIG9sZFByb3BzLFxuICAgICAgICBuZXdQcm9wcyxcbiAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgaXNTVkdcbiAgICAgICk7XG4gICAgfVxuICAgIGlmICgodm5vZGVIb29rID0gbmV3UHJvcHMub25Wbm9kZVVwZGF0ZWQpIHx8IGRpcnMpIHtcbiAgICAgIHF1ZXVlUG9zdFJlbmRlckVmZmVjdCgoKSA9PiB7XG4gICAgICAgIHZub2RlSG9vayAmJiBpbnZva2VWTm9kZUhvb2sodm5vZGVIb29rLCBwYXJlbnRDb21wb25lbnQsIG4yLCBuMSk7XG4gICAgICAgIGRpcnMgJiYgaW52b2tlRGlyZWN0aXZlSG9vayhuMiwgbjEsIHBhcmVudENvbXBvbmVudCwgXCJ1cGRhdGVkXCIpO1xuICAgICAgfSwgcGFyZW50U3VzcGVuc2UpO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgcGF0Y2hCbG9ja0NoaWxkcmVuID0gKG9sZENoaWxkcmVuLCBuZXdDaGlsZHJlbiwgZmFsbGJhY2tDb250YWluZXIsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMpID0+IHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5ld0NoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBvbGRWTm9kZSA9IG9sZENoaWxkcmVuW2ldO1xuICAgICAgY29uc3QgbmV3Vk5vZGUgPSBuZXdDaGlsZHJlbltpXTtcbiAgICAgIGNvbnN0IGNvbnRhaW5lciA9IChcbiAgICAgICAgLy8gb2xkVk5vZGUgbWF5IGJlIGFuIGVycm9yZWQgYXN5bmMgc2V0dXAoKSBjb21wb25lbnQgaW5zaWRlIFN1c3BlbnNlXG4gICAgICAgIC8vIHdoaWNoIHdpbGwgbm90IGhhdmUgYSBtb3VudGVkIGVsZW1lbnRcbiAgICAgICAgb2xkVk5vZGUuZWwgJiYgLy8gLSBJbiB0aGUgY2FzZSBvZiBhIEZyYWdtZW50LCB3ZSBuZWVkIHRvIHByb3ZpZGUgdGhlIGFjdHVhbCBwYXJlbnRcbiAgICAgICAgLy8gb2YgdGhlIEZyYWdtZW50IGl0c2VsZiBzbyBpdCBjYW4gbW92ZSBpdHMgY2hpbGRyZW4uXG4gICAgICAgIChvbGRWTm9kZS50eXBlID09PSBGcmFnbWVudCB8fCAvLyAtIEluIHRoZSBjYXNlIG9mIGRpZmZlcmVudCBub2RlcywgdGhlcmUgaXMgZ29pbmcgdG8gYmUgYSByZXBsYWNlbWVudFxuICAgICAgICAvLyB3aGljaCBhbHNvIHJlcXVpcmVzIHRoZSBjb3JyZWN0IHBhcmVudCBjb250YWluZXJcbiAgICAgICAgIWlzU2FtZVZOb2RlVHlwZShvbGRWTm9kZSwgbmV3Vk5vZGUpIHx8IC8vIC0gSW4gdGhlIGNhc2Ugb2YgYSBjb21wb25lbnQsIGl0IGNvdWxkIGNvbnRhaW4gYW55dGhpbmcuXG4gICAgICAgIG9sZFZOb2RlLnNoYXBlRmxhZyAmICg2IHwgNjQpKSA/IGhvc3RQYXJlbnROb2RlKG9sZFZOb2RlLmVsKSA6IChcbiAgICAgICAgICAvLyBJbiBvdGhlciBjYXNlcywgdGhlIHBhcmVudCBjb250YWluZXIgaXMgbm90IGFjdHVhbGx5IHVzZWQgc28gd2VcbiAgICAgICAgICAvLyBqdXN0IHBhc3MgdGhlIGJsb2NrIGVsZW1lbnQgaGVyZSB0byBhdm9pZCBhIERPTSBwYXJlbnROb2RlIGNhbGwuXG4gICAgICAgICAgZmFsbGJhY2tDb250YWluZXJcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICAgIHBhdGNoKFxuICAgICAgICBvbGRWTm9kZSxcbiAgICAgICAgbmV3Vk5vZGUsXG4gICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgbnVsbCxcbiAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgaXNTVkcsXG4gICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgdHJ1ZVxuICAgICAgKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHBhdGNoUHJvcHMgPSAoZWwsIHZub2RlLCBvbGRQcm9wcywgbmV3UHJvcHMsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHKSA9PiB7XG4gICAgaWYgKG9sZFByb3BzICE9PSBuZXdQcm9wcykge1xuICAgICAgaWYgKG9sZFByb3BzICE9PSBFTVBUWV9PQkopIHtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gb2xkUHJvcHMpIHtcbiAgICAgICAgICBpZiAoIWlzUmVzZXJ2ZWRQcm9wKGtleSkgJiYgIShrZXkgaW4gbmV3UHJvcHMpKSB7XG4gICAgICAgICAgICBob3N0UGF0Y2hQcm9wKFxuICAgICAgICAgICAgICBlbCxcbiAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICBvbGRQcm9wc1trZXldLFxuICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICBpc1NWRyxcbiAgICAgICAgICAgICAgdm5vZGUuY2hpbGRyZW4sXG4gICAgICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgICAgIHVubW91bnRDaGlsZHJlblxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3Qga2V5IGluIG5ld1Byb3BzKSB7XG4gICAgICAgIGlmIChpc1Jlc2VydmVkUHJvcChrZXkpKVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBjb25zdCBuZXh0ID0gbmV3UHJvcHNba2V5XTtcbiAgICAgICAgY29uc3QgcHJldiA9IG9sZFByb3BzW2tleV07XG4gICAgICAgIGlmIChuZXh0ICE9PSBwcmV2ICYmIGtleSAhPT0gXCJ2YWx1ZVwiKSB7XG4gICAgICAgICAgaG9zdFBhdGNoUHJvcChcbiAgICAgICAgICAgIGVsLFxuICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgcHJldixcbiAgICAgICAgICAgIG5leHQsXG4gICAgICAgICAgICBpc1NWRyxcbiAgICAgICAgICAgIHZub2RlLmNoaWxkcmVuLFxuICAgICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgICB1bm1vdW50Q2hpbGRyZW5cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoXCJ2YWx1ZVwiIGluIG5ld1Byb3BzKSB7XG4gICAgICAgIGhvc3RQYXRjaFByb3AoZWwsIFwidmFsdWVcIiwgb2xkUHJvcHMudmFsdWUsIG5ld1Byb3BzLnZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIGNvbnN0IHByb2Nlc3NGcmFnbWVudCA9IChuMSwgbjIsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpID0+IHtcbiAgICBjb25zdCBmcmFnbWVudFN0YXJ0QW5jaG9yID0gbjIuZWwgPSBuMSA/IG4xLmVsIDogaG9zdENyZWF0ZVRleHQoXCJcIik7XG4gICAgY29uc3QgZnJhZ21lbnRFbmRBbmNob3IgPSBuMi5hbmNob3IgPSBuMSA/IG4xLmFuY2hvciA6IGhvc3RDcmVhdGVUZXh0KFwiXCIpO1xuICAgIGxldCB7IHBhdGNoRmxhZywgZHluYW1pY0NoaWxkcmVuLCBzbG90U2NvcGVJZHM6IGZyYWdtZW50U2xvdFNjb3BlSWRzIH0gPSBuMjtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAvLyAjNTUyMyBkZXYgcm9vdCBmcmFnbWVudCBtYXkgaW5oZXJpdCBkaXJlY3RpdmVzXG4gICAgKGlzSG1yVXBkYXRpbmcgfHwgcGF0Y2hGbGFnICYgMjA0OCkpIHtcbiAgICAgIHBhdGNoRmxhZyA9IDA7XG4gICAgICBvcHRpbWl6ZWQgPSBmYWxzZTtcbiAgICAgIGR5bmFtaWNDaGlsZHJlbiA9IG51bGw7XG4gICAgfVxuICAgIGlmIChmcmFnbWVudFNsb3RTY29wZUlkcykge1xuICAgICAgc2xvdFNjb3BlSWRzID0gc2xvdFNjb3BlSWRzID8gc2xvdFNjb3BlSWRzLmNvbmNhdChmcmFnbWVudFNsb3RTY29wZUlkcykgOiBmcmFnbWVudFNsb3RTY29wZUlkcztcbiAgICB9XG4gICAgaWYgKG4xID09IG51bGwpIHtcbiAgICAgIGhvc3RJbnNlcnQoZnJhZ21lbnRTdGFydEFuY2hvciwgY29udGFpbmVyLCBhbmNob3IpO1xuICAgICAgaG9zdEluc2VydChmcmFnbWVudEVuZEFuY2hvciwgY29udGFpbmVyLCBhbmNob3IpO1xuICAgICAgbW91bnRDaGlsZHJlbihcbiAgICAgICAgbjIuY2hpbGRyZW4sXG4gICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgZnJhZ21lbnRFbmRBbmNob3IsXG4gICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgIGlzU1ZHLFxuICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgIG9wdGltaXplZFxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHBhdGNoRmxhZyA+IDAgJiYgcGF0Y2hGbGFnICYgNjQgJiYgZHluYW1pY0NoaWxkcmVuICYmIC8vICMyNzE1IHRoZSBwcmV2aW91cyBmcmFnbWVudCBjb3VsZCd2ZSBiZWVuIGEgQkFJTGVkIG9uZSBhcyBhIHJlc3VsdFxuICAgICAgLy8gb2YgcmVuZGVyU2xvdCgpIHdpdGggbm8gdmFsaWQgY2hpbGRyZW5cbiAgICAgIG4xLmR5bmFtaWNDaGlsZHJlbikge1xuICAgICAgICBwYXRjaEJsb2NrQ2hpbGRyZW4oXG4gICAgICAgICAgbjEuZHluYW1pY0NoaWxkcmVuLFxuICAgICAgICAgIGR5bmFtaWNDaGlsZHJlbixcbiAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgIGlzU1ZHLFxuICAgICAgICAgIHNsb3RTY29wZUlkc1xuICAgICAgICApO1xuICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgIHRyYXZlcnNlU3RhdGljQ2hpbGRyZW4objEsIG4yKTtcbiAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAvLyAjMjA4MCBpZiB0aGUgc3RhYmxlIGZyYWdtZW50IGhhcyBhIGtleSwgaXQncyBhIDx0ZW1wbGF0ZSB2LWZvcj4gdGhhdCBtYXlcbiAgICAgICAgICAvLyAgZ2V0IG1vdmVkIGFyb3VuZC4gTWFrZSBzdXJlIGFsbCByb290IGxldmVsIHZub2RlcyBpbmhlcml0IGVsLlxuICAgICAgICAgIC8vICMyMTM0IG9yIGlmIGl0J3MgYSBjb21wb25lbnQgcm9vdCwgaXQgbWF5IGFsc28gZ2V0IG1vdmVkIGFyb3VuZFxuICAgICAgICAgIC8vIGFzIHRoZSBjb21wb25lbnQgaXMgYmVpbmcgbW92ZWQuXG4gICAgICAgICAgbjIua2V5ICE9IG51bGwgfHwgcGFyZW50Q29tcG9uZW50ICYmIG4yID09PSBwYXJlbnRDb21wb25lbnQuc3ViVHJlZVxuICAgICAgICApIHtcbiAgICAgICAgICB0cmF2ZXJzZVN0YXRpY0NoaWxkcmVuKFxuICAgICAgICAgICAgbjEsXG4gICAgICAgICAgICBuMixcbiAgICAgICAgICAgIHRydWVcbiAgICAgICAgICAgIC8qIHNoYWxsb3cgKi9cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXRjaENoaWxkcmVuKFxuICAgICAgICAgIG4xLFxuICAgICAgICAgIG4yLFxuICAgICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgICBmcmFnbWVudEVuZEFuY2hvcixcbiAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgaXNTVkcsXG4gICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgIG9wdGltaXplZFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgY29uc3QgcHJvY2Vzc0NvbXBvbmVudCA9IChuMSwgbjIsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpID0+IHtcbiAgICBuMi5zbG90U2NvcGVJZHMgPSBzbG90U2NvcGVJZHM7XG4gICAgaWYgKG4xID09IG51bGwpIHtcbiAgICAgIGlmIChuMi5zaGFwZUZsYWcgJiA1MTIpIHtcbiAgICAgICAgcGFyZW50Q29tcG9uZW50LmN0eC5hY3RpdmF0ZShcbiAgICAgICAgICBuMixcbiAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgYW5jaG9yLFxuICAgICAgICAgIGlzU1ZHLFxuICAgICAgICAgIG9wdGltaXplZFxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbW91bnRDb21wb25lbnQoXG4gICAgICAgICAgbjIsXG4gICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgIGFuY2hvcixcbiAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgaXNTVkcsXG4gICAgICAgICAgb3B0aW1pemVkXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHVwZGF0ZUNvbXBvbmVudChuMSwgbjIsIG9wdGltaXplZCk7XG4gICAgfVxuICB9O1xuICBjb25zdCBtb3VudENvbXBvbmVudCA9IChpbml0aWFsVk5vZGUsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgb3B0aW1pemVkKSA9PiB7XG4gICAgY29uc3QgaW5zdGFuY2UgPSAoaW5pdGlhbFZOb2RlLmNvbXBvbmVudCA9IGNyZWF0ZUNvbXBvbmVudEluc3RhbmNlKFxuICAgICAgaW5pdGlhbFZOb2RlLFxuICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgcGFyZW50U3VzcGVuc2VcbiAgICApKTtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBpbnN0YW5jZS50eXBlLl9faG1ySWQpIHtcbiAgICAgIHJlZ2lzdGVySE1SKGluc3RhbmNlKTtcbiAgICB9XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgIHB1c2hXYXJuaW5nQ29udGV4dChpbml0aWFsVk5vZGUpO1xuICAgICAgc3RhcnRNZWFzdXJlKGluc3RhbmNlLCBgbW91bnRgKTtcbiAgICB9XG4gICAgaWYgKGlzS2VlcEFsaXZlKGluaXRpYWxWTm9kZSkpIHtcbiAgICAgIGluc3RhbmNlLmN0eC5yZW5kZXJlciA9IGludGVybmFscztcbiAgICB9XG4gICAge1xuICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgc3RhcnRNZWFzdXJlKGluc3RhbmNlLCBgaW5pdGApO1xuICAgICAgfVxuICAgICAgc2V0dXBDb21wb25lbnQoaW5zdGFuY2UpO1xuICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgZW5kTWVhc3VyZShpbnN0YW5jZSwgYGluaXRgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGluc3RhbmNlLmFzeW5jRGVwKSB7XG4gICAgICBwYXJlbnRTdXNwZW5zZSAmJiBwYXJlbnRTdXNwZW5zZS5yZWdpc3RlckRlcChpbnN0YW5jZSwgc2V0dXBSZW5kZXJFZmZlY3QpO1xuICAgICAgaWYgKCFpbml0aWFsVk5vZGUuZWwpIHtcbiAgICAgICAgY29uc3QgcGxhY2Vob2xkZXIgPSBpbnN0YW5jZS5zdWJUcmVlID0gY3JlYXRlVk5vZGUoQ29tbWVudCk7XG4gICAgICAgIHByb2Nlc3NDb21tZW50Tm9kZShudWxsLCBwbGFjZWhvbGRlciwgY29udGFpbmVyLCBhbmNob3IpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzZXR1cFJlbmRlckVmZmVjdChcbiAgICAgIGluc3RhbmNlLFxuICAgICAgaW5pdGlhbFZOb2RlLFxuICAgICAgY29udGFpbmVyLFxuICAgICAgYW5jaG9yLFxuICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICBpc1NWRyxcbiAgICAgIG9wdGltaXplZFxuICAgICk7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgIHBvcFdhcm5pbmdDb250ZXh0KCk7XG4gICAgICBlbmRNZWFzdXJlKGluc3RhbmNlLCBgbW91bnRgKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHVwZGF0ZUNvbXBvbmVudCA9IChuMSwgbjIsIG9wdGltaXplZCkgPT4ge1xuICAgIGNvbnN0IGluc3RhbmNlID0gbjIuY29tcG9uZW50ID0gbjEuY29tcG9uZW50O1xuICAgIGlmIChzaG91bGRVcGRhdGVDb21wb25lbnQobjEsIG4yLCBvcHRpbWl6ZWQpKSB7XG4gICAgICBpZiAoaW5zdGFuY2UuYXN5bmNEZXAgJiYgIWluc3RhbmNlLmFzeW5jUmVzb2x2ZWQpIHtcbiAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICBwdXNoV2FybmluZ0NvbnRleHQobjIpO1xuICAgICAgICB9XG4gICAgICAgIHVwZGF0ZUNvbXBvbmVudFByZVJlbmRlcihpbnN0YW5jZSwgbjIsIG9wdGltaXplZCk7XG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgcG9wV2FybmluZ0NvbnRleHQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbnN0YW5jZS5uZXh0ID0gbjI7XG4gICAgICAgIGludmFsaWRhdGVKb2IoaW5zdGFuY2UudXBkYXRlKTtcbiAgICAgICAgaW5zdGFuY2UudXBkYXRlKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG4yLmVsID0gbjEuZWw7XG4gICAgICBpbnN0YW5jZS52bm9kZSA9IG4yO1xuICAgIH1cbiAgfTtcbiAgY29uc3Qgc2V0dXBSZW5kZXJFZmZlY3QgPSAoaW5zdGFuY2UsIGluaXRpYWxWTm9kZSwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgb3B0aW1pemVkKSA9PiB7XG4gICAgY29uc3QgY29tcG9uZW50VXBkYXRlRm4gPSAoKSA9PiB7XG4gICAgICBpZiAoIWluc3RhbmNlLmlzTW91bnRlZCkge1xuICAgICAgICBsZXQgdm5vZGVIb29rO1xuICAgICAgICBjb25zdCB7IGVsLCBwcm9wcyB9ID0gaW5pdGlhbFZOb2RlO1xuICAgICAgICBjb25zdCB7IGJtLCBtLCBwYXJlbnQgfSA9IGluc3RhbmNlO1xuICAgICAgICBjb25zdCBpc0FzeW5jV3JhcHBlclZOb2RlID0gaXNBc3luY1dyYXBwZXIoaW5pdGlhbFZOb2RlKTtcbiAgICAgICAgdG9nZ2xlUmVjdXJzZShpbnN0YW5jZSwgZmFsc2UpO1xuICAgICAgICBpZiAoYm0pIHtcbiAgICAgICAgICBpbnZva2VBcnJheUZucyhibSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc0FzeW5jV3JhcHBlclZOb2RlICYmICh2bm9kZUhvb2sgPSBwcm9wcyAmJiBwcm9wcy5vblZub2RlQmVmb3JlTW91bnQpKSB7XG4gICAgICAgICAgaW52b2tlVk5vZGVIb29rKHZub2RlSG9vaywgcGFyZW50LCBpbml0aWFsVk5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIHRvZ2dsZVJlY3Vyc2UoaW5zdGFuY2UsIHRydWUpO1xuICAgICAgICBpZiAoZWwgJiYgaHlkcmF0ZU5vZGUpIHtcbiAgICAgICAgICBjb25zdCBoeWRyYXRlU3ViVHJlZSA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgICAgIHN0YXJ0TWVhc3VyZShpbnN0YW5jZSwgYHJlbmRlcmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW5zdGFuY2Uuc3ViVHJlZSA9IHJlbmRlckNvbXBvbmVudFJvb3QoaW5zdGFuY2UpO1xuICAgICAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICAgICAgZW5kTWVhc3VyZShpbnN0YW5jZSwgYHJlbmRlcmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICAgICAgc3RhcnRNZWFzdXJlKGluc3RhbmNlLCBgaHlkcmF0ZWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaHlkcmF0ZU5vZGUoXG4gICAgICAgICAgICAgIGVsLFxuICAgICAgICAgICAgICBpbnN0YW5jZS5zdWJUcmVlLFxuICAgICAgICAgICAgICBpbnN0YW5jZSxcbiAgICAgICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgICAgIG51bGxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgICAgICBlbmRNZWFzdXJlKGluc3RhbmNlLCBgaHlkcmF0ZWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgICAgaWYgKGlzQXN5bmNXcmFwcGVyVk5vZGUpIHtcbiAgICAgICAgICAgIGluaXRpYWxWTm9kZS50eXBlLl9fYXN5bmNMb2FkZXIoKS50aGVuKFxuICAgICAgICAgICAgICAvLyBub3RlOiB3ZSBhcmUgbW92aW5nIHRoZSByZW5kZXIgY2FsbCBpbnRvIGFuIGFzeW5jIGNhbGxiYWNrLFxuICAgICAgICAgICAgICAvLyB3aGljaCBtZWFucyBpdCB3b24ndCB0cmFjayBkZXBlbmRlbmNpZXMgLSBidXQgaXQncyBvayBiZWNhdXNlXG4gICAgICAgICAgICAgIC8vIGEgc2VydmVyLXJlbmRlcmVkIGFzeW5jIHdyYXBwZXIgaXMgYWxyZWFkeSBpbiByZXNvbHZlZCBzdGF0ZVxuICAgICAgICAgICAgICAvLyBhbmQgaXQgd2lsbCBuZXZlciBuZWVkIHRvIGNoYW5nZS5cbiAgICAgICAgICAgICAgKCkgPT4gIWluc3RhbmNlLmlzVW5tb3VudGVkICYmIGh5ZHJhdGVTdWJUcmVlKClcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGh5ZHJhdGVTdWJUcmVlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgICBzdGFydE1lYXN1cmUoaW5zdGFuY2UsIGByZW5kZXJgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3Qgc3ViVHJlZSA9IGluc3RhbmNlLnN1YlRyZWUgPSByZW5kZXJDb21wb25lbnRSb290KGluc3RhbmNlKTtcbiAgICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgICAgZW5kTWVhc3VyZShpbnN0YW5jZSwgYHJlbmRlcmApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgICAgc3RhcnRNZWFzdXJlKGluc3RhbmNlLCBgcGF0Y2hgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcGF0Y2goXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgc3ViVHJlZSxcbiAgICAgICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgICAgIGFuY2hvcixcbiAgICAgICAgICAgIGluc3RhbmNlLFxuICAgICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgICBpc1NWR1xuICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICAgIGVuZE1lYXN1cmUoaW5zdGFuY2UsIGBwYXRjaGApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpbml0aWFsVk5vZGUuZWwgPSBzdWJUcmVlLmVsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtKSB7XG4gICAgICAgICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KG0sIHBhcmVudFN1c3BlbnNlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzQXN5bmNXcmFwcGVyVk5vZGUgJiYgKHZub2RlSG9vayA9IHByb3BzICYmIHByb3BzLm9uVm5vZGVNb3VudGVkKSkge1xuICAgICAgICAgIGNvbnN0IHNjb3BlZEluaXRpYWxWTm9kZSA9IGluaXRpYWxWTm9kZTtcbiAgICAgICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QoXG4gICAgICAgICAgICAoKSA9PiBpbnZva2VWTm9kZUhvb2sodm5vZGVIb29rLCBwYXJlbnQsIHNjb3BlZEluaXRpYWxWTm9kZSksXG4gICAgICAgICAgICBwYXJlbnRTdXNwZW5zZVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluaXRpYWxWTm9kZS5zaGFwZUZsYWcgJiAyNTYgfHwgcGFyZW50ICYmIGlzQXN5bmNXcmFwcGVyKHBhcmVudC52bm9kZSkgJiYgcGFyZW50LnZub2RlLnNoYXBlRmxhZyAmIDI1Nikge1xuICAgICAgICAgIGluc3RhbmNlLmEgJiYgcXVldWVQb3N0UmVuZGVyRWZmZWN0KGluc3RhbmNlLmEsIHBhcmVudFN1c3BlbnNlKTtcbiAgICAgICAgfVxuICAgICAgICBpbnN0YW5jZS5pc01vdW50ZWQgPSB0cnVlO1xuICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcbiAgICAgICAgICBkZXZ0b29sc0NvbXBvbmVudEFkZGVkKGluc3RhbmNlKTtcbiAgICAgICAgfVxuICAgICAgICBpbml0aWFsVk5vZGUgPSBjb250YWluZXIgPSBhbmNob3IgPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IHsgbmV4dCwgYnUsIHUsIHBhcmVudCwgdm5vZGUgfSA9IGluc3RhbmNlO1xuICAgICAgICBsZXQgb3JpZ2luTmV4dCA9IG5leHQ7XG4gICAgICAgIGxldCB2bm9kZUhvb2s7XG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgcHVzaFdhcm5pbmdDb250ZXh0KG5leHQgfHwgaW5zdGFuY2Uudm5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIHRvZ2dsZVJlY3Vyc2UoaW5zdGFuY2UsIGZhbHNlKTtcbiAgICAgICAgaWYgKG5leHQpIHtcbiAgICAgICAgICBuZXh0LmVsID0gdm5vZGUuZWw7XG4gICAgICAgICAgdXBkYXRlQ29tcG9uZW50UHJlUmVuZGVyKGluc3RhbmNlLCBuZXh0LCBvcHRpbWl6ZWQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5leHQgPSB2bm9kZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYnUpIHtcbiAgICAgICAgICBpbnZva2VBcnJheUZucyhidSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZub2RlSG9vayA9IG5leHQucHJvcHMgJiYgbmV4dC5wcm9wcy5vblZub2RlQmVmb3JlVXBkYXRlKSB7XG4gICAgICAgICAgaW52b2tlVk5vZGVIb29rKHZub2RlSG9vaywgcGFyZW50LCBuZXh0LCB2bm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgdG9nZ2xlUmVjdXJzZShpbnN0YW5jZSwgdHJ1ZSk7XG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgc3RhcnRNZWFzdXJlKGluc3RhbmNlLCBgcmVuZGVyYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmV4dFRyZWUgPSByZW5kZXJDb21wb25lbnRSb290KGluc3RhbmNlKTtcbiAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICBlbmRNZWFzdXJlKGluc3RhbmNlLCBgcmVuZGVyYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJldlRyZWUgPSBpbnN0YW5jZS5zdWJUcmVlO1xuICAgICAgICBpbnN0YW5jZS5zdWJUcmVlID0gbmV4dFRyZWU7XG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgc3RhcnRNZWFzdXJlKGluc3RhbmNlLCBgcGF0Y2hgKTtcbiAgICAgICAgfVxuICAgICAgICBwYXRjaChcbiAgICAgICAgICBwcmV2VHJlZSxcbiAgICAgICAgICBuZXh0VHJlZSxcbiAgICAgICAgICAvLyBwYXJlbnQgbWF5IGhhdmUgY2hhbmdlZCBpZiBpdCdzIGluIGEgdGVsZXBvcnRcbiAgICAgICAgICBob3N0UGFyZW50Tm9kZShwcmV2VHJlZS5lbCksXG4gICAgICAgICAgLy8gYW5jaG9yIG1heSBoYXZlIGNoYW5nZWQgaWYgaXQncyBpbiBhIGZyYWdtZW50XG4gICAgICAgICAgZ2V0TmV4dEhvc3ROb2RlKHByZXZUcmVlKSxcbiAgICAgICAgICBpbnN0YW5jZSxcbiAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICBpc1NWR1xuICAgICAgICApO1xuICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgIGVuZE1lYXN1cmUoaW5zdGFuY2UsIGBwYXRjaGApO1xuICAgICAgICB9XG4gICAgICAgIG5leHQuZWwgPSBuZXh0VHJlZS5lbDtcbiAgICAgICAgaWYgKG9yaWdpbk5leHQgPT09IG51bGwpIHtcbiAgICAgICAgICB1cGRhdGVIT0NIb3N0RWwoaW5zdGFuY2UsIG5leHRUcmVlLmVsKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodSkge1xuICAgICAgICAgIHF1ZXVlUG9zdFJlbmRlckVmZmVjdCh1LCBwYXJlbnRTdXNwZW5zZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZub2RlSG9vayA9IG5leHQucHJvcHMgJiYgbmV4dC5wcm9wcy5vblZub2RlVXBkYXRlZCkge1xuICAgICAgICAgIHF1ZXVlUG9zdFJlbmRlckVmZmVjdChcbiAgICAgICAgICAgICgpID0+IGludm9rZVZOb2RlSG9vayh2bm9kZUhvb2ssIHBhcmVudCwgbmV4dCwgdm5vZGUpLFxuICAgICAgICAgICAgcGFyZW50U3VzcGVuc2VcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykge1xuICAgICAgICAgIGRldnRvb2xzQ29tcG9uZW50VXBkYXRlZChpbnN0YW5jZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICBwb3BXYXJuaW5nQ29udGV4dCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBlZmZlY3QgPSBpbnN0YW5jZS5lZmZlY3QgPSBuZXcgUmVhY3RpdmVFZmZlY3QoXG4gICAgICBjb21wb25lbnRVcGRhdGVGbixcbiAgICAgICgpID0+IHF1ZXVlSm9iKHVwZGF0ZSksXG4gICAgICBpbnN0YW5jZS5zY29wZVxuICAgICAgLy8gdHJhY2sgaXQgaW4gY29tcG9uZW50J3MgZWZmZWN0IHNjb3BlXG4gICAgKTtcbiAgICBjb25zdCB1cGRhdGUgPSBpbnN0YW5jZS51cGRhdGUgPSAoKSA9PiBlZmZlY3QucnVuKCk7XG4gICAgdXBkYXRlLmlkID0gaW5zdGFuY2UudWlkO1xuICAgIHRvZ2dsZVJlY3Vyc2UoaW5zdGFuY2UsIHRydWUpO1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICBlZmZlY3Qub25UcmFjayA9IGluc3RhbmNlLnJ0YyA/IChlKSA9PiBpbnZva2VBcnJheUZucyhpbnN0YW5jZS5ydGMsIGUpIDogdm9pZCAwO1xuICAgICAgZWZmZWN0Lm9uVHJpZ2dlciA9IGluc3RhbmNlLnJ0ZyA/IChlKSA9PiBpbnZva2VBcnJheUZucyhpbnN0YW5jZS5ydGcsIGUpIDogdm9pZCAwO1xuICAgICAgdXBkYXRlLm93bmVySW5zdGFuY2UgPSBpbnN0YW5jZTtcbiAgICB9XG4gICAgdXBkYXRlKCk7XG4gIH07XG4gIGNvbnN0IHVwZGF0ZUNvbXBvbmVudFByZVJlbmRlciA9IChpbnN0YW5jZSwgbmV4dFZOb2RlLCBvcHRpbWl6ZWQpID0+IHtcbiAgICBuZXh0Vk5vZGUuY29tcG9uZW50ID0gaW5zdGFuY2U7XG4gICAgY29uc3QgcHJldlByb3BzID0gaW5zdGFuY2Uudm5vZGUucHJvcHM7XG4gICAgaW5zdGFuY2Uudm5vZGUgPSBuZXh0Vk5vZGU7XG4gICAgaW5zdGFuY2UubmV4dCA9IG51bGw7XG4gICAgdXBkYXRlUHJvcHMoaW5zdGFuY2UsIG5leHRWTm9kZS5wcm9wcywgcHJldlByb3BzLCBvcHRpbWl6ZWQpO1xuICAgIHVwZGF0ZVNsb3RzKGluc3RhbmNlLCBuZXh0Vk5vZGUuY2hpbGRyZW4sIG9wdGltaXplZCk7XG4gICAgcGF1c2VUcmFja2luZygpO1xuICAgIGZsdXNoUHJlRmx1c2hDYnMoKTtcbiAgICByZXNldFRyYWNraW5nKCk7XG4gIH07XG4gIGNvbnN0IHBhdGNoQ2hpbGRyZW4gPSAobjEsIG4yLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkID0gZmFsc2UpID0+IHtcbiAgICBjb25zdCBjMSA9IG4xICYmIG4xLmNoaWxkcmVuO1xuICAgIGNvbnN0IHByZXZTaGFwZUZsYWcgPSBuMSA/IG4xLnNoYXBlRmxhZyA6IDA7XG4gICAgY29uc3QgYzIgPSBuMi5jaGlsZHJlbjtcbiAgICBjb25zdCB7IHBhdGNoRmxhZywgc2hhcGVGbGFnIH0gPSBuMjtcbiAgICBpZiAocGF0Y2hGbGFnID4gMCkge1xuICAgICAgaWYgKHBhdGNoRmxhZyAmIDEyOCkge1xuICAgICAgICBwYXRjaEtleWVkQ2hpbGRyZW4oXG4gICAgICAgICAgYzEsXG4gICAgICAgICAgYzIsXG4gICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgIGFuY2hvcixcbiAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgaXNTVkcsXG4gICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgIG9wdGltaXplZFxuICAgICAgICApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2UgaWYgKHBhdGNoRmxhZyAmIDI1Nikge1xuICAgICAgICBwYXRjaFVua2V5ZWRDaGlsZHJlbihcbiAgICAgICAgICBjMSxcbiAgICAgICAgICBjMixcbiAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgYW5jaG9yLFxuICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICBpc1NWRyxcbiAgICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgICAgb3B0aW1pemVkXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHNoYXBlRmxhZyAmIDgpIHtcbiAgICAgIGlmIChwcmV2U2hhcGVGbGFnICYgMTYpIHtcbiAgICAgICAgdW5tb3VudENoaWxkcmVuKGMxLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlKTtcbiAgICAgIH1cbiAgICAgIGlmIChjMiAhPT0gYzEpIHtcbiAgICAgICAgaG9zdFNldEVsZW1lbnRUZXh0KGNvbnRhaW5lciwgYzIpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocHJldlNoYXBlRmxhZyAmIDE2KSB7XG4gICAgICAgIGlmIChzaGFwZUZsYWcgJiAxNikge1xuICAgICAgICAgIHBhdGNoS2V5ZWRDaGlsZHJlbihcbiAgICAgICAgICAgIGMxLFxuICAgICAgICAgICAgYzIsXG4gICAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgICBhbmNob3IsXG4gICAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICAgIGlzU1ZHLFxuICAgICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgICAgb3B0aW1pemVkXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB1bm1vdW50Q2hpbGRyZW4oYzEsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHRydWUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocHJldlNoYXBlRmxhZyAmIDgpIHtcbiAgICAgICAgICBob3N0U2V0RWxlbWVudFRleHQoY29udGFpbmVyLCBcIlwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2hhcGVGbGFnICYgMTYpIHtcbiAgICAgICAgICBtb3VudENoaWxkcmVuKFxuICAgICAgICAgICAgYzIsXG4gICAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgICBhbmNob3IsXG4gICAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICAgIGlzU1ZHLFxuICAgICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgICAgb3B0aW1pemVkXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgY29uc3QgcGF0Y2hVbmtleWVkQ2hpbGRyZW4gPSAoYzEsIGMyLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKSA9PiB7XG4gICAgYzEgPSBjMSB8fCBFTVBUWV9BUlI7XG4gICAgYzIgPSBjMiB8fCBFTVBUWV9BUlI7XG4gICAgY29uc3Qgb2xkTGVuZ3RoID0gYzEubGVuZ3RoO1xuICAgIGNvbnN0IG5ld0xlbmd0aCA9IGMyLmxlbmd0aDtcbiAgICBjb25zdCBjb21tb25MZW5ndGggPSBNYXRoLm1pbihvbGRMZW5ndGgsIG5ld0xlbmd0aCk7XG4gICAgbGV0IGk7XG4gICAgZm9yIChpID0gMDsgaSA8IGNvbW1vbkxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBuZXh0Q2hpbGQgPSBjMltpXSA9IG9wdGltaXplZCA/IGNsb25lSWZNb3VudGVkKGMyW2ldKSA6IG5vcm1hbGl6ZVZOb2RlKGMyW2ldKTtcbiAgICAgIHBhdGNoKFxuICAgICAgICBjMVtpXSxcbiAgICAgICAgbmV4dENoaWxkLFxuICAgICAgICBjb250YWluZXIsXG4gICAgICAgIG51bGwsXG4gICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgIGlzU1ZHLFxuICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgIG9wdGltaXplZFxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKG9sZExlbmd0aCA+IG5ld0xlbmd0aCkge1xuICAgICAgdW5tb3VudENoaWxkcmVuKFxuICAgICAgICBjMSxcbiAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgdHJ1ZSxcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIGNvbW1vbkxlbmd0aFxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbW91bnRDaGlsZHJlbihcbiAgICAgICAgYzIsXG4gICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgYW5jaG9yLFxuICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICBpc1NWRyxcbiAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICBvcHRpbWl6ZWQsXG4gICAgICAgIGNvbW1vbkxlbmd0aFxuICAgICAgKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHBhdGNoS2V5ZWRDaGlsZHJlbiA9IChjMSwgYzIsIGNvbnRhaW5lciwgcGFyZW50QW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpID0+IHtcbiAgICBsZXQgaSA9IDA7XG4gICAgY29uc3QgbDIgPSBjMi5sZW5ndGg7XG4gICAgbGV0IGUxID0gYzEubGVuZ3RoIC0gMTtcbiAgICBsZXQgZTIgPSBsMiAtIDE7XG4gICAgd2hpbGUgKGkgPD0gZTEgJiYgaSA8PSBlMikge1xuICAgICAgY29uc3QgbjEgPSBjMVtpXTtcbiAgICAgIGNvbnN0IG4yID0gYzJbaV0gPSBvcHRpbWl6ZWQgPyBjbG9uZUlmTW91bnRlZChjMltpXSkgOiBub3JtYWxpemVWTm9kZShjMltpXSk7XG4gICAgICBpZiAoaXNTYW1lVk5vZGVUeXBlKG4xLCBuMikpIHtcbiAgICAgICAgcGF0Y2goXG4gICAgICAgICAgbjEsXG4gICAgICAgICAgbjIsXG4gICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgIG51bGwsXG4gICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgIGlzU1ZHLFxuICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaSsrO1xuICAgIH1cbiAgICB3aGlsZSAoaSA8PSBlMSAmJiBpIDw9IGUyKSB7XG4gICAgICBjb25zdCBuMSA9IGMxW2UxXTtcbiAgICAgIGNvbnN0IG4yID0gYzJbZTJdID0gb3B0aW1pemVkID8gY2xvbmVJZk1vdW50ZWQoYzJbZTJdKSA6IG5vcm1hbGl6ZVZOb2RlKGMyW2UyXSk7XG4gICAgICBpZiAoaXNTYW1lVk5vZGVUeXBlKG4xLCBuMikpIHtcbiAgICAgICAgcGF0Y2goXG4gICAgICAgICAgbjEsXG4gICAgICAgICAgbjIsXG4gICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgIG51bGwsXG4gICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgIGlzU1ZHLFxuICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgZTEtLTtcbiAgICAgIGUyLS07XG4gICAgfVxuICAgIGlmIChpID4gZTEpIHtcbiAgICAgIGlmIChpIDw9IGUyKSB7XG4gICAgICAgIGNvbnN0IG5leHRQb3MgPSBlMiArIDE7XG4gICAgICAgIGNvbnN0IGFuY2hvciA9IG5leHRQb3MgPCBsMiA/IGMyW25leHRQb3NdLmVsIDogcGFyZW50QW5jaG9yO1xuICAgICAgICB3aGlsZSAoaSA8PSBlMikge1xuICAgICAgICAgIHBhdGNoKFxuICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgIGMyW2ldID0gb3B0aW1pemVkID8gY2xvbmVJZk1vdW50ZWQoYzJbaV0pIDogbm9ybWFsaXplVk5vZGUoYzJbaV0pLFxuICAgICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgICAgYW5jaG9yLFxuICAgICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgICBpc1NWRyxcbiAgICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICAgIG9wdGltaXplZFxuICAgICAgICAgICk7XG4gICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpID4gZTIpIHtcbiAgICAgIHdoaWxlIChpIDw9IGUxKSB7XG4gICAgICAgIHVubW91bnQoYzFbaV0sIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHRydWUpO1xuICAgICAgICBpKys7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHMxID0gaTtcbiAgICAgIGNvbnN0IHMyID0gaTtcbiAgICAgIGNvbnN0IGtleVRvTmV3SW5kZXhNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgZm9yIChpID0gczI7IGkgPD0gZTI7IGkrKykge1xuICAgICAgICBjb25zdCBuZXh0Q2hpbGQgPSBjMltpXSA9IG9wdGltaXplZCA/IGNsb25lSWZNb3VudGVkKGMyW2ldKSA6IG5vcm1hbGl6ZVZOb2RlKGMyW2ldKTtcbiAgICAgICAgaWYgKG5leHRDaGlsZC5rZXkgIT0gbnVsbCkge1xuICAgICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGtleVRvTmV3SW5kZXhNYXAuaGFzKG5leHRDaGlsZC5rZXkpKSB7XG4gICAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgICBgRHVwbGljYXRlIGtleXMgZm91bmQgZHVyaW5nIHVwZGF0ZTpgLFxuICAgICAgICAgICAgICBKU09OLnN0cmluZ2lmeShuZXh0Q2hpbGQua2V5KSxcbiAgICAgICAgICAgICAgYE1ha2Ugc3VyZSBrZXlzIGFyZSB1bmlxdWUuYFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAga2V5VG9OZXdJbmRleE1hcC5zZXQobmV4dENoaWxkLmtleSwgaSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGxldCBqO1xuICAgICAgbGV0IHBhdGNoZWQgPSAwO1xuICAgICAgY29uc3QgdG9CZVBhdGNoZWQgPSBlMiAtIHMyICsgMTtcbiAgICAgIGxldCBtb3ZlZCA9IGZhbHNlO1xuICAgICAgbGV0IG1heE5ld0luZGV4U29GYXIgPSAwO1xuICAgICAgY29uc3QgbmV3SW5kZXhUb09sZEluZGV4TWFwID0gbmV3IEFycmF5KHRvQmVQYXRjaGVkKTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCB0b0JlUGF0Y2hlZDsgaSsrKVxuICAgICAgICBuZXdJbmRleFRvT2xkSW5kZXhNYXBbaV0gPSAwO1xuICAgICAgZm9yIChpID0gczE7IGkgPD0gZTE7IGkrKykge1xuICAgICAgICBjb25zdCBwcmV2Q2hpbGQgPSBjMVtpXTtcbiAgICAgICAgaWYgKHBhdGNoZWQgPj0gdG9CZVBhdGNoZWQpIHtcbiAgICAgICAgICB1bm1vdW50KHByZXZDaGlsZCwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgdHJ1ZSk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG5ld0luZGV4O1xuICAgICAgICBpZiAocHJldkNoaWxkLmtleSAhPSBudWxsKSB7XG4gICAgICAgICAgbmV3SW5kZXggPSBrZXlUb05ld0luZGV4TWFwLmdldChwcmV2Q2hpbGQua2V5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmb3IgKGogPSBzMjsgaiA8PSBlMjsgaisrKSB7XG4gICAgICAgICAgICBpZiAobmV3SW5kZXhUb09sZEluZGV4TWFwW2ogLSBzMl0gPT09IDAgJiYgaXNTYW1lVk5vZGVUeXBlKHByZXZDaGlsZCwgYzJbal0pKSB7XG4gICAgICAgICAgICAgIG5ld0luZGV4ID0gajtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChuZXdJbmRleCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgdW5tb3VudChwcmV2Q2hpbGQsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHRydWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5ld0luZGV4VG9PbGRJbmRleE1hcFtuZXdJbmRleCAtIHMyXSA9IGkgKyAxO1xuICAgICAgICAgIGlmIChuZXdJbmRleCA+PSBtYXhOZXdJbmRleFNvRmFyKSB7XG4gICAgICAgICAgICBtYXhOZXdJbmRleFNvRmFyID0gbmV3SW5kZXg7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1vdmVkID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcGF0Y2goXG4gICAgICAgICAgICBwcmV2Q2hpbGQsXG4gICAgICAgICAgICBjMltuZXdJbmRleF0sXG4gICAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgICBpc1NWRyxcbiAgICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICAgIG9wdGltaXplZFxuICAgICAgICAgICk7XG4gICAgICAgICAgcGF0Y2hlZCsrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBpbmNyZWFzaW5nTmV3SW5kZXhTZXF1ZW5jZSA9IG1vdmVkID8gZ2V0U2VxdWVuY2UobmV3SW5kZXhUb09sZEluZGV4TWFwKSA6IEVNUFRZX0FSUjtcbiAgICAgIGogPSBpbmNyZWFzaW5nTmV3SW5kZXhTZXF1ZW5jZS5sZW5ndGggLSAxO1xuICAgICAgZm9yIChpID0gdG9CZVBhdGNoZWQgLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBjb25zdCBuZXh0SW5kZXggPSBzMiArIGk7XG4gICAgICAgIGNvbnN0IG5leHRDaGlsZCA9IGMyW25leHRJbmRleF07XG4gICAgICAgIGNvbnN0IGFuY2hvciA9IG5leHRJbmRleCArIDEgPCBsMiA/IGMyW25leHRJbmRleCArIDFdLmVsIDogcGFyZW50QW5jaG9yO1xuICAgICAgICBpZiAobmV3SW5kZXhUb09sZEluZGV4TWFwW2ldID09PSAwKSB7XG4gICAgICAgICAgcGF0Y2goXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgbmV4dENoaWxkLFxuICAgICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgICAgYW5jaG9yLFxuICAgICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgICBpc1NWRyxcbiAgICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICAgIG9wdGltaXplZFxuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSBpZiAobW92ZWQpIHtcbiAgICAgICAgICBpZiAoaiA8IDAgfHwgaSAhPT0gaW5jcmVhc2luZ05ld0luZGV4U2VxdWVuY2Vbal0pIHtcbiAgICAgICAgICAgIG1vdmUobmV4dENoaWxkLCBjb250YWluZXIsIGFuY2hvciwgMik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGotLTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIGNvbnN0IG1vdmUgPSAodm5vZGUsIGNvbnRhaW5lciwgYW5jaG9yLCBtb3ZlVHlwZSwgcGFyZW50U3VzcGVuc2UgPSBudWxsKSA9PiB7XG4gICAgY29uc3QgeyBlbCwgdHlwZSwgdHJhbnNpdGlvbiwgY2hpbGRyZW4sIHNoYXBlRmxhZyB9ID0gdm5vZGU7XG4gICAgaWYgKHNoYXBlRmxhZyAmIDYpIHtcbiAgICAgIG1vdmUodm5vZGUuY29tcG9uZW50LnN1YlRyZWUsIGNvbnRhaW5lciwgYW5jaG9yLCBtb3ZlVHlwZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChzaGFwZUZsYWcgJiAxMjgpIHtcbiAgICAgIHZub2RlLnN1c3BlbnNlLm1vdmUoY29udGFpbmVyLCBhbmNob3IsIG1vdmVUeXBlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHNoYXBlRmxhZyAmIDY0KSB7XG4gICAgICB0eXBlLm1vdmUodm5vZGUsIGNvbnRhaW5lciwgYW5jaG9yLCBpbnRlcm5hbHMpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodHlwZSA9PT0gRnJhZ21lbnQpIHtcbiAgICAgIGhvc3RJbnNlcnQoZWwsIGNvbnRhaW5lciwgYW5jaG9yKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbW92ZShjaGlsZHJlbltpXSwgY29udGFpbmVyLCBhbmNob3IsIG1vdmVUeXBlKTtcbiAgICAgIH1cbiAgICAgIGhvc3RJbnNlcnQodm5vZGUuYW5jaG9yLCBjb250YWluZXIsIGFuY2hvcik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0eXBlID09PSBTdGF0aWMpIHtcbiAgICAgIG1vdmVTdGF0aWNOb2RlKHZub2RlLCBjb250YWluZXIsIGFuY2hvcik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG5lZWRUcmFuc2l0aW9uID0gbW92ZVR5cGUgIT09IDIgJiYgc2hhcGVGbGFnICYgMSAmJiB0cmFuc2l0aW9uO1xuICAgIGlmIChuZWVkVHJhbnNpdGlvbikge1xuICAgICAgaWYgKG1vdmVUeXBlID09PSAwKSB7XG4gICAgICAgIHRyYW5zaXRpb24uYmVmb3JlRW50ZXIoZWwpO1xuICAgICAgICBob3N0SW5zZXJ0KGVsLCBjb250YWluZXIsIGFuY2hvcik7XG4gICAgICAgIHF1ZXVlUG9zdFJlbmRlckVmZmVjdCgoKSA9PiB0cmFuc2l0aW9uLmVudGVyKGVsKSwgcGFyZW50U3VzcGVuc2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgeyBsZWF2ZSwgZGVsYXlMZWF2ZSwgYWZ0ZXJMZWF2ZSB9ID0gdHJhbnNpdGlvbjtcbiAgICAgICAgY29uc3QgcmVtb3ZlMiA9ICgpID0+IGhvc3RJbnNlcnQoZWwsIGNvbnRhaW5lciwgYW5jaG9yKTtcbiAgICAgICAgY29uc3QgcGVyZm9ybUxlYXZlID0gKCkgPT4ge1xuICAgICAgICAgIGxlYXZlKGVsLCAoKSA9PiB7XG4gICAgICAgICAgICByZW1vdmUyKCk7XG4gICAgICAgICAgICBhZnRlckxlYXZlICYmIGFmdGVyTGVhdmUoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGRlbGF5TGVhdmUpIHtcbiAgICAgICAgICBkZWxheUxlYXZlKGVsLCByZW1vdmUyLCBwZXJmb3JtTGVhdmUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBlcmZvcm1MZWF2ZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGhvc3RJbnNlcnQoZWwsIGNvbnRhaW5lciwgYW5jaG9yKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHVubW91bnQgPSAodm5vZGUsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGRvUmVtb3ZlID0gZmFsc2UsIG9wdGltaXplZCA9IGZhbHNlKSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgdHlwZSxcbiAgICAgIHByb3BzLFxuICAgICAgcmVmLFxuICAgICAgY2hpbGRyZW4sXG4gICAgICBkeW5hbWljQ2hpbGRyZW4sXG4gICAgICBzaGFwZUZsYWcsXG4gICAgICBwYXRjaEZsYWcsXG4gICAgICBkaXJzXG4gICAgfSA9IHZub2RlO1xuICAgIGlmIChyZWYgIT0gbnVsbCkge1xuICAgICAgc2V0UmVmKHJlZiwgbnVsbCwgcGFyZW50U3VzcGVuc2UsIHZub2RlLCB0cnVlKTtcbiAgICB9XG4gICAgaWYgKHNoYXBlRmxhZyAmIDI1Nikge1xuICAgICAgcGFyZW50Q29tcG9uZW50LmN0eC5kZWFjdGl2YXRlKHZub2RlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc2hvdWxkSW52b2tlRGlycyA9IHNoYXBlRmxhZyAmIDEgJiYgZGlycztcbiAgICBjb25zdCBzaG91bGRJbnZva2VWbm9kZUhvb2sgPSAhaXNBc3luY1dyYXBwZXIodm5vZGUpO1xuICAgIGxldCB2bm9kZUhvb2s7XG4gICAgaWYgKHNob3VsZEludm9rZVZub2RlSG9vayAmJiAodm5vZGVIb29rID0gcHJvcHMgJiYgcHJvcHMub25Wbm9kZUJlZm9yZVVubW91bnQpKSB7XG4gICAgICBpbnZva2VWTm9kZUhvb2sodm5vZGVIb29rLCBwYXJlbnRDb21wb25lbnQsIHZub2RlKTtcbiAgICB9XG4gICAgaWYgKHNoYXBlRmxhZyAmIDYpIHtcbiAgICAgIHVubW91bnRDb21wb25lbnQodm5vZGUuY29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgZG9SZW1vdmUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoc2hhcGVGbGFnICYgMTI4KSB7XG4gICAgICAgIHZub2RlLnN1c3BlbnNlLnVubW91bnQocGFyZW50U3VzcGVuc2UsIGRvUmVtb3ZlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHNob3VsZEludm9rZURpcnMpIHtcbiAgICAgICAgaW52b2tlRGlyZWN0aXZlSG9vayh2bm9kZSwgbnVsbCwgcGFyZW50Q29tcG9uZW50LCBcImJlZm9yZVVubW91bnRcIik7XG4gICAgICB9XG4gICAgICBpZiAoc2hhcGVGbGFnICYgNjQpIHtcbiAgICAgICAgdm5vZGUudHlwZS5yZW1vdmUoXG4gICAgICAgICAgdm5vZGUsXG4gICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgIG9wdGltaXplZCxcbiAgICAgICAgICBpbnRlcm5hbHMsXG4gICAgICAgICAgZG9SZW1vdmVcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSBpZiAoZHluYW1pY0NoaWxkcmVuICYmIC8vICMxMTUzOiBmYXN0IHBhdGggc2hvdWxkIG5vdCBiZSB0YWtlbiBmb3Igbm9uLXN0YWJsZSAodi1mb3IpIGZyYWdtZW50c1xuICAgICAgKHR5cGUgIT09IEZyYWdtZW50IHx8IHBhdGNoRmxhZyA+IDAgJiYgcGF0Y2hGbGFnICYgNjQpKSB7XG4gICAgICAgIHVubW91bnRDaGlsZHJlbihcbiAgICAgICAgICBkeW5hbWljQ2hpbGRyZW4sXG4gICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgIHRydWVcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gRnJhZ21lbnQgJiYgcGF0Y2hGbGFnICYgKDEyOCB8IDI1NikgfHwgIW9wdGltaXplZCAmJiBzaGFwZUZsYWcgJiAxNikge1xuICAgICAgICB1bm1vdW50Q2hpbGRyZW4oY2hpbGRyZW4sIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UpO1xuICAgICAgfVxuICAgICAgaWYgKGRvUmVtb3ZlKSB7XG4gICAgICAgIHJlbW92ZSh2bm9kZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChzaG91bGRJbnZva2VWbm9kZUhvb2sgJiYgKHZub2RlSG9vayA9IHByb3BzICYmIHByb3BzLm9uVm5vZGVVbm1vdW50ZWQpIHx8IHNob3VsZEludm9rZURpcnMpIHtcbiAgICAgIHF1ZXVlUG9zdFJlbmRlckVmZmVjdCgoKSA9PiB7XG4gICAgICAgIHZub2RlSG9vayAmJiBpbnZva2VWTm9kZUhvb2sodm5vZGVIb29rLCBwYXJlbnRDb21wb25lbnQsIHZub2RlKTtcbiAgICAgICAgc2hvdWxkSW52b2tlRGlycyAmJiBpbnZva2VEaXJlY3RpdmVIb29rKHZub2RlLCBudWxsLCBwYXJlbnRDb21wb25lbnQsIFwidW5tb3VudGVkXCIpO1xuICAgICAgfSwgcGFyZW50U3VzcGVuc2UpO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgcmVtb3ZlID0gKHZub2RlKSA9PiB7XG4gICAgY29uc3QgeyB0eXBlLCBlbCwgYW5jaG9yLCB0cmFuc2l0aW9uIH0gPSB2bm9kZTtcbiAgICBpZiAodHlwZSA9PT0gRnJhZ21lbnQpIHtcbiAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHZub2RlLnBhdGNoRmxhZyA+IDAgJiYgdm5vZGUucGF0Y2hGbGFnICYgMjA0OCAmJiB0cmFuc2l0aW9uICYmICF0cmFuc2l0aW9uLnBlcnNpc3RlZCkge1xuICAgICAgICB2bm9kZS5jaGlsZHJlbi5mb3JFYWNoKChjaGlsZCkgPT4ge1xuICAgICAgICAgIGlmIChjaGlsZC50eXBlID09PSBDb21tZW50KSB7XG4gICAgICAgICAgICBob3N0UmVtb3ZlKGNoaWxkLmVsKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVtb3ZlKGNoaWxkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVtb3ZlRnJhZ21lbnQoZWwsIGFuY2hvcik7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0eXBlID09PSBTdGF0aWMpIHtcbiAgICAgIHJlbW92ZVN0YXRpY05vZGUodm5vZGUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBwZXJmb3JtUmVtb3ZlID0gKCkgPT4ge1xuICAgICAgaG9zdFJlbW92ZShlbCk7XG4gICAgICBpZiAodHJhbnNpdGlvbiAmJiAhdHJhbnNpdGlvbi5wZXJzaXN0ZWQgJiYgdHJhbnNpdGlvbi5hZnRlckxlYXZlKSB7XG4gICAgICAgIHRyYW5zaXRpb24uYWZ0ZXJMZWF2ZSgpO1xuICAgICAgfVxuICAgIH07XG4gICAgaWYgKHZub2RlLnNoYXBlRmxhZyAmIDEgJiYgdHJhbnNpdGlvbiAmJiAhdHJhbnNpdGlvbi5wZXJzaXN0ZWQpIHtcbiAgICAgIGNvbnN0IHsgbGVhdmUsIGRlbGF5TGVhdmUgfSA9IHRyYW5zaXRpb247XG4gICAgICBjb25zdCBwZXJmb3JtTGVhdmUgPSAoKSA9PiBsZWF2ZShlbCwgcGVyZm9ybVJlbW92ZSk7XG4gICAgICBpZiAoZGVsYXlMZWF2ZSkge1xuICAgICAgICBkZWxheUxlYXZlKHZub2RlLmVsLCBwZXJmb3JtUmVtb3ZlLCBwZXJmb3JtTGVhdmUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGVyZm9ybUxlYXZlKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHBlcmZvcm1SZW1vdmUoKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHJlbW92ZUZyYWdtZW50ID0gKGN1ciwgZW5kKSA9PiB7XG4gICAgbGV0IG5leHQ7XG4gICAgd2hpbGUgKGN1ciAhPT0gZW5kKSB7XG4gICAgICBuZXh0ID0gaG9zdE5leHRTaWJsaW5nKGN1cik7XG4gICAgICBob3N0UmVtb3ZlKGN1cik7XG4gICAgICBjdXIgPSBuZXh0O1xuICAgIH1cbiAgICBob3N0UmVtb3ZlKGVuZCk7XG4gIH07XG4gIGNvbnN0IHVubW91bnRDb21wb25lbnQgPSAoaW5zdGFuY2UsIHBhcmVudFN1c3BlbnNlLCBkb1JlbW92ZSkgPT4ge1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGluc3RhbmNlLnR5cGUuX19obXJJZCkge1xuICAgICAgdW5yZWdpc3RlckhNUihpbnN0YW5jZSk7XG4gICAgfVxuICAgIGNvbnN0IHsgYnVtLCBzY29wZSwgdXBkYXRlLCBzdWJUcmVlLCB1bSB9ID0gaW5zdGFuY2U7XG4gICAgaWYgKGJ1bSkge1xuICAgICAgaW52b2tlQXJyYXlGbnMoYnVtKTtcbiAgICB9XG4gICAgc2NvcGUuc3RvcCgpO1xuICAgIGlmICh1cGRhdGUpIHtcbiAgICAgIHVwZGF0ZS5hY3RpdmUgPSBmYWxzZTtcbiAgICAgIHVubW91bnQoc3ViVHJlZSwgaW5zdGFuY2UsIHBhcmVudFN1c3BlbnNlLCBkb1JlbW92ZSk7XG4gICAgfVxuICAgIGlmICh1bSkge1xuICAgICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KHVtLCBwYXJlbnRTdXNwZW5zZSk7XG4gICAgfVxuICAgIHF1ZXVlUG9zdFJlbmRlckVmZmVjdCgoKSA9PiB7XG4gICAgICBpbnN0YW5jZS5pc1VubW91bnRlZCA9IHRydWU7XG4gICAgfSwgcGFyZW50U3VzcGVuc2UpO1xuICAgIGlmIChwYXJlbnRTdXNwZW5zZSAmJiBwYXJlbnRTdXNwZW5zZS5wZW5kaW5nQnJhbmNoICYmICFwYXJlbnRTdXNwZW5zZS5pc1VubW91bnRlZCAmJiBpbnN0YW5jZS5hc3luY0RlcCAmJiAhaW5zdGFuY2UuYXN5bmNSZXNvbHZlZCAmJiBpbnN0YW5jZS5zdXNwZW5zZUlkID09PSBwYXJlbnRTdXNwZW5zZS5wZW5kaW5nSWQpIHtcbiAgICAgIHBhcmVudFN1c3BlbnNlLmRlcHMtLTtcbiAgICAgIGlmIChwYXJlbnRTdXNwZW5zZS5kZXBzID09PSAwKSB7XG4gICAgICAgIHBhcmVudFN1c3BlbnNlLnJlc29sdmUoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XG4gICAgICBkZXZ0b29sc0NvbXBvbmVudFJlbW92ZWQoaW5zdGFuY2UpO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgdW5tb3VudENoaWxkcmVuID0gKGNoaWxkcmVuLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBkb1JlbW92ZSA9IGZhbHNlLCBvcHRpbWl6ZWQgPSBmYWxzZSwgc3RhcnQgPSAwKSA9PiB7XG4gICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHVubW91bnQoY2hpbGRyZW5baV0sIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGRvUmVtb3ZlLCBvcHRpbWl6ZWQpO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgZ2V0TmV4dEhvc3ROb2RlID0gKHZub2RlKSA9PiB7XG4gICAgaWYgKHZub2RlLnNoYXBlRmxhZyAmIDYpIHtcbiAgICAgIHJldHVybiBnZXROZXh0SG9zdE5vZGUodm5vZGUuY29tcG9uZW50LnN1YlRyZWUpO1xuICAgIH1cbiAgICBpZiAodm5vZGUuc2hhcGVGbGFnICYgMTI4KSB7XG4gICAgICByZXR1cm4gdm5vZGUuc3VzcGVuc2UubmV4dCgpO1xuICAgIH1cbiAgICByZXR1cm4gaG9zdE5leHRTaWJsaW5nKHZub2RlLmFuY2hvciB8fCB2bm9kZS5lbCk7XG4gIH07XG4gIGNvbnN0IHJlbmRlciA9ICh2bm9kZSwgY29udGFpbmVyLCBpc1NWRykgPT4ge1xuICAgIGlmICh2bm9kZSA9PSBudWxsKSB7XG4gICAgICBpZiAoY29udGFpbmVyLl92bm9kZSkge1xuICAgICAgICB1bm1vdW50KGNvbnRhaW5lci5fdm5vZGUsIG51bGwsIG51bGwsIHRydWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwYXRjaChjb250YWluZXIuX3Zub2RlIHx8IG51bGwsIHZub2RlLCBjb250YWluZXIsIG51bGwsIG51bGwsIG51bGwsIGlzU1ZHKTtcbiAgICB9XG4gICAgZmx1c2hQcmVGbHVzaENicygpO1xuICAgIGZsdXNoUG9zdEZsdXNoQ2JzKCk7XG4gICAgY29udGFpbmVyLl92bm9kZSA9IHZub2RlO1xuICB9O1xuICBjb25zdCBpbnRlcm5hbHMgPSB7XG4gICAgcDogcGF0Y2gsXG4gICAgdW06IHVubW91bnQsXG4gICAgbTogbW92ZSxcbiAgICByOiByZW1vdmUsXG4gICAgbXQ6IG1vdW50Q29tcG9uZW50LFxuICAgIG1jOiBtb3VudENoaWxkcmVuLFxuICAgIHBjOiBwYXRjaENoaWxkcmVuLFxuICAgIHBiYzogcGF0Y2hCbG9ja0NoaWxkcmVuLFxuICAgIG46IGdldE5leHRIb3N0Tm9kZSxcbiAgICBvOiBvcHRpb25zXG4gIH07XG4gIGxldCBoeWRyYXRlO1xuICBsZXQgaHlkcmF0ZU5vZGU7XG4gIGlmIChjcmVhdGVIeWRyYXRpb25GbnMpIHtcbiAgICBbaHlkcmF0ZSwgaHlkcmF0ZU5vZGVdID0gY3JlYXRlSHlkcmF0aW9uRm5zKFxuICAgICAgaW50ZXJuYWxzXG4gICAgKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHJlbmRlcixcbiAgICBoeWRyYXRlLFxuICAgIGNyZWF0ZUFwcDogY3JlYXRlQXBwQVBJKHJlbmRlciwgaHlkcmF0ZSlcbiAgfTtcbn1cbmZ1bmN0aW9uIHRvZ2dsZVJlY3Vyc2UoeyBlZmZlY3QsIHVwZGF0ZSB9LCBhbGxvd2VkKSB7XG4gIGVmZmVjdC5hbGxvd1JlY3Vyc2UgPSB1cGRhdGUuYWxsb3dSZWN1cnNlID0gYWxsb3dlZDtcbn1cbmZ1bmN0aW9uIHRyYXZlcnNlU3RhdGljQ2hpbGRyZW4objEsIG4yLCBzaGFsbG93ID0gZmFsc2UpIHtcbiAgY29uc3QgY2gxID0gbjEuY2hpbGRyZW47XG4gIGNvbnN0IGNoMiA9IG4yLmNoaWxkcmVuO1xuICBpZiAoaXNBcnJheShjaDEpICYmIGlzQXJyYXkoY2gyKSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2gxLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBjMSA9IGNoMVtpXTtcbiAgICAgIGxldCBjMiA9IGNoMltpXTtcbiAgICAgIGlmIChjMi5zaGFwZUZsYWcgJiAxICYmICFjMi5keW5hbWljQ2hpbGRyZW4pIHtcbiAgICAgICAgaWYgKGMyLnBhdGNoRmxhZyA8PSAwIHx8IGMyLnBhdGNoRmxhZyA9PT0gMzIpIHtcbiAgICAgICAgICBjMiA9IGNoMltpXSA9IGNsb25lSWZNb3VudGVkKGNoMltpXSk7XG4gICAgICAgICAgYzIuZWwgPSBjMS5lbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXNoYWxsb3cpXG4gICAgICAgICAgdHJhdmVyc2VTdGF0aWNDaGlsZHJlbihjMSwgYzIpO1xuICAgICAgfVxuICAgICAgaWYgKGMyLnR5cGUgPT09IFRleHQpIHtcbiAgICAgICAgYzIuZWwgPSBjMS5lbDtcbiAgICAgIH1cbiAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGMyLnR5cGUgPT09IENvbW1lbnQgJiYgIWMyLmVsKSB7XG4gICAgICAgIGMyLmVsID0gYzEuZWw7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBnZXRTZXF1ZW5jZShhcnIpIHtcbiAgY29uc3QgcCA9IGFyci5zbGljZSgpO1xuICBjb25zdCByZXN1bHQgPSBbMF07XG4gIGxldCBpLCBqLCB1LCB2LCBjO1xuICBjb25zdCBsZW4gPSBhcnIubGVuZ3RoO1xuICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBjb25zdCBhcnJJID0gYXJyW2ldO1xuICAgIGlmIChhcnJJICE9PSAwKSB7XG4gICAgICBqID0gcmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXTtcbiAgICAgIGlmIChhcnJbal0gPCBhcnJJKSB7XG4gICAgICAgIHBbaV0gPSBqO1xuICAgICAgICByZXN1bHQucHVzaChpKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB1ID0gMDtcbiAgICAgIHYgPSByZXN1bHQubGVuZ3RoIC0gMTtcbiAgICAgIHdoaWxlICh1IDwgdikge1xuICAgICAgICBjID0gdSArIHYgPj4gMTtcbiAgICAgICAgaWYgKGFycltyZXN1bHRbY11dIDwgYXJySSkge1xuICAgICAgICAgIHUgPSBjICsgMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2ID0gYztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGFyckkgPCBhcnJbcmVzdWx0W3VdXSkge1xuICAgICAgICBpZiAodSA+IDApIHtcbiAgICAgICAgICBwW2ldID0gcmVzdWx0W3UgLSAxXTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHRbdV0gPSBpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICB1ID0gcmVzdWx0Lmxlbmd0aDtcbiAgdiA9IHJlc3VsdFt1IC0gMV07XG4gIHdoaWxlICh1LS0gPiAwKSB7XG4gICAgcmVzdWx0W3VdID0gdjtcbiAgICB2ID0gcFt2XTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5jb25zdCBpc1RlbGVwb3J0ID0gKHR5cGUpID0+IHR5cGUuX19pc1RlbGVwb3J0O1xuY29uc3QgaXNUZWxlcG9ydERpc2FibGVkID0gKHByb3BzKSA9PiBwcm9wcyAmJiAocHJvcHMuZGlzYWJsZWQgfHwgcHJvcHMuZGlzYWJsZWQgPT09IFwiXCIpO1xuY29uc3QgaXNUYXJnZXRTVkcgPSAodGFyZ2V0KSA9PiB0eXBlb2YgU1ZHRWxlbWVudCAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0YXJnZXQgaW5zdGFuY2VvZiBTVkdFbGVtZW50O1xuY29uc3QgcmVzb2x2ZVRhcmdldCA9IChwcm9wcywgc2VsZWN0KSA9PiB7XG4gIGNvbnN0IHRhcmdldFNlbGVjdG9yID0gcHJvcHMgJiYgcHJvcHMudG87XG4gIGlmIChpc1N0cmluZyh0YXJnZXRTZWxlY3RvcikpIHtcbiAgICBpZiAoIXNlbGVjdCkge1xuICAgICAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiB3YXJuKFxuICAgICAgICBgQ3VycmVudCByZW5kZXJlciBkb2VzIG5vdCBzdXBwb3J0IHN0cmluZyB0YXJnZXQgZm9yIFRlbGVwb3J0cy4gKG1pc3NpbmcgcXVlcnlTZWxlY3RvciByZW5kZXJlciBvcHRpb24pYFxuICAgICAgKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB0YXJnZXQgPSBzZWxlY3QodGFyZ2V0U2VsZWN0b3IpO1xuICAgICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgICAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiB3YXJuKFxuICAgICAgICAgIGBGYWlsZWQgdG8gbG9jYXRlIFRlbGVwb3J0IHRhcmdldCB3aXRoIHNlbGVjdG9yIFwiJHt0YXJnZXRTZWxlY3Rvcn1cIi4gTm90ZSB0aGUgdGFyZ2V0IGVsZW1lbnQgbXVzdCBleGlzdCBiZWZvcmUgdGhlIGNvbXBvbmVudCBpcyBtb3VudGVkIC0gaS5lLiB0aGUgdGFyZ2V0IGNhbm5vdCBiZSByZW5kZXJlZCBieSB0aGUgY29tcG9uZW50IGl0c2VsZiwgYW5kIGlkZWFsbHkgc2hvdWxkIGJlIG91dHNpZGUgb2YgdGhlIGVudGlyZSBWdWUgY29tcG9uZW50IHRyZWUuYFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgIXRhcmdldFNlbGVjdG9yICYmICFpc1RlbGVwb3J0RGlzYWJsZWQocHJvcHMpKSB7XG4gICAgICB3YXJuKGBJbnZhbGlkIFRlbGVwb3J0IHRhcmdldDogJHt0YXJnZXRTZWxlY3Rvcn1gKTtcbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldFNlbGVjdG9yO1xuICB9XG59O1xuY29uc3QgVGVsZXBvcnRJbXBsID0ge1xuICBfX2lzVGVsZXBvcnQ6IHRydWUsXG4gIHByb2Nlc3MobjEsIG4yLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkLCBpbnRlcm5hbHMpIHtcbiAgICBjb25zdCB7XG4gICAgICBtYzogbW91bnRDaGlsZHJlbixcbiAgICAgIHBjOiBwYXRjaENoaWxkcmVuLFxuICAgICAgcGJjOiBwYXRjaEJsb2NrQ2hpbGRyZW4sXG4gICAgICBvOiB7IGluc2VydCwgcXVlcnlTZWxlY3RvciwgY3JlYXRlVGV4dCwgY3JlYXRlQ29tbWVudCB9XG4gICAgfSA9IGludGVybmFscztcbiAgICBjb25zdCBkaXNhYmxlZCA9IGlzVGVsZXBvcnREaXNhYmxlZChuMi5wcm9wcyk7XG4gICAgbGV0IHsgc2hhcGVGbGFnLCBjaGlsZHJlbiwgZHluYW1pY0NoaWxkcmVuIH0gPSBuMjtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBpc0htclVwZGF0aW5nKSB7XG4gICAgICBvcHRpbWl6ZWQgPSBmYWxzZTtcbiAgICAgIGR5bmFtaWNDaGlsZHJlbiA9IG51bGw7XG4gICAgfVxuICAgIGlmIChuMSA9PSBudWxsKSB7XG4gICAgICBjb25zdCBwbGFjZWhvbGRlciA9IG4yLmVsID0gISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IGNyZWF0ZUNvbW1lbnQoXCJ0ZWxlcG9ydCBzdGFydFwiKSA6IGNyZWF0ZVRleHQoXCJcIik7XG4gICAgICBjb25zdCBtYWluQW5jaG9yID0gbjIuYW5jaG9yID0gISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IGNyZWF0ZUNvbW1lbnQoXCJ0ZWxlcG9ydCBlbmRcIikgOiBjcmVhdGVUZXh0KFwiXCIpO1xuICAgICAgaW5zZXJ0KHBsYWNlaG9sZGVyLCBjb250YWluZXIsIGFuY2hvcik7XG4gICAgICBpbnNlcnQobWFpbkFuY2hvciwgY29udGFpbmVyLCBhbmNob3IpO1xuICAgICAgY29uc3QgdGFyZ2V0ID0gbjIudGFyZ2V0ID0gcmVzb2x2ZVRhcmdldChuMi5wcm9wcywgcXVlcnlTZWxlY3Rvcik7XG4gICAgICBjb25zdCB0YXJnZXRBbmNob3IgPSBuMi50YXJnZXRBbmNob3IgPSBjcmVhdGVUZXh0KFwiXCIpO1xuICAgICAgaWYgKHRhcmdldCkge1xuICAgICAgICBpbnNlcnQodGFyZ2V0QW5jaG9yLCB0YXJnZXQpO1xuICAgICAgICBpc1NWRyA9IGlzU1ZHIHx8IGlzVGFyZ2V0U1ZHKHRhcmdldCk7XG4gICAgICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgIWRpc2FibGVkKSB7XG4gICAgICAgIHdhcm4oXCJJbnZhbGlkIFRlbGVwb3J0IHRhcmdldCBvbiBtb3VudDpcIiwgdGFyZ2V0LCBgKCR7dHlwZW9mIHRhcmdldH0pYCk7XG4gICAgICB9XG4gICAgICBjb25zdCBtb3VudCA9IChjb250YWluZXIyLCBhbmNob3IyKSA9PiB7XG4gICAgICAgIGlmIChzaGFwZUZsYWcgJiAxNikge1xuICAgICAgICAgIG1vdW50Q2hpbGRyZW4oXG4gICAgICAgICAgICBjaGlsZHJlbixcbiAgICAgICAgICAgIGNvbnRhaW5lcjIsXG4gICAgICAgICAgICBhbmNob3IyLFxuICAgICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgICBpc1NWRyxcbiAgICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICAgIG9wdGltaXplZFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBpZiAoZGlzYWJsZWQpIHtcbiAgICAgICAgbW91bnQoY29udGFpbmVyLCBtYWluQW5jaG9yKTtcbiAgICAgIH0gZWxzZSBpZiAodGFyZ2V0KSB7XG4gICAgICAgIG1vdW50KHRhcmdldCwgdGFyZ2V0QW5jaG9yKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbjIuZWwgPSBuMS5lbDtcbiAgICAgIGNvbnN0IG1haW5BbmNob3IgPSBuMi5hbmNob3IgPSBuMS5hbmNob3I7XG4gICAgICBjb25zdCB0YXJnZXQgPSBuMi50YXJnZXQgPSBuMS50YXJnZXQ7XG4gICAgICBjb25zdCB0YXJnZXRBbmNob3IgPSBuMi50YXJnZXRBbmNob3IgPSBuMS50YXJnZXRBbmNob3I7XG4gICAgICBjb25zdCB3YXNEaXNhYmxlZCA9IGlzVGVsZXBvcnREaXNhYmxlZChuMS5wcm9wcyk7XG4gICAgICBjb25zdCBjdXJyZW50Q29udGFpbmVyID0gd2FzRGlzYWJsZWQgPyBjb250YWluZXIgOiB0YXJnZXQ7XG4gICAgICBjb25zdCBjdXJyZW50QW5jaG9yID0gd2FzRGlzYWJsZWQgPyBtYWluQW5jaG9yIDogdGFyZ2V0QW5jaG9yO1xuICAgICAgaXNTVkcgPSBpc1NWRyB8fCBpc1RhcmdldFNWRyh0YXJnZXQpO1xuICAgICAgaWYgKGR5bmFtaWNDaGlsZHJlbikge1xuICAgICAgICBwYXRjaEJsb2NrQ2hpbGRyZW4oXG4gICAgICAgICAgbjEuZHluYW1pY0NoaWxkcmVuLFxuICAgICAgICAgIGR5bmFtaWNDaGlsZHJlbixcbiAgICAgICAgICBjdXJyZW50Q29udGFpbmVyLFxuICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICBpc1NWRyxcbiAgICAgICAgICBzbG90U2NvcGVJZHNcbiAgICAgICAgKTtcbiAgICAgICAgdHJhdmVyc2VTdGF0aWNDaGlsZHJlbihuMSwgbjIsIHRydWUpO1xuICAgICAgfSBlbHNlIGlmICghb3B0aW1pemVkKSB7XG4gICAgICAgIHBhdGNoQ2hpbGRyZW4oXG4gICAgICAgICAgbjEsXG4gICAgICAgICAgbjIsXG4gICAgICAgICAgY3VycmVudENvbnRhaW5lcixcbiAgICAgICAgICBjdXJyZW50QW5jaG9yLFxuICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICBpc1NWRyxcbiAgICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgICAgZmFsc2VcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChkaXNhYmxlZCkge1xuICAgICAgICBpZiAoIXdhc0Rpc2FibGVkKSB7XG4gICAgICAgICAgbW92ZVRlbGVwb3J0KFxuICAgICAgICAgICAgbjIsXG4gICAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgICBtYWluQW5jaG9yLFxuICAgICAgICAgICAgaW50ZXJuYWxzLFxuICAgICAgICAgICAgMVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICgobjIucHJvcHMgJiYgbjIucHJvcHMudG8pICE9PSAobjEucHJvcHMgJiYgbjEucHJvcHMudG8pKSB7XG4gICAgICAgICAgY29uc3QgbmV4dFRhcmdldCA9IG4yLnRhcmdldCA9IHJlc29sdmVUYXJnZXQoXG4gICAgICAgICAgICBuMi5wcm9wcyxcbiAgICAgICAgICAgIHF1ZXJ5U2VsZWN0b3JcbiAgICAgICAgICApO1xuICAgICAgICAgIGlmIChuZXh0VGFyZ2V0KSB7XG4gICAgICAgICAgICBtb3ZlVGVsZXBvcnQoXG4gICAgICAgICAgICAgIG4yLFxuICAgICAgICAgICAgICBuZXh0VGFyZ2V0LFxuICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICBpbnRlcm5hbHMsXG4gICAgICAgICAgICAgIDBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgICBcIkludmFsaWQgVGVsZXBvcnQgdGFyZ2V0IG9uIHVwZGF0ZTpcIixcbiAgICAgICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgICAgICBgKCR7dHlwZW9mIHRhcmdldH0pYFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAod2FzRGlzYWJsZWQpIHtcbiAgICAgICAgICBtb3ZlVGVsZXBvcnQoXG4gICAgICAgICAgICBuMixcbiAgICAgICAgICAgIHRhcmdldCxcbiAgICAgICAgICAgIHRhcmdldEFuY2hvcixcbiAgICAgICAgICAgIGludGVybmFscyxcbiAgICAgICAgICAgIDFcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZUNzc1ZhcnMobjIpO1xuICB9LFxuICByZW1vdmUodm5vZGUsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIG9wdGltaXplZCwgeyB1bTogdW5tb3VudCwgbzogeyByZW1vdmU6IGhvc3RSZW1vdmUgfSB9LCBkb1JlbW92ZSkge1xuICAgIGNvbnN0IHsgc2hhcGVGbGFnLCBjaGlsZHJlbiwgYW5jaG9yLCB0YXJnZXRBbmNob3IsIHRhcmdldCwgcHJvcHMgfSA9IHZub2RlO1xuICAgIGlmICh0YXJnZXQpIHtcbiAgICAgIGhvc3RSZW1vdmUodGFyZ2V0QW5jaG9yKTtcbiAgICB9XG4gICAgaWYgKGRvUmVtb3ZlIHx8ICFpc1RlbGVwb3J0RGlzYWJsZWQocHJvcHMpKSB7XG4gICAgICBob3N0UmVtb3ZlKGFuY2hvcik7XG4gICAgICBpZiAoc2hhcGVGbGFnICYgMTYpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvbnN0IGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICAgICAgdW5tb3VudChcbiAgICAgICAgICAgIGNoaWxkLFxuICAgICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgICB0cnVlLFxuICAgICAgICAgICAgISFjaGlsZC5keW5hbWljQ2hpbGRyZW5cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBtb3ZlOiBtb3ZlVGVsZXBvcnQsXG4gIGh5ZHJhdGU6IGh5ZHJhdGVUZWxlcG9ydFxufTtcbmZ1bmN0aW9uIG1vdmVUZWxlcG9ydCh2bm9kZSwgY29udGFpbmVyLCBwYXJlbnRBbmNob3IsIHsgbzogeyBpbnNlcnQgfSwgbTogbW92ZSB9LCBtb3ZlVHlwZSA9IDIpIHtcbiAgaWYgKG1vdmVUeXBlID09PSAwKSB7XG4gICAgaW5zZXJ0KHZub2RlLnRhcmdldEFuY2hvciwgY29udGFpbmVyLCBwYXJlbnRBbmNob3IpO1xuICB9XG4gIGNvbnN0IHsgZWwsIGFuY2hvciwgc2hhcGVGbGFnLCBjaGlsZHJlbiwgcHJvcHMgfSA9IHZub2RlO1xuICBjb25zdCBpc1Jlb3JkZXIgPSBtb3ZlVHlwZSA9PT0gMjtcbiAgaWYgKGlzUmVvcmRlcikge1xuICAgIGluc2VydChlbCwgY29udGFpbmVyLCBwYXJlbnRBbmNob3IpO1xuICB9XG4gIGlmICghaXNSZW9yZGVyIHx8IGlzVGVsZXBvcnREaXNhYmxlZChwcm9wcykpIHtcbiAgICBpZiAoc2hhcGVGbGFnICYgMTYpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbW92ZShcbiAgICAgICAgICBjaGlsZHJlbltpXSxcbiAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgcGFyZW50QW5jaG9yLFxuICAgICAgICAgIDJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKGlzUmVvcmRlcikge1xuICAgIGluc2VydChhbmNob3IsIGNvbnRhaW5lciwgcGFyZW50QW5jaG9yKTtcbiAgfVxufVxuZnVuY3Rpb24gaHlkcmF0ZVRlbGVwb3J0KG5vZGUsIHZub2RlLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCwge1xuICBvOiB7IG5leHRTaWJsaW5nLCBwYXJlbnROb2RlLCBxdWVyeVNlbGVjdG9yIH1cbn0sIGh5ZHJhdGVDaGlsZHJlbikge1xuICBjb25zdCB0YXJnZXQgPSB2bm9kZS50YXJnZXQgPSByZXNvbHZlVGFyZ2V0KFxuICAgIHZub2RlLnByb3BzLFxuICAgIHF1ZXJ5U2VsZWN0b3JcbiAgKTtcbiAgaWYgKHRhcmdldCkge1xuICAgIGNvbnN0IHRhcmdldE5vZGUgPSB0YXJnZXQuX2xwYSB8fCB0YXJnZXQuZmlyc3RDaGlsZDtcbiAgICBpZiAodm5vZGUuc2hhcGVGbGFnICYgMTYpIHtcbiAgICAgIGlmIChpc1RlbGVwb3J0RGlzYWJsZWQodm5vZGUucHJvcHMpKSB7XG4gICAgICAgIHZub2RlLmFuY2hvciA9IGh5ZHJhdGVDaGlsZHJlbihcbiAgICAgICAgICBuZXh0U2libGluZyhub2RlKSxcbiAgICAgICAgICB2bm9kZSxcbiAgICAgICAgICBwYXJlbnROb2RlKG5vZGUpLFxuICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgICAgb3B0aW1pemVkXG4gICAgICAgICk7XG4gICAgICAgIHZub2RlLnRhcmdldEFuY2hvciA9IHRhcmdldE5vZGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2bm9kZS5hbmNob3IgPSBuZXh0U2libGluZyhub2RlKTtcbiAgICAgICAgbGV0IHRhcmdldEFuY2hvciA9IHRhcmdldE5vZGU7XG4gICAgICAgIHdoaWxlICh0YXJnZXRBbmNob3IpIHtcbiAgICAgICAgICB0YXJnZXRBbmNob3IgPSBuZXh0U2libGluZyh0YXJnZXRBbmNob3IpO1xuICAgICAgICAgIGlmICh0YXJnZXRBbmNob3IgJiYgdGFyZ2V0QW5jaG9yLm5vZGVUeXBlID09PSA4ICYmIHRhcmdldEFuY2hvci5kYXRhID09PSBcInRlbGVwb3J0IGFuY2hvclwiKSB7XG4gICAgICAgICAgICB2bm9kZS50YXJnZXRBbmNob3IgPSB0YXJnZXRBbmNob3I7XG4gICAgICAgICAgICB0YXJnZXQuX2xwYSA9IHZub2RlLnRhcmdldEFuY2hvciAmJiBuZXh0U2libGluZyh2bm9kZS50YXJnZXRBbmNob3IpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGh5ZHJhdGVDaGlsZHJlbihcbiAgICAgICAgICB0YXJnZXROb2RlLFxuICAgICAgICAgIHZub2RlLFxuICAgICAgICAgIHRhcmdldCxcbiAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgIG9wdGltaXplZFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICB1cGRhdGVDc3NWYXJzKHZub2RlKTtcbiAgfVxuICByZXR1cm4gdm5vZGUuYW5jaG9yICYmIG5leHRTaWJsaW5nKHZub2RlLmFuY2hvcik7XG59XG5jb25zdCBUZWxlcG9ydCA9IFRlbGVwb3J0SW1wbDtcbmZ1bmN0aW9uIHVwZGF0ZUNzc1ZhcnModm5vZGUpIHtcbiAgY29uc3QgY3R4ID0gdm5vZGUuY3R4O1xuICBpZiAoY3R4ICYmIGN0eC51dCkge1xuICAgIGxldCBub2RlID0gdm5vZGUuY2hpbGRyZW5bMF0uZWw7XG4gICAgd2hpbGUgKG5vZGUgIT09IHZub2RlLnRhcmdldEFuY2hvcikge1xuICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IDEpXG4gICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKFwiZGF0YS12LW93bmVyXCIsIGN0eC51aWQpO1xuICAgICAgbm9kZSA9IG5vZGUubmV4dFNpYmxpbmc7XG4gICAgfVxuICAgIGN0eC51dCgpO1xuICB9XG59XG5cbmNvbnN0IEZyYWdtZW50ID0gU3ltYm9sLmZvcihcInYtZmd0XCIpO1xuY29uc3QgVGV4dCA9IFN5bWJvbC5mb3IoXCJ2LXR4dFwiKTtcbmNvbnN0IENvbW1lbnQgPSBTeW1ib2wuZm9yKFwidi1jbXRcIik7XG5jb25zdCBTdGF0aWMgPSBTeW1ib2wuZm9yKFwidi1zdGNcIik7XG5jb25zdCBibG9ja1N0YWNrID0gW107XG5sZXQgY3VycmVudEJsb2NrID0gbnVsbDtcbmZ1bmN0aW9uIG9wZW5CbG9jayhkaXNhYmxlVHJhY2tpbmcgPSBmYWxzZSkge1xuICBibG9ja1N0YWNrLnB1c2goY3VycmVudEJsb2NrID0gZGlzYWJsZVRyYWNraW5nID8gbnVsbCA6IFtdKTtcbn1cbmZ1bmN0aW9uIGNsb3NlQmxvY2soKSB7XG4gIGJsb2NrU3RhY2sucG9wKCk7XG4gIGN1cnJlbnRCbG9jayA9IGJsb2NrU3RhY2tbYmxvY2tTdGFjay5sZW5ndGggLSAxXSB8fCBudWxsO1xufVxubGV0IGlzQmxvY2tUcmVlRW5hYmxlZCA9IDE7XG5mdW5jdGlvbiBzZXRCbG9ja1RyYWNraW5nKHZhbHVlKSB7XG4gIGlzQmxvY2tUcmVlRW5hYmxlZCArPSB2YWx1ZTtcbn1cbmZ1bmN0aW9uIHNldHVwQmxvY2sodm5vZGUpIHtcbiAgdm5vZGUuZHluYW1pY0NoaWxkcmVuID0gaXNCbG9ja1RyZWVFbmFibGVkID4gMCA/IGN1cnJlbnRCbG9jayB8fCBFTVBUWV9BUlIgOiBudWxsO1xuICBjbG9zZUJsb2NrKCk7XG4gIGlmIChpc0Jsb2NrVHJlZUVuYWJsZWQgPiAwICYmIGN1cnJlbnRCbG9jaykge1xuICAgIGN1cnJlbnRCbG9jay5wdXNoKHZub2RlKTtcbiAgfVxuICByZXR1cm4gdm5vZGU7XG59XG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50QmxvY2sodHlwZSwgcHJvcHMsIGNoaWxkcmVuLCBwYXRjaEZsYWcsIGR5bmFtaWNQcm9wcywgc2hhcGVGbGFnKSB7XG4gIHJldHVybiBzZXR1cEJsb2NrKFxuICAgIGNyZWF0ZUJhc2VWTm9kZShcbiAgICAgIHR5cGUsXG4gICAgICBwcm9wcyxcbiAgICAgIGNoaWxkcmVuLFxuICAgICAgcGF0Y2hGbGFnLFxuICAgICAgZHluYW1pY1Byb3BzLFxuICAgICAgc2hhcGVGbGFnLFxuICAgICAgdHJ1ZVxuICAgICAgLyogaXNCbG9jayAqL1xuICAgIClcbiAgKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUJsb2NrKHR5cGUsIHByb3BzLCBjaGlsZHJlbiwgcGF0Y2hGbGFnLCBkeW5hbWljUHJvcHMpIHtcbiAgcmV0dXJuIHNldHVwQmxvY2soXG4gICAgY3JlYXRlVk5vZGUoXG4gICAgICB0eXBlLFxuICAgICAgcHJvcHMsXG4gICAgICBjaGlsZHJlbixcbiAgICAgIHBhdGNoRmxhZyxcbiAgICAgIGR5bmFtaWNQcm9wcyxcbiAgICAgIHRydWVcbiAgICAgIC8qIGlzQmxvY2s6IHByZXZlbnQgYSBibG9jayBmcm9tIHRyYWNraW5nIGl0c2VsZiAqL1xuICAgIClcbiAgKTtcbn1cbmZ1bmN0aW9uIGlzVk5vZGUodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID8gdmFsdWUuX192X2lzVk5vZGUgPT09IHRydWUgOiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGlzU2FtZVZOb2RlVHlwZShuMSwgbjIpIHtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgbjIuc2hhcGVGbGFnICYgNiAmJiBobXJEaXJ0eUNvbXBvbmVudHMuaGFzKG4yLnR5cGUpKSB7XG4gICAgbjEuc2hhcGVGbGFnICY9IH4yNTY7XG4gICAgbjIuc2hhcGVGbGFnICY9IH41MTI7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBuMS50eXBlID09PSBuMi50eXBlICYmIG4xLmtleSA9PT0gbjIua2V5O1xufVxubGV0IHZub2RlQXJnc1RyYW5zZm9ybWVyO1xuZnVuY3Rpb24gdHJhbnNmb3JtVk5vZGVBcmdzKHRyYW5zZm9ybWVyKSB7XG4gIHZub2RlQXJnc1RyYW5zZm9ybWVyID0gdHJhbnNmb3JtZXI7XG59XG5jb25zdCBjcmVhdGVWTm9kZVdpdGhBcmdzVHJhbnNmb3JtID0gKC4uLmFyZ3MpID0+IHtcbiAgcmV0dXJuIF9jcmVhdGVWTm9kZShcbiAgICAuLi52bm9kZUFyZ3NUcmFuc2Zvcm1lciA/IHZub2RlQXJnc1RyYW5zZm9ybWVyKGFyZ3MsIGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSkgOiBhcmdzXG4gICk7XG59O1xuY29uc3QgSW50ZXJuYWxPYmplY3RLZXkgPSBgX192SW50ZXJuYWxgO1xuY29uc3Qgbm9ybWFsaXplS2V5ID0gKHsga2V5IH0pID0+IGtleSAhPSBudWxsID8ga2V5IDogbnVsbDtcbmNvbnN0IG5vcm1hbGl6ZVJlZiA9ICh7XG4gIHJlZixcbiAgcmVmX2tleSxcbiAgcmVmX2ZvclxufSkgPT4ge1xuICBpZiAodHlwZW9mIHJlZiA9PT0gXCJudW1iZXJcIikge1xuICAgIHJlZiA9IFwiXCIgKyByZWY7XG4gIH1cbiAgcmV0dXJuIHJlZiAhPSBudWxsID8gaXNTdHJpbmcocmVmKSB8fCBpc1JlZihyZWYpIHx8IGlzRnVuY3Rpb24ocmVmKSA/IHsgaTogY3VycmVudFJlbmRlcmluZ0luc3RhbmNlLCByOiByZWYsIGs6IHJlZl9rZXksIGY6ICEhcmVmX2ZvciB9IDogcmVmIDogbnVsbDtcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlVk5vZGUodHlwZSwgcHJvcHMgPSBudWxsLCBjaGlsZHJlbiA9IG51bGwsIHBhdGNoRmxhZyA9IDAsIGR5bmFtaWNQcm9wcyA9IG51bGwsIHNoYXBlRmxhZyA9IHR5cGUgPT09IEZyYWdtZW50ID8gMCA6IDEsIGlzQmxvY2tOb2RlID0gZmFsc2UsIG5lZWRGdWxsQ2hpbGRyZW5Ob3JtYWxpemF0aW9uID0gZmFsc2UpIHtcbiAgY29uc3Qgdm5vZGUgPSB7XG4gICAgX192X2lzVk5vZGU6IHRydWUsXG4gICAgX192X3NraXA6IHRydWUsXG4gICAgdHlwZSxcbiAgICBwcm9wcyxcbiAgICBrZXk6IHByb3BzICYmIG5vcm1hbGl6ZUtleShwcm9wcyksXG4gICAgcmVmOiBwcm9wcyAmJiBub3JtYWxpemVSZWYocHJvcHMpLFxuICAgIHNjb3BlSWQ6IGN1cnJlbnRTY29wZUlkLFxuICAgIHNsb3RTY29wZUlkczogbnVsbCxcbiAgICBjaGlsZHJlbixcbiAgICBjb21wb25lbnQ6IG51bGwsXG4gICAgc3VzcGVuc2U6IG51bGwsXG4gICAgc3NDb250ZW50OiBudWxsLFxuICAgIHNzRmFsbGJhY2s6IG51bGwsXG4gICAgZGlyczogbnVsbCxcbiAgICB0cmFuc2l0aW9uOiBudWxsLFxuICAgIGVsOiBudWxsLFxuICAgIGFuY2hvcjogbnVsbCxcbiAgICB0YXJnZXQ6IG51bGwsXG4gICAgdGFyZ2V0QW5jaG9yOiBudWxsLFxuICAgIHN0YXRpY0NvdW50OiAwLFxuICAgIHNoYXBlRmxhZyxcbiAgICBwYXRjaEZsYWcsXG4gICAgZHluYW1pY1Byb3BzLFxuICAgIGR5bmFtaWNDaGlsZHJlbjogbnVsbCxcbiAgICBhcHBDb250ZXh0OiBudWxsLFxuICAgIGN0eDogY3VycmVudFJlbmRlcmluZ0luc3RhbmNlXG4gIH07XG4gIGlmIChuZWVkRnVsbENoaWxkcmVuTm9ybWFsaXphdGlvbikge1xuICAgIG5vcm1hbGl6ZUNoaWxkcmVuKHZub2RlLCBjaGlsZHJlbik7XG4gICAgaWYgKHNoYXBlRmxhZyAmIDEyOCkge1xuICAgICAgdHlwZS5ub3JtYWxpemUodm5vZGUpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChjaGlsZHJlbikge1xuICAgIHZub2RlLnNoYXBlRmxhZyB8PSBpc1N0cmluZyhjaGlsZHJlbikgPyA4IDogMTY7XG4gIH1cbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgdm5vZGUua2V5ICE9PSB2bm9kZS5rZXkpIHtcbiAgICB3YXJuKGBWTm9kZSBjcmVhdGVkIHdpdGggaW52YWxpZCBrZXkgKE5hTikuIFZOb2RlIHR5cGU6YCwgdm5vZGUudHlwZSk7XG4gIH1cbiAgaWYgKGlzQmxvY2tUcmVlRW5hYmxlZCA+IDAgJiYgLy8gYXZvaWQgYSBibG9jayBub2RlIGZyb20gdHJhY2tpbmcgaXRzZWxmXG4gICFpc0Jsb2NrTm9kZSAmJiAvLyBoYXMgY3VycmVudCBwYXJlbnQgYmxvY2tcbiAgY3VycmVudEJsb2NrICYmIC8vIHByZXNlbmNlIG9mIGEgcGF0Y2ggZmxhZyBpbmRpY2F0ZXMgdGhpcyBub2RlIG5lZWRzIHBhdGNoaW5nIG9uIHVwZGF0ZXMuXG4gIC8vIGNvbXBvbmVudCBub2RlcyBhbHNvIHNob3VsZCBhbHdheXMgYmUgcGF0Y2hlZCwgYmVjYXVzZSBldmVuIGlmIHRoZVxuICAvLyBjb21wb25lbnQgZG9lc24ndCBuZWVkIHRvIHVwZGF0ZSwgaXQgbmVlZHMgdG8gcGVyc2lzdCB0aGUgaW5zdGFuY2Ugb24gdG9cbiAgLy8gdGhlIG5leHQgdm5vZGUgc28gdGhhdCBpdCBjYW4gYmUgcHJvcGVybHkgdW5tb3VudGVkIGxhdGVyLlxuICAodm5vZGUucGF0Y2hGbGFnID4gMCB8fCBzaGFwZUZsYWcgJiA2KSAmJiAvLyB0aGUgRVZFTlRTIGZsYWcgaXMgb25seSBmb3IgaHlkcmF0aW9uIGFuZCBpZiBpdCBpcyB0aGUgb25seSBmbGFnLCB0aGVcbiAgLy8gdm5vZGUgc2hvdWxkIG5vdCBiZSBjb25zaWRlcmVkIGR5bmFtaWMgZHVlIHRvIGhhbmRsZXIgY2FjaGluZy5cbiAgdm5vZGUucGF0Y2hGbGFnICE9PSAzMikge1xuICAgIGN1cnJlbnRCbG9jay5wdXNoKHZub2RlKTtcbiAgfVxuICByZXR1cm4gdm5vZGU7XG59XG5jb25zdCBjcmVhdGVWTm9kZSA9ICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyBjcmVhdGVWTm9kZVdpdGhBcmdzVHJhbnNmb3JtIDogX2NyZWF0ZVZOb2RlO1xuZnVuY3Rpb24gX2NyZWF0ZVZOb2RlKHR5cGUsIHByb3BzID0gbnVsbCwgY2hpbGRyZW4gPSBudWxsLCBwYXRjaEZsYWcgPSAwLCBkeW5hbWljUHJvcHMgPSBudWxsLCBpc0Jsb2NrTm9kZSA9IGZhbHNlKSB7XG4gIGlmICghdHlwZSB8fCB0eXBlID09PSBOVUxMX0RZTkFNSUNfQ09NUE9ORU5UKSB7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgIXR5cGUpIHtcbiAgICAgIHdhcm4oYEludmFsaWQgdm5vZGUgdHlwZSB3aGVuIGNyZWF0aW5nIHZub2RlOiAke3R5cGV9LmApO1xuICAgIH1cbiAgICB0eXBlID0gQ29tbWVudDtcbiAgfVxuICBpZiAoaXNWTm9kZSh0eXBlKSkge1xuICAgIGNvbnN0IGNsb25lZCA9IGNsb25lVk5vZGUoXG4gICAgICB0eXBlLFxuICAgICAgcHJvcHMsXG4gICAgICB0cnVlXG4gICAgICAvKiBtZXJnZVJlZjogdHJ1ZSAqL1xuICAgICk7XG4gICAgaWYgKGNoaWxkcmVuKSB7XG4gICAgICBub3JtYWxpemVDaGlsZHJlbihjbG9uZWQsIGNoaWxkcmVuKTtcbiAgICB9XG4gICAgaWYgKGlzQmxvY2tUcmVlRW5hYmxlZCA+IDAgJiYgIWlzQmxvY2tOb2RlICYmIGN1cnJlbnRCbG9jaykge1xuICAgICAgaWYgKGNsb25lZC5zaGFwZUZsYWcgJiA2KSB7XG4gICAgICAgIGN1cnJlbnRCbG9ja1tjdXJyZW50QmxvY2suaW5kZXhPZih0eXBlKV0gPSBjbG9uZWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdXJyZW50QmxvY2sucHVzaChjbG9uZWQpO1xuICAgICAgfVxuICAgIH1cbiAgICBjbG9uZWQucGF0Y2hGbGFnIHw9IC0yO1xuICAgIHJldHVybiBjbG9uZWQ7XG4gIH1cbiAgaWYgKGlzQ2xhc3NDb21wb25lbnQodHlwZSkpIHtcbiAgICB0eXBlID0gdHlwZS5fX3ZjY09wdHM7XG4gIH1cbiAgaWYgKHByb3BzKSB7XG4gICAgcHJvcHMgPSBndWFyZFJlYWN0aXZlUHJvcHMocHJvcHMpO1xuICAgIGxldCB7IGNsYXNzOiBrbGFzcywgc3R5bGUgfSA9IHByb3BzO1xuICAgIGlmIChrbGFzcyAmJiAhaXNTdHJpbmcoa2xhc3MpKSB7XG4gICAgICBwcm9wcy5jbGFzcyA9IG5vcm1hbGl6ZUNsYXNzKGtsYXNzKTtcbiAgICB9XG4gICAgaWYgKGlzT2JqZWN0KHN0eWxlKSkge1xuICAgICAgaWYgKGlzUHJveHkoc3R5bGUpICYmICFpc0FycmF5KHN0eWxlKSkge1xuICAgICAgICBzdHlsZSA9IGV4dGVuZCh7fSwgc3R5bGUpO1xuICAgICAgfVxuICAgICAgcHJvcHMuc3R5bGUgPSBub3JtYWxpemVTdHlsZShzdHlsZSk7XG4gICAgfVxuICB9XG4gIGNvbnN0IHNoYXBlRmxhZyA9IGlzU3RyaW5nKHR5cGUpID8gMSA6IGlzU3VzcGVuc2UodHlwZSkgPyAxMjggOiBpc1RlbGVwb3J0KHR5cGUpID8gNjQgOiBpc09iamVjdCh0eXBlKSA/IDQgOiBpc0Z1bmN0aW9uKHR5cGUpID8gMiA6IDA7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHNoYXBlRmxhZyAmIDQgJiYgaXNQcm94eSh0eXBlKSkge1xuICAgIHR5cGUgPSB0b1Jhdyh0eXBlKTtcbiAgICB3YXJuKFxuICAgICAgYFZ1ZSByZWNlaXZlZCBhIENvbXBvbmVudCB3aGljaCB3YXMgbWFkZSBhIHJlYWN0aXZlIG9iamVjdC4gVGhpcyBjYW4gbGVhZCB0byB1bm5lY2Vzc2FyeSBwZXJmb3JtYW5jZSBvdmVyaGVhZCwgYW5kIHNob3VsZCBiZSBhdm9pZGVkIGJ5IG1hcmtpbmcgdGhlIGNvbXBvbmVudCB3aXRoIFxcYG1hcmtSYXdcXGAgb3IgdXNpbmcgXFxgc2hhbGxvd1JlZlxcYCBpbnN0ZWFkIG9mIFxcYHJlZlxcYC5gLFxuICAgICAgYFxuQ29tcG9uZW50IHRoYXQgd2FzIG1hZGUgcmVhY3RpdmU6IGAsXG4gICAgICB0eXBlXG4gICAgKTtcbiAgfVxuICByZXR1cm4gY3JlYXRlQmFzZVZOb2RlKFxuICAgIHR5cGUsXG4gICAgcHJvcHMsXG4gICAgY2hpbGRyZW4sXG4gICAgcGF0Y2hGbGFnLFxuICAgIGR5bmFtaWNQcm9wcyxcbiAgICBzaGFwZUZsYWcsXG4gICAgaXNCbG9ja05vZGUsXG4gICAgdHJ1ZVxuICApO1xufVxuZnVuY3Rpb24gZ3VhcmRSZWFjdGl2ZVByb3BzKHByb3BzKSB7XG4gIGlmICghcHJvcHMpXG4gICAgcmV0dXJuIG51bGw7XG4gIHJldHVybiBpc1Byb3h5KHByb3BzKSB8fCBJbnRlcm5hbE9iamVjdEtleSBpbiBwcm9wcyA/IGV4dGVuZCh7fSwgcHJvcHMpIDogcHJvcHM7XG59XG5mdW5jdGlvbiBjbG9uZVZOb2RlKHZub2RlLCBleHRyYVByb3BzLCBtZXJnZVJlZiA9IGZhbHNlKSB7XG4gIGNvbnN0IHsgcHJvcHMsIHJlZiwgcGF0Y2hGbGFnLCBjaGlsZHJlbiB9ID0gdm5vZGU7XG4gIGNvbnN0IG1lcmdlZFByb3BzID0gZXh0cmFQcm9wcyA/IG1lcmdlUHJvcHMocHJvcHMgfHwge30sIGV4dHJhUHJvcHMpIDogcHJvcHM7XG4gIGNvbnN0IGNsb25lZCA9IHtcbiAgICBfX3ZfaXNWTm9kZTogdHJ1ZSxcbiAgICBfX3Zfc2tpcDogdHJ1ZSxcbiAgICB0eXBlOiB2bm9kZS50eXBlLFxuICAgIHByb3BzOiBtZXJnZWRQcm9wcyxcbiAgICBrZXk6IG1lcmdlZFByb3BzICYmIG5vcm1hbGl6ZUtleShtZXJnZWRQcm9wcyksXG4gICAgcmVmOiBleHRyYVByb3BzICYmIGV4dHJhUHJvcHMucmVmID8gKFxuICAgICAgLy8gIzIwNzggaW4gdGhlIGNhc2Ugb2YgPGNvbXBvbmVudCA6aXM9XCJ2bm9kZVwiIHJlZj1cImV4dHJhXCIvPlxuICAgICAgLy8gaWYgdGhlIHZub2RlIGl0c2VsZiBhbHJlYWR5IGhhcyBhIHJlZiwgY2xvbmVWTm9kZSB3aWxsIG5lZWQgdG8gbWVyZ2VcbiAgICAgIC8vIHRoZSByZWZzIHNvIHRoZSBzaW5nbGUgdm5vZGUgY2FuIGJlIHNldCBvbiBtdWx0aXBsZSByZWZzXG4gICAgICBtZXJnZVJlZiAmJiByZWYgPyBpc0FycmF5KHJlZikgPyByZWYuY29uY2F0KG5vcm1hbGl6ZVJlZihleHRyYVByb3BzKSkgOiBbcmVmLCBub3JtYWxpemVSZWYoZXh0cmFQcm9wcyldIDogbm9ybWFsaXplUmVmKGV4dHJhUHJvcHMpXG4gICAgKSA6IHJlZixcbiAgICBzY29wZUlkOiB2bm9kZS5zY29wZUlkLFxuICAgIHNsb3RTY29wZUlkczogdm5vZGUuc2xvdFNjb3BlSWRzLFxuICAgIGNoaWxkcmVuOiAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHBhdGNoRmxhZyA9PT0gLTEgJiYgaXNBcnJheShjaGlsZHJlbikgPyBjaGlsZHJlbi5tYXAoZGVlcENsb25lVk5vZGUpIDogY2hpbGRyZW4sXG4gICAgdGFyZ2V0OiB2bm9kZS50YXJnZXQsXG4gICAgdGFyZ2V0QW5jaG9yOiB2bm9kZS50YXJnZXRBbmNob3IsXG4gICAgc3RhdGljQ291bnQ6IHZub2RlLnN0YXRpY0NvdW50LFxuICAgIHNoYXBlRmxhZzogdm5vZGUuc2hhcGVGbGFnLFxuICAgIC8vIGlmIHRoZSB2bm9kZSBpcyBjbG9uZWQgd2l0aCBleHRyYSBwcm9wcywgd2UgY2FuIG5vIGxvbmdlciBhc3N1bWUgaXRzXG4gICAgLy8gZXhpc3RpbmcgcGF0Y2ggZmxhZyB0byBiZSByZWxpYWJsZSBhbmQgbmVlZCB0byBhZGQgdGhlIEZVTExfUFJPUFMgZmxhZy5cbiAgICAvLyBub3RlOiBwcmVzZXJ2ZSBmbGFnIGZvciBmcmFnbWVudHMgc2luY2UgdGhleSB1c2UgdGhlIGZsYWcgZm9yIGNoaWxkcmVuXG4gICAgLy8gZmFzdCBwYXRocyBvbmx5LlxuICAgIHBhdGNoRmxhZzogZXh0cmFQcm9wcyAmJiB2bm9kZS50eXBlICE9PSBGcmFnbWVudCA/IHBhdGNoRmxhZyA9PT0gLTEgPyAxNiA6IHBhdGNoRmxhZyB8IDE2IDogcGF0Y2hGbGFnLFxuICAgIGR5bmFtaWNQcm9wczogdm5vZGUuZHluYW1pY1Byb3BzLFxuICAgIGR5bmFtaWNDaGlsZHJlbjogdm5vZGUuZHluYW1pY0NoaWxkcmVuLFxuICAgIGFwcENvbnRleHQ6IHZub2RlLmFwcENvbnRleHQsXG4gICAgZGlyczogdm5vZGUuZGlycyxcbiAgICB0cmFuc2l0aW9uOiB2bm9kZS50cmFuc2l0aW9uLFxuICAgIC8vIFRoZXNlIHNob3VsZCB0ZWNobmljYWxseSBvbmx5IGJlIG5vbi1udWxsIG9uIG1vdW50ZWQgVk5vZGVzLiBIb3dldmVyLFxuICAgIC8vIHRoZXkgKnNob3VsZCogYmUgY29waWVkIGZvciBrZXB0LWFsaXZlIHZub2Rlcy4gU28gd2UganVzdCBhbHdheXMgY29weVxuICAgIC8vIHRoZW0gc2luY2UgdGhlbSBiZWluZyBub24tbnVsbCBkdXJpbmcgYSBtb3VudCBkb2Vzbid0IGFmZmVjdCB0aGUgbG9naWMgYXNcbiAgICAvLyB0aGV5IHdpbGwgc2ltcGx5IGJlIG92ZXJ3cml0dGVuLlxuICAgIGNvbXBvbmVudDogdm5vZGUuY29tcG9uZW50LFxuICAgIHN1c3BlbnNlOiB2bm9kZS5zdXNwZW5zZSxcbiAgICBzc0NvbnRlbnQ6IHZub2RlLnNzQ29udGVudCAmJiBjbG9uZVZOb2RlKHZub2RlLnNzQ29udGVudCksXG4gICAgc3NGYWxsYmFjazogdm5vZGUuc3NGYWxsYmFjayAmJiBjbG9uZVZOb2RlKHZub2RlLnNzRmFsbGJhY2spLFxuICAgIGVsOiB2bm9kZS5lbCxcbiAgICBhbmNob3I6IHZub2RlLmFuY2hvcixcbiAgICBjdHg6IHZub2RlLmN0eCxcbiAgICBjZTogdm5vZGUuY2VcbiAgfTtcbiAgcmV0dXJuIGNsb25lZDtcbn1cbmZ1bmN0aW9uIGRlZXBDbG9uZVZOb2RlKHZub2RlKSB7XG4gIGNvbnN0IGNsb25lZCA9IGNsb25lVk5vZGUodm5vZGUpO1xuICBpZiAoaXNBcnJheSh2bm9kZS5jaGlsZHJlbikpIHtcbiAgICBjbG9uZWQuY2hpbGRyZW4gPSB2bm9kZS5jaGlsZHJlbi5tYXAoZGVlcENsb25lVk5vZGUpO1xuICB9XG4gIHJldHVybiBjbG9uZWQ7XG59XG5mdW5jdGlvbiBjcmVhdGVUZXh0Vk5vZGUodGV4dCA9IFwiIFwiLCBmbGFnID0gMCkge1xuICByZXR1cm4gY3JlYXRlVk5vZGUoVGV4dCwgbnVsbCwgdGV4dCwgZmxhZyk7XG59XG5mdW5jdGlvbiBjcmVhdGVTdGF0aWNWTm9kZShjb250ZW50LCBudW1iZXJPZk5vZGVzKSB7XG4gIGNvbnN0IHZub2RlID0gY3JlYXRlVk5vZGUoU3RhdGljLCBudWxsLCBjb250ZW50KTtcbiAgdm5vZGUuc3RhdGljQ291bnQgPSBudW1iZXJPZk5vZGVzO1xuICByZXR1cm4gdm5vZGU7XG59XG5mdW5jdGlvbiBjcmVhdGVDb21tZW50Vk5vZGUodGV4dCA9IFwiXCIsIGFzQmxvY2sgPSBmYWxzZSkge1xuICByZXR1cm4gYXNCbG9jayA/IChvcGVuQmxvY2soKSwgY3JlYXRlQmxvY2soQ29tbWVudCwgbnVsbCwgdGV4dCkpIDogY3JlYXRlVk5vZGUoQ29tbWVudCwgbnVsbCwgdGV4dCk7XG59XG5mdW5jdGlvbiBub3JtYWxpemVWTm9kZShjaGlsZCkge1xuICBpZiAoY2hpbGQgPT0gbnVsbCB8fCB0eXBlb2YgY2hpbGQgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgcmV0dXJuIGNyZWF0ZVZOb2RlKENvbW1lbnQpO1xuICB9IGVsc2UgaWYgKGlzQXJyYXkoY2hpbGQpKSB7XG4gICAgcmV0dXJuIGNyZWF0ZVZOb2RlKFxuICAgICAgRnJhZ21lbnQsXG4gICAgICBudWxsLFxuICAgICAgLy8gIzM2NjYsIGF2b2lkIHJlZmVyZW5jZSBwb2xsdXRpb24gd2hlbiByZXVzaW5nIHZub2RlXG4gICAgICBjaGlsZC5zbGljZSgpXG4gICAgKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgY2hpbGQgPT09IFwib2JqZWN0XCIpIHtcbiAgICByZXR1cm4gY2xvbmVJZk1vdW50ZWQoY2hpbGQpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBjcmVhdGVWTm9kZShUZXh0LCBudWxsLCBTdHJpbmcoY2hpbGQpKTtcbiAgfVxufVxuZnVuY3Rpb24gY2xvbmVJZk1vdW50ZWQoY2hpbGQpIHtcbiAgcmV0dXJuIGNoaWxkLmVsID09PSBudWxsICYmIGNoaWxkLnBhdGNoRmxhZyAhPT0gLTEgfHwgY2hpbGQubWVtbyA/IGNoaWxkIDogY2xvbmVWTm9kZShjaGlsZCk7XG59XG5mdW5jdGlvbiBub3JtYWxpemVDaGlsZHJlbih2bm9kZSwgY2hpbGRyZW4pIHtcbiAgbGV0IHR5cGUgPSAwO1xuICBjb25zdCB7IHNoYXBlRmxhZyB9ID0gdm5vZGU7XG4gIGlmIChjaGlsZHJlbiA9PSBudWxsKSB7XG4gICAgY2hpbGRyZW4gPSBudWxsO1xuICB9IGVsc2UgaWYgKGlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgdHlwZSA9IDE2O1xuICB9IGVsc2UgaWYgKHR5cGVvZiBjaGlsZHJlbiA9PT0gXCJvYmplY3RcIikge1xuICAgIGlmIChzaGFwZUZsYWcgJiAoMSB8IDY0KSkge1xuICAgICAgY29uc3Qgc2xvdCA9IGNoaWxkcmVuLmRlZmF1bHQ7XG4gICAgICBpZiAoc2xvdCkge1xuICAgICAgICBzbG90Ll9jICYmIChzbG90Ll9kID0gZmFsc2UpO1xuICAgICAgICBub3JtYWxpemVDaGlsZHJlbih2bm9kZSwgc2xvdCgpKTtcbiAgICAgICAgc2xvdC5fYyAmJiAoc2xvdC5fZCA9IHRydWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSB7XG4gICAgICB0eXBlID0gMzI7XG4gICAgICBjb25zdCBzbG90RmxhZyA9IGNoaWxkcmVuLl87XG4gICAgICBpZiAoIXNsb3RGbGFnICYmICEoSW50ZXJuYWxPYmplY3RLZXkgaW4gY2hpbGRyZW4pKSB7XG4gICAgICAgIGNoaWxkcmVuLl9jdHggPSBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2U7XG4gICAgICB9IGVsc2UgaWYgKHNsb3RGbGFnID09PSAzICYmIGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSkge1xuICAgICAgICBpZiAoY3VycmVudFJlbmRlcmluZ0luc3RhbmNlLnNsb3RzLl8gPT09IDEpIHtcbiAgICAgICAgICBjaGlsZHJlbi5fID0gMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjaGlsZHJlbi5fID0gMjtcbiAgICAgICAgICB2bm9kZS5wYXRjaEZsYWcgfD0gMTAyNDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChpc0Z1bmN0aW9uKGNoaWxkcmVuKSkge1xuICAgIGNoaWxkcmVuID0geyBkZWZhdWx0OiBjaGlsZHJlbiwgX2N0eDogY3VycmVudFJlbmRlcmluZ0luc3RhbmNlIH07XG4gICAgdHlwZSA9IDMyO1xuICB9IGVsc2Uge1xuICAgIGNoaWxkcmVuID0gU3RyaW5nKGNoaWxkcmVuKTtcbiAgICBpZiAoc2hhcGVGbGFnICYgNjQpIHtcbiAgICAgIHR5cGUgPSAxNjtcbiAgICAgIGNoaWxkcmVuID0gW2NyZWF0ZVRleHRWTm9kZShjaGlsZHJlbildO1xuICAgIH0gZWxzZSB7XG4gICAgICB0eXBlID0gODtcbiAgICB9XG4gIH1cbiAgdm5vZGUuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgdm5vZGUuc2hhcGVGbGFnIHw9IHR5cGU7XG59XG5mdW5jdGlvbiBtZXJnZVByb3BzKC4uLmFyZ3MpIHtcbiAgY29uc3QgcmV0ID0ge307XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHRvTWVyZ2UgPSBhcmdzW2ldO1xuICAgIGZvciAoY29uc3Qga2V5IGluIHRvTWVyZ2UpIHtcbiAgICAgIGlmIChrZXkgPT09IFwiY2xhc3NcIikge1xuICAgICAgICBpZiAocmV0LmNsYXNzICE9PSB0b01lcmdlLmNsYXNzKSB7XG4gICAgICAgICAgcmV0LmNsYXNzID0gbm9ybWFsaXplQ2xhc3MoW3JldC5jbGFzcywgdG9NZXJnZS5jbGFzc10pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGtleSA9PT0gXCJzdHlsZVwiKSB7XG4gICAgICAgIHJldC5zdHlsZSA9IG5vcm1hbGl6ZVN0eWxlKFtyZXQuc3R5bGUsIHRvTWVyZ2Uuc3R5bGVdKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNPbihrZXkpKSB7XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nID0gcmV0W2tleV07XG4gICAgICAgIGNvbnN0IGluY29taW5nID0gdG9NZXJnZVtrZXldO1xuICAgICAgICBpZiAoaW5jb21pbmcgJiYgZXhpc3RpbmcgIT09IGluY29taW5nICYmICEoaXNBcnJheShleGlzdGluZykgJiYgZXhpc3RpbmcuaW5jbHVkZXMoaW5jb21pbmcpKSkge1xuICAgICAgICAgIHJldFtrZXldID0gZXhpc3RpbmcgPyBbXS5jb25jYXQoZXhpc3RpbmcsIGluY29taW5nKSA6IGluY29taW5nO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGtleSAhPT0gXCJcIikge1xuICAgICAgICByZXRba2V5XSA9IHRvTWVyZ2Vba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cbmZ1bmN0aW9uIGludm9rZVZOb2RlSG9vayhob29rLCBpbnN0YW5jZSwgdm5vZGUsIHByZXZWTm9kZSA9IG51bGwpIHtcbiAgY2FsbFdpdGhBc3luY0Vycm9ySGFuZGxpbmcoaG9vaywgaW5zdGFuY2UsIDcsIFtcbiAgICB2bm9kZSxcbiAgICBwcmV2Vk5vZGVcbiAgXSk7XG59XG5cbmNvbnN0IGVtcHR5QXBwQ29udGV4dCA9IGNyZWF0ZUFwcENvbnRleHQoKTtcbmxldCB1aWQgPSAwO1xuZnVuY3Rpb24gY3JlYXRlQ29tcG9uZW50SW5zdGFuY2Uodm5vZGUsIHBhcmVudCwgc3VzcGVuc2UpIHtcbiAgY29uc3QgdHlwZSA9IHZub2RlLnR5cGU7XG4gIGNvbnN0IGFwcENvbnRleHQgPSAocGFyZW50ID8gcGFyZW50LmFwcENvbnRleHQgOiB2bm9kZS5hcHBDb250ZXh0KSB8fCBlbXB0eUFwcENvbnRleHQ7XG4gIGNvbnN0IGluc3RhbmNlID0ge1xuICAgIHVpZDogdWlkKyssXG4gICAgdm5vZGUsXG4gICAgdHlwZSxcbiAgICBwYXJlbnQsXG4gICAgYXBwQ29udGV4dCxcbiAgICByb290OiBudWxsLFxuICAgIC8vIHRvIGJlIGltbWVkaWF0ZWx5IHNldFxuICAgIG5leHQ6IG51bGwsXG4gICAgc3ViVHJlZTogbnVsbCxcbiAgICAvLyB3aWxsIGJlIHNldCBzeW5jaHJvbm91c2x5IHJpZ2h0IGFmdGVyIGNyZWF0aW9uXG4gICAgZWZmZWN0OiBudWxsLFxuICAgIHVwZGF0ZTogbnVsbCxcbiAgICAvLyB3aWxsIGJlIHNldCBzeW5jaHJvbm91c2x5IHJpZ2h0IGFmdGVyIGNyZWF0aW9uXG4gICAgc2NvcGU6IG5ldyBFZmZlY3RTY29wZShcbiAgICAgIHRydWVcbiAgICAgIC8qIGRldGFjaGVkICovXG4gICAgKSxcbiAgICByZW5kZXI6IG51bGwsXG4gICAgcHJveHk6IG51bGwsXG4gICAgZXhwb3NlZDogbnVsbCxcbiAgICBleHBvc2VQcm94eTogbnVsbCxcbiAgICB3aXRoUHJveHk6IG51bGwsXG4gICAgcHJvdmlkZXM6IHBhcmVudCA/IHBhcmVudC5wcm92aWRlcyA6IE9iamVjdC5jcmVhdGUoYXBwQ29udGV4dC5wcm92aWRlcyksXG4gICAgYWNjZXNzQ2FjaGU6IG51bGwsXG4gICAgcmVuZGVyQ2FjaGU6IFtdLFxuICAgIC8vIGxvY2FsIHJlc29sdmVkIGFzc2V0c1xuICAgIGNvbXBvbmVudHM6IG51bGwsXG4gICAgZGlyZWN0aXZlczogbnVsbCxcbiAgICAvLyByZXNvbHZlZCBwcm9wcyBhbmQgZW1pdHMgb3B0aW9uc1xuICAgIHByb3BzT3B0aW9uczogbm9ybWFsaXplUHJvcHNPcHRpb25zKHR5cGUsIGFwcENvbnRleHQpLFxuICAgIGVtaXRzT3B0aW9uczogbm9ybWFsaXplRW1pdHNPcHRpb25zKHR5cGUsIGFwcENvbnRleHQpLFxuICAgIC8vIGVtaXRcbiAgICBlbWl0OiBudWxsLFxuICAgIC8vIHRvIGJlIHNldCBpbW1lZGlhdGVseVxuICAgIGVtaXR0ZWQ6IG51bGwsXG4gICAgLy8gcHJvcHMgZGVmYXVsdCB2YWx1ZVxuICAgIHByb3BzRGVmYXVsdHM6IEVNUFRZX09CSixcbiAgICAvLyBpbmhlcml0QXR0cnNcbiAgICBpbmhlcml0QXR0cnM6IHR5cGUuaW5oZXJpdEF0dHJzLFxuICAgIC8vIHN0YXRlXG4gICAgY3R4OiBFTVBUWV9PQkosXG4gICAgZGF0YTogRU1QVFlfT0JKLFxuICAgIHByb3BzOiBFTVBUWV9PQkosXG4gICAgYXR0cnM6IEVNUFRZX09CSixcbiAgICBzbG90czogRU1QVFlfT0JKLFxuICAgIHJlZnM6IEVNUFRZX09CSixcbiAgICBzZXR1cFN0YXRlOiBFTVBUWV9PQkosXG4gICAgc2V0dXBDb250ZXh0OiBudWxsLFxuICAgIGF0dHJzUHJveHk6IG51bGwsXG4gICAgc2xvdHNQcm94eTogbnVsbCxcbiAgICAvLyBzdXNwZW5zZSByZWxhdGVkXG4gICAgc3VzcGVuc2UsXG4gICAgc3VzcGVuc2VJZDogc3VzcGVuc2UgPyBzdXNwZW5zZS5wZW5kaW5nSWQgOiAwLFxuICAgIGFzeW5jRGVwOiBudWxsLFxuICAgIGFzeW5jUmVzb2x2ZWQ6IGZhbHNlLFxuICAgIC8vIGxpZmVjeWNsZSBob29rc1xuICAgIC8vIG5vdCB1c2luZyBlbnVtcyBoZXJlIGJlY2F1c2UgaXQgcmVzdWx0cyBpbiBjb21wdXRlZCBwcm9wZXJ0aWVzXG4gICAgaXNNb3VudGVkOiBmYWxzZSxcbiAgICBpc1VubW91bnRlZDogZmFsc2UsXG4gICAgaXNEZWFjdGl2YXRlZDogZmFsc2UsXG4gICAgYmM6IG51bGwsXG4gICAgYzogbnVsbCxcbiAgICBibTogbnVsbCxcbiAgICBtOiBudWxsLFxuICAgIGJ1OiBudWxsLFxuICAgIHU6IG51bGwsXG4gICAgdW06IG51bGwsXG4gICAgYnVtOiBudWxsLFxuICAgIGRhOiBudWxsLFxuICAgIGE6IG51bGwsXG4gICAgcnRnOiBudWxsLFxuICAgIHJ0YzogbnVsbCxcbiAgICBlYzogbnVsbCxcbiAgICBzcDogbnVsbFxuICB9O1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIGluc3RhbmNlLmN0eCA9IGNyZWF0ZURldlJlbmRlckNvbnRleHQoaW5zdGFuY2UpO1xuICB9IGVsc2Uge1xuICAgIGluc3RhbmNlLmN0eCA9IHsgXzogaW5zdGFuY2UgfTtcbiAgfVxuICBpbnN0YW5jZS5yb290ID0gcGFyZW50ID8gcGFyZW50LnJvb3QgOiBpbnN0YW5jZTtcbiAgaW5zdGFuY2UuZW1pdCA9IGVtaXQuYmluZChudWxsLCBpbnN0YW5jZSk7XG4gIGlmICh2bm9kZS5jZSkge1xuICAgIHZub2RlLmNlKGluc3RhbmNlKTtcbiAgfVxuICByZXR1cm4gaW5zdGFuY2U7XG59XG5sZXQgY3VycmVudEluc3RhbmNlID0gbnVsbDtcbmNvbnN0IGdldEN1cnJlbnRJbnN0YW5jZSA9ICgpID0+IGN1cnJlbnRJbnN0YW5jZSB8fCBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2U7XG5sZXQgaW50ZXJuYWxTZXRDdXJyZW50SW5zdGFuY2U7XG5sZXQgZ2xvYmFsQ3VycmVudEluc3RhbmNlU2V0dGVycztcbmxldCBzZXR0ZXJzS2V5ID0gXCJfX1ZVRV9JTlNUQU5DRV9TRVRURVJTX19cIjtcbntcbiAgaWYgKCEoZ2xvYmFsQ3VycmVudEluc3RhbmNlU2V0dGVycyA9IGdldEdsb2JhbFRoaXMoKVtzZXR0ZXJzS2V5XSkpIHtcbiAgICBnbG9iYWxDdXJyZW50SW5zdGFuY2VTZXR0ZXJzID0gZ2V0R2xvYmFsVGhpcygpW3NldHRlcnNLZXldID0gW107XG4gIH1cbiAgZ2xvYmFsQ3VycmVudEluc3RhbmNlU2V0dGVycy5wdXNoKChpKSA9PiBjdXJyZW50SW5zdGFuY2UgPSBpKTtcbiAgaW50ZXJuYWxTZXRDdXJyZW50SW5zdGFuY2UgPSAoaW5zdGFuY2UpID0+IHtcbiAgICBpZiAoZ2xvYmFsQ3VycmVudEluc3RhbmNlU2V0dGVycy5sZW5ndGggPiAxKSB7XG4gICAgICBnbG9iYWxDdXJyZW50SW5zdGFuY2VTZXR0ZXJzLmZvckVhY2goKHMpID0+IHMoaW5zdGFuY2UpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZ2xvYmFsQ3VycmVudEluc3RhbmNlU2V0dGVyc1swXShpbnN0YW5jZSk7XG4gICAgfVxuICB9O1xufVxuY29uc3Qgc2V0Q3VycmVudEluc3RhbmNlID0gKGluc3RhbmNlKSA9PiB7XG4gIGludGVybmFsU2V0Q3VycmVudEluc3RhbmNlKGluc3RhbmNlKTtcbiAgaW5zdGFuY2Uuc2NvcGUub24oKTtcbn07XG5jb25zdCB1bnNldEN1cnJlbnRJbnN0YW5jZSA9ICgpID0+IHtcbiAgY3VycmVudEluc3RhbmNlICYmIGN1cnJlbnRJbnN0YW5jZS5zY29wZS5vZmYoKTtcbiAgaW50ZXJuYWxTZXRDdXJyZW50SW5zdGFuY2UobnVsbCk7XG59O1xuY29uc3QgaXNCdWlsdEluVGFnID0gLyogQF9fUFVSRV9fICovIG1ha2VNYXAoXCJzbG90LGNvbXBvbmVudFwiKTtcbmZ1bmN0aW9uIHZhbGlkYXRlQ29tcG9uZW50TmFtZShuYW1lLCBjb25maWcpIHtcbiAgY29uc3QgYXBwSXNOYXRpdmVUYWcgPSBjb25maWcuaXNOYXRpdmVUYWcgfHwgTk87XG4gIGlmIChpc0J1aWx0SW5UYWcobmFtZSkgfHwgYXBwSXNOYXRpdmVUYWcobmFtZSkpIHtcbiAgICB3YXJuKFxuICAgICAgXCJEbyBub3QgdXNlIGJ1aWx0LWluIG9yIHJlc2VydmVkIEhUTUwgZWxlbWVudHMgYXMgY29tcG9uZW50IGlkOiBcIiArIG5hbWVcbiAgICApO1xuICB9XG59XG5mdW5jdGlvbiBpc1N0YXRlZnVsQ29tcG9uZW50KGluc3RhbmNlKSB7XG4gIHJldHVybiBpbnN0YW5jZS52bm9kZS5zaGFwZUZsYWcgJiA0O1xufVxubGV0IGlzSW5TU1JDb21wb25lbnRTZXR1cCA9IGZhbHNlO1xuZnVuY3Rpb24gc2V0dXBDb21wb25lbnQoaW5zdGFuY2UsIGlzU1NSID0gZmFsc2UpIHtcbiAgaXNJblNTUkNvbXBvbmVudFNldHVwID0gaXNTU1I7XG4gIGNvbnN0IHsgcHJvcHMsIGNoaWxkcmVuIH0gPSBpbnN0YW5jZS52bm9kZTtcbiAgY29uc3QgaXNTdGF0ZWZ1bCA9IGlzU3RhdGVmdWxDb21wb25lbnQoaW5zdGFuY2UpO1xuICBpbml0UHJvcHMoaW5zdGFuY2UsIHByb3BzLCBpc1N0YXRlZnVsLCBpc1NTUik7XG4gIGluaXRTbG90cyhpbnN0YW5jZSwgY2hpbGRyZW4pO1xuICBjb25zdCBzZXR1cFJlc3VsdCA9IGlzU3RhdGVmdWwgPyBzZXR1cFN0YXRlZnVsQ29tcG9uZW50KGluc3RhbmNlLCBpc1NTUikgOiB2b2lkIDA7XG4gIGlzSW5TU1JDb21wb25lbnRTZXR1cCA9IGZhbHNlO1xuICByZXR1cm4gc2V0dXBSZXN1bHQ7XG59XG5mdW5jdGlvbiBzZXR1cFN0YXRlZnVsQ29tcG9uZW50KGluc3RhbmNlLCBpc1NTUikge1xuICB2YXIgX2E7XG4gIGNvbnN0IENvbXBvbmVudCA9IGluc3RhbmNlLnR5cGU7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgaWYgKENvbXBvbmVudC5uYW1lKSB7XG4gICAgICB2YWxpZGF0ZUNvbXBvbmVudE5hbWUoQ29tcG9uZW50Lm5hbWUsIGluc3RhbmNlLmFwcENvbnRleHQuY29uZmlnKTtcbiAgICB9XG4gICAgaWYgKENvbXBvbmVudC5jb21wb25lbnRzKSB7XG4gICAgICBjb25zdCBuYW1lcyA9IE9iamVjdC5rZXlzKENvbXBvbmVudC5jb21wb25lbnRzKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFsaWRhdGVDb21wb25lbnROYW1lKG5hbWVzW2ldLCBpbnN0YW5jZS5hcHBDb250ZXh0LmNvbmZpZyk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChDb21wb25lbnQuZGlyZWN0aXZlcykge1xuICAgICAgY29uc3QgbmFtZXMgPSBPYmplY3Qua2V5cyhDb21wb25lbnQuZGlyZWN0aXZlcyk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhbGlkYXRlRGlyZWN0aXZlTmFtZShuYW1lc1tpXSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChDb21wb25lbnQuY29tcGlsZXJPcHRpb25zICYmIGlzUnVudGltZU9ubHkoKSkge1xuICAgICAgd2FybihcbiAgICAgICAgYFwiY29tcGlsZXJPcHRpb25zXCIgaXMgb25seSBzdXBwb3J0ZWQgd2hlbiB1c2luZyBhIGJ1aWxkIG9mIFZ1ZSB0aGF0IGluY2x1ZGVzIHRoZSBydW50aW1lIGNvbXBpbGVyLiBTaW5jZSB5b3UgYXJlIHVzaW5nIGEgcnVudGltZS1vbmx5IGJ1aWxkLCB0aGUgb3B0aW9ucyBzaG91bGQgYmUgcGFzc2VkIHZpYSB5b3VyIGJ1aWxkIHRvb2wgY29uZmlnIGluc3RlYWQuYFxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgaW5zdGFuY2UuYWNjZXNzQ2FjaGUgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgaW5zdGFuY2UucHJveHkgPSBtYXJrUmF3KG5ldyBQcm94eShpbnN0YW5jZS5jdHgsIFB1YmxpY0luc3RhbmNlUHJveHlIYW5kbGVycykpO1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIGV4cG9zZVByb3BzT25SZW5kZXJDb250ZXh0KGluc3RhbmNlKTtcbiAgfVxuICBjb25zdCB7IHNldHVwIH0gPSBDb21wb25lbnQ7XG4gIGlmIChzZXR1cCkge1xuICAgIGNvbnN0IHNldHVwQ29udGV4dCA9IGluc3RhbmNlLnNldHVwQ29udGV4dCA9IHNldHVwLmxlbmd0aCA+IDEgPyBjcmVhdGVTZXR1cENvbnRleHQoaW5zdGFuY2UpIDogbnVsbDtcbiAgICBzZXRDdXJyZW50SW5zdGFuY2UoaW5zdGFuY2UpO1xuICAgIHBhdXNlVHJhY2tpbmcoKTtcbiAgICBjb25zdCBzZXR1cFJlc3VsdCA9IGNhbGxXaXRoRXJyb3JIYW5kbGluZyhcbiAgICAgIHNldHVwLFxuICAgICAgaW5zdGFuY2UsXG4gICAgICAwLFxuICAgICAgWyEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyBzaGFsbG93UmVhZG9ubHkoaW5zdGFuY2UucHJvcHMpIDogaW5zdGFuY2UucHJvcHMsIHNldHVwQ29udGV4dF1cbiAgICApO1xuICAgIHJlc2V0VHJhY2tpbmcoKTtcbiAgICB1bnNldEN1cnJlbnRJbnN0YW5jZSgpO1xuICAgIGlmIChpc1Byb21pc2Uoc2V0dXBSZXN1bHQpKSB7XG4gICAgICBzZXR1cFJlc3VsdC50aGVuKHVuc2V0Q3VycmVudEluc3RhbmNlLCB1bnNldEN1cnJlbnRJbnN0YW5jZSk7XG4gICAgICBpZiAoaXNTU1IpIHtcbiAgICAgICAgcmV0dXJuIHNldHVwUmVzdWx0LnRoZW4oKHJlc29sdmVkUmVzdWx0KSA9PiB7XG4gICAgICAgICAgaGFuZGxlU2V0dXBSZXN1bHQoaW5zdGFuY2UsIHJlc29sdmVkUmVzdWx0LCBpc1NTUik7XG4gICAgICAgIH0pLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgaGFuZGxlRXJyb3IoZSwgaW5zdGFuY2UsIDApO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluc3RhbmNlLmFzeW5jRGVwID0gc2V0dXBSZXN1bHQ7XG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICFpbnN0YW5jZS5zdXNwZW5zZSkge1xuICAgICAgICAgIGNvbnN0IG5hbWUgPSAoX2EgPSBDb21wb25lbnQubmFtZSkgIT0gbnVsbCA/IF9hIDogXCJBbm9ueW1vdXNcIjtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgYENvbXBvbmVudCA8JHtuYW1lfT46IHNldHVwIGZ1bmN0aW9uIHJldHVybmVkIGEgcHJvbWlzZSwgYnV0IG5vIDxTdXNwZW5zZT4gYm91bmRhcnkgd2FzIGZvdW5kIGluIHRoZSBwYXJlbnQgY29tcG9uZW50IHRyZWUuIEEgY29tcG9uZW50IHdpdGggYXN5bmMgc2V0dXAoKSBtdXN0IGJlIG5lc3RlZCBpbiBhIDxTdXNwZW5zZT4gaW4gb3JkZXIgdG8gYmUgcmVuZGVyZWQuYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaGFuZGxlU2V0dXBSZXN1bHQoaW5zdGFuY2UsIHNldHVwUmVzdWx0LCBpc1NTUik7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZpbmlzaENvbXBvbmVudFNldHVwKGluc3RhbmNlLCBpc1NTUik7XG4gIH1cbn1cbmZ1bmN0aW9uIGhhbmRsZVNldHVwUmVzdWx0KGluc3RhbmNlLCBzZXR1cFJlc3VsdCwgaXNTU1IpIHtcbiAgaWYgKGlzRnVuY3Rpb24oc2V0dXBSZXN1bHQpKSB7XG4gICAgaWYgKGluc3RhbmNlLnR5cGUuX19zc3JJbmxpbmVSZW5kZXIpIHtcbiAgICAgIGluc3RhbmNlLnNzclJlbmRlciA9IHNldHVwUmVzdWx0O1xuICAgIH0gZWxzZSB7XG4gICAgICBpbnN0YW5jZS5yZW5kZXIgPSBzZXR1cFJlc3VsdDtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNPYmplY3Qoc2V0dXBSZXN1bHQpKSB7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgaXNWTm9kZShzZXR1cFJlc3VsdCkpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIGBzZXR1cCgpIHNob3VsZCBub3QgcmV0dXJuIFZOb2RlcyBkaXJlY3RseSAtIHJldHVybiBhIHJlbmRlciBmdW5jdGlvbiBpbnN0ZWFkLmBcbiAgICAgICk7XG4gICAgfVxuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykge1xuICAgICAgaW5zdGFuY2UuZGV2dG9vbHNSYXdTZXR1cFN0YXRlID0gc2V0dXBSZXN1bHQ7XG4gICAgfVxuICAgIGluc3RhbmNlLnNldHVwU3RhdGUgPSBwcm94eVJlZnMoc2V0dXBSZXN1bHQpO1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICBleHBvc2VTZXR1cFN0YXRlT25SZW5kZXJDb250ZXh0KGluc3RhbmNlKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBzZXR1cFJlc3VsdCAhPT0gdm9pZCAwKSB7XG4gICAgd2FybihcbiAgICAgIGBzZXR1cCgpIHNob3VsZCByZXR1cm4gYW4gb2JqZWN0LiBSZWNlaXZlZDogJHtzZXR1cFJlc3VsdCA9PT0gbnVsbCA/IFwibnVsbFwiIDogdHlwZW9mIHNldHVwUmVzdWx0fWBcbiAgICApO1xuICB9XG4gIGZpbmlzaENvbXBvbmVudFNldHVwKGluc3RhbmNlLCBpc1NTUik7XG59XG5sZXQgY29tcGlsZTtcbmxldCBpbnN0YWxsV2l0aFByb3h5O1xuZnVuY3Rpb24gcmVnaXN0ZXJSdW50aW1lQ29tcGlsZXIoX2NvbXBpbGUpIHtcbiAgY29tcGlsZSA9IF9jb21waWxlO1xuICBpbnN0YWxsV2l0aFByb3h5ID0gKGkpID0+IHtcbiAgICBpZiAoaS5yZW5kZXIuX3JjKSB7XG4gICAgICBpLndpdGhQcm94eSA9IG5ldyBQcm94eShpLmN0eCwgUnVudGltZUNvbXBpbGVkUHVibGljSW5zdGFuY2VQcm94eUhhbmRsZXJzKTtcbiAgICB9XG4gIH07XG59XG5jb25zdCBpc1J1bnRpbWVPbmx5ID0gKCkgPT4gIWNvbXBpbGU7XG5mdW5jdGlvbiBmaW5pc2hDb21wb25lbnRTZXR1cChpbnN0YW5jZSwgaXNTU1IsIHNraXBPcHRpb25zKSB7XG4gIGNvbnN0IENvbXBvbmVudCA9IGluc3RhbmNlLnR5cGU7XG4gIGlmICghaW5zdGFuY2UucmVuZGVyKSB7XG4gICAgaWYgKCFpc1NTUiAmJiBjb21waWxlICYmICFDb21wb25lbnQucmVuZGVyKSB7XG4gICAgICBjb25zdCB0ZW1wbGF0ZSA9IENvbXBvbmVudC50ZW1wbGF0ZSB8fCByZXNvbHZlTWVyZ2VkT3B0aW9ucyhpbnN0YW5jZSkudGVtcGxhdGU7XG4gICAgICBpZiAodGVtcGxhdGUpIHtcbiAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICBzdGFydE1lYXN1cmUoaW5zdGFuY2UsIGBjb21waWxlYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBpc0N1c3RvbUVsZW1lbnQsIGNvbXBpbGVyT3B0aW9ucyB9ID0gaW5zdGFuY2UuYXBwQ29udGV4dC5jb25maWc7XG4gICAgICAgIGNvbnN0IHsgZGVsaW1pdGVycywgY29tcGlsZXJPcHRpb25zOiBjb21wb25lbnRDb21waWxlck9wdGlvbnMgfSA9IENvbXBvbmVudDtcbiAgICAgICAgY29uc3QgZmluYWxDb21waWxlck9wdGlvbnMgPSBleHRlbmQoXG4gICAgICAgICAgZXh0ZW5kKFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBpc0N1c3RvbUVsZW1lbnQsXG4gICAgICAgICAgICAgIGRlbGltaXRlcnNcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjb21waWxlck9wdGlvbnNcbiAgICAgICAgICApLFxuICAgICAgICAgIGNvbXBvbmVudENvbXBpbGVyT3B0aW9uc1xuICAgICAgICApO1xuICAgICAgICBDb21wb25lbnQucmVuZGVyID0gY29tcGlsZSh0ZW1wbGF0ZSwgZmluYWxDb21waWxlck9wdGlvbnMpO1xuICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgIGVuZE1lYXN1cmUoaW5zdGFuY2UsIGBjb21waWxlYCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaW5zdGFuY2UucmVuZGVyID0gQ29tcG9uZW50LnJlbmRlciB8fCBOT09QO1xuICAgIGlmIChpbnN0YWxsV2l0aFByb3h5KSB7XG4gICAgICBpbnN0YWxsV2l0aFByb3h5KGluc3RhbmNlKTtcbiAgICB9XG4gIH1cbiAgaWYgKF9fVlVFX09QVElPTlNfQVBJX18gJiYgdHJ1ZSkge1xuICAgIHNldEN1cnJlbnRJbnN0YW5jZShpbnN0YW5jZSk7XG4gICAgcGF1c2VUcmFja2luZygpO1xuICAgIGFwcGx5T3B0aW9ucyhpbnN0YW5jZSk7XG4gICAgcmVzZXRUcmFja2luZygpO1xuICAgIHVuc2V0Q3VycmVudEluc3RhbmNlKCk7XG4gIH1cbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgIUNvbXBvbmVudC5yZW5kZXIgJiYgaW5zdGFuY2UucmVuZGVyID09PSBOT09QICYmICFpc1NTUikge1xuICAgIGlmICghY29tcGlsZSAmJiBDb21wb25lbnQudGVtcGxhdGUpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIGBDb21wb25lbnQgcHJvdmlkZWQgdGVtcGxhdGUgb3B0aW9uIGJ1dCBydW50aW1lIGNvbXBpbGF0aW9uIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBidWlsZCBvZiBWdWUuYCArIChgIENvbmZpZ3VyZSB5b3VyIGJ1bmRsZXIgdG8gYWxpYXMgXCJ2dWVcIiB0byBcInZ1ZS9kaXN0L3Z1ZS5lc20tYnVuZGxlci5qc1wiLmAgKVxuICAgICAgICAvKiBzaG91bGQgbm90IGhhcHBlbiAqL1xuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgd2FybihgQ29tcG9uZW50IGlzIG1pc3NpbmcgdGVtcGxhdGUgb3IgcmVuZGVyIGZ1bmN0aW9uLmApO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZ2V0QXR0cnNQcm94eShpbnN0YW5jZSkge1xuICByZXR1cm4gaW5zdGFuY2UuYXR0cnNQcm94eSB8fCAoaW5zdGFuY2UuYXR0cnNQcm94eSA9IG5ldyBQcm94eShcbiAgICBpbnN0YW5jZS5hdHRycyxcbiAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8ge1xuICAgICAgZ2V0KHRhcmdldCwga2V5KSB7XG4gICAgICAgIG1hcmtBdHRyc0FjY2Vzc2VkKCk7XG4gICAgICAgIHRyYWNrKGluc3RhbmNlLCBcImdldFwiLCBcIiRhdHRyc1wiKTtcbiAgICAgICAgcmV0dXJuIHRhcmdldFtrZXldO1xuICAgICAgfSxcbiAgICAgIHNldCgpIHtcbiAgICAgICAgd2Fybihgc2V0dXBDb250ZXh0LmF0dHJzIGlzIHJlYWRvbmx5LmApO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9LFxuICAgICAgZGVsZXRlUHJvcGVydHkoKSB7XG4gICAgICAgIHdhcm4oYHNldHVwQ29udGV4dC5hdHRycyBpcyByZWFkb25seS5gKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0gOiB7XG4gICAgICBnZXQodGFyZ2V0LCBrZXkpIHtcbiAgICAgICAgdHJhY2soaW5zdGFuY2UsIFwiZ2V0XCIsIFwiJGF0dHJzXCIpO1xuICAgICAgICByZXR1cm4gdGFyZ2V0W2tleV07XG4gICAgICB9XG4gICAgfVxuICApKTtcbn1cbmZ1bmN0aW9uIGdldFNsb3RzUHJveHkoaW5zdGFuY2UpIHtcbiAgcmV0dXJuIGluc3RhbmNlLnNsb3RzUHJveHkgfHwgKGluc3RhbmNlLnNsb3RzUHJveHkgPSBuZXcgUHJveHkoaW5zdGFuY2Uuc2xvdHMsIHtcbiAgICBnZXQodGFyZ2V0LCBrZXkpIHtcbiAgICAgIHRyYWNrKGluc3RhbmNlLCBcImdldFwiLCBcIiRzbG90c1wiKTtcbiAgICAgIHJldHVybiB0YXJnZXRba2V5XTtcbiAgICB9XG4gIH0pKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVNldHVwQ29udGV4dChpbnN0YW5jZSkge1xuICBjb25zdCBleHBvc2UgPSAoZXhwb3NlZCkgPT4ge1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICBpZiAoaW5zdGFuY2UuZXhwb3NlZCkge1xuICAgICAgICB3YXJuKGBleHBvc2UoKSBzaG91bGQgYmUgY2FsbGVkIG9ubHkgb25jZSBwZXIgc2V0dXAoKS5gKTtcbiAgICAgIH1cbiAgICAgIGlmIChleHBvc2VkICE9IG51bGwpIHtcbiAgICAgICAgbGV0IGV4cG9zZWRUeXBlID0gdHlwZW9mIGV4cG9zZWQ7XG4gICAgICAgIGlmIChleHBvc2VkVHlwZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgIGlmIChpc0FycmF5KGV4cG9zZWQpKSB7XG4gICAgICAgICAgICBleHBvc2VkVHlwZSA9IFwiYXJyYXlcIjtcbiAgICAgICAgICB9IGVsc2UgaWYgKGlzUmVmKGV4cG9zZWQpKSB7XG4gICAgICAgICAgICBleHBvc2VkVHlwZSA9IFwicmVmXCI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChleHBvc2VkVHlwZSAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICBgZXhwb3NlKCkgc2hvdWxkIGJlIHBhc3NlZCBhIHBsYWluIG9iamVjdCwgcmVjZWl2ZWQgJHtleHBvc2VkVHlwZX0uYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaW5zdGFuY2UuZXhwb3NlZCA9IGV4cG9zZWQgfHwge307XG4gIH07XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUoe1xuICAgICAgZ2V0IGF0dHJzKCkge1xuICAgICAgICByZXR1cm4gZ2V0QXR0cnNQcm94eShpbnN0YW5jZSk7XG4gICAgICB9LFxuICAgICAgZ2V0IHNsb3RzKCkge1xuICAgICAgICByZXR1cm4gZ2V0U2xvdHNQcm94eShpbnN0YW5jZSk7XG4gICAgICB9LFxuICAgICAgZ2V0IGVtaXQoKSB7XG4gICAgICAgIHJldHVybiAoZXZlbnQsIC4uLmFyZ3MpID0+IGluc3RhbmNlLmVtaXQoZXZlbnQsIC4uLmFyZ3MpO1xuICAgICAgfSxcbiAgICAgIGV4cG9zZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB7XG4gICAgICBnZXQgYXR0cnMoKSB7XG4gICAgICAgIHJldHVybiBnZXRBdHRyc1Byb3h5KGluc3RhbmNlKTtcbiAgICAgIH0sXG4gICAgICBzbG90czogaW5zdGFuY2Uuc2xvdHMsXG4gICAgICBlbWl0OiBpbnN0YW5jZS5lbWl0LFxuICAgICAgZXhwb3NlXG4gICAgfTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0RXhwb3NlUHJveHkoaW5zdGFuY2UpIHtcbiAgaWYgKGluc3RhbmNlLmV4cG9zZWQpIHtcbiAgICByZXR1cm4gaW5zdGFuY2UuZXhwb3NlUHJveHkgfHwgKGluc3RhbmNlLmV4cG9zZVByb3h5ID0gbmV3IFByb3h5KHByb3h5UmVmcyhtYXJrUmF3KGluc3RhbmNlLmV4cG9zZWQpKSwge1xuICAgICAgZ2V0KHRhcmdldCwga2V5KSB7XG4gICAgICAgIGlmIChrZXkgaW4gdGFyZ2V0KSB7XG4gICAgICAgICAgcmV0dXJuIHRhcmdldFtrZXldO1xuICAgICAgICB9IGVsc2UgaWYgKGtleSBpbiBwdWJsaWNQcm9wZXJ0aWVzTWFwKSB7XG4gICAgICAgICAgcmV0dXJuIHB1YmxpY1Byb3BlcnRpZXNNYXBba2V5XShpbnN0YW5jZSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBoYXModGFyZ2V0LCBrZXkpIHtcbiAgICAgICAgcmV0dXJuIGtleSBpbiB0YXJnZXQgfHwga2V5IGluIHB1YmxpY1Byb3BlcnRpZXNNYXA7XG4gICAgICB9XG4gICAgfSkpO1xuICB9XG59XG5jb25zdCBjbGFzc2lmeVJFID0gLyg/Ol58Wy1fXSkoXFx3KS9nO1xuY29uc3QgY2xhc3NpZnkgPSAoc3RyKSA9PiBzdHIucmVwbGFjZShjbGFzc2lmeVJFLCAoYykgPT4gYy50b1VwcGVyQ2FzZSgpKS5yZXBsYWNlKC9bLV9dL2csIFwiXCIpO1xuZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZShDb21wb25lbnQsIGluY2x1ZGVJbmZlcnJlZCA9IHRydWUpIHtcbiAgcmV0dXJuIGlzRnVuY3Rpb24oQ29tcG9uZW50KSA/IENvbXBvbmVudC5kaXNwbGF5TmFtZSB8fCBDb21wb25lbnQubmFtZSA6IENvbXBvbmVudC5uYW1lIHx8IGluY2x1ZGVJbmZlcnJlZCAmJiBDb21wb25lbnQuX19uYW1lO1xufVxuZnVuY3Rpb24gZm9ybWF0Q29tcG9uZW50TmFtZShpbnN0YW5jZSwgQ29tcG9uZW50LCBpc1Jvb3QgPSBmYWxzZSkge1xuICBsZXQgbmFtZSA9IGdldENvbXBvbmVudE5hbWUoQ29tcG9uZW50KTtcbiAgaWYgKCFuYW1lICYmIENvbXBvbmVudC5fX2ZpbGUpIHtcbiAgICBjb25zdCBtYXRjaCA9IENvbXBvbmVudC5fX2ZpbGUubWF0Y2goLyhbXi9cXFxcXSspXFwuXFx3KyQvKTtcbiAgICBpZiAobWF0Y2gpIHtcbiAgICAgIG5hbWUgPSBtYXRjaFsxXTtcbiAgICB9XG4gIH1cbiAgaWYgKCFuYW1lICYmIGluc3RhbmNlICYmIGluc3RhbmNlLnBhcmVudCkge1xuICAgIGNvbnN0IGluZmVyRnJvbVJlZ2lzdHJ5ID0gKHJlZ2lzdHJ5KSA9PiB7XG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiByZWdpc3RyeSkge1xuICAgICAgICBpZiAocmVnaXN0cnlba2V5XSA9PT0gQ29tcG9uZW50KSB7XG4gICAgICAgICAgcmV0dXJuIGtleTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgbmFtZSA9IGluZmVyRnJvbVJlZ2lzdHJ5KFxuICAgICAgaW5zdGFuY2UuY29tcG9uZW50cyB8fCBpbnN0YW5jZS5wYXJlbnQudHlwZS5jb21wb25lbnRzXG4gICAgKSB8fCBpbmZlckZyb21SZWdpc3RyeShpbnN0YW5jZS5hcHBDb250ZXh0LmNvbXBvbmVudHMpO1xuICB9XG4gIHJldHVybiBuYW1lID8gY2xhc3NpZnkobmFtZSkgOiBpc1Jvb3QgPyBgQXBwYCA6IGBBbm9ueW1vdXNgO1xufVxuZnVuY3Rpb24gaXNDbGFzc0NvbXBvbmVudCh2YWx1ZSkge1xuICByZXR1cm4gaXNGdW5jdGlvbih2YWx1ZSkgJiYgXCJfX3ZjY09wdHNcIiBpbiB2YWx1ZTtcbn1cblxuY29uc3QgY29tcHV0ZWQgPSAoZ2V0dGVyT3JPcHRpb25zLCBkZWJ1Z09wdGlvbnMpID0+IHtcbiAgcmV0dXJuIGNvbXB1dGVkJDEoZ2V0dGVyT3JPcHRpb25zLCBkZWJ1Z09wdGlvbnMsIGlzSW5TU1JDb21wb25lbnRTZXR1cCk7XG59O1xuXG5mdW5jdGlvbiBoKHR5cGUsIHByb3BzT3JDaGlsZHJlbiwgY2hpbGRyZW4pIHtcbiAgY29uc3QgbCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gIGlmIChsID09PSAyKSB7XG4gICAgaWYgKGlzT2JqZWN0KHByb3BzT3JDaGlsZHJlbikgJiYgIWlzQXJyYXkocHJvcHNPckNoaWxkcmVuKSkge1xuICAgICAgaWYgKGlzVk5vZGUocHJvcHNPckNoaWxkcmVuKSkge1xuICAgICAgICByZXR1cm4gY3JlYXRlVk5vZGUodHlwZSwgbnVsbCwgW3Byb3BzT3JDaGlsZHJlbl0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNyZWF0ZVZOb2RlKHR5cGUsIHByb3BzT3JDaGlsZHJlbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBjcmVhdGVWTm9kZSh0eXBlLCBudWxsLCBwcm9wc09yQ2hpbGRyZW4pO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAobCA+IDMpIHtcbiAgICAgIGNoaWxkcmVuID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKTtcbiAgICB9IGVsc2UgaWYgKGwgPT09IDMgJiYgaXNWTm9kZShjaGlsZHJlbikpIHtcbiAgICAgIGNoaWxkcmVuID0gW2NoaWxkcmVuXTtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZVZOb2RlKHR5cGUsIHByb3BzT3JDaGlsZHJlbiwgY2hpbGRyZW4pO1xuICB9XG59XG5cbmNvbnN0IHNzckNvbnRleHRLZXkgPSBTeW1ib2wuZm9yKFwidi1zY3hcIik7XG5jb25zdCB1c2VTU1JDb250ZXh0ID0gKCkgPT4ge1xuICB7XG4gICAgY29uc3QgY3R4ID0gaW5qZWN0KHNzckNvbnRleHRLZXkpO1xuICAgIGlmICghY3R4KSB7XG4gICAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHdhcm4oXG4gICAgICAgIGBTZXJ2ZXIgcmVuZGVyaW5nIGNvbnRleHQgbm90IHByb3ZpZGVkLiBNYWtlIHN1cmUgdG8gb25seSBjYWxsIHVzZVNTUkNvbnRleHQoKSBjb25kaXRpb25hbGx5IGluIHRoZSBzZXJ2ZXIgYnVpbGQuYFxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIGN0eDtcbiAgfVxufTtcblxuZnVuY3Rpb24gaXNTaGFsbG93KHZhbHVlKSB7XG4gIHJldHVybiAhISh2YWx1ZSAmJiB2YWx1ZVtcIl9fdl9pc1NoYWxsb3dcIl0pO1xufVxuXG5mdW5jdGlvbiBpbml0Q3VzdG9tRm9ybWF0dGVyKCkge1xuICBpZiAoISEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgfHwgdHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCB2dWVTdHlsZSA9IHsgc3R5bGU6IFwiY29sb3I6IzNiYTc3NlwiIH07XG4gIGNvbnN0IG51bWJlclN0eWxlID0geyBzdHlsZTogXCJjb2xvcjojMGIxYmM5XCIgfTtcbiAgY29uc3Qgc3RyaW5nU3R5bGUgPSB7IHN0eWxlOiBcImNvbG9yOiNiNjJlMjRcIiB9O1xuICBjb25zdCBrZXl3b3JkU3R5bGUgPSB7IHN0eWxlOiBcImNvbG9yOiM5ZDI4OGNcIiB9O1xuICBjb25zdCBmb3JtYXR0ZXIgPSB7XG4gICAgaGVhZGVyKG9iaikge1xuICAgICAgaWYgKCFpc09iamVjdChvYmopKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKG9iai5fX2lzVnVlKSB7XG4gICAgICAgIHJldHVybiBbXCJkaXZcIiwgdnVlU3R5bGUsIGBWdWVJbnN0YW5jZWBdO1xuICAgICAgfSBlbHNlIGlmIChpc1JlZihvYmopKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgXCJkaXZcIixcbiAgICAgICAgICB7fSxcbiAgICAgICAgICBbXCJzcGFuXCIsIHZ1ZVN0eWxlLCBnZW5SZWZGbGFnKG9iaildLFxuICAgICAgICAgIFwiPFwiLFxuICAgICAgICAgIGZvcm1hdFZhbHVlKG9iai52YWx1ZSksXG4gICAgICAgICAgYD5gXG4gICAgICAgIF07XG4gICAgICB9IGVsc2UgaWYgKGlzUmVhY3RpdmUob2JqKSkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgIFwiZGl2XCIsXG4gICAgICAgICAge30sXG4gICAgICAgICAgW1wic3BhblwiLCB2dWVTdHlsZSwgaXNTaGFsbG93KG9iaikgPyBcIlNoYWxsb3dSZWFjdGl2ZVwiIDogXCJSZWFjdGl2ZVwiXSxcbiAgICAgICAgICBcIjxcIixcbiAgICAgICAgICBmb3JtYXRWYWx1ZShvYmopLFxuICAgICAgICAgIGA+JHtpc1JlYWRvbmx5KG9iaikgPyBgIChyZWFkb25seSlgIDogYGB9YFxuICAgICAgICBdO1xuICAgICAgfSBlbHNlIGlmIChpc1JlYWRvbmx5KG9iaikpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICBcImRpdlwiLFxuICAgICAgICAgIHt9LFxuICAgICAgICAgIFtcInNwYW5cIiwgdnVlU3R5bGUsIGlzU2hhbGxvdyhvYmopID8gXCJTaGFsbG93UmVhZG9ubHlcIiA6IFwiUmVhZG9ubHlcIl0sXG4gICAgICAgICAgXCI8XCIsXG4gICAgICAgICAgZm9ybWF0VmFsdWUob2JqKSxcbiAgICAgICAgICBcIj5cIlxuICAgICAgICBdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcbiAgICBoYXNCb2R5KG9iaikge1xuICAgICAgcmV0dXJuIG9iaiAmJiBvYmouX19pc1Z1ZTtcbiAgICB9LFxuICAgIGJvZHkob2JqKSB7XG4gICAgICBpZiAob2JqICYmIG9iai5fX2lzVnVlKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgXCJkaXZcIixcbiAgICAgICAgICB7fSxcbiAgICAgICAgICAuLi5mb3JtYXRJbnN0YW5jZShvYmouJClcbiAgICAgICAgXTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIGZ1bmN0aW9uIGZvcm1hdEluc3RhbmNlKGluc3RhbmNlKSB7XG4gICAgY29uc3QgYmxvY2tzID0gW107XG4gICAgaWYgKGluc3RhbmNlLnR5cGUucHJvcHMgJiYgaW5zdGFuY2UucHJvcHMpIHtcbiAgICAgIGJsb2Nrcy5wdXNoKGNyZWF0ZUluc3RhbmNlQmxvY2soXCJwcm9wc1wiLCB0b1JhdyhpbnN0YW5jZS5wcm9wcykpKTtcbiAgICB9XG4gICAgaWYgKGluc3RhbmNlLnNldHVwU3RhdGUgIT09IEVNUFRZX09CSikge1xuICAgICAgYmxvY2tzLnB1c2goY3JlYXRlSW5zdGFuY2VCbG9jayhcInNldHVwXCIsIGluc3RhbmNlLnNldHVwU3RhdGUpKTtcbiAgICB9XG4gICAgaWYgKGluc3RhbmNlLmRhdGEgIT09IEVNUFRZX09CSikge1xuICAgICAgYmxvY2tzLnB1c2goY3JlYXRlSW5zdGFuY2VCbG9jayhcImRhdGFcIiwgdG9SYXcoaW5zdGFuY2UuZGF0YSkpKTtcbiAgICB9XG4gICAgY29uc3QgY29tcHV0ZWQgPSBleHRyYWN0S2V5cyhpbnN0YW5jZSwgXCJjb21wdXRlZFwiKTtcbiAgICBpZiAoY29tcHV0ZWQpIHtcbiAgICAgIGJsb2Nrcy5wdXNoKGNyZWF0ZUluc3RhbmNlQmxvY2soXCJjb21wdXRlZFwiLCBjb21wdXRlZCkpO1xuICAgIH1cbiAgICBjb25zdCBpbmplY3RlZCA9IGV4dHJhY3RLZXlzKGluc3RhbmNlLCBcImluamVjdFwiKTtcbiAgICBpZiAoaW5qZWN0ZWQpIHtcbiAgICAgIGJsb2Nrcy5wdXNoKGNyZWF0ZUluc3RhbmNlQmxvY2soXCJpbmplY3RlZFwiLCBpbmplY3RlZCkpO1xuICAgIH1cbiAgICBibG9ja3MucHVzaChbXG4gICAgICBcImRpdlwiLFxuICAgICAge30sXG4gICAgICBbXG4gICAgICAgIFwic3BhblwiLFxuICAgICAgICB7XG4gICAgICAgICAgc3R5bGU6IGtleXdvcmRTdHlsZS5zdHlsZSArIFwiO29wYWNpdHk6MC42NlwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiJCAoaW50ZXJuYWwpOiBcIlxuICAgICAgXSxcbiAgICAgIFtcIm9iamVjdFwiLCB7IG9iamVjdDogaW5zdGFuY2UgfV1cbiAgICBdKTtcbiAgICByZXR1cm4gYmxvY2tzO1xuICB9XG4gIGZ1bmN0aW9uIGNyZWF0ZUluc3RhbmNlQmxvY2sodHlwZSwgdGFyZ2V0KSB7XG4gICAgdGFyZ2V0ID0gZXh0ZW5kKHt9LCB0YXJnZXQpO1xuICAgIGlmICghT2JqZWN0LmtleXModGFyZ2V0KS5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBbXCJzcGFuXCIsIHt9XTtcbiAgICB9XG4gICAgcmV0dXJuIFtcbiAgICAgIFwiZGl2XCIsXG4gICAgICB7IHN0eWxlOiBcImxpbmUtaGVpZ2h0OjEuMjVlbTttYXJnaW4tYm90dG9tOjAuNmVtXCIgfSxcbiAgICAgIFtcbiAgICAgICAgXCJkaXZcIixcbiAgICAgICAge1xuICAgICAgICAgIHN0eWxlOiBcImNvbG9yOiM0NzY1ODJcIlxuICAgICAgICB9LFxuICAgICAgICB0eXBlXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICBcImRpdlwiLFxuICAgICAgICB7XG4gICAgICAgICAgc3R5bGU6IFwicGFkZGluZy1sZWZ0OjEuMjVlbVwiXG4gICAgICAgIH0sXG4gICAgICAgIC4uLk9iamVjdC5rZXlzKHRhcmdldCkubWFwKChrZXkpID0+IHtcbiAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgXCJkaXZcIixcbiAgICAgICAgICAgIHt9LFxuICAgICAgICAgICAgW1wic3BhblwiLCBrZXl3b3JkU3R5bGUsIGtleSArIFwiOiBcIl0sXG4gICAgICAgICAgICBmb3JtYXRWYWx1ZSh0YXJnZXRba2V5XSwgZmFsc2UpXG4gICAgICAgICAgXTtcbiAgICAgICAgfSlcbiAgICAgIF1cbiAgICBdO1xuICB9XG4gIGZ1bmN0aW9uIGZvcm1hdFZhbHVlKHYsIGFzUmF3ID0gdHJ1ZSkge1xuICAgIGlmICh0eXBlb2YgdiA9PT0gXCJudW1iZXJcIikge1xuICAgICAgcmV0dXJuIFtcInNwYW5cIiwgbnVtYmVyU3R5bGUsIHZdO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHYgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJldHVybiBbXCJzcGFuXCIsIHN0cmluZ1N0eWxlLCBKU09OLnN0cmluZ2lmeSh2KV07XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdiA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgIHJldHVybiBbXCJzcGFuXCIsIGtleXdvcmRTdHlsZSwgdl07XG4gICAgfSBlbHNlIGlmIChpc09iamVjdCh2KSkge1xuICAgICAgcmV0dXJuIFtcIm9iamVjdFwiLCB7IG9iamVjdDogYXNSYXcgPyB0b1Jhdyh2KSA6IHYgfV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBbXCJzcGFuXCIsIHN0cmluZ1N0eWxlLCBTdHJpbmcodildO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBleHRyYWN0S2V5cyhpbnN0YW5jZSwgdHlwZSkge1xuICAgIGNvbnN0IENvbXAgPSBpbnN0YW5jZS50eXBlO1xuICAgIGlmIChpc0Z1bmN0aW9uKENvbXApKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGV4dHJhY3RlZCA9IHt9O1xuICAgIGZvciAoY29uc3Qga2V5IGluIGluc3RhbmNlLmN0eCkge1xuICAgICAgaWYgKGlzS2V5T2ZUeXBlKENvbXAsIGtleSwgdHlwZSkpIHtcbiAgICAgICAgZXh0cmFjdGVkW2tleV0gPSBpbnN0YW5jZS5jdHhba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGV4dHJhY3RlZDtcbiAgfVxuICBmdW5jdGlvbiBpc0tleU9mVHlwZShDb21wLCBrZXksIHR5cGUpIHtcbiAgICBjb25zdCBvcHRzID0gQ29tcFt0eXBlXTtcbiAgICBpZiAoaXNBcnJheShvcHRzKSAmJiBvcHRzLmluY2x1ZGVzKGtleSkgfHwgaXNPYmplY3Qob3B0cykgJiYga2V5IGluIG9wdHMpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoQ29tcC5leHRlbmRzICYmIGlzS2V5T2ZUeXBlKENvbXAuZXh0ZW5kcywga2V5LCB0eXBlKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChDb21wLm1peGlucyAmJiBDb21wLm1peGlucy5zb21lKChtKSA9PiBpc0tleU9mVHlwZShtLCBrZXksIHR5cGUpKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGdlblJlZkZsYWcodikge1xuICAgIGlmIChpc1NoYWxsb3codikpIHtcbiAgICAgIHJldHVybiBgU2hhbGxvd1JlZmA7XG4gICAgfVxuICAgIGlmICh2LmVmZmVjdCkge1xuICAgICAgcmV0dXJuIGBDb21wdXRlZFJlZmA7XG4gICAgfVxuICAgIHJldHVybiBgUmVmYDtcbiAgfVxuICBpZiAod2luZG93LmRldnRvb2xzRm9ybWF0dGVycykge1xuICAgIHdpbmRvdy5kZXZ0b29sc0Zvcm1hdHRlcnMucHVzaChmb3JtYXR0ZXIpO1xuICB9IGVsc2Uge1xuICAgIHdpbmRvdy5kZXZ0b29sc0Zvcm1hdHRlcnMgPSBbZm9ybWF0dGVyXTtcbiAgfVxufVxuXG5mdW5jdGlvbiB3aXRoTWVtbyhtZW1vLCByZW5kZXIsIGNhY2hlLCBpbmRleCkge1xuICBjb25zdCBjYWNoZWQgPSBjYWNoZVtpbmRleF07XG4gIGlmIChjYWNoZWQgJiYgaXNNZW1vU2FtZShjYWNoZWQsIG1lbW8pKSB7XG4gICAgcmV0dXJuIGNhY2hlZDtcbiAgfVxuICBjb25zdCByZXQgPSByZW5kZXIoKTtcbiAgcmV0Lm1lbW8gPSBtZW1vLnNsaWNlKCk7XG4gIHJldHVybiBjYWNoZVtpbmRleF0gPSByZXQ7XG59XG5mdW5jdGlvbiBpc01lbW9TYW1lKGNhY2hlZCwgbWVtbykge1xuICBjb25zdCBwcmV2ID0gY2FjaGVkLm1lbW87XG4gIGlmIChwcmV2Lmxlbmd0aCAhPSBtZW1vLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IHByZXYubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoaGFzQ2hhbmdlZChwcmV2W2ldLCBtZW1vW2ldKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBpZiAoaXNCbG9ja1RyZWVFbmFibGVkID4gMCAmJiBjdXJyZW50QmxvY2spIHtcbiAgICBjdXJyZW50QmxvY2sucHVzaChjYWNoZWQpO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG5jb25zdCB2ZXJzaW9uID0gXCIzLjMuNFwiO1xuY29uc3QgX3NzclV0aWxzID0ge1xuICBjcmVhdGVDb21wb25lbnRJbnN0YW5jZSxcbiAgc2V0dXBDb21wb25lbnQsXG4gIHJlbmRlckNvbXBvbmVudFJvb3QsXG4gIHNldEN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSxcbiAgaXNWTm9kZTogaXNWTm9kZSxcbiAgbm9ybWFsaXplVk5vZGVcbn07XG5jb25zdCBzc3JVdGlscyA9IF9zc3JVdGlscyA7XG5jb25zdCByZXNvbHZlRmlsdGVyID0gbnVsbDtcbmNvbnN0IGNvbXBhdFV0aWxzID0gbnVsbDtcblxuZXhwb3J0IHsgQmFzZVRyYW5zaXRpb24sIEJhc2VUcmFuc2l0aW9uUHJvcHNWYWxpZGF0b3JzLCBDb21tZW50LCBGcmFnbWVudCwgS2VlcEFsaXZlLCBTdGF0aWMsIFN1c3BlbnNlLCBUZWxlcG9ydCwgVGV4dCwgYXNzZXJ0TnVtYmVyLCBjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZywgY2FsbFdpdGhFcnJvckhhbmRsaW5nLCBjbG9uZVZOb2RlLCBjb21wYXRVdGlscywgY29tcHV0ZWQsIGNyZWF0ZUJsb2NrLCBjcmVhdGVDb21tZW50Vk5vZGUsIGNyZWF0ZUVsZW1lbnRCbG9jaywgY3JlYXRlQmFzZVZOb2RlIGFzIGNyZWF0ZUVsZW1lbnRWTm9kZSwgY3JlYXRlSHlkcmF0aW9uUmVuZGVyZXIsIGNyZWF0ZVByb3BzUmVzdFByb3h5LCBjcmVhdGVSZW5kZXJlciwgY3JlYXRlU2xvdHMsIGNyZWF0ZVN0YXRpY1ZOb2RlLCBjcmVhdGVUZXh0Vk5vZGUsIGNyZWF0ZVZOb2RlLCBkZWZpbmVBc3luY0NvbXBvbmVudCwgZGVmaW5lQ29tcG9uZW50LCBkZWZpbmVFbWl0cywgZGVmaW5lRXhwb3NlLCBkZWZpbmVNb2RlbCwgZGVmaW5lT3B0aW9ucywgZGVmaW5lUHJvcHMsIGRlZmluZVNsb3RzLCBkZXZ0b29scywgZ2V0Q3VycmVudEluc3RhbmNlLCBnZXRUcmFuc2l0aW9uUmF3Q2hpbGRyZW4sIGd1YXJkUmVhY3RpdmVQcm9wcywgaCwgaGFuZGxlRXJyb3IsIGhhc0luamVjdGlvbkNvbnRleHQsIGluaXRDdXN0b21Gb3JtYXR0ZXIsIGluamVjdCwgaXNNZW1vU2FtZSwgaXNSdW50aW1lT25seSwgaXNWTm9kZSwgbWVyZ2VEZWZhdWx0cywgbWVyZ2VNb2RlbHMsIG1lcmdlUHJvcHMsIG5leHRUaWNrLCBvbkFjdGl2YXRlZCwgb25CZWZvcmVNb3VudCwgb25CZWZvcmVVbm1vdW50LCBvbkJlZm9yZVVwZGF0ZSwgb25EZWFjdGl2YXRlZCwgb25FcnJvckNhcHR1cmVkLCBvbk1vdW50ZWQsIG9uUmVuZGVyVHJhY2tlZCwgb25SZW5kZXJUcmlnZ2VyZWQsIG9uU2VydmVyUHJlZmV0Y2gsIG9uVW5tb3VudGVkLCBvblVwZGF0ZWQsIG9wZW5CbG9jaywgcG9wU2NvcGVJZCwgcHJvdmlkZSwgcHVzaFNjb3BlSWQsIHF1ZXVlUG9zdEZsdXNoQ2IsIHJlZ2lzdGVyUnVudGltZUNvbXBpbGVyLCByZW5kZXJMaXN0LCByZW5kZXJTbG90LCByZXNvbHZlQ29tcG9uZW50LCByZXNvbHZlRGlyZWN0aXZlLCByZXNvbHZlRHluYW1pY0NvbXBvbmVudCwgcmVzb2x2ZUZpbHRlciwgcmVzb2x2ZVRyYW5zaXRpb25Ib29rcywgc2V0QmxvY2tUcmFja2luZywgc2V0RGV2dG9vbHNIb29rLCBzZXRUcmFuc2l0aW9uSG9va3MsIHNzckNvbnRleHRLZXksIHNzclV0aWxzLCB0b0hhbmRsZXJzLCB0cmFuc2Zvcm1WTm9kZUFyZ3MsIHVzZUF0dHJzLCB1c2VNb2RlbCwgdXNlU1NSQ29udGV4dCwgdXNlU2xvdHMsIHVzZVRyYW5zaXRpb25TdGF0ZSwgdmVyc2lvbiwgd2Fybiwgd2F0Y2gsIHdhdGNoRWZmZWN0LCB3YXRjaFBvc3RFZmZlY3QsIHdhdGNoU3luY0VmZmVjdCwgd2l0aEFzeW5jQ29udGV4dCwgd2l0aEN0eCwgd2l0aERlZmF1bHRzLCB3aXRoRGlyZWN0aXZlcywgd2l0aE1lbW8sIHdpdGhTY29wZUlkIH07XG4iLCJpbXBvcnQgeyBleHRlbmQsIGlzQXJyYXksIGlzTWFwLCBpc0ludGVnZXJLZXksIGhhc093biwgaXNTeW1ib2wsIGlzT2JqZWN0LCBoYXNDaGFuZ2VkLCBtYWtlTWFwLCBjYXBpdGFsaXplLCB0b1Jhd1R5cGUsIGRlZiwgaXNGdW5jdGlvbiwgTk9PUCB9IGZyb20gJ0B2dWUvc2hhcmVkJztcblxuZnVuY3Rpb24gd2Fybihtc2csIC4uLmFyZ3MpIHtcbiAgY29uc29sZS53YXJuKGBbVnVlIHdhcm5dICR7bXNnfWAsIC4uLmFyZ3MpO1xufVxuXG5sZXQgYWN0aXZlRWZmZWN0U2NvcGU7XG5jbGFzcyBFZmZlY3RTY29wZSB7XG4gIGNvbnN0cnVjdG9yKGRldGFjaGVkID0gZmFsc2UpIHtcbiAgICB0aGlzLmRldGFjaGVkID0gZGV0YWNoZWQ7XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgdGhpcy5fYWN0aXZlID0gdHJ1ZTtcbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICB0aGlzLmVmZmVjdHMgPSBbXTtcbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICB0aGlzLmNsZWFudXBzID0gW107XG4gICAgdGhpcy5wYXJlbnQgPSBhY3RpdmVFZmZlY3RTY29wZTtcbiAgICBpZiAoIWRldGFjaGVkICYmIGFjdGl2ZUVmZmVjdFNjb3BlKSB7XG4gICAgICB0aGlzLmluZGV4ID0gKGFjdGl2ZUVmZmVjdFNjb3BlLnNjb3BlcyB8fCAoYWN0aXZlRWZmZWN0U2NvcGUuc2NvcGVzID0gW10pKS5wdXNoKFxuICAgICAgICB0aGlzXG4gICAgICApIC0gMTtcbiAgICB9XG4gIH1cbiAgZ2V0IGFjdGl2ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fYWN0aXZlO1xuICB9XG4gIHJ1bihmbikge1xuICAgIGlmICh0aGlzLl9hY3RpdmUpIHtcbiAgICAgIGNvbnN0IGN1cnJlbnRFZmZlY3RTY29wZSA9IGFjdGl2ZUVmZmVjdFNjb3BlO1xuICAgICAgdHJ5IHtcbiAgICAgICAgYWN0aXZlRWZmZWN0U2NvcGUgPSB0aGlzO1xuICAgICAgICByZXR1cm4gZm4oKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGFjdGl2ZUVmZmVjdFNjb3BlID0gY3VycmVudEVmZmVjdFNjb3BlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgd2FybihgY2Fubm90IHJ1biBhbiBpbmFjdGl2ZSBlZmZlY3Qgc2NvcGUuYCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBUaGlzIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBvbiBub24tZGV0YWNoZWQgc2NvcGVzXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgb24oKSB7XG4gICAgYWN0aXZlRWZmZWN0U2NvcGUgPSB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBUaGlzIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBvbiBub24tZGV0YWNoZWQgc2NvcGVzXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgb2ZmKCkge1xuICAgIGFjdGl2ZUVmZmVjdFNjb3BlID0gdGhpcy5wYXJlbnQ7XG4gIH1cbiAgc3RvcChmcm9tUGFyZW50KSB7XG4gICAgaWYgKHRoaXMuX2FjdGl2ZSkge1xuICAgICAgbGV0IGksIGw7XG4gICAgICBmb3IgKGkgPSAwLCBsID0gdGhpcy5lZmZlY3RzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB0aGlzLmVmZmVjdHNbaV0uc3RvcCgpO1xuICAgICAgfVxuICAgICAgZm9yIChpID0gMCwgbCA9IHRoaXMuY2xlYW51cHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHRoaXMuY2xlYW51cHNbaV0oKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnNjb3Blcykge1xuICAgICAgICBmb3IgKGkgPSAwLCBsID0gdGhpcy5zY29wZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgdGhpcy5zY29wZXNbaV0uc3RvcCh0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLmRldGFjaGVkICYmIHRoaXMucGFyZW50ICYmICFmcm9tUGFyZW50KSB7XG4gICAgICAgIGNvbnN0IGxhc3QgPSB0aGlzLnBhcmVudC5zY29wZXMucG9wKCk7XG4gICAgICAgIGlmIChsYXN0ICYmIGxhc3QgIT09IHRoaXMpIHtcbiAgICAgICAgICB0aGlzLnBhcmVudC5zY29wZXNbdGhpcy5pbmRleF0gPSBsYXN0O1xuICAgICAgICAgIGxhc3QuaW5kZXggPSB0aGlzLmluZGV4O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLnBhcmVudCA9IHZvaWQgMDtcbiAgICAgIHRoaXMuX2FjdGl2ZSA9IGZhbHNlO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZWZmZWN0U2NvcGUoZGV0YWNoZWQpIHtcbiAgcmV0dXJuIG5ldyBFZmZlY3RTY29wZShkZXRhY2hlZCk7XG59XG5mdW5jdGlvbiByZWNvcmRFZmZlY3RTY29wZShlZmZlY3QsIHNjb3BlID0gYWN0aXZlRWZmZWN0U2NvcGUpIHtcbiAgaWYgKHNjb3BlICYmIHNjb3BlLmFjdGl2ZSkge1xuICAgIHNjb3BlLmVmZmVjdHMucHVzaChlZmZlY3QpO1xuICB9XG59XG5mdW5jdGlvbiBnZXRDdXJyZW50U2NvcGUoKSB7XG4gIHJldHVybiBhY3RpdmVFZmZlY3RTY29wZTtcbn1cbmZ1bmN0aW9uIG9uU2NvcGVEaXNwb3NlKGZuKSB7XG4gIGlmIChhY3RpdmVFZmZlY3RTY29wZSkge1xuICAgIGFjdGl2ZUVmZmVjdFNjb3BlLmNsZWFudXBzLnB1c2goZm4pO1xuICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICB3YXJuKFxuICAgICAgYG9uU2NvcGVEaXNwb3NlKCkgaXMgY2FsbGVkIHdoZW4gdGhlcmUgaXMgbm8gYWN0aXZlIGVmZmVjdCBzY29wZSB0byBiZSBhc3NvY2lhdGVkIHdpdGguYFxuICAgICk7XG4gIH1cbn1cblxuY29uc3QgY3JlYXRlRGVwID0gKGVmZmVjdHMpID0+IHtcbiAgY29uc3QgZGVwID0gbmV3IFNldChlZmZlY3RzKTtcbiAgZGVwLncgPSAwO1xuICBkZXAubiA9IDA7XG4gIHJldHVybiBkZXA7XG59O1xuY29uc3Qgd2FzVHJhY2tlZCA9IChkZXApID0+IChkZXAudyAmIHRyYWNrT3BCaXQpID4gMDtcbmNvbnN0IG5ld1RyYWNrZWQgPSAoZGVwKSA9PiAoZGVwLm4gJiB0cmFja09wQml0KSA+IDA7XG5jb25zdCBpbml0RGVwTWFya2VycyA9ICh7IGRlcHMgfSkgPT4ge1xuICBpZiAoZGVwcy5sZW5ndGgpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRlcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGRlcHNbaV0udyB8PSB0cmFja09wQml0O1xuICAgIH1cbiAgfVxufTtcbmNvbnN0IGZpbmFsaXplRGVwTWFya2VycyA9IChlZmZlY3QpID0+IHtcbiAgY29uc3QgeyBkZXBzIH0gPSBlZmZlY3Q7XG4gIGlmIChkZXBzLmxlbmd0aCkge1xuICAgIGxldCBwdHIgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGVwcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgZGVwID0gZGVwc1tpXTtcbiAgICAgIGlmICh3YXNUcmFja2VkKGRlcCkgJiYgIW5ld1RyYWNrZWQoZGVwKSkge1xuICAgICAgICBkZXAuZGVsZXRlKGVmZmVjdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZXBzW3B0cisrXSA9IGRlcDtcbiAgICAgIH1cbiAgICAgIGRlcC53ICY9IH50cmFja09wQml0O1xuICAgICAgZGVwLm4gJj0gfnRyYWNrT3BCaXQ7XG4gICAgfVxuICAgIGRlcHMubGVuZ3RoID0gcHRyO1xuICB9XG59O1xuXG5jb25zdCB0YXJnZXRNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbmxldCBlZmZlY3RUcmFja0RlcHRoID0gMDtcbmxldCB0cmFja09wQml0ID0gMTtcbmNvbnN0IG1heE1hcmtlckJpdHMgPSAzMDtcbmxldCBhY3RpdmVFZmZlY3Q7XG5jb25zdCBJVEVSQVRFX0tFWSA9IFN5bWJvbCghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gXCJpdGVyYXRlXCIgOiBcIlwiKTtcbmNvbnN0IE1BUF9LRVlfSVRFUkFURV9LRVkgPSBTeW1ib2woISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IFwiTWFwIGtleSBpdGVyYXRlXCIgOiBcIlwiKTtcbmNsYXNzIFJlYWN0aXZlRWZmZWN0IHtcbiAgY29uc3RydWN0b3IoZm4sIHNjaGVkdWxlciA9IG51bGwsIHNjb3BlKSB7XG4gICAgdGhpcy5mbiA9IGZuO1xuICAgIHRoaXMuc2NoZWR1bGVyID0gc2NoZWR1bGVyO1xuICAgIHRoaXMuYWN0aXZlID0gdHJ1ZTtcbiAgICB0aGlzLmRlcHMgPSBbXTtcbiAgICB0aGlzLnBhcmVudCA9IHZvaWQgMDtcbiAgICByZWNvcmRFZmZlY3RTY29wZSh0aGlzLCBzY29wZSk7XG4gIH1cbiAgcnVuKCkge1xuICAgIGlmICghdGhpcy5hY3RpdmUpIHtcbiAgICAgIHJldHVybiB0aGlzLmZuKCk7XG4gICAgfVxuICAgIGxldCBwYXJlbnQgPSBhY3RpdmVFZmZlY3Q7XG4gICAgbGV0IGxhc3RTaG91bGRUcmFjayA9IHNob3VsZFRyYWNrO1xuICAgIHdoaWxlIChwYXJlbnQpIHtcbiAgICAgIGlmIChwYXJlbnQgPT09IHRoaXMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMucGFyZW50ID0gYWN0aXZlRWZmZWN0O1xuICAgICAgYWN0aXZlRWZmZWN0ID0gdGhpcztcbiAgICAgIHNob3VsZFRyYWNrID0gdHJ1ZTtcbiAgICAgIHRyYWNrT3BCaXQgPSAxIDw8ICsrZWZmZWN0VHJhY2tEZXB0aDtcbiAgICAgIGlmIChlZmZlY3RUcmFja0RlcHRoIDw9IG1heE1hcmtlckJpdHMpIHtcbiAgICAgICAgaW5pdERlcE1hcmtlcnModGhpcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjbGVhbnVwRWZmZWN0KHRoaXMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuZm4oKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKGVmZmVjdFRyYWNrRGVwdGggPD0gbWF4TWFya2VyQml0cykge1xuICAgICAgICBmaW5hbGl6ZURlcE1hcmtlcnModGhpcyk7XG4gICAgICB9XG4gICAgICB0cmFja09wQml0ID0gMSA8PCAtLWVmZmVjdFRyYWNrRGVwdGg7XG4gICAgICBhY3RpdmVFZmZlY3QgPSB0aGlzLnBhcmVudDtcbiAgICAgIHNob3VsZFRyYWNrID0gbGFzdFNob3VsZFRyYWNrO1xuICAgICAgdGhpcy5wYXJlbnQgPSB2b2lkIDA7XG4gICAgICBpZiAodGhpcy5kZWZlclN0b3ApIHtcbiAgICAgICAgdGhpcy5zdG9wKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHN0b3AoKSB7XG4gICAgaWYgKGFjdGl2ZUVmZmVjdCA9PT0gdGhpcykge1xuICAgICAgdGhpcy5kZWZlclN0b3AgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAodGhpcy5hY3RpdmUpIHtcbiAgICAgIGNsZWFudXBFZmZlY3QodGhpcyk7XG4gICAgICBpZiAodGhpcy5vblN0b3ApIHtcbiAgICAgICAgdGhpcy5vblN0b3AoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBjbGVhbnVwRWZmZWN0KGVmZmVjdDIpIHtcbiAgY29uc3QgeyBkZXBzIH0gPSBlZmZlY3QyO1xuICBpZiAoZGVwcy5sZW5ndGgpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRlcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGRlcHNbaV0uZGVsZXRlKGVmZmVjdDIpO1xuICAgIH1cbiAgICBkZXBzLmxlbmd0aCA9IDA7XG4gIH1cbn1cbmZ1bmN0aW9uIGVmZmVjdChmbiwgb3B0aW9ucykge1xuICBpZiAoZm4uZWZmZWN0KSB7XG4gICAgZm4gPSBmbi5lZmZlY3QuZm47XG4gIH1cbiAgY29uc3QgX2VmZmVjdCA9IG5ldyBSZWFjdGl2ZUVmZmVjdChmbik7XG4gIGlmIChvcHRpb25zKSB7XG4gICAgZXh0ZW5kKF9lZmZlY3QsIG9wdGlvbnMpO1xuICAgIGlmIChvcHRpb25zLnNjb3BlKVxuICAgICAgcmVjb3JkRWZmZWN0U2NvcGUoX2VmZmVjdCwgb3B0aW9ucy5zY29wZSk7XG4gIH1cbiAgaWYgKCFvcHRpb25zIHx8ICFvcHRpb25zLmxhenkpIHtcbiAgICBfZWZmZWN0LnJ1bigpO1xuICB9XG4gIGNvbnN0IHJ1bm5lciA9IF9lZmZlY3QucnVuLmJpbmQoX2VmZmVjdCk7XG4gIHJ1bm5lci5lZmZlY3QgPSBfZWZmZWN0O1xuICByZXR1cm4gcnVubmVyO1xufVxuZnVuY3Rpb24gc3RvcChydW5uZXIpIHtcbiAgcnVubmVyLmVmZmVjdC5zdG9wKCk7XG59XG5sZXQgc2hvdWxkVHJhY2sgPSB0cnVlO1xuY29uc3QgdHJhY2tTdGFjayA9IFtdO1xuZnVuY3Rpb24gcGF1c2VUcmFja2luZygpIHtcbiAgdHJhY2tTdGFjay5wdXNoKHNob3VsZFRyYWNrKTtcbiAgc2hvdWxkVHJhY2sgPSBmYWxzZTtcbn1cbmZ1bmN0aW9uIGVuYWJsZVRyYWNraW5nKCkge1xuICB0cmFja1N0YWNrLnB1c2goc2hvdWxkVHJhY2spO1xuICBzaG91bGRUcmFjayA9IHRydWU7XG59XG5mdW5jdGlvbiByZXNldFRyYWNraW5nKCkge1xuICBjb25zdCBsYXN0ID0gdHJhY2tTdGFjay5wb3AoKTtcbiAgc2hvdWxkVHJhY2sgPSBsYXN0ID09PSB2b2lkIDAgPyB0cnVlIDogbGFzdDtcbn1cbmZ1bmN0aW9uIHRyYWNrKHRhcmdldCwgdHlwZSwga2V5KSB7XG4gIGlmIChzaG91bGRUcmFjayAmJiBhY3RpdmVFZmZlY3QpIHtcbiAgICBsZXQgZGVwc01hcCA9IHRhcmdldE1hcC5nZXQodGFyZ2V0KTtcbiAgICBpZiAoIWRlcHNNYXApIHtcbiAgICAgIHRhcmdldE1hcC5zZXQodGFyZ2V0LCBkZXBzTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSk7XG4gICAgfVxuICAgIGxldCBkZXAgPSBkZXBzTWFwLmdldChrZXkpO1xuICAgIGlmICghZGVwKSB7XG4gICAgICBkZXBzTWFwLnNldChrZXksIGRlcCA9IGNyZWF0ZURlcCgpKTtcbiAgICB9XG4gICAgY29uc3QgZXZlbnRJbmZvID0gISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IHsgZWZmZWN0OiBhY3RpdmVFZmZlY3QsIHRhcmdldCwgdHlwZSwga2V5IH0gOiB2b2lkIDA7XG4gICAgdHJhY2tFZmZlY3RzKGRlcCwgZXZlbnRJbmZvKTtcbiAgfVxufVxuZnVuY3Rpb24gdHJhY2tFZmZlY3RzKGRlcCwgZGVidWdnZXJFdmVudEV4dHJhSW5mbykge1xuICBsZXQgc2hvdWxkVHJhY2syID0gZmFsc2U7XG4gIGlmIChlZmZlY3RUcmFja0RlcHRoIDw9IG1heE1hcmtlckJpdHMpIHtcbiAgICBpZiAoIW5ld1RyYWNrZWQoZGVwKSkge1xuICAgICAgZGVwLm4gfD0gdHJhY2tPcEJpdDtcbiAgICAgIHNob3VsZFRyYWNrMiA9ICF3YXNUcmFja2VkKGRlcCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHNob3VsZFRyYWNrMiA9ICFkZXAuaGFzKGFjdGl2ZUVmZmVjdCk7XG4gIH1cbiAgaWYgKHNob3VsZFRyYWNrMikge1xuICAgIGRlcC5hZGQoYWN0aXZlRWZmZWN0KTtcbiAgICBhY3RpdmVFZmZlY3QuZGVwcy5wdXNoKGRlcCk7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgYWN0aXZlRWZmZWN0Lm9uVHJhY2spIHtcbiAgICAgIGFjdGl2ZUVmZmVjdC5vblRyYWNrKFxuICAgICAgICBleHRlbmQoXG4gICAgICAgICAge1xuICAgICAgICAgICAgZWZmZWN0OiBhY3RpdmVFZmZlY3RcbiAgICAgICAgICB9LFxuICAgICAgICAgIGRlYnVnZ2VyRXZlbnRFeHRyYUluZm9cbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHRyaWdnZXIodGFyZ2V0LCB0eXBlLCBrZXksIG5ld1ZhbHVlLCBvbGRWYWx1ZSwgb2xkVGFyZ2V0KSB7XG4gIGNvbnN0IGRlcHNNYXAgPSB0YXJnZXRNYXAuZ2V0KHRhcmdldCk7XG4gIGlmICghZGVwc01hcCkge1xuICAgIHJldHVybjtcbiAgfVxuICBsZXQgZGVwcyA9IFtdO1xuICBpZiAodHlwZSA9PT0gXCJjbGVhclwiKSB7XG4gICAgZGVwcyA9IFsuLi5kZXBzTWFwLnZhbHVlcygpXTtcbiAgfSBlbHNlIGlmIChrZXkgPT09IFwibGVuZ3RoXCIgJiYgaXNBcnJheSh0YXJnZXQpKSB7XG4gICAgY29uc3QgbmV3TGVuZ3RoID0gTnVtYmVyKG5ld1ZhbHVlKTtcbiAgICBkZXBzTWFwLmZvckVhY2goKGRlcCwga2V5MikgPT4ge1xuICAgICAgaWYgKGtleTIgPT09IFwibGVuZ3RoXCIgfHwga2V5MiA+PSBuZXdMZW5ndGgpIHtcbiAgICAgICAgZGVwcy5wdXNoKGRlcCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKGtleSAhPT0gdm9pZCAwKSB7XG4gICAgICBkZXBzLnB1c2goZGVwc01hcC5nZXQoa2V5KSk7XG4gICAgfVxuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSBcImFkZFwiOlxuICAgICAgICBpZiAoIWlzQXJyYXkodGFyZ2V0KSkge1xuICAgICAgICAgIGRlcHMucHVzaChkZXBzTWFwLmdldChJVEVSQVRFX0tFWSkpO1xuICAgICAgICAgIGlmIChpc01hcCh0YXJnZXQpKSB7XG4gICAgICAgICAgICBkZXBzLnB1c2goZGVwc01hcC5nZXQoTUFQX0tFWV9JVEVSQVRFX0tFWSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChpc0ludGVnZXJLZXkoa2V5KSkge1xuICAgICAgICAgIGRlcHMucHVzaChkZXBzTWFwLmdldChcImxlbmd0aFwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiZGVsZXRlXCI6XG4gICAgICAgIGlmICghaXNBcnJheSh0YXJnZXQpKSB7XG4gICAgICAgICAgZGVwcy5wdXNoKGRlcHNNYXAuZ2V0KElURVJBVEVfS0VZKSk7XG4gICAgICAgICAgaWYgKGlzTWFwKHRhcmdldCkpIHtcbiAgICAgICAgICAgIGRlcHMucHVzaChkZXBzTWFwLmdldChNQVBfS0VZX0lURVJBVEVfS0VZKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInNldFwiOlxuICAgICAgICBpZiAoaXNNYXAodGFyZ2V0KSkge1xuICAgICAgICAgIGRlcHMucHVzaChkZXBzTWFwLmdldChJVEVSQVRFX0tFWSkpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBjb25zdCBldmVudEluZm8gPSAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8geyB0YXJnZXQsIHR5cGUsIGtleSwgbmV3VmFsdWUsIG9sZFZhbHVlLCBvbGRUYXJnZXQgfSA6IHZvaWQgMDtcbiAgaWYgKGRlcHMubGVuZ3RoID09PSAxKSB7XG4gICAgaWYgKGRlcHNbMF0pIHtcbiAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgIHRyaWdnZXJFZmZlY3RzKGRlcHNbMF0sIGV2ZW50SW5mbyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0cmlnZ2VyRWZmZWN0cyhkZXBzWzBdKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgZWZmZWN0cyA9IFtdO1xuICAgIGZvciAoY29uc3QgZGVwIG9mIGRlcHMpIHtcbiAgICAgIGlmIChkZXApIHtcbiAgICAgICAgZWZmZWN0cy5wdXNoKC4uLmRlcCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICB0cmlnZ2VyRWZmZWN0cyhjcmVhdGVEZXAoZWZmZWN0cyksIGV2ZW50SW5mbyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyaWdnZXJFZmZlY3RzKGNyZWF0ZURlcChlZmZlY3RzKSk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiB0cmlnZ2VyRWZmZWN0cyhkZXAsIGRlYnVnZ2VyRXZlbnRFeHRyYUluZm8pIHtcbiAgY29uc3QgZWZmZWN0cyA9IGlzQXJyYXkoZGVwKSA/IGRlcCA6IFsuLi5kZXBdO1xuICBmb3IgKGNvbnN0IGVmZmVjdDIgb2YgZWZmZWN0cykge1xuICAgIGlmIChlZmZlY3QyLmNvbXB1dGVkKSB7XG4gICAgICB0cmlnZ2VyRWZmZWN0KGVmZmVjdDIsIGRlYnVnZ2VyRXZlbnRFeHRyYUluZm8pO1xuICAgIH1cbiAgfVxuICBmb3IgKGNvbnN0IGVmZmVjdDIgb2YgZWZmZWN0cykge1xuICAgIGlmICghZWZmZWN0Mi5jb21wdXRlZCkge1xuICAgICAgdHJpZ2dlckVmZmVjdChlZmZlY3QyLCBkZWJ1Z2dlckV2ZW50RXh0cmFJbmZvKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHRyaWdnZXJFZmZlY3QoZWZmZWN0MiwgZGVidWdnZXJFdmVudEV4dHJhSW5mbykge1xuICBpZiAoZWZmZWN0MiAhPT0gYWN0aXZlRWZmZWN0IHx8IGVmZmVjdDIuYWxsb3dSZWN1cnNlKSB7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgZWZmZWN0Mi5vblRyaWdnZXIpIHtcbiAgICAgIGVmZmVjdDIub25UcmlnZ2VyKGV4dGVuZCh7IGVmZmVjdDogZWZmZWN0MiB9LCBkZWJ1Z2dlckV2ZW50RXh0cmFJbmZvKSk7XG4gICAgfVxuICAgIGlmIChlZmZlY3QyLnNjaGVkdWxlcikge1xuICAgICAgZWZmZWN0Mi5zY2hlZHVsZXIoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWZmZWN0Mi5ydW4oKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGdldERlcEZyb21SZWFjdGl2ZShvYmplY3QsIGtleSkge1xuICB2YXIgX2E7XG4gIHJldHVybiAoX2EgPSB0YXJnZXRNYXAuZ2V0KG9iamVjdCkpID09IG51bGwgPyB2b2lkIDAgOiBfYS5nZXQoa2V5KTtcbn1cblxuY29uc3QgaXNOb25UcmFja2FibGVLZXlzID0gLyogQF9fUFVSRV9fICovIG1ha2VNYXAoYF9fcHJvdG9fXyxfX3ZfaXNSZWYsX19pc1Z1ZWApO1xuY29uc3QgYnVpbHRJblN5bWJvbHMgPSBuZXcgU2V0KFxuICAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoU3ltYm9sKS5maWx0ZXIoKGtleSkgPT4ga2V5ICE9PSBcImFyZ3VtZW50c1wiICYmIGtleSAhPT0gXCJjYWxsZXJcIikubWFwKChrZXkpID0+IFN5bWJvbFtrZXldKS5maWx0ZXIoaXNTeW1ib2wpXG4pO1xuY29uc3QgZ2V0JDEgPSAvKiBAX19QVVJFX18gKi8gY3JlYXRlR2V0dGVyKCk7XG5jb25zdCBzaGFsbG93R2V0ID0gLyogQF9fUFVSRV9fICovIGNyZWF0ZUdldHRlcihmYWxzZSwgdHJ1ZSk7XG5jb25zdCByZWFkb25seUdldCA9IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVHZXR0ZXIodHJ1ZSk7XG5jb25zdCBzaGFsbG93UmVhZG9ubHlHZXQgPSAvKiBAX19QVVJFX18gKi8gY3JlYXRlR2V0dGVyKHRydWUsIHRydWUpO1xuY29uc3QgYXJyYXlJbnN0cnVtZW50YXRpb25zID0gLyogQF9fUFVSRV9fICovIGNyZWF0ZUFycmF5SW5zdHJ1bWVudGF0aW9ucygpO1xuZnVuY3Rpb24gY3JlYXRlQXJyYXlJbnN0cnVtZW50YXRpb25zKCkge1xuICBjb25zdCBpbnN0cnVtZW50YXRpb25zID0ge307XG4gIFtcImluY2x1ZGVzXCIsIFwiaW5kZXhPZlwiLCBcImxhc3RJbmRleE9mXCJdLmZvckVhY2goKGtleSkgPT4ge1xuICAgIGluc3RydW1lbnRhdGlvbnNba2V5XSA9IGZ1bmN0aW9uKC4uLmFyZ3MpIHtcbiAgICAgIGNvbnN0IGFyciA9IHRvUmF3KHRoaXMpO1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSB0aGlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB0cmFjayhhcnIsIFwiZ2V0XCIsIGkgKyBcIlwiKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlcyA9IGFycltrZXldKC4uLmFyZ3MpO1xuICAgICAgaWYgKHJlcyA9PT0gLTEgfHwgcmVzID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gYXJyW2tleV0oLi4uYXJncy5tYXAodG9SYXcpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgICB9XG4gICAgfTtcbiAgfSk7XG4gIFtcInB1c2hcIiwgXCJwb3BcIiwgXCJzaGlmdFwiLCBcInVuc2hpZnRcIiwgXCJzcGxpY2VcIl0uZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgaW5zdHJ1bWVudGF0aW9uc1trZXldID0gZnVuY3Rpb24oLi4uYXJncykge1xuICAgICAgcGF1c2VUcmFja2luZygpO1xuICAgICAgY29uc3QgcmVzID0gdG9SYXcodGhpcylba2V5XS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgIHJlc2V0VHJhY2tpbmcoKTtcbiAgICAgIHJldHVybiByZXM7XG4gICAgfTtcbiAgfSk7XG4gIHJldHVybiBpbnN0cnVtZW50YXRpb25zO1xufVxuZnVuY3Rpb24gaGFzT3duUHJvcGVydHkoa2V5KSB7XG4gIGNvbnN0IG9iaiA9IHRvUmF3KHRoaXMpO1xuICB0cmFjayhvYmosIFwiaGFzXCIsIGtleSk7XG4gIHJldHVybiBvYmouaGFzT3duUHJvcGVydHkoa2V5KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUdldHRlcihpc1JlYWRvbmx5MiA9IGZhbHNlLCBzaGFsbG93ID0gZmFsc2UpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGdldDIodGFyZ2V0LCBrZXksIHJlY2VpdmVyKSB7XG4gICAgaWYgKGtleSA9PT0gXCJfX3ZfaXNSZWFjdGl2ZVwiKSB7XG4gICAgICByZXR1cm4gIWlzUmVhZG9ubHkyO1xuICAgIH0gZWxzZSBpZiAoa2V5ID09PSBcIl9fdl9pc1JlYWRvbmx5XCIpIHtcbiAgICAgIHJldHVybiBpc1JlYWRvbmx5MjtcbiAgICB9IGVsc2UgaWYgKGtleSA9PT0gXCJfX3ZfaXNTaGFsbG93XCIpIHtcbiAgICAgIHJldHVybiBzaGFsbG93O1xuICAgIH0gZWxzZSBpZiAoa2V5ID09PSBcIl9fdl9yYXdcIiAmJiByZWNlaXZlciA9PT0gKGlzUmVhZG9ubHkyID8gc2hhbGxvdyA/IHNoYWxsb3dSZWFkb25seU1hcCA6IHJlYWRvbmx5TWFwIDogc2hhbGxvdyA/IHNoYWxsb3dSZWFjdGl2ZU1hcCA6IHJlYWN0aXZlTWFwKS5nZXQodGFyZ2V0KSkge1xuICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG4gICAgY29uc3QgdGFyZ2V0SXNBcnJheSA9IGlzQXJyYXkodGFyZ2V0KTtcbiAgICBpZiAoIWlzUmVhZG9ubHkyKSB7XG4gICAgICBpZiAodGFyZ2V0SXNBcnJheSAmJiBoYXNPd24oYXJyYXlJbnN0cnVtZW50YXRpb25zLCBrZXkpKSB7XG4gICAgICAgIHJldHVybiBSZWZsZWN0LmdldChhcnJheUluc3RydW1lbnRhdGlvbnMsIGtleSwgcmVjZWl2ZXIpO1xuICAgICAgfVxuICAgICAgaWYgKGtleSA9PT0gXCJoYXNPd25Qcm9wZXJ0eVwiKSB7XG4gICAgICAgIHJldHVybiBoYXNPd25Qcm9wZXJ0eTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgcmVzID0gUmVmbGVjdC5nZXQodGFyZ2V0LCBrZXksIHJlY2VpdmVyKTtcbiAgICBpZiAoaXNTeW1ib2woa2V5KSA/IGJ1aWx0SW5TeW1ib2xzLmhhcyhrZXkpIDogaXNOb25UcmFja2FibGVLZXlzKGtleSkpIHtcbiAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIGlmICghaXNSZWFkb25seTIpIHtcbiAgICAgIHRyYWNrKHRhcmdldCwgXCJnZXRcIiwga2V5KTtcbiAgICB9XG4gICAgaWYgKHNoYWxsb3cpIHtcbiAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIGlmIChpc1JlZihyZXMpKSB7XG4gICAgICByZXR1cm4gdGFyZ2V0SXNBcnJheSAmJiBpc0ludGVnZXJLZXkoa2V5KSA/IHJlcyA6IHJlcy52YWx1ZTtcbiAgICB9XG4gICAgaWYgKGlzT2JqZWN0KHJlcykpIHtcbiAgICAgIHJldHVybiBpc1JlYWRvbmx5MiA/IHJlYWRvbmx5KHJlcykgOiByZWFjdGl2ZShyZXMpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xuICB9O1xufVxuY29uc3Qgc2V0JDEgPSAvKiBAX19QVVJFX18gKi8gY3JlYXRlU2V0dGVyKCk7XG5jb25zdCBzaGFsbG93U2V0ID0gLyogQF9fUFVSRV9fICovIGNyZWF0ZVNldHRlcih0cnVlKTtcbmZ1bmN0aW9uIGNyZWF0ZVNldHRlcihzaGFsbG93ID0gZmFsc2UpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHNldDIodGFyZ2V0LCBrZXksIHZhbHVlLCByZWNlaXZlcikge1xuICAgIGxldCBvbGRWYWx1ZSA9IHRhcmdldFtrZXldO1xuICAgIGlmIChpc1JlYWRvbmx5KG9sZFZhbHVlKSAmJiBpc1JlZihvbGRWYWx1ZSkgJiYgIWlzUmVmKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoIXNoYWxsb3cpIHtcbiAgICAgIGlmICghaXNTaGFsbG93KHZhbHVlKSAmJiAhaXNSZWFkb25seSh2YWx1ZSkpIHtcbiAgICAgICAgb2xkVmFsdWUgPSB0b1JhdyhvbGRWYWx1ZSk7XG4gICAgICAgIHZhbHVlID0gdG9SYXcodmFsdWUpO1xuICAgICAgfVxuICAgICAgaWYgKCFpc0FycmF5KHRhcmdldCkgJiYgaXNSZWYob2xkVmFsdWUpICYmICFpc1JlZih2YWx1ZSkpIHtcbiAgICAgICAgb2xkVmFsdWUudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGhhZEtleSA9IGlzQXJyYXkodGFyZ2V0KSAmJiBpc0ludGVnZXJLZXkoa2V5KSA/IE51bWJlcihrZXkpIDwgdGFyZ2V0Lmxlbmd0aCA6IGhhc093bih0YXJnZXQsIGtleSk7XG4gICAgY29uc3QgcmVzdWx0ID0gUmVmbGVjdC5zZXQodGFyZ2V0LCBrZXksIHZhbHVlLCByZWNlaXZlcik7XG4gICAgaWYgKHRhcmdldCA9PT0gdG9SYXcocmVjZWl2ZXIpKSB7XG4gICAgICBpZiAoIWhhZEtleSkge1xuICAgICAgICB0cmlnZ2VyKHRhcmdldCwgXCJhZGRcIiwga2V5LCB2YWx1ZSk7XG4gICAgICB9IGVsc2UgaWYgKGhhc0NoYW5nZWQodmFsdWUsIG9sZFZhbHVlKSkge1xuICAgICAgICB0cmlnZ2VyKHRhcmdldCwgXCJzZXRcIiwga2V5LCB2YWx1ZSwgb2xkVmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xufVxuZnVuY3Rpb24gZGVsZXRlUHJvcGVydHkodGFyZ2V0LCBrZXkpIHtcbiAgY29uc3QgaGFkS2V5ID0gaGFzT3duKHRhcmdldCwga2V5KTtcbiAgY29uc3Qgb2xkVmFsdWUgPSB0YXJnZXRba2V5XTtcbiAgY29uc3QgcmVzdWx0ID0gUmVmbGVjdC5kZWxldGVQcm9wZXJ0eSh0YXJnZXQsIGtleSk7XG4gIGlmIChyZXN1bHQgJiYgaGFkS2V5KSB7XG4gICAgdHJpZ2dlcih0YXJnZXQsIFwiZGVsZXRlXCIsIGtleSwgdm9pZCAwLCBvbGRWYWx1ZSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGhhcyQxKHRhcmdldCwga2V5KSB7XG4gIGNvbnN0IHJlc3VsdCA9IFJlZmxlY3QuaGFzKHRhcmdldCwga2V5KTtcbiAgaWYgKCFpc1N5bWJvbChrZXkpIHx8ICFidWlsdEluU3ltYm9scy5oYXMoa2V5KSkge1xuICAgIHRyYWNrKHRhcmdldCwgXCJoYXNcIiwga2V5KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gb3duS2V5cyh0YXJnZXQpIHtcbiAgdHJhY2sodGFyZ2V0LCBcIml0ZXJhdGVcIiwgaXNBcnJheSh0YXJnZXQpID8gXCJsZW5ndGhcIiA6IElURVJBVEVfS0VZKTtcbiAgcmV0dXJuIFJlZmxlY3Qub3duS2V5cyh0YXJnZXQpO1xufVxuY29uc3QgbXV0YWJsZUhhbmRsZXJzID0ge1xuICBnZXQ6IGdldCQxLFxuICBzZXQ6IHNldCQxLFxuICBkZWxldGVQcm9wZXJ0eSxcbiAgaGFzOiBoYXMkMSxcbiAgb3duS2V5c1xufTtcbmNvbnN0IHJlYWRvbmx5SGFuZGxlcnMgPSB7XG4gIGdldDogcmVhZG9ubHlHZXQsXG4gIHNldCh0YXJnZXQsIGtleSkge1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICB3YXJuKFxuICAgICAgICBgU2V0IG9wZXJhdGlvbiBvbiBrZXkgXCIke1N0cmluZyhrZXkpfVwiIGZhaWxlZDogdGFyZ2V0IGlzIHJlYWRvbmx5LmAsXG4gICAgICAgIHRhcmdldFxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sXG4gIGRlbGV0ZVByb3BlcnR5KHRhcmdldCwga2V5KSB7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIGBEZWxldGUgb3BlcmF0aW9uIG9uIGtleSBcIiR7U3RyaW5nKGtleSl9XCIgZmFpbGVkOiB0YXJnZXQgaXMgcmVhZG9ubHkuYCxcbiAgICAgICAgdGFyZ2V0XG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcbmNvbnN0IHNoYWxsb3dSZWFjdGl2ZUhhbmRsZXJzID0gLyogQF9fUFVSRV9fICovIGV4dGVuZChcbiAge30sXG4gIG11dGFibGVIYW5kbGVycyxcbiAge1xuICAgIGdldDogc2hhbGxvd0dldCxcbiAgICBzZXQ6IHNoYWxsb3dTZXRcbiAgfVxuKTtcbmNvbnN0IHNoYWxsb3dSZWFkb25seUhhbmRsZXJzID0gLyogQF9fUFVSRV9fICovIGV4dGVuZChcbiAge30sXG4gIHJlYWRvbmx5SGFuZGxlcnMsXG4gIHtcbiAgICBnZXQ6IHNoYWxsb3dSZWFkb25seUdldFxuICB9XG4pO1xuXG5jb25zdCB0b1NoYWxsb3cgPSAodmFsdWUpID0+IHZhbHVlO1xuY29uc3QgZ2V0UHJvdG8gPSAodikgPT4gUmVmbGVjdC5nZXRQcm90b3R5cGVPZih2KTtcbmZ1bmN0aW9uIGdldCh0YXJnZXQsIGtleSwgaXNSZWFkb25seSA9IGZhbHNlLCBpc1NoYWxsb3cgPSBmYWxzZSkge1xuICB0YXJnZXQgPSB0YXJnZXRbXCJfX3ZfcmF3XCJdO1xuICBjb25zdCByYXdUYXJnZXQgPSB0b1Jhdyh0YXJnZXQpO1xuICBjb25zdCByYXdLZXkgPSB0b1JhdyhrZXkpO1xuICBpZiAoIWlzUmVhZG9ubHkpIHtcbiAgICBpZiAoa2V5ICE9PSByYXdLZXkpIHtcbiAgICAgIHRyYWNrKHJhd1RhcmdldCwgXCJnZXRcIiwga2V5KTtcbiAgICB9XG4gICAgdHJhY2socmF3VGFyZ2V0LCBcImdldFwiLCByYXdLZXkpO1xuICB9XG4gIGNvbnN0IHsgaGFzOiBoYXMyIH0gPSBnZXRQcm90byhyYXdUYXJnZXQpO1xuICBjb25zdCB3cmFwID0gaXNTaGFsbG93ID8gdG9TaGFsbG93IDogaXNSZWFkb25seSA/IHRvUmVhZG9ubHkgOiB0b1JlYWN0aXZlO1xuICBpZiAoaGFzMi5jYWxsKHJhd1RhcmdldCwga2V5KSkge1xuICAgIHJldHVybiB3cmFwKHRhcmdldC5nZXQoa2V5KSk7XG4gIH0gZWxzZSBpZiAoaGFzMi5jYWxsKHJhd1RhcmdldCwgcmF3S2V5KSkge1xuICAgIHJldHVybiB3cmFwKHRhcmdldC5nZXQocmF3S2V5KSk7XG4gIH0gZWxzZSBpZiAodGFyZ2V0ICE9PSByYXdUYXJnZXQpIHtcbiAgICB0YXJnZXQuZ2V0KGtleSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGhhcyhrZXksIGlzUmVhZG9ubHkgPSBmYWxzZSkge1xuICBjb25zdCB0YXJnZXQgPSB0aGlzW1wiX192X3Jhd1wiXTtcbiAgY29uc3QgcmF3VGFyZ2V0ID0gdG9SYXcodGFyZ2V0KTtcbiAgY29uc3QgcmF3S2V5ID0gdG9SYXcoa2V5KTtcbiAgaWYgKCFpc1JlYWRvbmx5KSB7XG4gICAgaWYgKGtleSAhPT0gcmF3S2V5KSB7XG4gICAgICB0cmFjayhyYXdUYXJnZXQsIFwiaGFzXCIsIGtleSk7XG4gICAgfVxuICAgIHRyYWNrKHJhd1RhcmdldCwgXCJoYXNcIiwgcmF3S2V5KTtcbiAgfVxuICByZXR1cm4ga2V5ID09PSByYXdLZXkgPyB0YXJnZXQuaGFzKGtleSkgOiB0YXJnZXQuaGFzKGtleSkgfHwgdGFyZ2V0LmhhcyhyYXdLZXkpO1xufVxuZnVuY3Rpb24gc2l6ZSh0YXJnZXQsIGlzUmVhZG9ubHkgPSBmYWxzZSkge1xuICB0YXJnZXQgPSB0YXJnZXRbXCJfX3ZfcmF3XCJdO1xuICAhaXNSZWFkb25seSAmJiB0cmFjayh0b1Jhdyh0YXJnZXQpLCBcIml0ZXJhdGVcIiwgSVRFUkFURV9LRVkpO1xuICByZXR1cm4gUmVmbGVjdC5nZXQodGFyZ2V0LCBcInNpemVcIiwgdGFyZ2V0KTtcbn1cbmZ1bmN0aW9uIGFkZCh2YWx1ZSkge1xuICB2YWx1ZSA9IHRvUmF3KHZhbHVlKTtcbiAgY29uc3QgdGFyZ2V0ID0gdG9SYXcodGhpcyk7XG4gIGNvbnN0IHByb3RvID0gZ2V0UHJvdG8odGFyZ2V0KTtcbiAgY29uc3QgaGFkS2V5ID0gcHJvdG8uaGFzLmNhbGwodGFyZ2V0LCB2YWx1ZSk7XG4gIGlmICghaGFkS2V5KSB7XG4gICAgdGFyZ2V0LmFkZCh2YWx1ZSk7XG4gICAgdHJpZ2dlcih0YXJnZXQsIFwiYWRkXCIsIHZhbHVlLCB2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59XG5mdW5jdGlvbiBzZXQoa2V5LCB2YWx1ZSkge1xuICB2YWx1ZSA9IHRvUmF3KHZhbHVlKTtcbiAgY29uc3QgdGFyZ2V0ID0gdG9SYXcodGhpcyk7XG4gIGNvbnN0IHsgaGFzOiBoYXMyLCBnZXQ6IGdldDIgfSA9IGdldFByb3RvKHRhcmdldCk7XG4gIGxldCBoYWRLZXkgPSBoYXMyLmNhbGwodGFyZ2V0LCBrZXkpO1xuICBpZiAoIWhhZEtleSkge1xuICAgIGtleSA9IHRvUmF3KGtleSk7XG4gICAgaGFkS2V5ID0gaGFzMi5jYWxsKHRhcmdldCwga2V5KTtcbiAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgY2hlY2tJZGVudGl0eUtleXModGFyZ2V0LCBoYXMyLCBrZXkpO1xuICB9XG4gIGNvbnN0IG9sZFZhbHVlID0gZ2V0Mi5jYWxsKHRhcmdldCwga2V5KTtcbiAgdGFyZ2V0LnNldChrZXksIHZhbHVlKTtcbiAgaWYgKCFoYWRLZXkpIHtcbiAgICB0cmlnZ2VyKHRhcmdldCwgXCJhZGRcIiwga2V5LCB2YWx1ZSk7XG4gIH0gZWxzZSBpZiAoaGFzQ2hhbmdlZCh2YWx1ZSwgb2xkVmFsdWUpKSB7XG4gICAgdHJpZ2dlcih0YXJnZXQsIFwic2V0XCIsIGtleSwgdmFsdWUsIG9sZFZhbHVlKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn1cbmZ1bmN0aW9uIGRlbGV0ZUVudHJ5KGtleSkge1xuICBjb25zdCB0YXJnZXQgPSB0b1Jhdyh0aGlzKTtcbiAgY29uc3QgeyBoYXM6IGhhczIsIGdldDogZ2V0MiB9ID0gZ2V0UHJvdG8odGFyZ2V0KTtcbiAgbGV0IGhhZEtleSA9IGhhczIuY2FsbCh0YXJnZXQsIGtleSk7XG4gIGlmICghaGFkS2V5KSB7XG4gICAga2V5ID0gdG9SYXcoa2V5KTtcbiAgICBoYWRLZXkgPSBoYXMyLmNhbGwodGFyZ2V0LCBrZXkpO1xuICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICBjaGVja0lkZW50aXR5S2V5cyh0YXJnZXQsIGhhczIsIGtleSk7XG4gIH1cbiAgY29uc3Qgb2xkVmFsdWUgPSBnZXQyID8gZ2V0Mi5jYWxsKHRhcmdldCwga2V5KSA6IHZvaWQgMDtcbiAgY29uc3QgcmVzdWx0ID0gdGFyZ2V0LmRlbGV0ZShrZXkpO1xuICBpZiAoaGFkS2V5KSB7XG4gICAgdHJpZ2dlcih0YXJnZXQsIFwiZGVsZXRlXCIsIGtleSwgdm9pZCAwLCBvbGRWYWx1ZSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGNsZWFyKCkge1xuICBjb25zdCB0YXJnZXQgPSB0b1Jhdyh0aGlzKTtcbiAgY29uc3QgaGFkSXRlbXMgPSB0YXJnZXQuc2l6ZSAhPT0gMDtcbiAgY29uc3Qgb2xkVGFyZ2V0ID0gISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IGlzTWFwKHRhcmdldCkgPyBuZXcgTWFwKHRhcmdldCkgOiBuZXcgU2V0KHRhcmdldCkgOiB2b2lkIDA7XG4gIGNvbnN0IHJlc3VsdCA9IHRhcmdldC5jbGVhcigpO1xuICBpZiAoaGFkSXRlbXMpIHtcbiAgICB0cmlnZ2VyKHRhcmdldCwgXCJjbGVhclwiLCB2b2lkIDAsIHZvaWQgMCwgb2xkVGFyZ2V0KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gY3JlYXRlRm9yRWFjaChpc1JlYWRvbmx5LCBpc1NoYWxsb3cpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGZvckVhY2goY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICBjb25zdCBvYnNlcnZlZCA9IHRoaXM7XG4gICAgY29uc3QgdGFyZ2V0ID0gb2JzZXJ2ZWRbXCJfX3ZfcmF3XCJdO1xuICAgIGNvbnN0IHJhd1RhcmdldCA9IHRvUmF3KHRhcmdldCk7XG4gICAgY29uc3Qgd3JhcCA9IGlzU2hhbGxvdyA/IHRvU2hhbGxvdyA6IGlzUmVhZG9ubHkgPyB0b1JlYWRvbmx5IDogdG9SZWFjdGl2ZTtcbiAgICAhaXNSZWFkb25seSAmJiB0cmFjayhyYXdUYXJnZXQsIFwiaXRlcmF0ZVwiLCBJVEVSQVRFX0tFWSk7XG4gICAgcmV0dXJuIHRhcmdldC5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICByZXR1cm4gY2FsbGJhY2suY2FsbCh0aGlzQXJnLCB3cmFwKHZhbHVlKSwgd3JhcChrZXkpLCBvYnNlcnZlZCk7XG4gICAgfSk7XG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVJdGVyYWJsZU1ldGhvZChtZXRob2QsIGlzUmVhZG9ubHksIGlzU2hhbGxvdykge1xuICByZXR1cm4gZnVuY3Rpb24oLi4uYXJncykge1xuICAgIGNvbnN0IHRhcmdldCA9IHRoaXNbXCJfX3ZfcmF3XCJdO1xuICAgIGNvbnN0IHJhd1RhcmdldCA9IHRvUmF3KHRhcmdldCk7XG4gICAgY29uc3QgdGFyZ2V0SXNNYXAgPSBpc01hcChyYXdUYXJnZXQpO1xuICAgIGNvbnN0IGlzUGFpciA9IG1ldGhvZCA9PT0gXCJlbnRyaWVzXCIgfHwgbWV0aG9kID09PSBTeW1ib2wuaXRlcmF0b3IgJiYgdGFyZ2V0SXNNYXA7XG4gICAgY29uc3QgaXNLZXlPbmx5ID0gbWV0aG9kID09PSBcImtleXNcIiAmJiB0YXJnZXRJc01hcDtcbiAgICBjb25zdCBpbm5lckl0ZXJhdG9yID0gdGFyZ2V0W21ldGhvZF0oLi4uYXJncyk7XG4gICAgY29uc3Qgd3JhcCA9IGlzU2hhbGxvdyA/IHRvU2hhbGxvdyA6IGlzUmVhZG9ubHkgPyB0b1JlYWRvbmx5IDogdG9SZWFjdGl2ZTtcbiAgICAhaXNSZWFkb25seSAmJiB0cmFjayhcbiAgICAgIHJhd1RhcmdldCxcbiAgICAgIFwiaXRlcmF0ZVwiLFxuICAgICAgaXNLZXlPbmx5ID8gTUFQX0tFWV9JVEVSQVRFX0tFWSA6IElURVJBVEVfS0VZXG4gICAgKTtcbiAgICByZXR1cm4ge1xuICAgICAgLy8gaXRlcmF0b3IgcHJvdG9jb2xcbiAgICAgIG5leHQoKSB7XG4gICAgICAgIGNvbnN0IHsgdmFsdWUsIGRvbmUgfSA9IGlubmVySXRlcmF0b3IubmV4dCgpO1xuICAgICAgICByZXR1cm4gZG9uZSA/IHsgdmFsdWUsIGRvbmUgfSA6IHtcbiAgICAgICAgICB2YWx1ZTogaXNQYWlyID8gW3dyYXAodmFsdWVbMF0pLCB3cmFwKHZhbHVlWzFdKV0gOiB3cmFwKHZhbHVlKSxcbiAgICAgICAgICBkb25lXG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgLy8gaXRlcmFibGUgcHJvdG9jb2xcbiAgICAgIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICB9O1xuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlUmVhZG9ubHlNZXRob2QodHlwZSkge1xuICByZXR1cm4gZnVuY3Rpb24oLi4uYXJncykge1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICBjb25zdCBrZXkgPSBhcmdzWzBdID8gYG9uIGtleSBcIiR7YXJnc1swXX1cIiBgIDogYGA7XG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgIGAke2NhcGl0YWxpemUodHlwZSl9IG9wZXJhdGlvbiAke2tleX1mYWlsZWQ6IHRhcmdldCBpcyByZWFkb25seS5gLFxuICAgICAgICB0b1Jhdyh0aGlzKVxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHR5cGUgPT09IFwiZGVsZXRlXCIgPyBmYWxzZSA6IHRoaXM7XG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVJbnN0cnVtZW50YXRpb25zKCkge1xuICBjb25zdCBtdXRhYmxlSW5zdHJ1bWVudGF0aW9uczIgPSB7XG4gICAgZ2V0KGtleSkge1xuICAgICAgcmV0dXJuIGdldCh0aGlzLCBrZXkpO1xuICAgIH0sXG4gICAgZ2V0IHNpemUoKSB7XG4gICAgICByZXR1cm4gc2l6ZSh0aGlzKTtcbiAgICB9LFxuICAgIGhhcyxcbiAgICBhZGQsXG4gICAgc2V0LFxuICAgIGRlbGV0ZTogZGVsZXRlRW50cnksXG4gICAgY2xlYXIsXG4gICAgZm9yRWFjaDogY3JlYXRlRm9yRWFjaChmYWxzZSwgZmFsc2UpXG4gIH07XG4gIGNvbnN0IHNoYWxsb3dJbnN0cnVtZW50YXRpb25zMiA9IHtcbiAgICBnZXQoa2V5KSB7XG4gICAgICByZXR1cm4gZ2V0KHRoaXMsIGtleSwgZmFsc2UsIHRydWUpO1xuICAgIH0sXG4gICAgZ2V0IHNpemUoKSB7XG4gICAgICByZXR1cm4gc2l6ZSh0aGlzKTtcbiAgICB9LFxuICAgIGhhcyxcbiAgICBhZGQsXG4gICAgc2V0LFxuICAgIGRlbGV0ZTogZGVsZXRlRW50cnksXG4gICAgY2xlYXIsXG4gICAgZm9yRWFjaDogY3JlYXRlRm9yRWFjaChmYWxzZSwgdHJ1ZSlcbiAgfTtcbiAgY29uc3QgcmVhZG9ubHlJbnN0cnVtZW50YXRpb25zMiA9IHtcbiAgICBnZXQoa2V5KSB7XG4gICAgICByZXR1cm4gZ2V0KHRoaXMsIGtleSwgdHJ1ZSk7XG4gICAgfSxcbiAgICBnZXQgc2l6ZSgpIHtcbiAgICAgIHJldHVybiBzaXplKHRoaXMsIHRydWUpO1xuICAgIH0sXG4gICAgaGFzKGtleSkge1xuICAgICAgcmV0dXJuIGhhcy5jYWxsKHRoaXMsIGtleSwgdHJ1ZSk7XG4gICAgfSxcbiAgICBhZGQ6IGNyZWF0ZVJlYWRvbmx5TWV0aG9kKFwiYWRkXCIpLFxuICAgIHNldDogY3JlYXRlUmVhZG9ubHlNZXRob2QoXCJzZXRcIiksXG4gICAgZGVsZXRlOiBjcmVhdGVSZWFkb25seU1ldGhvZChcImRlbGV0ZVwiKSxcbiAgICBjbGVhcjogY3JlYXRlUmVhZG9ubHlNZXRob2QoXCJjbGVhclwiKSxcbiAgICBmb3JFYWNoOiBjcmVhdGVGb3JFYWNoKHRydWUsIGZhbHNlKVxuICB9O1xuICBjb25zdCBzaGFsbG93UmVhZG9ubHlJbnN0cnVtZW50YXRpb25zMiA9IHtcbiAgICBnZXQoa2V5KSB7XG4gICAgICByZXR1cm4gZ2V0KHRoaXMsIGtleSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgfSxcbiAgICBnZXQgc2l6ZSgpIHtcbiAgICAgIHJldHVybiBzaXplKHRoaXMsIHRydWUpO1xuICAgIH0sXG4gICAgaGFzKGtleSkge1xuICAgICAgcmV0dXJuIGhhcy5jYWxsKHRoaXMsIGtleSwgdHJ1ZSk7XG4gICAgfSxcbiAgICBhZGQ6IGNyZWF0ZVJlYWRvbmx5TWV0aG9kKFwiYWRkXCIpLFxuICAgIHNldDogY3JlYXRlUmVhZG9ubHlNZXRob2QoXCJzZXRcIiksXG4gICAgZGVsZXRlOiBjcmVhdGVSZWFkb25seU1ldGhvZChcImRlbGV0ZVwiKSxcbiAgICBjbGVhcjogY3JlYXRlUmVhZG9ubHlNZXRob2QoXCJjbGVhclwiKSxcbiAgICBmb3JFYWNoOiBjcmVhdGVGb3JFYWNoKHRydWUsIHRydWUpXG4gIH07XG4gIGNvbnN0IGl0ZXJhdG9yTWV0aG9kcyA9IFtcImtleXNcIiwgXCJ2YWx1ZXNcIiwgXCJlbnRyaWVzXCIsIFN5bWJvbC5pdGVyYXRvcl07XG4gIGl0ZXJhdG9yTWV0aG9kcy5mb3JFYWNoKChtZXRob2QpID0+IHtcbiAgICBtdXRhYmxlSW5zdHJ1bWVudGF0aW9uczJbbWV0aG9kXSA9IGNyZWF0ZUl0ZXJhYmxlTWV0aG9kKFxuICAgICAgbWV0aG9kLFxuICAgICAgZmFsc2UsXG4gICAgICBmYWxzZVxuICAgICk7XG4gICAgcmVhZG9ubHlJbnN0cnVtZW50YXRpb25zMlttZXRob2RdID0gY3JlYXRlSXRlcmFibGVNZXRob2QoXG4gICAgICBtZXRob2QsXG4gICAgICB0cnVlLFxuICAgICAgZmFsc2VcbiAgICApO1xuICAgIHNoYWxsb3dJbnN0cnVtZW50YXRpb25zMlttZXRob2RdID0gY3JlYXRlSXRlcmFibGVNZXRob2QoXG4gICAgICBtZXRob2QsXG4gICAgICBmYWxzZSxcbiAgICAgIHRydWVcbiAgICApO1xuICAgIHNoYWxsb3dSZWFkb25seUluc3RydW1lbnRhdGlvbnMyW21ldGhvZF0gPSBjcmVhdGVJdGVyYWJsZU1ldGhvZChcbiAgICAgIG1ldGhvZCxcbiAgICAgIHRydWUsXG4gICAgICB0cnVlXG4gICAgKTtcbiAgfSk7XG4gIHJldHVybiBbXG4gICAgbXV0YWJsZUluc3RydW1lbnRhdGlvbnMyLFxuICAgIHJlYWRvbmx5SW5zdHJ1bWVudGF0aW9uczIsXG4gICAgc2hhbGxvd0luc3RydW1lbnRhdGlvbnMyLFxuICAgIHNoYWxsb3dSZWFkb25seUluc3RydW1lbnRhdGlvbnMyXG4gIF07XG59XG5jb25zdCBbXG4gIG11dGFibGVJbnN0cnVtZW50YXRpb25zLFxuICByZWFkb25seUluc3RydW1lbnRhdGlvbnMsXG4gIHNoYWxsb3dJbnN0cnVtZW50YXRpb25zLFxuICBzaGFsbG93UmVhZG9ubHlJbnN0cnVtZW50YXRpb25zXG5dID0gLyogQF9fUFVSRV9fICovIGNyZWF0ZUluc3RydW1lbnRhdGlvbnMoKTtcbmZ1bmN0aW9uIGNyZWF0ZUluc3RydW1lbnRhdGlvbkdldHRlcihpc1JlYWRvbmx5LCBzaGFsbG93KSB7XG4gIGNvbnN0IGluc3RydW1lbnRhdGlvbnMgPSBzaGFsbG93ID8gaXNSZWFkb25seSA/IHNoYWxsb3dSZWFkb25seUluc3RydW1lbnRhdGlvbnMgOiBzaGFsbG93SW5zdHJ1bWVudGF0aW9ucyA6IGlzUmVhZG9ubHkgPyByZWFkb25seUluc3RydW1lbnRhdGlvbnMgOiBtdXRhYmxlSW5zdHJ1bWVudGF0aW9ucztcbiAgcmV0dXJuICh0YXJnZXQsIGtleSwgcmVjZWl2ZXIpID0+IHtcbiAgICBpZiAoa2V5ID09PSBcIl9fdl9pc1JlYWN0aXZlXCIpIHtcbiAgICAgIHJldHVybiAhaXNSZWFkb25seTtcbiAgICB9IGVsc2UgaWYgKGtleSA9PT0gXCJfX3ZfaXNSZWFkb25seVwiKSB7XG4gICAgICByZXR1cm4gaXNSZWFkb25seTtcbiAgICB9IGVsc2UgaWYgKGtleSA9PT0gXCJfX3ZfcmF3XCIpIHtcbiAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuICAgIHJldHVybiBSZWZsZWN0LmdldChcbiAgICAgIGhhc093bihpbnN0cnVtZW50YXRpb25zLCBrZXkpICYmIGtleSBpbiB0YXJnZXQgPyBpbnN0cnVtZW50YXRpb25zIDogdGFyZ2V0LFxuICAgICAga2V5LFxuICAgICAgcmVjZWl2ZXJcbiAgICApO1xuICB9O1xufVxuY29uc3QgbXV0YWJsZUNvbGxlY3Rpb25IYW5kbGVycyA9IHtcbiAgZ2V0OiAvKiBAX19QVVJFX18gKi8gY3JlYXRlSW5zdHJ1bWVudGF0aW9uR2V0dGVyKGZhbHNlLCBmYWxzZSlcbn07XG5jb25zdCBzaGFsbG93Q29sbGVjdGlvbkhhbmRsZXJzID0ge1xuICBnZXQ6IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVJbnN0cnVtZW50YXRpb25HZXR0ZXIoZmFsc2UsIHRydWUpXG59O1xuY29uc3QgcmVhZG9ubHlDb2xsZWN0aW9uSGFuZGxlcnMgPSB7XG4gIGdldDogLyogQF9fUFVSRV9fICovIGNyZWF0ZUluc3RydW1lbnRhdGlvbkdldHRlcih0cnVlLCBmYWxzZSlcbn07XG5jb25zdCBzaGFsbG93UmVhZG9ubHlDb2xsZWN0aW9uSGFuZGxlcnMgPSB7XG4gIGdldDogLyogQF9fUFVSRV9fICovIGNyZWF0ZUluc3RydW1lbnRhdGlvbkdldHRlcih0cnVlLCB0cnVlKVxufTtcbmZ1bmN0aW9uIGNoZWNrSWRlbnRpdHlLZXlzKHRhcmdldCwgaGFzMiwga2V5KSB7XG4gIGNvbnN0IHJhd0tleSA9IHRvUmF3KGtleSk7XG4gIGlmIChyYXdLZXkgIT09IGtleSAmJiBoYXMyLmNhbGwodGFyZ2V0LCByYXdLZXkpKSB7XG4gICAgY29uc3QgdHlwZSA9IHRvUmF3VHlwZSh0YXJnZXQpO1xuICAgIGNvbnNvbGUud2FybihcbiAgICAgIGBSZWFjdGl2ZSAke3R5cGV9IGNvbnRhaW5zIGJvdGggdGhlIHJhdyBhbmQgcmVhY3RpdmUgdmVyc2lvbnMgb2YgdGhlIHNhbWUgb2JqZWN0JHt0eXBlID09PSBgTWFwYCA/IGAgYXMga2V5c2AgOiBgYH0sIHdoaWNoIGNhbiBsZWFkIHRvIGluY29uc2lzdGVuY2llcy4gQXZvaWQgZGlmZmVyZW50aWF0aW5nIGJldHdlZW4gdGhlIHJhdyBhbmQgcmVhY3RpdmUgdmVyc2lvbnMgb2YgYW4gb2JqZWN0IGFuZCBvbmx5IHVzZSB0aGUgcmVhY3RpdmUgdmVyc2lvbiBpZiBwb3NzaWJsZS5gXG4gICAgKTtcbiAgfVxufVxuXG5jb25zdCByZWFjdGl2ZU1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuY29uc3Qgc2hhbGxvd1JlYWN0aXZlTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG5jb25zdCByZWFkb25seU1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuY29uc3Qgc2hhbGxvd1JlYWRvbmx5TWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG5mdW5jdGlvbiB0YXJnZXRUeXBlTWFwKHJhd1R5cGUpIHtcbiAgc3dpdGNoIChyYXdUeXBlKSB7XG4gICAgY2FzZSBcIk9iamVjdFwiOlxuICAgIGNhc2UgXCJBcnJheVwiOlxuICAgICAgcmV0dXJuIDEgLyogQ09NTU9OICovO1xuICAgIGNhc2UgXCJNYXBcIjpcbiAgICBjYXNlIFwiU2V0XCI6XG4gICAgY2FzZSBcIldlYWtNYXBcIjpcbiAgICBjYXNlIFwiV2Vha1NldFwiOlxuICAgICAgcmV0dXJuIDIgLyogQ09MTEVDVElPTiAqLztcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIDAgLyogSU5WQUxJRCAqLztcbiAgfVxufVxuZnVuY3Rpb24gZ2V0VGFyZ2V0VHlwZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWVbXCJfX3Zfc2tpcFwiXSB8fCAhT2JqZWN0LmlzRXh0ZW5zaWJsZSh2YWx1ZSkgPyAwIC8qIElOVkFMSUQgKi8gOiB0YXJnZXRUeXBlTWFwKHRvUmF3VHlwZSh2YWx1ZSkpO1xufVxuZnVuY3Rpb24gcmVhY3RpdmUodGFyZ2V0KSB7XG4gIGlmIChpc1JlYWRvbmx5KHRhcmdldCkpIHtcbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9XG4gIHJldHVybiBjcmVhdGVSZWFjdGl2ZU9iamVjdChcbiAgICB0YXJnZXQsXG4gICAgZmFsc2UsXG4gICAgbXV0YWJsZUhhbmRsZXJzLFxuICAgIG11dGFibGVDb2xsZWN0aW9uSGFuZGxlcnMsXG4gICAgcmVhY3RpdmVNYXBcbiAgKTtcbn1cbmZ1bmN0aW9uIHNoYWxsb3dSZWFjdGl2ZSh0YXJnZXQpIHtcbiAgcmV0dXJuIGNyZWF0ZVJlYWN0aXZlT2JqZWN0KFxuICAgIHRhcmdldCxcbiAgICBmYWxzZSxcbiAgICBzaGFsbG93UmVhY3RpdmVIYW5kbGVycyxcbiAgICBzaGFsbG93Q29sbGVjdGlvbkhhbmRsZXJzLFxuICAgIHNoYWxsb3dSZWFjdGl2ZU1hcFxuICApO1xufVxuZnVuY3Rpb24gcmVhZG9ubHkodGFyZ2V0KSB7XG4gIHJldHVybiBjcmVhdGVSZWFjdGl2ZU9iamVjdChcbiAgICB0YXJnZXQsXG4gICAgdHJ1ZSxcbiAgICByZWFkb25seUhhbmRsZXJzLFxuICAgIHJlYWRvbmx5Q29sbGVjdGlvbkhhbmRsZXJzLFxuICAgIHJlYWRvbmx5TWFwXG4gICk7XG59XG5mdW5jdGlvbiBzaGFsbG93UmVhZG9ubHkodGFyZ2V0KSB7XG4gIHJldHVybiBjcmVhdGVSZWFjdGl2ZU9iamVjdChcbiAgICB0YXJnZXQsXG4gICAgdHJ1ZSxcbiAgICBzaGFsbG93UmVhZG9ubHlIYW5kbGVycyxcbiAgICBzaGFsbG93UmVhZG9ubHlDb2xsZWN0aW9uSGFuZGxlcnMsXG4gICAgc2hhbGxvd1JlYWRvbmx5TWFwXG4gICk7XG59XG5mdW5jdGlvbiBjcmVhdGVSZWFjdGl2ZU9iamVjdCh0YXJnZXQsIGlzUmVhZG9ubHkyLCBiYXNlSGFuZGxlcnMsIGNvbGxlY3Rpb25IYW5kbGVycywgcHJveHlNYXApIHtcbiAgaWYgKCFpc09iamVjdCh0YXJnZXQpKSB7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgIGNvbnNvbGUud2FybihgdmFsdWUgY2Fubm90IGJlIG1hZGUgcmVhY3RpdmU6ICR7U3RyaW5nKHRhcmdldCl9YCk7XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH1cbiAgaWYgKHRhcmdldFtcIl9fdl9yYXdcIl0gJiYgIShpc1JlYWRvbmx5MiAmJiB0YXJnZXRbXCJfX3ZfaXNSZWFjdGl2ZVwiXSkpIHtcbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9XG4gIGNvbnN0IGV4aXN0aW5nUHJveHkgPSBwcm94eU1hcC5nZXQodGFyZ2V0KTtcbiAgaWYgKGV4aXN0aW5nUHJveHkpIHtcbiAgICByZXR1cm4gZXhpc3RpbmdQcm94eTtcbiAgfVxuICBjb25zdCB0YXJnZXRUeXBlID0gZ2V0VGFyZ2V0VHlwZSh0YXJnZXQpO1xuICBpZiAodGFyZ2V0VHlwZSA9PT0gMCAvKiBJTlZBTElEICovKSB7XG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfVxuICBjb25zdCBwcm94eSA9IG5ldyBQcm94eShcbiAgICB0YXJnZXQsXG4gICAgdGFyZ2V0VHlwZSA9PT0gMiAvKiBDT0xMRUNUSU9OICovID8gY29sbGVjdGlvbkhhbmRsZXJzIDogYmFzZUhhbmRsZXJzXG4gICk7XG4gIHByb3h5TWFwLnNldCh0YXJnZXQsIHByb3h5KTtcbiAgcmV0dXJuIHByb3h5O1xufVxuZnVuY3Rpb24gaXNSZWFjdGl2ZSh2YWx1ZSkge1xuICBpZiAoaXNSZWFkb25seSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gaXNSZWFjdGl2ZSh2YWx1ZVtcIl9fdl9yYXdcIl0pO1xuICB9XG4gIHJldHVybiAhISh2YWx1ZSAmJiB2YWx1ZVtcIl9fdl9pc1JlYWN0aXZlXCJdKTtcbn1cbmZ1bmN0aW9uIGlzUmVhZG9ubHkodmFsdWUpIHtcbiAgcmV0dXJuICEhKHZhbHVlICYmIHZhbHVlW1wiX192X2lzUmVhZG9ubHlcIl0pO1xufVxuZnVuY3Rpb24gaXNTaGFsbG93KHZhbHVlKSB7XG4gIHJldHVybiAhISh2YWx1ZSAmJiB2YWx1ZVtcIl9fdl9pc1NoYWxsb3dcIl0pO1xufVxuZnVuY3Rpb24gaXNQcm94eSh2YWx1ZSkge1xuICByZXR1cm4gaXNSZWFjdGl2ZSh2YWx1ZSkgfHwgaXNSZWFkb25seSh2YWx1ZSk7XG59XG5mdW5jdGlvbiB0b1JhdyhvYnNlcnZlZCkge1xuICBjb25zdCByYXcgPSBvYnNlcnZlZCAmJiBvYnNlcnZlZFtcIl9fdl9yYXdcIl07XG4gIHJldHVybiByYXcgPyB0b1JhdyhyYXcpIDogb2JzZXJ2ZWQ7XG59XG5mdW5jdGlvbiBtYXJrUmF3KHZhbHVlKSB7XG4gIGRlZih2YWx1ZSwgXCJfX3Zfc2tpcFwiLCB0cnVlKTtcbiAgcmV0dXJuIHZhbHVlO1xufVxuY29uc3QgdG9SZWFjdGl2ZSA9ICh2YWx1ZSkgPT4gaXNPYmplY3QodmFsdWUpID8gcmVhY3RpdmUodmFsdWUpIDogdmFsdWU7XG5jb25zdCB0b1JlYWRvbmx5ID0gKHZhbHVlKSA9PiBpc09iamVjdCh2YWx1ZSkgPyByZWFkb25seSh2YWx1ZSkgOiB2YWx1ZTtcblxuZnVuY3Rpb24gdHJhY2tSZWZWYWx1ZShyZWYyKSB7XG4gIGlmIChzaG91bGRUcmFjayAmJiBhY3RpdmVFZmZlY3QpIHtcbiAgICByZWYyID0gdG9SYXcocmVmMik7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgIHRyYWNrRWZmZWN0cyhyZWYyLmRlcCB8fCAocmVmMi5kZXAgPSBjcmVhdGVEZXAoKSksIHtcbiAgICAgICAgdGFyZ2V0OiByZWYyLFxuICAgICAgICB0eXBlOiBcImdldFwiLFxuICAgICAgICBrZXk6IFwidmFsdWVcIlxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyYWNrRWZmZWN0cyhyZWYyLmRlcCB8fCAocmVmMi5kZXAgPSBjcmVhdGVEZXAoKSkpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gdHJpZ2dlclJlZlZhbHVlKHJlZjIsIG5ld1ZhbCkge1xuICByZWYyID0gdG9SYXcocmVmMik7XG4gIGNvbnN0IGRlcCA9IHJlZjIuZGVwO1xuICBpZiAoZGVwKSB7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgIHRyaWdnZXJFZmZlY3RzKGRlcCwge1xuICAgICAgICB0YXJnZXQ6IHJlZjIsXG4gICAgICAgIHR5cGU6IFwic2V0XCIsXG4gICAgICAgIGtleTogXCJ2YWx1ZVwiLFxuICAgICAgICBuZXdWYWx1ZTogbmV3VmFsXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdHJpZ2dlckVmZmVjdHMoZGVwKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGlzUmVmKHIpIHtcbiAgcmV0dXJuICEhKHIgJiYgci5fX3ZfaXNSZWYgPT09IHRydWUpO1xufVxuZnVuY3Rpb24gcmVmKHZhbHVlKSB7XG4gIHJldHVybiBjcmVhdGVSZWYodmFsdWUsIGZhbHNlKTtcbn1cbmZ1bmN0aW9uIHNoYWxsb3dSZWYodmFsdWUpIHtcbiAgcmV0dXJuIGNyZWF0ZVJlZih2YWx1ZSwgdHJ1ZSk7XG59XG5mdW5jdGlvbiBjcmVhdGVSZWYocmF3VmFsdWUsIHNoYWxsb3cpIHtcbiAgaWYgKGlzUmVmKHJhd1ZhbHVlKSkge1xuICAgIHJldHVybiByYXdWYWx1ZTtcbiAgfVxuICByZXR1cm4gbmV3IFJlZkltcGwocmF3VmFsdWUsIHNoYWxsb3cpO1xufVxuY2xhc3MgUmVmSW1wbCB7XG4gIGNvbnN0cnVjdG9yKHZhbHVlLCBfX3ZfaXNTaGFsbG93KSB7XG4gICAgdGhpcy5fX3ZfaXNTaGFsbG93ID0gX192X2lzU2hhbGxvdztcbiAgICB0aGlzLmRlcCA9IHZvaWQgMDtcbiAgICB0aGlzLl9fdl9pc1JlZiA9IHRydWU7XG4gICAgdGhpcy5fcmF3VmFsdWUgPSBfX3ZfaXNTaGFsbG93ID8gdmFsdWUgOiB0b1Jhdyh2YWx1ZSk7XG4gICAgdGhpcy5fdmFsdWUgPSBfX3ZfaXNTaGFsbG93ID8gdmFsdWUgOiB0b1JlYWN0aXZlKHZhbHVlKTtcbiAgfVxuICBnZXQgdmFsdWUoKSB7XG4gICAgdHJhY2tSZWZWYWx1ZSh0aGlzKTtcbiAgICByZXR1cm4gdGhpcy5fdmFsdWU7XG4gIH1cbiAgc2V0IHZhbHVlKG5ld1ZhbCkge1xuICAgIGNvbnN0IHVzZURpcmVjdFZhbHVlID0gdGhpcy5fX3ZfaXNTaGFsbG93IHx8IGlzU2hhbGxvdyhuZXdWYWwpIHx8IGlzUmVhZG9ubHkobmV3VmFsKTtcbiAgICBuZXdWYWwgPSB1c2VEaXJlY3RWYWx1ZSA/IG5ld1ZhbCA6IHRvUmF3KG5ld1ZhbCk7XG4gICAgaWYgKGhhc0NoYW5nZWQobmV3VmFsLCB0aGlzLl9yYXdWYWx1ZSkpIHtcbiAgICAgIHRoaXMuX3Jhd1ZhbHVlID0gbmV3VmFsO1xuICAgICAgdGhpcy5fdmFsdWUgPSB1c2VEaXJlY3RWYWx1ZSA/IG5ld1ZhbCA6IHRvUmVhY3RpdmUobmV3VmFsKTtcbiAgICAgIHRyaWdnZXJSZWZWYWx1ZSh0aGlzLCBuZXdWYWwpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gdHJpZ2dlclJlZihyZWYyKSB7XG4gIHRyaWdnZXJSZWZWYWx1ZShyZWYyLCAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gcmVmMi52YWx1ZSA6IHZvaWQgMCk7XG59XG5mdW5jdGlvbiB1bnJlZihyZWYyKSB7XG4gIHJldHVybiBpc1JlZihyZWYyKSA/IHJlZjIudmFsdWUgOiByZWYyO1xufVxuZnVuY3Rpb24gdG9WYWx1ZShzb3VyY2UpIHtcbiAgcmV0dXJuIGlzRnVuY3Rpb24oc291cmNlKSA/IHNvdXJjZSgpIDogdW5yZWYoc291cmNlKTtcbn1cbmNvbnN0IHNoYWxsb3dVbndyYXBIYW5kbGVycyA9IHtcbiAgZ2V0OiAodGFyZ2V0LCBrZXksIHJlY2VpdmVyKSA9PiB1bnJlZihSZWZsZWN0LmdldCh0YXJnZXQsIGtleSwgcmVjZWl2ZXIpKSxcbiAgc2V0OiAodGFyZ2V0LCBrZXksIHZhbHVlLCByZWNlaXZlcikgPT4ge1xuICAgIGNvbnN0IG9sZFZhbHVlID0gdGFyZ2V0W2tleV07XG4gICAgaWYgKGlzUmVmKG9sZFZhbHVlKSAmJiAhaXNSZWYodmFsdWUpKSB7XG4gICAgICBvbGRWYWx1ZS52YWx1ZSA9IHZhbHVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBSZWZsZWN0LnNldCh0YXJnZXQsIGtleSwgdmFsdWUsIHJlY2VpdmVyKTtcbiAgICB9XG4gIH1cbn07XG5mdW5jdGlvbiBwcm94eVJlZnMob2JqZWN0V2l0aFJlZnMpIHtcbiAgcmV0dXJuIGlzUmVhY3RpdmUob2JqZWN0V2l0aFJlZnMpID8gb2JqZWN0V2l0aFJlZnMgOiBuZXcgUHJveHkob2JqZWN0V2l0aFJlZnMsIHNoYWxsb3dVbndyYXBIYW5kbGVycyk7XG59XG5jbGFzcyBDdXN0b21SZWZJbXBsIHtcbiAgY29uc3RydWN0b3IoZmFjdG9yeSkge1xuICAgIHRoaXMuZGVwID0gdm9pZCAwO1xuICAgIHRoaXMuX192X2lzUmVmID0gdHJ1ZTtcbiAgICBjb25zdCB7IGdldCwgc2V0IH0gPSBmYWN0b3J5KFxuICAgICAgKCkgPT4gdHJhY2tSZWZWYWx1ZSh0aGlzKSxcbiAgICAgICgpID0+IHRyaWdnZXJSZWZWYWx1ZSh0aGlzKVxuICAgICk7XG4gICAgdGhpcy5fZ2V0ID0gZ2V0O1xuICAgIHRoaXMuX3NldCA9IHNldDtcbiAgfVxuICBnZXQgdmFsdWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldCgpO1xuICB9XG4gIHNldCB2YWx1ZShuZXdWYWwpIHtcbiAgICB0aGlzLl9zZXQobmV3VmFsKTtcbiAgfVxufVxuZnVuY3Rpb24gY3VzdG9tUmVmKGZhY3RvcnkpIHtcbiAgcmV0dXJuIG5ldyBDdXN0b21SZWZJbXBsKGZhY3RvcnkpO1xufVxuZnVuY3Rpb24gdG9SZWZzKG9iamVjdCkge1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhaXNQcm94eShvYmplY3QpKSB7XG4gICAgY29uc29sZS53YXJuKGB0b1JlZnMoKSBleHBlY3RzIGEgcmVhY3RpdmUgb2JqZWN0IGJ1dCByZWNlaXZlZCBhIHBsYWluIG9uZS5gKTtcbiAgfVxuICBjb25zdCByZXQgPSBpc0FycmF5KG9iamVjdCkgPyBuZXcgQXJyYXkob2JqZWN0Lmxlbmd0aCkgOiB7fTtcbiAgZm9yIChjb25zdCBrZXkgaW4gb2JqZWN0KSB7XG4gICAgcmV0W2tleV0gPSBwcm9wZXJ0eVRvUmVmKG9iamVjdCwga2V5KTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuY2xhc3MgT2JqZWN0UmVmSW1wbCB7XG4gIGNvbnN0cnVjdG9yKF9vYmplY3QsIF9rZXksIF9kZWZhdWx0VmFsdWUpIHtcbiAgICB0aGlzLl9vYmplY3QgPSBfb2JqZWN0O1xuICAgIHRoaXMuX2tleSA9IF9rZXk7XG4gICAgdGhpcy5fZGVmYXVsdFZhbHVlID0gX2RlZmF1bHRWYWx1ZTtcbiAgICB0aGlzLl9fdl9pc1JlZiA9IHRydWU7XG4gIH1cbiAgZ2V0IHZhbHVlKCkge1xuICAgIGNvbnN0IHZhbCA9IHRoaXMuX29iamVjdFt0aGlzLl9rZXldO1xuICAgIHJldHVybiB2YWwgPT09IHZvaWQgMCA/IHRoaXMuX2RlZmF1bHRWYWx1ZSA6IHZhbDtcbiAgfVxuICBzZXQgdmFsdWUobmV3VmFsKSB7XG4gICAgdGhpcy5fb2JqZWN0W3RoaXMuX2tleV0gPSBuZXdWYWw7XG4gIH1cbiAgZ2V0IGRlcCgpIHtcbiAgICByZXR1cm4gZ2V0RGVwRnJvbVJlYWN0aXZlKHRvUmF3KHRoaXMuX29iamVjdCksIHRoaXMuX2tleSk7XG4gIH1cbn1cbmNsYXNzIEdldHRlclJlZkltcGwge1xuICBjb25zdHJ1Y3RvcihfZ2V0dGVyKSB7XG4gICAgdGhpcy5fZ2V0dGVyID0gX2dldHRlcjtcbiAgICB0aGlzLl9fdl9pc1JlZiA9IHRydWU7XG4gICAgdGhpcy5fX3ZfaXNSZWFkb25seSA9IHRydWU7XG4gIH1cbiAgZ2V0IHZhbHVlKCkge1xuICAgIHJldHVybiB0aGlzLl9nZXR0ZXIoKTtcbiAgfVxufVxuZnVuY3Rpb24gdG9SZWYoc291cmNlLCBrZXksIGRlZmF1bHRWYWx1ZSkge1xuICBpZiAoaXNSZWYoc291cmNlKSkge1xuICAgIHJldHVybiBzb3VyY2U7XG4gIH0gZWxzZSBpZiAoaXNGdW5jdGlvbihzb3VyY2UpKSB7XG4gICAgcmV0dXJuIG5ldyBHZXR0ZXJSZWZJbXBsKHNvdXJjZSk7XG4gIH0gZWxzZSBpZiAoaXNPYmplY3Qoc291cmNlKSAmJiBhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgIHJldHVybiBwcm9wZXJ0eVRvUmVmKHNvdXJjZSwga2V5LCBkZWZhdWx0VmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiByZWYoc291cmNlKTtcbiAgfVxufVxuZnVuY3Rpb24gcHJvcGVydHlUb1JlZihzb3VyY2UsIGtleSwgZGVmYXVsdFZhbHVlKSB7XG4gIGNvbnN0IHZhbCA9IHNvdXJjZVtrZXldO1xuICByZXR1cm4gaXNSZWYodmFsKSA/IHZhbCA6IG5ldyBPYmplY3RSZWZJbXBsKFxuICAgIHNvdXJjZSxcbiAgICBrZXksXG4gICAgZGVmYXVsdFZhbHVlXG4gICk7XG59XG5cbmNsYXNzIENvbXB1dGVkUmVmSW1wbCB7XG4gIGNvbnN0cnVjdG9yKGdldHRlciwgX3NldHRlciwgaXNSZWFkb25seSwgaXNTU1IpIHtcbiAgICB0aGlzLl9zZXR0ZXIgPSBfc2V0dGVyO1xuICAgIHRoaXMuZGVwID0gdm9pZCAwO1xuICAgIHRoaXMuX192X2lzUmVmID0gdHJ1ZTtcbiAgICB0aGlzW1wiX192X2lzUmVhZG9ubHlcIl0gPSBmYWxzZTtcbiAgICB0aGlzLl9kaXJ0eSA9IHRydWU7XG4gICAgdGhpcy5lZmZlY3QgPSBuZXcgUmVhY3RpdmVFZmZlY3QoZ2V0dGVyLCAoKSA9PiB7XG4gICAgICBpZiAoIXRoaXMuX2RpcnR5KSB7XG4gICAgICAgIHRoaXMuX2RpcnR5ID0gdHJ1ZTtcbiAgICAgICAgdHJpZ2dlclJlZlZhbHVlKHRoaXMpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuZWZmZWN0LmNvbXB1dGVkID0gdGhpcztcbiAgICB0aGlzLmVmZmVjdC5hY3RpdmUgPSB0aGlzLl9jYWNoZWFibGUgPSAhaXNTU1I7XG4gICAgdGhpc1tcIl9fdl9pc1JlYWRvbmx5XCJdID0gaXNSZWFkb25seTtcbiAgfVxuICBnZXQgdmFsdWUoKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRvUmF3KHRoaXMpO1xuICAgIHRyYWNrUmVmVmFsdWUoc2VsZik7XG4gICAgaWYgKHNlbGYuX2RpcnR5IHx8ICFzZWxmLl9jYWNoZWFibGUpIHtcbiAgICAgIHNlbGYuX2RpcnR5ID0gZmFsc2U7XG4gICAgICBzZWxmLl92YWx1ZSA9IHNlbGYuZWZmZWN0LnJ1bigpO1xuICAgIH1cbiAgICByZXR1cm4gc2VsZi5fdmFsdWU7XG4gIH1cbiAgc2V0IHZhbHVlKG5ld1ZhbHVlKSB7XG4gICAgdGhpcy5fc2V0dGVyKG5ld1ZhbHVlKTtcbiAgfVxufVxuZnVuY3Rpb24gY29tcHV0ZWQoZ2V0dGVyT3JPcHRpb25zLCBkZWJ1Z09wdGlvbnMsIGlzU1NSID0gZmFsc2UpIHtcbiAgbGV0IGdldHRlcjtcbiAgbGV0IHNldHRlcjtcbiAgY29uc3Qgb25seUdldHRlciA9IGlzRnVuY3Rpb24oZ2V0dGVyT3JPcHRpb25zKTtcbiAgaWYgKG9ubHlHZXR0ZXIpIHtcbiAgICBnZXR0ZXIgPSBnZXR0ZXJPck9wdGlvbnM7XG4gICAgc2V0dGVyID0gISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/ICgpID0+IHtcbiAgICAgIGNvbnNvbGUud2FybihcIldyaXRlIG9wZXJhdGlvbiBmYWlsZWQ6IGNvbXB1dGVkIHZhbHVlIGlzIHJlYWRvbmx5XCIpO1xuICAgIH0gOiBOT09QO1xuICB9IGVsc2Uge1xuICAgIGdldHRlciA9IGdldHRlck9yT3B0aW9ucy5nZXQ7XG4gICAgc2V0dGVyID0gZ2V0dGVyT3JPcHRpb25zLnNldDtcbiAgfVxuICBjb25zdCBjUmVmID0gbmV3IENvbXB1dGVkUmVmSW1wbChnZXR0ZXIsIHNldHRlciwgb25seUdldHRlciB8fCAhc2V0dGVyLCBpc1NTUik7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGRlYnVnT3B0aW9ucyAmJiAhaXNTU1IpIHtcbiAgICBjUmVmLmVmZmVjdC5vblRyYWNrID0gZGVidWdPcHRpb25zLm9uVHJhY2s7XG4gICAgY1JlZi5lZmZlY3Qub25UcmlnZ2VyID0gZGVidWdPcHRpb25zLm9uVHJpZ2dlcjtcbiAgfVxuICByZXR1cm4gY1JlZjtcbn1cblxuY29uc3QgdGljayA9IC8qIEBfX1BVUkVfXyAqLyBQcm9taXNlLnJlc29sdmUoKTtcbmNvbnN0IHF1ZXVlID0gW107XG5sZXQgcXVldWVkID0gZmFsc2U7XG5jb25zdCBzY2hlZHVsZXIgPSAoZm4pID0+IHtcbiAgcXVldWUucHVzaChmbik7XG4gIGlmICghcXVldWVkKSB7XG4gICAgcXVldWVkID0gdHJ1ZTtcbiAgICB0aWNrLnRoZW4oZmx1c2gpO1xuICB9XG59O1xuY29uc3QgZmx1c2ggPSAoKSA9PiB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICBxdWV1ZVtpXSgpO1xuICB9XG4gIHF1ZXVlLmxlbmd0aCA9IDA7XG4gIHF1ZXVlZCA9IGZhbHNlO1xufTtcbmNsYXNzIERlZmVycmVkQ29tcHV0ZWRSZWZJbXBsIHtcbiAgY29uc3RydWN0b3IoZ2V0dGVyKSB7XG4gICAgdGhpcy5kZXAgPSB2b2lkIDA7XG4gICAgdGhpcy5fZGlydHkgPSB0cnVlO1xuICAgIHRoaXMuX192X2lzUmVmID0gdHJ1ZTtcbiAgICB0aGlzW1wiX192X2lzUmVhZG9ubHlcIl0gPSB0cnVlO1xuICAgIGxldCBjb21wYXJlVGFyZ2V0O1xuICAgIGxldCBoYXNDb21wYXJlVGFyZ2V0ID0gZmFsc2U7XG4gICAgbGV0IHNjaGVkdWxlZCA9IGZhbHNlO1xuICAgIHRoaXMuZWZmZWN0ID0gbmV3IFJlYWN0aXZlRWZmZWN0KGdldHRlciwgKGNvbXB1dGVkVHJpZ2dlcikgPT4ge1xuICAgICAgaWYgKHRoaXMuZGVwKSB7XG4gICAgICAgIGlmIChjb21wdXRlZFRyaWdnZXIpIHtcbiAgICAgICAgICBjb21wYXJlVGFyZ2V0ID0gdGhpcy5fdmFsdWU7XG4gICAgICAgICAgaGFzQ29tcGFyZVRhcmdldCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAoIXNjaGVkdWxlZCkge1xuICAgICAgICAgIGNvbnN0IHZhbHVlVG9Db21wYXJlID0gaGFzQ29tcGFyZVRhcmdldCA/IGNvbXBhcmVUYXJnZXQgOiB0aGlzLl92YWx1ZTtcbiAgICAgICAgICBzY2hlZHVsZWQgPSB0cnVlO1xuICAgICAgICAgIGhhc0NvbXBhcmVUYXJnZXQgPSBmYWxzZTtcbiAgICAgICAgICBzY2hlZHVsZXIoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuZWZmZWN0LmFjdGl2ZSAmJiB0aGlzLl9nZXQoKSAhPT0gdmFsdWVUb0NvbXBhcmUpIHtcbiAgICAgICAgICAgICAgdHJpZ2dlclJlZlZhbHVlKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2NoZWR1bGVkID0gZmFsc2U7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBlIG9mIHRoaXMuZGVwKSB7XG4gICAgICAgICAgaWYgKGUuY29tcHV0ZWQgaW5zdGFuY2VvZiBEZWZlcnJlZENvbXB1dGVkUmVmSW1wbCkge1xuICAgICAgICAgICAgZS5zY2hlZHVsZXIoXG4gICAgICAgICAgICAgIHRydWVcbiAgICAgICAgICAgICAgLyogY29tcHV0ZWRUcmlnZ2VyICovXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5fZGlydHkgPSB0cnVlO1xuICAgIH0pO1xuICAgIHRoaXMuZWZmZWN0LmNvbXB1dGVkID0gdGhpcztcbiAgfVxuICBfZ2V0KCkge1xuICAgIGlmICh0aGlzLl9kaXJ0eSkge1xuICAgICAgdGhpcy5fZGlydHkgPSBmYWxzZTtcbiAgICAgIHJldHVybiB0aGlzLl92YWx1ZSA9IHRoaXMuZWZmZWN0LnJ1bigpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fdmFsdWU7XG4gIH1cbiAgZ2V0IHZhbHVlKCkge1xuICAgIHRyYWNrUmVmVmFsdWUodGhpcyk7XG4gICAgcmV0dXJuIHRvUmF3KHRoaXMpLl9nZXQoKTtcbiAgfVxufVxuZnVuY3Rpb24gZGVmZXJyZWRDb21wdXRlZChnZXR0ZXIpIHtcbiAgcmV0dXJuIG5ldyBEZWZlcnJlZENvbXB1dGVkUmVmSW1wbChnZXR0ZXIpO1xufVxuXG5leHBvcnQgeyBFZmZlY3RTY29wZSwgSVRFUkFURV9LRVksIFJlYWN0aXZlRWZmZWN0LCBjb21wdXRlZCwgY3VzdG9tUmVmLCBkZWZlcnJlZENvbXB1dGVkLCBlZmZlY3QsIGVmZmVjdFNjb3BlLCBlbmFibGVUcmFja2luZywgZ2V0Q3VycmVudFNjb3BlLCBpc1Byb3h5LCBpc1JlYWN0aXZlLCBpc1JlYWRvbmx5LCBpc1JlZiwgaXNTaGFsbG93LCBtYXJrUmF3LCBvblNjb3BlRGlzcG9zZSwgcGF1c2VUcmFja2luZywgcHJveHlSZWZzLCByZWFjdGl2ZSwgcmVhZG9ubHksIHJlZiwgcmVzZXRUcmFja2luZywgc2hhbGxvd1JlYWN0aXZlLCBzaGFsbG93UmVhZG9ubHksIHNoYWxsb3dSZWYsIHN0b3AsIHRvUmF3LCB0b1JlZiwgdG9SZWZzLCB0b1ZhbHVlLCB0cmFjaywgdHJpZ2dlciwgdHJpZ2dlclJlZiwgdW5yZWYgfTtcbiIsImZ1bmN0aW9uIG1ha2VNYXAoc3RyLCBleHBlY3RzTG93ZXJDYXNlKSB7XG4gIGNvbnN0IG1hcCA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBjb25zdCBsaXN0ID0gc3RyLnNwbGl0KFwiLFwiKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgbWFwW2xpc3RbaV1dID0gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZXhwZWN0c0xvd2VyQ2FzZSA/ICh2YWwpID0+ICEhbWFwW3ZhbC50b0xvd2VyQ2FzZSgpXSA6ICh2YWwpID0+ICEhbWFwW3ZhbF07XG59XG5cbmNvbnN0IEVNUFRZX09CSiA9ICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyBPYmplY3QuZnJlZXplKHt9KSA6IHt9O1xuY29uc3QgRU1QVFlfQVJSID0gISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IE9iamVjdC5mcmVlemUoW10pIDogW107XG5jb25zdCBOT09QID0gKCkgPT4ge1xufTtcbmNvbnN0IE5PID0gKCkgPT4gZmFsc2U7XG5jb25zdCBvblJFID0gL15vblteYS16XS87XG5jb25zdCBpc09uID0gKGtleSkgPT4gb25SRS50ZXN0KGtleSk7XG5jb25zdCBpc01vZGVsTGlzdGVuZXIgPSAoa2V5KSA9PiBrZXkuc3RhcnRzV2l0aChcIm9uVXBkYXRlOlwiKTtcbmNvbnN0IGV4dGVuZCA9IE9iamVjdC5hc3NpZ247XG5jb25zdCByZW1vdmUgPSAoYXJyLCBlbCkgPT4ge1xuICBjb25zdCBpID0gYXJyLmluZGV4T2YoZWwpO1xuICBpZiAoaSA+IC0xKSB7XG4gICAgYXJyLnNwbGljZShpLCAxKTtcbiAgfVxufTtcbmNvbnN0IGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbmNvbnN0IGhhc093biA9ICh2YWwsIGtleSkgPT4gaGFzT3duUHJvcGVydHkuY2FsbCh2YWwsIGtleSk7XG5jb25zdCBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcbmNvbnN0IGlzTWFwID0gKHZhbCkgPT4gdG9UeXBlU3RyaW5nKHZhbCkgPT09IFwiW29iamVjdCBNYXBdXCI7XG5jb25zdCBpc1NldCA9ICh2YWwpID0+IHRvVHlwZVN0cmluZyh2YWwpID09PSBcIltvYmplY3QgU2V0XVwiO1xuY29uc3QgaXNEYXRlID0gKHZhbCkgPT4gdG9UeXBlU3RyaW5nKHZhbCkgPT09IFwiW29iamVjdCBEYXRlXVwiO1xuY29uc3QgaXNSZWdFeHAgPSAodmFsKSA9PiB0b1R5cGVTdHJpbmcodmFsKSA9PT0gXCJbb2JqZWN0IFJlZ0V4cF1cIjtcbmNvbnN0IGlzRnVuY3Rpb24gPSAodmFsKSA9PiB0eXBlb2YgdmFsID09PSBcImZ1bmN0aW9uXCI7XG5jb25zdCBpc1N0cmluZyA9ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09IFwic3RyaW5nXCI7XG5jb25zdCBpc1N5bWJvbCA9ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09IFwic3ltYm9sXCI7XG5jb25zdCBpc09iamVjdCA9ICh2YWwpID0+IHZhbCAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsID09PSBcIm9iamVjdFwiO1xuY29uc3QgaXNQcm9taXNlID0gKHZhbCkgPT4ge1xuICByZXR1cm4gaXNPYmplY3QodmFsKSAmJiBpc0Z1bmN0aW9uKHZhbC50aGVuKSAmJiBpc0Z1bmN0aW9uKHZhbC5jYXRjaCk7XG59O1xuY29uc3Qgb2JqZWN0VG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuY29uc3QgdG9UeXBlU3RyaW5nID0gKHZhbHVlKSA9PiBvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbmNvbnN0IHRvUmF3VHlwZSA9ICh2YWx1ZSkgPT4ge1xuICByZXR1cm4gdG9UeXBlU3RyaW5nKHZhbHVlKS5zbGljZSg4LCAtMSk7XG59O1xuY29uc3QgaXNQbGFpbk9iamVjdCA9ICh2YWwpID0+IHRvVHlwZVN0cmluZyh2YWwpID09PSBcIltvYmplY3QgT2JqZWN0XVwiO1xuY29uc3QgaXNJbnRlZ2VyS2V5ID0gKGtleSkgPT4gaXNTdHJpbmcoa2V5KSAmJiBrZXkgIT09IFwiTmFOXCIgJiYga2V5WzBdICE9PSBcIi1cIiAmJiBcIlwiICsgcGFyc2VJbnQoa2V5LCAxMCkgPT09IGtleTtcbmNvbnN0IGlzUmVzZXJ2ZWRQcm9wID0gLyogQF9fUFVSRV9fICovIG1ha2VNYXAoXG4gIC8vIHRoZSBsZWFkaW5nIGNvbW1hIGlzIGludGVudGlvbmFsIHNvIGVtcHR5IHN0cmluZyBcIlwiIGlzIGFsc28gaW5jbHVkZWRcbiAgXCIsa2V5LHJlZixyZWZfZm9yLHJlZl9rZXksb25Wbm9kZUJlZm9yZU1vdW50LG9uVm5vZGVNb3VudGVkLG9uVm5vZGVCZWZvcmVVcGRhdGUsb25Wbm9kZVVwZGF0ZWQsb25Wbm9kZUJlZm9yZVVubW91bnQsb25Wbm9kZVVubW91bnRlZFwiXG4pO1xuY29uc3QgaXNCdWlsdEluRGlyZWN0aXZlID0gLyogQF9fUFVSRV9fICovIG1ha2VNYXAoXG4gIFwiYmluZCxjbG9hayxlbHNlLWlmLGVsc2UsZm9yLGh0bWwsaWYsbW9kZWwsb24sb25jZSxwcmUsc2hvdyxzbG90LHRleHQsbWVtb1wiXG4pO1xuY29uc3QgY2FjaGVTdHJpbmdGdW5jdGlvbiA9IChmbikgPT4ge1xuICBjb25zdCBjYWNoZSA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICByZXR1cm4gKHN0cikgPT4ge1xuICAgIGNvbnN0IGhpdCA9IGNhY2hlW3N0cl07XG4gICAgcmV0dXJuIGhpdCB8fCAoY2FjaGVbc3RyXSA9IGZuKHN0cikpO1xuICB9O1xufTtcbmNvbnN0IGNhbWVsaXplUkUgPSAvLShcXHcpL2c7XG5jb25zdCBjYW1lbGl6ZSA9IGNhY2hlU3RyaW5nRnVuY3Rpb24oKHN0cikgPT4ge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoY2FtZWxpemVSRSwgKF8sIGMpID0+IGMgPyBjLnRvVXBwZXJDYXNlKCkgOiBcIlwiKTtcbn0pO1xuY29uc3QgaHlwaGVuYXRlUkUgPSAvXFxCKFtBLVpdKS9nO1xuY29uc3QgaHlwaGVuYXRlID0gY2FjaGVTdHJpbmdGdW5jdGlvbihcbiAgKHN0cikgPT4gc3RyLnJlcGxhY2UoaHlwaGVuYXRlUkUsIFwiLSQxXCIpLnRvTG93ZXJDYXNlKClcbik7XG5jb25zdCBjYXBpdGFsaXplID0gY2FjaGVTdHJpbmdGdW5jdGlvbihcbiAgKHN0cikgPT4gc3RyLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyLnNsaWNlKDEpXG4pO1xuY29uc3QgdG9IYW5kbGVyS2V5ID0gY2FjaGVTdHJpbmdGdW5jdGlvbihcbiAgKHN0cikgPT4gc3RyID8gYG9uJHtjYXBpdGFsaXplKHN0cil9YCA6IGBgXG4pO1xuY29uc3QgaGFzQ2hhbmdlZCA9ICh2YWx1ZSwgb2xkVmFsdWUpID0+ICFPYmplY3QuaXModmFsdWUsIG9sZFZhbHVlKTtcbmNvbnN0IGludm9rZUFycmF5Rm5zID0gKGZucywgYXJnKSA9PiB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZm5zLmxlbmd0aDsgaSsrKSB7XG4gICAgZm5zW2ldKGFyZyk7XG4gIH1cbn07XG5jb25zdCBkZWYgPSAob2JqLCBrZXksIHZhbHVlKSA9PiB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICB2YWx1ZVxuICB9KTtcbn07XG5jb25zdCBsb29zZVRvTnVtYmVyID0gKHZhbCkgPT4ge1xuICBjb25zdCBuID0gcGFyc2VGbG9hdCh2YWwpO1xuICByZXR1cm4gaXNOYU4obikgPyB2YWwgOiBuO1xufTtcbmNvbnN0IHRvTnVtYmVyID0gKHZhbCkgPT4ge1xuICBjb25zdCBuID0gaXNTdHJpbmcodmFsKSA/IE51bWJlcih2YWwpIDogTmFOO1xuICByZXR1cm4gaXNOYU4obikgPyB2YWwgOiBuO1xufTtcbmxldCBfZ2xvYmFsVGhpcztcbmNvbnN0IGdldEdsb2JhbFRoaXMgPSAoKSA9PiB7XG4gIHJldHVybiBfZ2xvYmFsVGhpcyB8fCAoX2dsb2JhbFRoaXMgPSB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbFRoaXMgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHt9KTtcbn07XG5jb25zdCBpZGVudFJFID0gL15bXyRhLXpBLVpcXHhBMC1cXHVGRkZGXVtfJGEtekEtWjAtOVxceEEwLVxcdUZGRkZdKiQvO1xuZnVuY3Rpb24gZ2VuUHJvcHNBY2Nlc3NFeHAobmFtZSkge1xuICByZXR1cm4gaWRlbnRSRS50ZXN0KG5hbWUpID8gYF9fcHJvcHMuJHtuYW1lfWAgOiBgX19wcm9wc1ske0pTT04uc3RyaW5naWZ5KG5hbWUpfV1gO1xufVxuXG5jb25zdCBQYXRjaEZsYWdOYW1lcyA9IHtcbiAgWzFdOiBgVEVYVGAsXG4gIFsyXTogYENMQVNTYCxcbiAgWzRdOiBgU1RZTEVgLFxuICBbOF06IGBQUk9QU2AsXG4gIFsxNl06IGBGVUxMX1BST1BTYCxcbiAgWzMyXTogYEhZRFJBVEVfRVZFTlRTYCxcbiAgWzY0XTogYFNUQUJMRV9GUkFHTUVOVGAsXG4gIFsxMjhdOiBgS0VZRURfRlJBR01FTlRgLFxuICBbMjU2XTogYFVOS0VZRURfRlJBR01FTlRgLFxuICBbNTEyXTogYE5FRURfUEFUQ0hgLFxuICBbMTAyNF06IGBEWU5BTUlDX1NMT1RTYCxcbiAgWzIwNDhdOiBgREVWX1JPT1RfRlJBR01FTlRgLFxuICBbLTFdOiBgSE9JU1RFRGAsXG4gIFstMl06IGBCQUlMYFxufTtcblxuY29uc3Qgc2xvdEZsYWdzVGV4dCA9IHtcbiAgWzFdOiBcIlNUQUJMRVwiLFxuICBbMl06IFwiRFlOQU1JQ1wiLFxuICBbM106IFwiRk9SV0FSREVEXCJcbn07XG5cbmNvbnN0IEdMT0JBTFNfV0hJVEVfTElTVEVEID0gXCJJbmZpbml0eSx1bmRlZmluZWQsTmFOLGlzRmluaXRlLGlzTmFOLHBhcnNlRmxvYXQscGFyc2VJbnQsZGVjb2RlVVJJLGRlY29kZVVSSUNvbXBvbmVudCxlbmNvZGVVUkksZW5jb2RlVVJJQ29tcG9uZW50LE1hdGgsTnVtYmVyLERhdGUsQXJyYXksT2JqZWN0LEJvb2xlYW4sU3RyaW5nLFJlZ0V4cCxNYXAsU2V0LEpTT04sSW50bCxCaWdJbnQsY29uc29sZVwiO1xuY29uc3QgaXNHbG9iYWxseVdoaXRlbGlzdGVkID0gLyogQF9fUFVSRV9fICovIG1ha2VNYXAoR0xPQkFMU19XSElURV9MSVNURUQpO1xuXG5jb25zdCByYW5nZSA9IDI7XG5mdW5jdGlvbiBnZW5lcmF0ZUNvZGVGcmFtZShzb3VyY2UsIHN0YXJ0ID0gMCwgZW5kID0gc291cmNlLmxlbmd0aCkge1xuICBsZXQgbGluZXMgPSBzb3VyY2Uuc3BsaXQoLyhcXHI/XFxuKS8pO1xuICBjb25zdCBuZXdsaW5lU2VxdWVuY2VzID0gbGluZXMuZmlsdGVyKChfLCBpZHgpID0+IGlkeCAlIDIgPT09IDEpO1xuICBsaW5lcyA9IGxpbmVzLmZpbHRlcigoXywgaWR4KSA9PiBpZHggJSAyID09PSAwKTtcbiAgbGV0IGNvdW50ID0gMDtcbiAgY29uc3QgcmVzID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb3VudCArPSBsaW5lc1tpXS5sZW5ndGggKyAobmV3bGluZVNlcXVlbmNlc1tpXSAmJiBuZXdsaW5lU2VxdWVuY2VzW2ldLmxlbmd0aCB8fCAwKTtcbiAgICBpZiAoY291bnQgPj0gc3RhcnQpIHtcbiAgICAgIGZvciAobGV0IGogPSBpIC0gcmFuZ2U7IGogPD0gaSArIHJhbmdlIHx8IGVuZCA+IGNvdW50OyBqKyspIHtcbiAgICAgICAgaWYgKGogPCAwIHx8IGogPj0gbGluZXMubGVuZ3RoKVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBjb25zdCBsaW5lID0gaiArIDE7XG4gICAgICAgIHJlcy5wdXNoKFxuICAgICAgICAgIGAke2xpbmV9JHtcIiBcIi5yZXBlYXQoTWF0aC5tYXgoMyAtIFN0cmluZyhsaW5lKS5sZW5ndGgsIDApKX18ICAke2xpbmVzW2pdfWBcbiAgICAgICAgKTtcbiAgICAgICAgY29uc3QgbGluZUxlbmd0aCA9IGxpbmVzW2pdLmxlbmd0aDtcbiAgICAgICAgY29uc3QgbmV3TGluZVNlcUxlbmd0aCA9IG5ld2xpbmVTZXF1ZW5jZXNbal0gJiYgbmV3bGluZVNlcXVlbmNlc1tqXS5sZW5ndGggfHwgMDtcbiAgICAgICAgaWYgKGogPT09IGkpIHtcbiAgICAgICAgICBjb25zdCBwYWQgPSBzdGFydCAtIChjb3VudCAtIChsaW5lTGVuZ3RoICsgbmV3TGluZVNlcUxlbmd0aCkpO1xuICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IE1hdGgubWF4KFxuICAgICAgICAgICAgMSxcbiAgICAgICAgICAgIGVuZCA+IGNvdW50ID8gbGluZUxlbmd0aCAtIHBhZCA6IGVuZCAtIHN0YXJ0XG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXMucHVzaChgICAgfCAgYCArIFwiIFwiLnJlcGVhdChwYWQpICsgXCJeXCIucmVwZWF0KGxlbmd0aCkpO1xuICAgICAgICB9IGVsc2UgaWYgKGogPiBpKSB7XG4gICAgICAgICAgaWYgKGVuZCA+IGNvdW50KSB7XG4gICAgICAgICAgICBjb25zdCBsZW5ndGggPSBNYXRoLm1heChNYXRoLm1pbihlbmQgLSBjb3VudCwgbGluZUxlbmd0aCksIDEpO1xuICAgICAgICAgICAgcmVzLnB1c2goYCAgIHwgIGAgKyBcIl5cIi5yZXBlYXQobGVuZ3RoKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvdW50ICs9IGxpbmVMZW5ndGggKyBuZXdMaW5lU2VxTGVuZ3RoO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlcy5qb2luKFwiXFxuXCIpO1xufVxuXG5mdW5jdGlvbiBub3JtYWxpemVTdHlsZSh2YWx1ZSkge1xuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICBjb25zdCByZXMgPSB7fTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBpdGVtID0gdmFsdWVbaV07XG4gICAgICBjb25zdCBub3JtYWxpemVkID0gaXNTdHJpbmcoaXRlbSkgPyBwYXJzZVN0cmluZ1N0eWxlKGl0ZW0pIDogbm9ybWFsaXplU3R5bGUoaXRlbSk7XG4gICAgICBpZiAobm9ybWFsaXplZCkge1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBub3JtYWxpemVkKSB7XG4gICAgICAgICAgcmVzW2tleV0gPSBub3JtYWxpemVkW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbiAgfSBlbHNlIGlmIChpc1N0cmluZyh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG59XG5jb25zdCBsaXN0RGVsaW1pdGVyUkUgPSAvOyg/IVteKF0qXFwpKS9nO1xuY29uc3QgcHJvcGVydHlEZWxpbWl0ZXJSRSA9IC86KFteXSspLztcbmNvbnN0IHN0eWxlQ29tbWVudFJFID0gL1xcL1xcKlteXSo/XFwqXFwvL2c7XG5mdW5jdGlvbiBwYXJzZVN0cmluZ1N0eWxlKGNzc1RleHQpIHtcbiAgY29uc3QgcmV0ID0ge307XG4gIGNzc1RleHQucmVwbGFjZShzdHlsZUNvbW1lbnRSRSwgXCJcIikuc3BsaXQobGlzdERlbGltaXRlclJFKS5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgaWYgKGl0ZW0pIHtcbiAgICAgIGNvbnN0IHRtcCA9IGl0ZW0uc3BsaXQocHJvcGVydHlEZWxpbWl0ZXJSRSk7XG4gICAgICB0bXAubGVuZ3RoID4gMSAmJiAocmV0W3RtcFswXS50cmltKCldID0gdG1wWzFdLnRyaW0oKSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJldDtcbn1cbmZ1bmN0aW9uIHN0cmluZ2lmeVN0eWxlKHN0eWxlcykge1xuICBsZXQgcmV0ID0gXCJcIjtcbiAgaWYgKCFzdHlsZXMgfHwgaXNTdHJpbmcoc3R5bGVzKSkge1xuICAgIHJldHVybiByZXQ7XG4gIH1cbiAgZm9yIChjb25zdCBrZXkgaW4gc3R5bGVzKSB7XG4gICAgY29uc3QgdmFsdWUgPSBzdHlsZXNba2V5XTtcbiAgICBjb25zdCBub3JtYWxpemVkS2V5ID0ga2V5LnN0YXJ0c1dpdGgoYC0tYCkgPyBrZXkgOiBoeXBoZW5hdGUoa2V5KTtcbiAgICBpZiAoaXNTdHJpbmcodmFsdWUpIHx8IHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgcmV0ICs9IGAke25vcm1hbGl6ZWRLZXl9OiR7dmFsdWV9O2A7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXQ7XG59XG5mdW5jdGlvbiBub3JtYWxpemVDbGFzcyh2YWx1ZSkge1xuICBsZXQgcmVzID0gXCJcIjtcbiAgaWYgKGlzU3RyaW5nKHZhbHVlKSkge1xuICAgIHJlcyA9IHZhbHVlO1xuICB9IGVsc2UgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qgbm9ybWFsaXplZCA9IG5vcm1hbGl6ZUNsYXNzKHZhbHVlW2ldKTtcbiAgICAgIGlmIChub3JtYWxpemVkKSB7XG4gICAgICAgIHJlcyArPSBub3JtYWxpemVkICsgXCIgXCI7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xuICAgIGZvciAoY29uc3QgbmFtZSBpbiB2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlW25hbWVdKSB7XG4gICAgICAgIHJlcyArPSBuYW1lICsgXCIgXCI7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiByZXMudHJpbSgpO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplUHJvcHMocHJvcHMpIHtcbiAgaWYgKCFwcm9wcylcbiAgICByZXR1cm4gbnVsbDtcbiAgbGV0IHsgY2xhc3M6IGtsYXNzLCBzdHlsZSB9ID0gcHJvcHM7XG4gIGlmIChrbGFzcyAmJiAhaXNTdHJpbmcoa2xhc3MpKSB7XG4gICAgcHJvcHMuY2xhc3MgPSBub3JtYWxpemVDbGFzcyhrbGFzcyk7XG4gIH1cbiAgaWYgKHN0eWxlKSB7XG4gICAgcHJvcHMuc3R5bGUgPSBub3JtYWxpemVTdHlsZShzdHlsZSk7XG4gIH1cbiAgcmV0dXJuIHByb3BzO1xufVxuXG5jb25zdCBIVE1MX1RBR1MgPSBcImh0bWwsYm9keSxiYXNlLGhlYWQsbGluayxtZXRhLHN0eWxlLHRpdGxlLGFkZHJlc3MsYXJ0aWNsZSxhc2lkZSxmb290ZXIsaGVhZGVyLGhncm91cCxoMSxoMixoMyxoNCxoNSxoNixuYXYsc2VjdGlvbixkaXYsZGQsZGwsZHQsZmlnY2FwdGlvbixmaWd1cmUscGljdHVyZSxocixpbWcsbGksbWFpbixvbCxwLHByZSx1bCxhLGIsYWJicixiZGksYmRvLGJyLGNpdGUsY29kZSxkYXRhLGRmbixlbSxpLGtiZCxtYXJrLHEscnAscnQscnVieSxzLHNhbXAsc21hbGwsc3BhbixzdHJvbmcsc3ViLHN1cCx0aW1lLHUsdmFyLHdicixhcmVhLGF1ZGlvLG1hcCx0cmFjayx2aWRlbyxlbWJlZCxvYmplY3QscGFyYW0sc291cmNlLGNhbnZhcyxzY3JpcHQsbm9zY3JpcHQsZGVsLGlucyxjYXB0aW9uLGNvbCxjb2xncm91cCx0YWJsZSx0aGVhZCx0Ym9keSx0ZCx0aCx0cixidXR0b24sZGF0YWxpc3QsZmllbGRzZXQsZm9ybSxpbnB1dCxsYWJlbCxsZWdlbmQsbWV0ZXIsb3B0Z3JvdXAsb3B0aW9uLG91dHB1dCxwcm9ncmVzcyxzZWxlY3QsdGV4dGFyZWEsZGV0YWlscyxkaWFsb2csbWVudSxzdW1tYXJ5LHRlbXBsYXRlLGJsb2NrcXVvdGUsaWZyYW1lLHRmb290XCI7XG5jb25zdCBTVkdfVEFHUyA9IFwic3ZnLGFuaW1hdGUsYW5pbWF0ZU1vdGlvbixhbmltYXRlVHJhbnNmb3JtLGNpcmNsZSxjbGlwUGF0aCxjb2xvci1wcm9maWxlLGRlZnMsZGVzYyxkaXNjYXJkLGVsbGlwc2UsZmVCbGVuZCxmZUNvbG9yTWF0cml4LGZlQ29tcG9uZW50VHJhbnNmZXIsZmVDb21wb3NpdGUsZmVDb252b2x2ZU1hdHJpeCxmZURpZmZ1c2VMaWdodGluZyxmZURpc3BsYWNlbWVudE1hcCxmZURpc3RhbnRMaWdodCxmZURyb3BTaGFkb3csZmVGbG9vZCxmZUZ1bmNBLGZlRnVuY0IsZmVGdW5jRyxmZUZ1bmNSLGZlR2F1c3NpYW5CbHVyLGZlSW1hZ2UsZmVNZXJnZSxmZU1lcmdlTm9kZSxmZU1vcnBob2xvZ3ksZmVPZmZzZXQsZmVQb2ludExpZ2h0LGZlU3BlY3VsYXJMaWdodGluZyxmZVNwb3RMaWdodCxmZVRpbGUsZmVUdXJidWxlbmNlLGZpbHRlcixmb3JlaWduT2JqZWN0LGcsaGF0Y2gsaGF0Y2hwYXRoLGltYWdlLGxpbmUsbGluZWFyR3JhZGllbnQsbWFya2VyLG1hc2ssbWVzaCxtZXNoZ3JhZGllbnQsbWVzaHBhdGNoLG1lc2hyb3csbWV0YWRhdGEsbXBhdGgscGF0aCxwYXR0ZXJuLHBvbHlnb24scG9seWxpbmUscmFkaWFsR3JhZGllbnQscmVjdCxzZXQsc29saWRjb2xvcixzdG9wLHN3aXRjaCxzeW1ib2wsdGV4dCx0ZXh0UGF0aCx0aXRsZSx0c3Bhbix1bmtub3duLHVzZSx2aWV3XCI7XG5jb25zdCBWT0lEX1RBR1MgPSBcImFyZWEsYmFzZSxicixjb2wsZW1iZWQsaHIsaW1nLGlucHV0LGxpbmssbWV0YSxwYXJhbSxzb3VyY2UsdHJhY2ssd2JyXCI7XG5jb25zdCBpc0hUTUxUYWcgPSAvKiBAX19QVVJFX18gKi8gbWFrZU1hcChIVE1MX1RBR1MpO1xuY29uc3QgaXNTVkdUYWcgPSAvKiBAX19QVVJFX18gKi8gbWFrZU1hcChTVkdfVEFHUyk7XG5jb25zdCBpc1ZvaWRUYWcgPSAvKiBAX19QVVJFX18gKi8gbWFrZU1hcChWT0lEX1RBR1MpO1xuXG5jb25zdCBzcGVjaWFsQm9vbGVhbkF0dHJzID0gYGl0ZW1zY29wZSxhbGxvd2Z1bGxzY3JlZW4sZm9ybW5vdmFsaWRhdGUsaXNtYXAsbm9tb2R1bGUsbm92YWxpZGF0ZSxyZWFkb25seWA7XG5jb25zdCBpc1NwZWNpYWxCb29sZWFuQXR0ciA9IC8qIEBfX1BVUkVfXyAqLyBtYWtlTWFwKHNwZWNpYWxCb29sZWFuQXR0cnMpO1xuY29uc3QgaXNCb29sZWFuQXR0ciA9IC8qIEBfX1BVUkVfXyAqLyBtYWtlTWFwKFxuICBzcGVjaWFsQm9vbGVhbkF0dHJzICsgYCxhc3luYyxhdXRvZm9jdXMsYXV0b3BsYXksY29udHJvbHMsZGVmYXVsdCxkZWZlcixkaXNhYmxlZCxoaWRkZW4saW5lcnQsbG9vcCxvcGVuLHJlcXVpcmVkLHJldmVyc2VkLHNjb3BlZCxzZWFtbGVzcyxjaGVja2VkLG11dGVkLG11bHRpcGxlLHNlbGVjdGVkYFxuKTtcbmZ1bmN0aW9uIGluY2x1ZGVCb29sZWFuQXR0cih2YWx1ZSkge1xuICByZXR1cm4gISF2YWx1ZSB8fCB2YWx1ZSA9PT0gXCJcIjtcbn1cbmNvbnN0IHVuc2FmZUF0dHJDaGFyUkUgPSAvWz4vPVwiJ1xcdTAwMDlcXHUwMDBhXFx1MDAwY1xcdTAwMjBdLztcbmNvbnN0IGF0dHJWYWxpZGF0aW9uQ2FjaGUgPSB7fTtcbmZ1bmN0aW9uIGlzU1NSU2FmZUF0dHJOYW1lKG5hbWUpIHtcbiAgaWYgKGF0dHJWYWxpZGF0aW9uQ2FjaGUuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICByZXR1cm4gYXR0clZhbGlkYXRpb25DYWNoZVtuYW1lXTtcbiAgfVxuICBjb25zdCBpc1Vuc2FmZSA9IHVuc2FmZUF0dHJDaGFyUkUudGVzdChuYW1lKTtcbiAgaWYgKGlzVW5zYWZlKSB7XG4gICAgY29uc29sZS5lcnJvcihgdW5zYWZlIGF0dHJpYnV0ZSBuYW1lOiAke25hbWV9YCk7XG4gIH1cbiAgcmV0dXJuIGF0dHJWYWxpZGF0aW9uQ2FjaGVbbmFtZV0gPSAhaXNVbnNhZmU7XG59XG5jb25zdCBwcm9wc1RvQXR0ck1hcCA9IHtcbiAgYWNjZXB0Q2hhcnNldDogXCJhY2NlcHQtY2hhcnNldFwiLFxuICBjbGFzc05hbWU6IFwiY2xhc3NcIixcbiAgaHRtbEZvcjogXCJmb3JcIixcbiAgaHR0cEVxdWl2OiBcImh0dHAtZXF1aXZcIlxufTtcbmNvbnN0IGlzS25vd25IdG1sQXR0ciA9IC8qIEBfX1BVUkVfXyAqLyBtYWtlTWFwKFxuICBgYWNjZXB0LGFjY2VwdC1jaGFyc2V0LGFjY2Vzc2tleSxhY3Rpb24sYWxpZ24sYWxsb3csYWx0LGFzeW5jLGF1dG9jYXBpdGFsaXplLGF1dG9jb21wbGV0ZSxhdXRvZm9jdXMsYXV0b3BsYXksYmFja2dyb3VuZCxiZ2NvbG9yLGJvcmRlcixidWZmZXJlZCxjYXB0dXJlLGNoYWxsZW5nZSxjaGFyc2V0LGNoZWNrZWQsY2l0ZSxjbGFzcyxjb2RlLGNvZGViYXNlLGNvbG9yLGNvbHMsY29sc3Bhbixjb250ZW50LGNvbnRlbnRlZGl0YWJsZSxjb250ZXh0bWVudSxjb250cm9scyxjb29yZHMsY3Jvc3NvcmlnaW4sY3NwLGRhdGEsZGF0ZXRpbWUsZGVjb2RpbmcsZGVmYXVsdCxkZWZlcixkaXIsZGlybmFtZSxkaXNhYmxlZCxkb3dubG9hZCxkcmFnZ2FibGUsZHJvcHpvbmUsZW5jdHlwZSxlbnRlcmtleWhpbnQsZm9yLGZvcm0sZm9ybWFjdGlvbixmb3JtZW5jdHlwZSxmb3JtbWV0aG9kLGZvcm1ub3ZhbGlkYXRlLGZvcm10YXJnZXQsaGVhZGVycyxoZWlnaHQsaGlkZGVuLGhpZ2gsaHJlZixocmVmbGFuZyxodHRwLWVxdWl2LGljb24saWQsaW1wb3J0YW5jZSxpbmVydCxpbnRlZ3JpdHksaXNtYXAsaXRlbXByb3Asa2V5dHlwZSxraW5kLGxhYmVsLGxhbmcsbGFuZ3VhZ2UsbG9hZGluZyxsaXN0LGxvb3AsbG93LG1hbmlmZXN0LG1heCxtYXhsZW5ndGgsbWlubGVuZ3RoLG1lZGlhLG1pbixtdWx0aXBsZSxtdXRlZCxuYW1lLG5vdmFsaWRhdGUsb3BlbixvcHRpbXVtLHBhdHRlcm4scGluZyxwbGFjZWhvbGRlcixwb3N0ZXIscHJlbG9hZCxyYWRpb2dyb3VwLHJlYWRvbmx5LHJlZmVycmVycG9saWN5LHJlbCxyZXF1aXJlZCxyZXZlcnNlZCxyb3dzLHJvd3NwYW4sc2FuZGJveCxzY29wZSxzY29wZWQsc2VsZWN0ZWQsc2hhcGUsc2l6ZSxzaXplcyxzbG90LHNwYW4sc3BlbGxjaGVjayxzcmMsc3JjZG9jLHNyY2xhbmcsc3Jjc2V0LHN0YXJ0LHN0ZXAsc3R5bGUsc3VtbWFyeSx0YWJpbmRleCx0YXJnZXQsdGl0bGUsdHJhbnNsYXRlLHR5cGUsdXNlbWFwLHZhbHVlLHdpZHRoLHdyYXBgXG4pO1xuY29uc3QgaXNLbm93blN2Z0F0dHIgPSAvKiBAX19QVVJFX18gKi8gbWFrZU1hcChcbiAgYHhtbG5zLGFjY2VudC1oZWlnaHQsYWNjdW11bGF0ZSxhZGRpdGl2ZSxhbGlnbm1lbnQtYmFzZWxpbmUsYWxwaGFiZXRpYyxhbXBsaXR1ZGUsYXJhYmljLWZvcm0sYXNjZW50LGF0dHJpYnV0ZU5hbWUsYXR0cmlidXRlVHlwZSxhemltdXRoLGJhc2VGcmVxdWVuY3ksYmFzZWxpbmUtc2hpZnQsYmFzZVByb2ZpbGUsYmJveCxiZWdpbixiaWFzLGJ5LGNhbGNNb2RlLGNhcC1oZWlnaHQsY2xhc3MsY2xpcCxjbGlwUGF0aFVuaXRzLGNsaXAtcGF0aCxjbGlwLXJ1bGUsY29sb3IsY29sb3ItaW50ZXJwb2xhdGlvbixjb2xvci1pbnRlcnBvbGF0aW9uLWZpbHRlcnMsY29sb3ItcHJvZmlsZSxjb2xvci1yZW5kZXJpbmcsY29udGVudFNjcmlwdFR5cGUsY29udGVudFN0eWxlVHlwZSxjcm9zc29yaWdpbixjdXJzb3IsY3gsY3ksZCxkZWNlbGVyYXRlLGRlc2NlbnQsZGlmZnVzZUNvbnN0YW50LGRpcmVjdGlvbixkaXNwbGF5LGRpdmlzb3IsZG9taW5hbnQtYmFzZWxpbmUsZHVyLGR4LGR5LGVkZ2VNb2RlLGVsZXZhdGlvbixlbmFibGUtYmFja2dyb3VuZCxlbmQsZXhwb25lbnQsZmlsbCxmaWxsLW9wYWNpdHksZmlsbC1ydWxlLGZpbHRlcixmaWx0ZXJSZXMsZmlsdGVyVW5pdHMsZmxvb2QtY29sb3IsZmxvb2Qtb3BhY2l0eSxmb250LWZhbWlseSxmb250LXNpemUsZm9udC1zaXplLWFkanVzdCxmb250LXN0cmV0Y2gsZm9udC1zdHlsZSxmb250LXZhcmlhbnQsZm9udC13ZWlnaHQsZm9ybWF0LGZyb20sZnIsZngsZnksZzEsZzIsZ2x5cGgtbmFtZSxnbHlwaC1vcmllbnRhdGlvbi1ob3Jpem9udGFsLGdseXBoLW9yaWVudGF0aW9uLXZlcnRpY2FsLGdseXBoUmVmLGdyYWRpZW50VHJhbnNmb3JtLGdyYWRpZW50VW5pdHMsaGFuZ2luZyxoZWlnaHQsaHJlZixocmVmbGFuZyxob3Jpei1hZHYteCxob3Jpei1vcmlnaW4teCxpZCxpZGVvZ3JhcGhpYyxpbWFnZS1yZW5kZXJpbmcsaW4saW4yLGludGVyY2VwdCxrLGsxLGsyLGszLGs0LGtlcm5lbE1hdHJpeCxrZXJuZWxVbml0TGVuZ3RoLGtlcm5pbmcsa2V5UG9pbnRzLGtleVNwbGluZXMsa2V5VGltZXMsbGFuZyxsZW5ndGhBZGp1c3QsbGV0dGVyLXNwYWNpbmcsbGlnaHRpbmctY29sb3IsbGltaXRpbmdDb25lQW5nbGUsbG9jYWwsbWFya2VyLWVuZCxtYXJrZXItbWlkLG1hcmtlci1zdGFydCxtYXJrZXJIZWlnaHQsbWFya2VyVW5pdHMsbWFya2VyV2lkdGgsbWFzayxtYXNrQ29udGVudFVuaXRzLG1hc2tVbml0cyxtYXRoZW1hdGljYWwsbWF4LG1lZGlhLG1ldGhvZCxtaW4sbW9kZSxuYW1lLG51bU9jdGF2ZXMsb2Zmc2V0LG9wYWNpdHksb3BlcmF0b3Isb3JkZXIsb3JpZW50LG9yaWVudGF0aW9uLG9yaWdpbixvdmVyZmxvdyxvdmVybGluZS1wb3NpdGlvbixvdmVybGluZS10aGlja25lc3MscGFub3NlLTEscGFpbnQtb3JkZXIscGF0aCxwYXRoTGVuZ3RoLHBhdHRlcm5Db250ZW50VW5pdHMscGF0dGVyblRyYW5zZm9ybSxwYXR0ZXJuVW5pdHMscGluZyxwb2ludGVyLWV2ZW50cyxwb2ludHMscG9pbnRzQXRYLHBvaW50c0F0WSxwb2ludHNBdFoscHJlc2VydmVBbHBoYSxwcmVzZXJ2ZUFzcGVjdFJhdGlvLHByaW1pdGl2ZVVuaXRzLHIscmFkaXVzLHJlZmVycmVyUG9saWN5LHJlZlgscmVmWSxyZWwscmVuZGVyaW5nLWludGVudCxyZXBlYXRDb3VudCxyZXBlYXREdXIscmVxdWlyZWRFeHRlbnNpb25zLHJlcXVpcmVkRmVhdHVyZXMscmVzdGFydCxyZXN1bHQscm90YXRlLHJ4LHJ5LHNjYWxlLHNlZWQsc2hhcGUtcmVuZGVyaW5nLHNsb3BlLHNwYWNpbmcsc3BlY3VsYXJDb25zdGFudCxzcGVjdWxhckV4cG9uZW50LHNwZWVkLHNwcmVhZE1ldGhvZCxzdGFydE9mZnNldCxzdGREZXZpYXRpb24sc3RlbWgsc3RlbXYsc3RpdGNoVGlsZXMsc3RvcC1jb2xvcixzdG9wLW9wYWNpdHksc3RyaWtldGhyb3VnaC1wb3NpdGlvbixzdHJpa2V0aHJvdWdoLXRoaWNrbmVzcyxzdHJpbmcsc3Ryb2tlLHN0cm9rZS1kYXNoYXJyYXksc3Ryb2tlLWRhc2hvZmZzZXQsc3Ryb2tlLWxpbmVjYXAsc3Ryb2tlLWxpbmVqb2luLHN0cm9rZS1taXRlcmxpbWl0LHN0cm9rZS1vcGFjaXR5LHN0cm9rZS13aWR0aCxzdHlsZSxzdXJmYWNlU2NhbGUsc3lzdGVtTGFuZ3VhZ2UsdGFiaW5kZXgsdGFibGVWYWx1ZXMsdGFyZ2V0LHRhcmdldFgsdGFyZ2V0WSx0ZXh0LWFuY2hvcix0ZXh0LWRlY29yYXRpb24sdGV4dC1yZW5kZXJpbmcsdGV4dExlbmd0aCx0byx0cmFuc2Zvcm0sdHJhbnNmb3JtLW9yaWdpbix0eXBlLHUxLHUyLHVuZGVybGluZS1wb3NpdGlvbix1bmRlcmxpbmUtdGhpY2tuZXNzLHVuaWNvZGUsdW5pY29kZS1iaWRpLHVuaWNvZGUtcmFuZ2UsdW5pdHMtcGVyLWVtLHYtYWxwaGFiZXRpYyx2LWhhbmdpbmcsdi1pZGVvZ3JhcGhpYyx2LW1hdGhlbWF0aWNhbCx2YWx1ZXMsdmVjdG9yLWVmZmVjdCx2ZXJzaW9uLHZlcnQtYWR2LXksdmVydC1vcmlnaW4teCx2ZXJ0LW9yaWdpbi15LHZpZXdCb3gsdmlld1RhcmdldCx2aXNpYmlsaXR5LHdpZHRoLHdpZHRocyx3b3JkLXNwYWNpbmcsd3JpdGluZy1tb2RlLHgseC1oZWlnaHQseDEseDIseENoYW5uZWxTZWxlY3Rvcix4bGluazphY3R1YXRlLHhsaW5rOmFyY3JvbGUseGxpbms6aHJlZix4bGluazpyb2xlLHhsaW5rOnNob3cseGxpbms6dGl0bGUseGxpbms6dHlwZSx4bWw6YmFzZSx4bWw6bGFuZyx4bWw6c3BhY2UseSx5MSx5Mix5Q2hhbm5lbFNlbGVjdG9yLHosem9vbUFuZFBhbmBcbik7XG5cbmNvbnN0IGVzY2FwZVJFID0gL1tcIicmPD5dLztcbmZ1bmN0aW9uIGVzY2FwZUh0bWwoc3RyaW5nKSB7XG4gIGNvbnN0IHN0ciA9IFwiXCIgKyBzdHJpbmc7XG4gIGNvbnN0IG1hdGNoID0gZXNjYXBlUkUuZXhlYyhzdHIpO1xuICBpZiAoIW1hdGNoKSB7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxuICBsZXQgaHRtbCA9IFwiXCI7XG4gIGxldCBlc2NhcGVkO1xuICBsZXQgaW5kZXg7XG4gIGxldCBsYXN0SW5kZXggPSAwO1xuICBmb3IgKGluZGV4ID0gbWF0Y2guaW5kZXg7IGluZGV4IDwgc3RyLmxlbmd0aDsgaW5kZXgrKykge1xuICAgIHN3aXRjaCAoc3RyLmNoYXJDb2RlQXQoaW5kZXgpKSB7XG4gICAgICBjYXNlIDM0OlxuICAgICAgICBlc2NhcGVkID0gXCImcXVvdDtcIjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDM4OlxuICAgICAgICBlc2NhcGVkID0gXCImYW1wO1wiO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMzk6XG4gICAgICAgIGVzY2FwZWQgPSBcIiYjMzk7XCI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSA2MDpcbiAgICAgICAgZXNjYXBlZCA9IFwiJmx0O1wiO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgNjI6XG4gICAgICAgIGVzY2FwZWQgPSBcIiZndDtcIjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKGxhc3RJbmRleCAhPT0gaW5kZXgpIHtcbiAgICAgIGh0bWwgKz0gc3RyLnNsaWNlKGxhc3RJbmRleCwgaW5kZXgpO1xuICAgIH1cbiAgICBsYXN0SW5kZXggPSBpbmRleCArIDE7XG4gICAgaHRtbCArPSBlc2NhcGVkO1xuICB9XG4gIHJldHVybiBsYXN0SW5kZXggIT09IGluZGV4ID8gaHRtbCArIHN0ci5zbGljZShsYXN0SW5kZXgsIGluZGV4KSA6IGh0bWw7XG59XG5jb25zdCBjb21tZW50U3RyaXBSRSA9IC9eLT8+fDwhLS18LS0+fC0tIT58PCEtJC9nO1xuZnVuY3Rpb24gZXNjYXBlSHRtbENvbW1lbnQoc3JjKSB7XG4gIHJldHVybiBzcmMucmVwbGFjZShjb21tZW50U3RyaXBSRSwgXCJcIik7XG59XG5cbmZ1bmN0aW9uIGxvb3NlQ29tcGFyZUFycmF5cyhhLCBiKSB7XG4gIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBsZXQgZXF1YWwgPSB0cnVlO1xuICBmb3IgKGxldCBpID0gMDsgZXF1YWwgJiYgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICBlcXVhbCA9IGxvb3NlRXF1YWwoYVtpXSwgYltpXSk7XG4gIH1cbiAgcmV0dXJuIGVxdWFsO1xufVxuZnVuY3Rpb24gbG9vc2VFcXVhbChhLCBiKSB7XG4gIGlmIChhID09PSBiKVxuICAgIHJldHVybiB0cnVlO1xuICBsZXQgYVZhbGlkVHlwZSA9IGlzRGF0ZShhKTtcbiAgbGV0IGJWYWxpZFR5cGUgPSBpc0RhdGUoYik7XG4gIGlmIChhVmFsaWRUeXBlIHx8IGJWYWxpZFR5cGUpIHtcbiAgICByZXR1cm4gYVZhbGlkVHlwZSAmJiBiVmFsaWRUeXBlID8gYS5nZXRUaW1lKCkgPT09IGIuZ2V0VGltZSgpIDogZmFsc2U7XG4gIH1cbiAgYVZhbGlkVHlwZSA9IGlzU3ltYm9sKGEpO1xuICBiVmFsaWRUeXBlID0gaXNTeW1ib2woYik7XG4gIGlmIChhVmFsaWRUeXBlIHx8IGJWYWxpZFR5cGUpIHtcbiAgICByZXR1cm4gYSA9PT0gYjtcbiAgfVxuICBhVmFsaWRUeXBlID0gaXNBcnJheShhKTtcbiAgYlZhbGlkVHlwZSA9IGlzQXJyYXkoYik7XG4gIGlmIChhVmFsaWRUeXBlIHx8IGJWYWxpZFR5cGUpIHtcbiAgICByZXR1cm4gYVZhbGlkVHlwZSAmJiBiVmFsaWRUeXBlID8gbG9vc2VDb21wYXJlQXJyYXlzKGEsIGIpIDogZmFsc2U7XG4gIH1cbiAgYVZhbGlkVHlwZSA9IGlzT2JqZWN0KGEpO1xuICBiVmFsaWRUeXBlID0gaXNPYmplY3QoYik7XG4gIGlmIChhVmFsaWRUeXBlIHx8IGJWYWxpZFR5cGUpIHtcbiAgICBpZiAoIWFWYWxpZFR5cGUgfHwgIWJWYWxpZFR5cGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgYUtleXNDb3VudCA9IE9iamVjdC5rZXlzKGEpLmxlbmd0aDtcbiAgICBjb25zdCBiS2V5c0NvdW50ID0gT2JqZWN0LmtleXMoYikubGVuZ3RoO1xuICAgIGlmIChhS2V5c0NvdW50ICE9PSBiS2V5c0NvdW50KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZvciAoY29uc3Qga2V5IGluIGEpIHtcbiAgICAgIGNvbnN0IGFIYXNLZXkgPSBhLmhhc093blByb3BlcnR5KGtleSk7XG4gICAgICBjb25zdCBiSGFzS2V5ID0gYi5oYXNPd25Qcm9wZXJ0eShrZXkpO1xuICAgICAgaWYgKGFIYXNLZXkgJiYgIWJIYXNLZXkgfHwgIWFIYXNLZXkgJiYgYkhhc0tleSB8fCAhbG9vc2VFcXVhbChhW2tleV0sIGJba2V5XSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gU3RyaW5nKGEpID09PSBTdHJpbmcoYik7XG59XG5mdW5jdGlvbiBsb29zZUluZGV4T2YoYXJyLCB2YWwpIHtcbiAgcmV0dXJuIGFyci5maW5kSW5kZXgoKGl0ZW0pID0+IGxvb3NlRXF1YWwoaXRlbSwgdmFsKSk7XG59XG5cbmNvbnN0IHRvRGlzcGxheVN0cmluZyA9ICh2YWwpID0+IHtcbiAgcmV0dXJuIGlzU3RyaW5nKHZhbCkgPyB2YWwgOiB2YWwgPT0gbnVsbCA/IFwiXCIgOiBpc0FycmF5KHZhbCkgfHwgaXNPYmplY3QodmFsKSAmJiAodmFsLnRvU3RyaW5nID09PSBvYmplY3RUb1N0cmluZyB8fCAhaXNGdW5jdGlvbih2YWwudG9TdHJpbmcpKSA/IEpTT04uc3RyaW5naWZ5KHZhbCwgcmVwbGFjZXIsIDIpIDogU3RyaW5nKHZhbCk7XG59O1xuY29uc3QgcmVwbGFjZXIgPSAoX2tleSwgdmFsKSA9PiB7XG4gIGlmICh2YWwgJiYgdmFsLl9fdl9pc1JlZikge1xuICAgIHJldHVybiByZXBsYWNlcihfa2V5LCB2YWwudmFsdWUpO1xuICB9IGVsc2UgaWYgKGlzTWFwKHZhbCkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgW2BNYXAoJHt2YWwuc2l6ZX0pYF06IFsuLi52YWwuZW50cmllcygpXS5yZWR1Y2UoKGVudHJpZXMsIFtrZXksIHZhbDJdKSA9PiB7XG4gICAgICAgIGVudHJpZXNbYCR7a2V5fSA9PmBdID0gdmFsMjtcbiAgICAgICAgcmV0dXJuIGVudHJpZXM7XG4gICAgICB9LCB7fSlcbiAgICB9O1xuICB9IGVsc2UgaWYgKGlzU2V0KHZhbCkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgW2BTZXQoJHt2YWwuc2l6ZX0pYF06IFsuLi52YWwudmFsdWVzKCldXG4gICAgfTtcbiAgfSBlbHNlIGlmIChpc09iamVjdCh2YWwpICYmICFpc0FycmF5KHZhbCkgJiYgIWlzUGxhaW5PYmplY3QodmFsKSkge1xuICAgIHJldHVybiBTdHJpbmcodmFsKTtcbiAgfVxuICByZXR1cm4gdmFsO1xufTtcblxuZXhwb3J0IHsgRU1QVFlfQVJSLCBFTVBUWV9PQkosIE5PLCBOT09QLCBQYXRjaEZsYWdOYW1lcywgY2FtZWxpemUsIGNhcGl0YWxpemUsIGRlZiwgZXNjYXBlSHRtbCwgZXNjYXBlSHRtbENvbW1lbnQsIGV4dGVuZCwgZ2VuUHJvcHNBY2Nlc3NFeHAsIGdlbmVyYXRlQ29kZUZyYW1lLCBnZXRHbG9iYWxUaGlzLCBoYXNDaGFuZ2VkLCBoYXNPd24sIGh5cGhlbmF0ZSwgaW5jbHVkZUJvb2xlYW5BdHRyLCBpbnZva2VBcnJheUZucywgaXNBcnJheSwgaXNCb29sZWFuQXR0ciwgaXNCdWlsdEluRGlyZWN0aXZlLCBpc0RhdGUsIGlzRnVuY3Rpb24sIGlzR2xvYmFsbHlXaGl0ZWxpc3RlZCwgaXNIVE1MVGFnLCBpc0ludGVnZXJLZXksIGlzS25vd25IdG1sQXR0ciwgaXNLbm93blN2Z0F0dHIsIGlzTWFwLCBpc01vZGVsTGlzdGVuZXIsIGlzT2JqZWN0LCBpc09uLCBpc1BsYWluT2JqZWN0LCBpc1Byb21pc2UsIGlzUmVnRXhwLCBpc1Jlc2VydmVkUHJvcCwgaXNTU1JTYWZlQXR0ck5hbWUsIGlzU1ZHVGFnLCBpc1NldCwgaXNTcGVjaWFsQm9vbGVhbkF0dHIsIGlzU3RyaW5nLCBpc1N5bWJvbCwgaXNWb2lkVGFnLCBsb29zZUVxdWFsLCBsb29zZUluZGV4T2YsIGxvb3NlVG9OdW1iZXIsIG1ha2VNYXAsIG5vcm1hbGl6ZUNsYXNzLCBub3JtYWxpemVQcm9wcywgbm9ybWFsaXplU3R5bGUsIG9iamVjdFRvU3RyaW5nLCBwYXJzZVN0cmluZ1N0eWxlLCBwcm9wc1RvQXR0ck1hcCwgcmVtb3ZlLCBzbG90RmxhZ3NUZXh0LCBzdHJpbmdpZnlTdHlsZSwgdG9EaXNwbGF5U3RyaW5nLCB0b0hhbmRsZXJLZXksIHRvTnVtYmVyLCB0b1Jhd1R5cGUsIHRvVHlwZVN0cmluZyB9O1xuIiwiZXhwb3J0cy5pbnRlcm9wRGVmYXVsdCA9IGZ1bmN0aW9uIChhKSB7XG4gIHJldHVybiBhICYmIGEuX19lc01vZHVsZSA/IGEgOiB7ZGVmYXVsdDogYX07XG59O1xuXG5leHBvcnRzLmRlZmluZUludGVyb3BGbGFnID0gZnVuY3Rpb24gKGEpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGEsICdfX2VzTW9kdWxlJywge3ZhbHVlOiB0cnVlfSk7XG59O1xuXG5leHBvcnRzLmV4cG9ydEFsbCA9IGZ1bmN0aW9uIChzb3VyY2UsIGRlc3QpIHtcbiAgT2JqZWN0LmtleXMoc291cmNlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICBpZiAoa2V5ID09PSAnZGVmYXVsdCcgfHwga2V5ID09PSAnX19lc01vZHVsZScgfHwgZGVzdC5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGRlc3QsIGtleSwge1xuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gc291cmNlW2tleV07XG4gICAgICB9LFxuICAgIH0pO1xuICB9KTtcblxuICByZXR1cm4gZGVzdDtcbn07XG5cbmV4cG9ydHMuZXhwb3J0ID0gZnVuY3Rpb24gKGRlc3QsIGRlc3ROYW1lLCBnZXQpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGRlc3QsIGRlc3ROYW1lLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGdldCxcbiAgfSk7XG59O1xuIiwiaW1wb3J0IHR5cGUgeyBQbGFzbW9DU1VJLCBQbGFzbW9DU1VJQW5jaG9yLCBQbGFzbW9DU1VJTW91bnRTdGF0ZSB9IGZyb20gXCJ+dHlwZVwiXG5cbmFzeW5jIGZ1bmN0aW9uIGNyZWF0ZVNoYWRvd0RPTTxUPihNb3VudDogUGxhc21vQ1NVSTxUPikge1xuICBjb25zdCBzaGFkb3dIb3N0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInBsYXNtby1jc3VpXCIpXG5cbiAgY29uc3Qgc2hhZG93Um9vdCA9XG4gICAgdHlwZW9mIE1vdW50LmNyZWF0ZVNoYWRvd1Jvb3QgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgPyBhd2FpdCBNb3VudC5jcmVhdGVTaGFkb3dSb290KHNoYWRvd0hvc3QpXG4gICAgICA6IHNoYWRvd0hvc3QuYXR0YWNoU2hhZG93KHsgbW9kZTogXCJvcGVuXCIgfSlcblxuICBjb25zdCBzaGFkb3dDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpXG5cbiAgc2hhZG93Q29udGFpbmVyLmlkID0gXCJwbGFzbW8tc2hhZG93LWNvbnRhaW5lclwiXG4gIHNoYWRvd0NvbnRhaW5lci5zdHlsZS56SW5kZXggPSBcIjIxNDc0ODM2NDdcIlxuICBzaGFkb3dDb250YWluZXIuc3R5bGUucG9zaXRpb24gPSBcInJlbGF0aXZlXCJcblxuICBzaGFkb3dSb290LmFwcGVuZENoaWxkKHNoYWRvd0NvbnRhaW5lcilcblxuICByZXR1cm4ge1xuICAgIHNoYWRvd0hvc3QsXG4gICAgc2hhZG93Um9vdCxcbiAgICBzaGFkb3dDb250YWluZXJcbiAgfVxufVxuXG5leHBvcnQgdHlwZSBQbGFzbW9DU1VJU2hhZG93RE9NID0gQXdhaXRlZDxSZXR1cm5UeXBlPHR5cGVvZiBjcmVhdGVTaGFkb3dET00+PlxuXG5hc3luYyBmdW5jdGlvbiBpbmplY3RBbmNob3I8VD4oXG4gIE1vdW50OiBQbGFzbW9DU1VJPFQ+LFxuICBhbmNob3I6IFBsYXNtb0NTVUlBbmNob3IsXG4gIHsgc2hhZG93SG9zdCwgc2hhZG93Um9vdCB9OiBQbGFzbW9DU1VJU2hhZG93RE9NLFxuICBtb3VudFN0YXRlPzogUGxhc21vQ1NVSU1vdW50U3RhdGVcbikge1xuICBpZiAodHlwZW9mIE1vdW50LmdldFN0eWxlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBjb25zdCBzZmNTdHlsZUNvbnRlbnQgPVxuICAgICAgdHlwZW9mIE1vdW50LmdldFNmY1N0eWxlQ29udGVudCA9PT0gXCJmdW5jdGlvblwiXG4gICAgICAgID8gYXdhaXQgTW91bnQuZ2V0U2ZjU3R5bGVDb250ZW50KClcbiAgICAgICAgOiBcIlwiXG4gICAgc2hhZG93Um9vdC5wcmVwZW5kKGF3YWl0IE1vdW50LmdldFN0eWxlKHsgLi4uYW5jaG9yLCBzZmNTdHlsZUNvbnRlbnQgfSkpXG4gIH1cblxuICBpZiAodHlwZW9mIE1vdW50LmdldFNoYWRvd0hvc3RJZCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgc2hhZG93SG9zdC5pZCA9IGF3YWl0IE1vdW50LmdldFNoYWRvd0hvc3RJZChhbmNob3IpXG4gIH1cblxuICBpZiAodHlwZW9mIE1vdW50Lm1vdW50U2hhZG93SG9zdCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgYXdhaXQgTW91bnQubW91bnRTaGFkb3dIb3N0KHtcbiAgICAgIHNoYWRvd0hvc3QsXG4gICAgICBhbmNob3IsXG4gICAgICBtb3VudFN0YXRlXG4gICAgfSlcbiAgfSBlbHNlIGlmIChhbmNob3IudHlwZSA9PT0gXCJpbmxpbmVcIikge1xuICAgIGFuY2hvci5lbGVtZW50Lmluc2VydEFkamFjZW50RWxlbWVudChcImFmdGVyZW5kXCIsIHNoYWRvd0hvc3QpXG4gIH0gZWxzZSB7XG4gICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnByZXBlbmQoc2hhZG93SG9zdClcbiAgfVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY3JlYXRlU2hhZG93Q29udGFpbmVyPFQ+KFxuICBNb3VudDogUGxhc21vQ1NVSTxUPixcbiAgYW5jaG9yOiBQbGFzbW9DU1VJQW5jaG9yLFxuICBtb3VudFN0YXRlPzogUGxhc21vQ1NVSU1vdW50U3RhdGVcbikge1xuICBjb25zdCBzaGFkb3dEb20gPSBhd2FpdCBjcmVhdGVTaGFkb3dET00oTW91bnQpXG5cbiAgbW91bnRTdGF0ZT8uaG9zdFNldC5hZGQoc2hhZG93RG9tLnNoYWRvd0hvc3QpXG4gIG1vdW50U3RhdGU/Lmhvc3RNYXAuc2V0KHNoYWRvd0RvbS5zaGFkb3dIb3N0LCBhbmNob3IpXG5cbiAgYXdhaXQgaW5qZWN0QW5jaG9yKE1vdW50LCBhbmNob3IsIHNoYWRvd0RvbSwgbW91bnRTdGF0ZSlcblxuICByZXR1cm4gc2hhZG93RG9tLnNoYWRvd0NvbnRhaW5lclxufVxuXG5jb25zdCBpc1Zpc2libGUgPSAoZWw6IEVsZW1lbnQpID0+IHtcbiAgaWYgKCFlbCkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIGNvbnN0IGVsZW1lbnRSZWN0ID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcbiAgY29uc3QgZWxlbWVudFN0eWxlID0gZ2xvYmFsVGhpcy5nZXRDb21wdXRlZFN0eWxlKGVsKVxuXG4gIC8vIGNvbnNvbGUubG9nKGVsZW1lbnRSZWN0LCBlbGVtZW50U3R5bGUpXG5cbiAgaWYgKGVsZW1lbnRTdHlsZS5kaXNwbGF5ID09PSBcIm5vbmVcIikge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgaWYgKGVsZW1lbnRTdHlsZS52aXNpYmlsaXR5ID09PSBcImhpZGRlblwiKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBpZiAoZWxlbWVudFN0eWxlLm9wYWNpdHkgPT09IFwiMFwiKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBpZiAoXG4gICAgZWxlbWVudFJlY3Qud2lkdGggPT09IDAgJiZcbiAgICBlbGVtZW50UmVjdC5oZWlnaHQgPT09IDAgJiZcbiAgICBlbGVtZW50U3R5bGUub3ZlcmZsb3cgIT09IFwiaGlkZGVuXCJcbiAgKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICAvLyBDaGVjayBpZiB0aGUgZWxlbWVudCBpcyBpcnJldm9jYWJseSBvZmYtc2NyZWVuOlxuICBpZiAoXG4gICAgZWxlbWVudFJlY3QueCArIGVsZW1lbnRSZWN0LndpZHRoIDwgMCB8fFxuICAgIGVsZW1lbnRSZWN0LnkgKyBlbGVtZW50UmVjdC5oZWlnaHQgPCAwXG4gICkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgcmV0dXJuIHRydWVcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUFuY2hvck9ic2VydmVyPFQ+KE1vdW50OiBQbGFzbW9DU1VJPFQ+KSB7XG4gIGNvbnN0IG1vdW50U3RhdGU6IFBsYXNtb0NTVUlNb3VudFN0YXRlID0ge1xuICAgIGRvY3VtZW50OiBkb2N1bWVudCB8fCB3aW5kb3cuZG9jdW1lbnQsXG4gICAgb2JzZXJ2ZXI6IG51bGwsXG5cbiAgICBtb3VudEludGVydmFsOiBudWxsLFxuXG4gICAgaXNNb3VudGluZzogZmFsc2UsXG4gICAgaXNNdXRhdGVkOiBmYWxzZSxcblxuICAgIGhvc3RTZXQ6IG5ldyBTZXQoKSxcbiAgICBob3N0TWFwOiBuZXcgV2Vha01hcCgpLFxuXG4gICAgb3ZlcmxheVRhcmdldExpc3Q6IFtdXG4gIH1cblxuICBjb25zdCBpc01vdW50ZWQgPSAoZWw6IEVsZW1lbnQgfCBudWxsKSA9PlxuICAgIGVsPy5pZFxuICAgICAgPyAhIWRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGVsLmlkKVxuICAgICAgOiBlbD8uZ2V0Um9vdE5vZGUoeyBjb21wb3NlZDogdHJ1ZSB9KSA9PT0gbW91bnRTdGF0ZS5kb2N1bWVudFxuXG4gIGNvbnN0IGhhc0lubGluZUFuY2hvciA9IHR5cGVvZiBNb3VudC5nZXRJbmxpbmVBbmNob3IgPT09IFwiZnVuY3Rpb25cIlxuICBjb25zdCBoYXNPdmVybGF5QW5jaG9yID0gdHlwZW9mIE1vdW50LmdldE92ZXJsYXlBbmNob3IgPT09IFwiZnVuY3Rpb25cIlxuXG4gIGNvbnN0IGhhc0lubGluZUFuY2hvckxpc3QgPSB0eXBlb2YgTW91bnQuZ2V0SW5saW5lQW5jaG9yTGlzdCA9PT0gXCJmdW5jdGlvblwiXG4gIGNvbnN0IGhhc092ZXJsYXlBbmNob3JMaXN0ID0gdHlwZW9mIE1vdW50LmdldE92ZXJsYXlBbmNob3JMaXN0ID09PSBcImZ1bmN0aW9uXCJcblxuICBjb25zdCBzaG91bGRPYnNlcnZlID1cbiAgICBoYXNJbmxpbmVBbmNob3IgfHxcbiAgICBoYXNPdmVybGF5QW5jaG9yIHx8XG4gICAgaGFzSW5saW5lQW5jaG9yTGlzdCB8fFxuICAgIGhhc092ZXJsYXlBbmNob3JMaXN0XG5cbiAgaWYgKCFzaG91bGRPYnNlcnZlKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIGFzeW5jIGZ1bmN0aW9uIG1vdW50QW5jaG9ycyhyZW5kZXI6IChhbmNob3I/OiBQbGFzbW9DU1VJQW5jaG9yKSA9PiB2b2lkKSB7XG4gICAgbW91bnRTdGF0ZS5pc01vdW50aW5nID0gdHJ1ZVxuXG4gICAgY29uc3QgbW91bnRlZElubGluZUFuY2hvclNldCA9IG5ldyBXZWFrU2V0KClcblxuICAgIC8vIFRoZXJlIHNob3VsZCBvbmx5IGJlIDEgb3ZlcmxheSBtb3VudFxuICAgIGxldCBvdmVybGF5SG9zdDogRWxlbWVudCA9IG51bGxcblxuICAgIC8vIEdvIHRocm91Z2ggbW91bnRlZCBzZXRzIGFuZCBjaGVjayBpZiB0aGV5IGFyZSBzdGlsbCBtb3VudGVkXG4gICAgZm9yIChjb25zdCBlbCBvZiBtb3VudFN0YXRlLmhvc3RTZXQpIHtcbiAgICAgIGlmIChpc01vdW50ZWQoZWwpKSB7XG4gICAgICAgIGNvbnN0IGFuY2hvciA9IG1vdW50U3RhdGUuaG9zdE1hcC5nZXQoZWwpXG4gICAgICAgIGlmICghIWFuY2hvcikge1xuICAgICAgICAgIGlmIChhbmNob3IudHlwZSA9PT0gXCJpbmxpbmVcIikge1xuICAgICAgICAgICAgbW91bnRlZElubGluZUFuY2hvclNldC5hZGQoYW5jaG9yLmVsZW1lbnQpXG4gICAgICAgICAgfSBlbHNlIGlmIChhbmNob3IudHlwZSA9PT0gXCJvdmVybGF5XCIpIHtcbiAgICAgICAgICAgIG92ZXJsYXlIb3N0ID0gZWxcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1vdW50U3RhdGUuaG9zdFNldC5kZWxldGUoZWwpXG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgW2lubGluZUFuY2hvciwgaW5saW5lQW5jaG9yTGlzdCwgb3ZlcmxheUFuY2hvciwgb3ZlcmxheUFuY2hvckxpc3RdID1cbiAgICAgIGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgaGFzSW5saW5lQW5jaG9yID8gTW91bnQuZ2V0SW5saW5lQW5jaG9yKCkgOiBudWxsLFxuICAgICAgICBoYXNJbmxpbmVBbmNob3JMaXN0ID8gTW91bnQuZ2V0SW5saW5lQW5jaG9yTGlzdCgpIDogbnVsbCxcbiAgICAgICAgaGFzT3ZlcmxheUFuY2hvciA/IE1vdW50LmdldE92ZXJsYXlBbmNob3IoKSA6IG51bGwsXG4gICAgICAgIGhhc092ZXJsYXlBbmNob3JMaXN0ID8gTW91bnQuZ2V0T3ZlcmxheUFuY2hvckxpc3QoKSA6IG51bGxcbiAgICAgIF0pXG5cbiAgICBjb25zdCByZW5kZXJMaXN0OiBQbGFzbW9DU1VJQW5jaG9yW10gPSBbXVxuXG4gICAgaWYgKCEhaW5saW5lQW5jaG9yICYmICFtb3VudGVkSW5saW5lQW5jaG9yU2V0LmhhcyhpbmxpbmVBbmNob3IpKSB7XG4gICAgICByZW5kZXJMaXN0LnB1c2goe1xuICAgICAgICBlbGVtZW50OiBpbmxpbmVBbmNob3IsXG4gICAgICAgIHR5cGU6IFwiaW5saW5lXCJcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgaWYgKChpbmxpbmVBbmNob3JMaXN0Py5sZW5ndGggfHwgMCkgPiAwKSB7XG4gICAgICBpbmxpbmVBbmNob3JMaXN0LmZvckVhY2goKGlubGluZUFuY2hvcikgPT4ge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgaW5saW5lQW5jaG9yIGluc3RhbmNlb2YgRWxlbWVudCAmJlxuICAgICAgICAgICFtb3VudGVkSW5saW5lQW5jaG9yU2V0LmhhcyhpbmxpbmVBbmNob3IpXG4gICAgICAgICkge1xuICAgICAgICAgIHJlbmRlckxpc3QucHVzaCh7XG4gICAgICAgICAgICBlbGVtZW50OiBpbmxpbmVBbmNob3IsXG4gICAgICAgICAgICB0eXBlOiBcImlubGluZVwiXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG5cbiAgICBjb25zdCBvdmVybGF5VGFyZ2V0TGlzdCA9IFtdXG5cbiAgICBpZiAoISFvdmVybGF5QW5jaG9yICYmIGlzVmlzaWJsZShvdmVybGF5QW5jaG9yKSkge1xuICAgICAgb3ZlcmxheVRhcmdldExpc3QucHVzaChvdmVybGF5QW5jaG9yKVxuICAgIH1cblxuICAgIGlmICgob3ZlcmxheUFuY2hvckxpc3Q/Lmxlbmd0aCB8fCAwKSA+IDApIHtcbiAgICAgIG92ZXJsYXlBbmNob3JMaXN0LmZvckVhY2goKGVsKSA9PiB7XG4gICAgICAgIGlmIChlbCBpbnN0YW5jZW9mIEVsZW1lbnQgJiYgaXNWaXNpYmxlKGVsKSkge1xuICAgICAgICAgIG92ZXJsYXlUYXJnZXRMaXN0LnB1c2goZWwpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuXG4gICAgaWYgKG92ZXJsYXlUYXJnZXRMaXN0Lmxlbmd0aCA+IDApIHtcbiAgICAgIG1vdW50U3RhdGUub3ZlcmxheVRhcmdldExpc3QgPSBvdmVybGF5VGFyZ2V0TGlzdFxuICAgICAgaWYgKCFvdmVybGF5SG9zdCkge1xuICAgICAgICByZW5kZXJMaXN0LnB1c2goe1xuICAgICAgICAgIGVsZW1lbnQ6IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCxcbiAgICAgICAgICB0eXBlOiBcIm92ZXJsYXlcIlxuICAgICAgICB9KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZm9yY2UgcmUtcmVuZGVyXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG92ZXJsYXlIb3N0Py5yZW1vdmUoKVxuICAgICAgbW91bnRTdGF0ZS5ob3N0U2V0LmRlbGV0ZShvdmVybGF5SG9zdClcbiAgICB9XG5cbiAgICBhd2FpdCBQcm9taXNlLmFsbChyZW5kZXJMaXN0Lm1hcChyZW5kZXIpKVxuXG4gICAgaWYgKG1vdW50U3RhdGUuaXNNdXRhdGVkKSB7XG4gICAgICBtb3VudFN0YXRlLmlzTXV0YXRlZCA9IGZhbHNlXG4gICAgICBhd2FpdCBtb3VudEFuY2hvcnMocmVuZGVyKVxuICAgIH1cblxuICAgIG1vdW50U3RhdGUuaXNNb3VudGluZyA9IGZhbHNlXG4gIH1cblxuICBjb25zdCBzdGFydCA9IChyZW5kZXI6IChhbmNob3I/OiBQbGFzbW9DU1VJQW5jaG9yKSA9PiB2b2lkKSA9PiB7XG4gICAgbW91bnRTdGF0ZS5vYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKCgpID0+IHtcbiAgICAgIGlmIChtb3VudFN0YXRlLmlzTW91bnRpbmcpIHtcbiAgICAgICAgbW91bnRTdGF0ZS5pc011dGF0ZWQgPSB0cnVlXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgbW91bnRBbmNob3JzKHJlbmRlcilcbiAgICB9KVxuXG4gICAgLy8gTmVlZCB0byB3YXRjaCB0aGUgc3VidHJlZSBmb3Igc2hhZG93RE9NXG4gICAgbW91bnRTdGF0ZS5vYnNlcnZlci5vYnNlcnZlKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCwge1xuICAgICAgY2hpbGRMaXN0OiB0cnVlLFxuICAgICAgc3VidHJlZTogdHJ1ZVxuICAgIH0pXG5cbiAgICBtb3VudFN0YXRlLm1vdW50SW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICBpZiAobW91bnRTdGF0ZS5pc01vdW50aW5nKSB7XG4gICAgICAgIG1vdW50U3RhdGUuaXNNdXRhdGVkID0gdHJ1ZVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIG1vdW50QW5jaG9ycyhyZW5kZXIpXG4gICAgfSwgMTQyKVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBzdGFydCxcbiAgICBtb3VudFN0YXRlXG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IGNyZWF0ZVJlbmRlciA9IDxUPihcbiAgTW91bnQ6IFBsYXNtb0NTVUk8VD4sXG4gIGNvbnRhaW5lcnM6IFtULCBUXSxcbiAgbW91bnRTdGF0ZT86IFBsYXNtb0NTVUlNb3VudFN0YXRlLFxuICByZW5kZXJGeD86IChhbmNob3I6IFBsYXNtb0NTVUlBbmNob3IsIHJvb3RDb250YWluZXI6IEVsZW1lbnQpID0+IFByb21pc2U8dm9pZD5cbikgPT4ge1xuICBjb25zdCBjcmVhdGVSb290Q29udGFpbmVyID0gKGFuY2hvcjogUGxhc21vQ1NVSUFuY2hvcikgPT5cbiAgICB0eXBlb2YgTW91bnQuZ2V0Um9vdENvbnRhaW5lciA9PT0gXCJmdW5jdGlvblwiXG4gICAgICA/IE1vdW50LmdldFJvb3RDb250YWluZXIoe1xuICAgICAgICAgIGFuY2hvcixcbiAgICAgICAgICBtb3VudFN0YXRlXG4gICAgICAgIH0pXG4gICAgICA6IGNyZWF0ZVNoYWRvd0NvbnRhaW5lcihNb3VudCwgYW5jaG9yLCBtb3VudFN0YXRlKVxuXG4gIGlmICh0eXBlb2YgTW91bnQucmVuZGVyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICByZXR1cm4gKGFuY2hvcjogUGxhc21vQ1NVSUFuY2hvcikgPT5cbiAgICAgIE1vdW50LnJlbmRlcihcbiAgICAgICAge1xuICAgICAgICAgIGFuY2hvcixcbiAgICAgICAgICBjcmVhdGVSb290Q29udGFpbmVyXG4gICAgICAgIH0sXG4gICAgICAgIC4uLmNvbnRhaW5lcnNcbiAgICAgIClcbiAgfVxuXG4gIHJldHVybiBhc3luYyAoYW5jaG9yOiBQbGFzbW9DU1VJQW5jaG9yKSA9PiB7XG4gICAgY29uc3Qgcm9vdENvbnRhaW5lciA9IGF3YWl0IGNyZWF0ZVJvb3RDb250YWluZXIoYW5jaG9yKVxuICAgIHJldHVybiByZW5kZXJGeChhbmNob3IsIHJvb3RDb250YWluZXIpXG4gIH1cbn1cbiIsImltcG9ydCB0eXBlIHsgUGxhc21vQ1NVSUNvbnRhaW5lclByb3BzIH0gZnJvbSBcIn50eXBlXCJcblxuZXhwb3J0IGNvbnN0IGNyZWF0ZU92ZXJsYXlDU1VJQ29udGFpbmVyID0gKHByb3BzOiBQbGFzbW9DU1VJQ29udGFpbmVyUHJvcHMpID0+IHtcbiAgY29uc3QgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKVxuICBjb250YWluZXIuY2xhc3NOYW1lID0gXCJwbGFzbW8tY3N1aS1jb250YWluZXJcIlxuICBjb250YWluZXIuaWQgPSBwcm9wcy5pZFxuXG4gIGNvbnRhaW5lci5zdHlsZS5jc3NUZXh0ID0gYFxuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgIHRvcDogMHB4O1xuICAgIGxlZnQ6IDBweDtcbiAgYFxuXG4gIGlmIChwcm9wcy5hbmNob3IudHlwZSA9PT0gXCJvdmVybGF5XCIpIHtcbiAgICBjb25zdCB1cGRhdGVQb3NpdGlvbiA9IGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHJlY3QgPSBwcm9wcy5hbmNob3IuZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuXG4gICAgICBpZiAoIXJlY3QpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHBvcyA9IHtcbiAgICAgICAgbGVmdDogcmVjdC5sZWZ0ICsgd2luZG93LnNjcm9sbFgsXG4gICAgICAgIHRvcDogcmVjdC50b3AgKyB3aW5kb3cuc2Nyb2xsWVxuICAgICAgfVxuXG4gICAgICBjb250YWluZXIuc3R5bGUudG9wID0gYCR7cG9zLnRvcH1weGBcbiAgICAgIGNvbnRhaW5lci5zdHlsZS5sZWZ0ID0gYCR7cG9zLmxlZnR9cHhgXG4gICAgfVxuXG4gICAgdXBkYXRlUG9zaXRpb24oKVxuXG4gICAgcHJvcHMud2F0Y2hPdmVybGF5QW5jaG9yPy4odXBkYXRlUG9zaXRpb24pXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgdXBkYXRlUG9zaXRpb24pXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgdXBkYXRlUG9zaXRpb24pXG4gIH1cblxuICByZXR1cm4gY29udGFpbmVyXG59XG5cbmV4cG9ydCBjb25zdCBjcmVhdGVJbmxpbmVDU1VJQ29udGFpbmVyID0gKHByb3BzOiBQbGFzbW9DU1VJQ29udGFpbmVyUHJvcHMpID0+IHtcbiAgY29uc3QgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKVxuICBjb250YWluZXIuY2xhc3NOYW1lID0gXCJwbGFzbW8tY3N1aS1jb250YWluZXJcIlxuICBjb250YWluZXIuaWQgPSBcInBsYXNtby1pbmxpbmVcIlxuXG4gIGNvbnRhaW5lci5zdHlsZS5jc3NUZXh0ID0gYFxuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgIHRvcDogMHB4O1xuICAgIGxlZnQ6IDBweDtcbiAgYFxuXG4gIHJldHVybiBjb250YWluZXJcbn1cbiIsImdsb2JhbFRoaXMuX19WVUVfT1BUSU9OU19BUElfXyA9IHRydWVcbmdsb2JhbFRoaXMuX19WVUVfUFJPRF9ERVZUT09MU19fID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiXG4iLG51bGwsIm1vZHVsZS5leHBvcnRzID0gXCJkNmVlZDUyZTc0YzNkMTBmXCI7Il0sIm5hbWVzIjpbXSwidmVyc2lvbiI6MywiZmlsZSI6InBsYXNtby1vdmVybGF5LjlmM2I5MTNmLmpzLm1hcCJ9
 globalThis.define=__define;  })(globalThis.define);