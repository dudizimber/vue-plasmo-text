(function(define){var __define; typeof define === "function" && (__define=define,define=null);
// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles

(function (modules, entry, mainEntry, parcelRequireName, globalName) {
  /* eslint-disable no-undef */
  var globalObject =
    typeof globalThis !== 'undefined'
      ? globalThis
      : typeof self !== 'undefined'
      ? self
      : typeof window !== 'undefined'
      ? window
      : typeof global !== 'undefined'
      ? global
      : {};
  /* eslint-enable no-undef */

  // Save the require from previous bundle to this closure if any
  var previousRequire =
    typeof globalObject[parcelRequireName] === 'function' &&
    globalObject[parcelRequireName];

  var cache = previousRequire.cache || {};
  // Do not use `require` to prevent Webpack from trying to bundle this call
  var nodeRequire =
    typeof module !== 'undefined' &&
    typeof module.require === 'function' &&
    module.require.bind(module);

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire =
          typeof globalObject[parcelRequireName] === 'function' &&
          globalObject[parcelRequireName];
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error("Cannot find module '" + name + "'");
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = (cache[name] = new newRequire.Module(name));

      modules[name][0].call(
        module.exports,
        localRequire,
        module,
        module.exports,
        this
      );
    }

    return cache[name].exports;

    function localRequire(x) {
      var res = localRequire.resolve(x);
      return res === false ? {} : newRequire(res);
    }

    function resolve(x) {
      var id = modules[name][1][x];
      return id != null ? id : x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.register = function (id, exports) {
    modules[id] = [
      function (require, module) {
        module.exports = exports;
      },
      {},
    ];
  };

  Object.defineProperty(newRequire, 'root', {
    get: function () {
      return globalObject[parcelRequireName];
    },
  });

  globalObject[parcelRequireName] = newRequire;

  for (var i = 0; i < entry.length; i++) {
    newRequire(entry[i]);
  }

  if (mainEntry) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(mainEntry);

    // CommonJS
    if (typeof exports === 'object' && typeof module !== 'undefined') {
      module.exports = mainExports;

      // RequireJS
    } else if (typeof define === 'function' && define.amd) {
      define(function () {
        return mainExports;
      });

      // <script>
    } else if (globalName) {
      this[globalName] = mainExports;
    }
  }
})({"beKS4":[function(require,module,exports) {
var p = typeof globalThis.process < "u" ? globalThis.process.argv : [];
var y = ()=>typeof globalThis.process < "u" ? globalThis.process.env : {};
var M = new Set(p), _ = (e)=>M.has(e), z = p.filter((e)=>e.startsWith("--") && e.includes("=")).map((e)=>e.split("=")).reduce((e, [t, o])=>(e[t] = o, e), {});
var X = _("--dry-run"), d = ()=>_("--verbose") || y().VERBOSE === "true", G = d();
var u = (e = "", ...t)=>console.log(e.padEnd(9), "|", ...t);
var v = (...e)=>console.error("\uD83D\uDD34 ERROR".padEnd(9), "|", ...e), x = (...e)=>u("\uD83D\uDD35 INFO", ...e), g = (...e)=>u("\uD83D\uDFE0 WARN", ...e), D = 0, c = (...e)=>d() && u(`\u{1F7E1} ${D++}`, ...e);
var s = {
    "isContentScript": true,
    "isBackground": false,
    "isReact": false,
    "runtimes": [
        "script-runtime"
    ],
    "host": "localhost",
    "port": 1815,
    "entryFilePath": "/Users/davidzimberknopf/Documents/Apps/vue-plasmo-text/.plasmo/static/contents/plasmo-inline.ts",
    "bundleId": "0d6818aad57b6e9f",
    "envHash": "e792fbbdaa78ee84",
    "verbose": "false",
    "secure": false,
    "serverPort": 52712
};
module.bundle.HMR_BUNDLE_ID = s.bundleId;
globalThis.process = {
    argv: [],
    env: {
        VERBOSE: s.verbose
    }
};
var H = module.bundle.Module;
function I(e) {
    H.call(this, e), this.hot = {
        data: module.bundle.hotData[e],
        _acceptCallbacks: [],
        _disposeCallbacks: [],
        accept: function(t) {
            this._acceptCallbacks.push(t || function() {});
        },
        dispose: function(t) {
            this._disposeCallbacks.push(t);
        }
    }, module.bundle.hotData[e] = void 0;
}
module.bundle.Module = I;
module.bundle.hotData = {};
var l = globalThis.browser || globalThis.chrome || null;
function b() {
    return !s.host || s.host === "0.0.0.0" ? location.protocol.indexOf("http") === 0 ? location.hostname : "localhost" : s.host;
}
function C() {
    return s.port || location.port;
}
var E = "__plasmo_runtime_script_";
function L(e, t) {
    let { modules: o } = e;
    return o ? !!o[t] : !1;
}
function S(e = C()) {
    let t = b();
    return `${s.secure || location.protocol === "https:" && !/localhost|127.0.0.1|0.0.0.0/.test(t) ? "wss" : "ws"}://${t}:${e}/`;
}
function O(e) {
    typeof e.message == "string" && v("[plasmo/parcel-runtime]: " + e.message);
}
function P(e) {
    if (typeof globalThis.WebSocket > "u") return;
    let t = new WebSocket(S());
    return t.addEventListener("message", async function(o) {
        let r = JSON.parse(o.data);
        if (r.type === "update" && await e(r.assets), r.type === "error") for (let i of r.diagnostics.ansi){
            let w = i.codeframe || i.stack;
            g("[plasmo/parcel-runtime]: " + i.message + `
` + w + `

` + i.hints.join(`
`));
        }
    }), t.addEventListener("error", O), t.addEventListener("open", ()=>{
        x(`[plasmo/parcel-runtime]: Connected to HMR server for ${s.entryFilePath}`);
    }), t.addEventListener("close", ()=>{
        g(`[plasmo/parcel-runtime]: Connection to the HMR server is closed for ${s.entryFilePath}`);
    }), t;
}
var n = "__plasmo-loading__";
function m() {
    return document.getElementById(n);
}
function f() {
    return !m();
}
function B() {
    let e = document.createElement("div");
    return e.id = n, e.innerHTML = `
  <style>
    #${n} {
      background: #f3f3f3;
      color: #333;
      border: 1px solid #333;
      box-shadow: #333 4.7px 4.7px;
    }

    #${n}:hover {
      background: #e3e3e3;
      color: #444;
    }

    @keyframes plasmo-loading-animate-svg-fill {
      0% {
        fill: transparent;
      }
    
      100% {
        fill: #333;
      }
    }

    #${n} .svg-elem-1 {
      animation: plasmo-loading-animate-svg-fill 1.47s cubic-bezier(0.47, 0, 0.745, 0.715) 0.8s both infinite;
    }

    #${n} .svg-elem-2 {
      animation: plasmo-loading-animate-svg-fill 1.47s cubic-bezier(0.47, 0, 0.745, 0.715) 0.9s both infinite;
    }
    
    #${n} .svg-elem-3 {
      animation: plasmo-loading-animate-svg-fill 1.47s cubic-bezier(0.47, 0, 0.745, 0.715) 1s both infinite;
    }

    #${n} .hidden {
      display: none;
    }

  </style>
  
  <svg height="32" width="32" viewBox="0 0 264 354" fill="none" xmlns="http://www.w3.org/2000/svg">
    <path d="M139.221 282.243C154.252 282.243 166.903 294.849 161.338 308.812C159.489 313.454 157.15 317.913 154.347 322.109C146.464 333.909 135.26 343.107 122.151 348.538C109.043 353.969 94.6182 355.39 80.7022 352.621C66.7861 349.852 54.0034 343.018 43.9705 332.983C33.9375 322.947 27.105 310.162 24.3369 296.242C21.5689 282.323 22.9895 267.895 28.4193 254.783C33.8491 241.671 43.0441 230.464 54.8416 222.579C59.0353 219.777 63.4908 217.438 68.1295 215.588C82.0915 210.021 94.6978 222.671 94.6978 237.703L94.6978 255.027C94.6978 270.058 106.883 282.243 121.914 282.243H139.221Z" fill="#333" class="svg-elem-1" ></path>
    <path d="M192.261 142.028C192.261 126.996 204.867 114.346 218.829 119.913C223.468 121.763 227.923 124.102 232.117 126.904C243.915 134.789 253.11 145.996 258.539 159.108C263.969 172.22 265.39 186.648 262.622 200.567C259.854 214.487 253.021 227.272 242.988 237.308C232.955 247.343 220.173 254.177 206.256 256.946C192.34 259.715 177.916 258.294 164.807 252.863C151.699 247.432 140.495 238.234 132.612 226.434C129.808 222.238 127.47 217.779 125.62 213.137C120.056 199.174 132.707 186.568 147.738 186.568L165.044 186.568C180.076 186.568 192.261 174.383 192.261 159.352L192.261 142.028Z" fill="#333" class="svg-elem-2" ></path>
    <path d="M95.6522 164.135C95.6522 179.167 83.2279 191.725 68.8013 187.505C59.5145 184.788 50.6432 180.663 42.5106 175.227C26.7806 164.714 14.5206 149.772 7.28089 132.289C0.041183 114.807 -1.85305 95.5697 1.83772 77.0104C5.52849 58.4511 14.6385 41.4033 28.0157 28.0228C41.393 14.6423 58.4366 5.53006 76.9914 1.83839C95.5461 -1.85329 114.779 0.0414162 132.257 7.2829C149.735 14.5244 164.674 26.7874 175.184 42.5212C180.62 50.6576 184.744 59.5332 187.46 68.8245C191.678 83.2519 179.119 95.6759 164.088 95.6759L122.869 95.6759C107.837 95.6759 95.6522 107.861 95.6522 122.892L95.6522 164.135Z" fill="#333" class="svg-elem-3"></path>
  </svg>
  <span class="hidden">Context Invalidated, Press to Reload</span>
  `, e.style.pointerEvents = "none", e.style.position = "fixed", e.style.bottom = "14.7px", e.style.right = "14.7px", e.style.fontFamily = "sans-serif", e.style.display = "flex", e.style.justifyContent = "center", e.style.alignItems = "center", e.style.padding = "14.7px", e.style.gap = "14.7px", e.style.borderRadius = "4.7px", e.style.zIndex = "2147483647", e.style.opacity = "0", e.style.transition = "all 0.47s ease-in-out", e;
}
function $(e) {
    return new Promise((t)=>{
        document.documentElement ? (f() && (document.documentElement.appendChild(e), t()), t()) : globalThis.addEventListener("DOMContentLoaded", ()=>{
            f() && document.documentElement.appendChild(e), t();
        });
    });
}
var R = ()=>{
    let e;
    if (f()) {
        let t = B();
        e = $(t);
    }
    return {
        show: async ({ reloadButton: t = !1 } = {})=>{
            await e;
            let o = m();
            o.style.opacity = "1", t && (o.onclick = (r)=>{
                r.stopPropagation(), globalThis.location.reload();
            }, o.querySelector("span").classList.remove("hidden"), o.style.cursor = "pointer", o.style.pointerEvents = "all");
        },
        hide: async ()=>{
            await e;
            let t = m();
            t.style.opacity = "0";
        }
    };
};
var F = `${E}${module.id}__`, a, T = !1, A = R();
async function h() {
    c("Script Runtime - reloading"), T ? globalThis.location?.reload?.() : A.show({
        reloadButton: !0
    });
}
function k() {
    a?.disconnect(), a = l?.runtime.connect({
        name: F
    }), a.onDisconnect.addListener(()=>{
        h();
    }), a.onMessage.addListener((e)=>{
        e.__plasmo_cs_reload__ && h(), e.__plasmo_cs_active_tab__ && (T = !0);
    });
}
function N() {
    if (l?.runtime) try {
        k(), setInterval(k, 24e3);
    } catch  {
        return;
    }
}
N();
P(async (e)=>{
    c("Script runtime - on updated assets"), e.filter((o)=>o.envHash === s.envHash).some((o)=>L(module.bundle, o.id)) && (A.show(), l?.runtime ? a.postMessage({
        __plasmo_cs_changed__: !0
    }) : setTimeout(()=>{
        h();
    }, 4700));
});

},{}],"8znIH":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
var _vue = require("vue");
var _csui = require("@plasmo-static-common/csui");
var _csuiContainerVanilla = require("@plasmo-static-common/csui-container-vanilla");
var _vue1 = require("@plasmo-static-common/vue");
// @ts-ignore
var _plasmoInline = require("~contents/plasmo-inline");
var _plasmoInlineDefault = parcelHelpers.interopDefault(_plasmoInline);
// @ts-ignore
var _plasmoInline1 = require("style-raw:~contents/plasmo-inline");
var _plasmoInlineDefault1 = parcelHelpers.interopDefault(_plasmoInline1);
// Escape parcel's static analyzer
const Mount = (0, _plasmoInlineDefault.default).plasmo || {};
if (typeof (0, _plasmoInlineDefault1.default) === "string") {
    Mount.getSfcStyleContent = ()=>(0, _plasmoInlineDefault1.default);
    if (typeof Mount.getStyle !== "function") Mount.getStyle = ({ sfcStyleContent })=>{
        const element = document.createElement("style");
        element.textContent = sfcStyleContent;
        return element;
    };
}
const observer = (0, _csui.createAnchorObserver)(Mount);
const render = (0, _csui.createRender)(Mount, [
    (0, _csuiContainerVanilla.createInlineCSUIContainer),
    (0, _csuiContainerVanilla.createOverlayCSUIContainer)
], observer?.mountState, async (anchor, rootContainer)=>{
    switch(anchor.type){
        case "inline":
            {
                const mountPoint = (0, _csuiContainerVanilla.createInlineCSUIContainer)({
                    anchor
                });
                rootContainer.appendChild(mountPoint);
                const app = (0, _vue.createApp)((0, _plasmoInlineDefault.default));
                app.config.globalProperties.$anchor = anchor;
                app.mount(mountPoint);
                break;
            }
        case "overlay":
            {
                const targetList = observer?.mountState.overlayTargetList || [
                    anchor.element
                ];
                targetList.forEach((target, i)=>{
                    const id = `plasmo-overlay-${i}`;
                    const innerAnchor = {
                        element: target,
                        type: "overlay"
                    };
                    const mountPoint = (0, _csuiContainerVanilla.createOverlayCSUIContainer)({
                        id,
                        anchor: innerAnchor,
                        watchOverlayAnchor: Mount.watchOverlayAnchor
                    });
                    rootContainer.appendChild(mountPoint);
                    const app = (0, _vue.createApp)((0, _plasmoInlineDefault.default));
                    app.config.globalProperties.$anchor = innerAnchor;
                    app.mount(mountPoint);
                });
                break;
            }
    }
});
if (!!observer) observer.start(render);
else render({
    element: document.documentElement,
    type: "overlay"
});
if (typeof Mount.watch === "function") Mount.watch({
    observer,
    render
});

},{"vue":"dmrjI","@plasmo-static-common/csui":"b2Mq6","@plasmo-static-common/csui-container-vanilla":"7z4EY","@plasmo-static-common/vue":"4j7Mh","~contents/plasmo-inline":"2pena","style-raw:~contents/plasmo-inline":"lwGre","@parcel/transformer-js/src/esmodule-helpers.js":"boKlo"}],"dmrjI":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "compile", ()=>compile);
var _runtimeDom = require("@vue/runtime-dom");
parcelHelpers.exportAll(_runtimeDom, exports);
function initDev() {
    (0, _runtimeDom.initCustomFormatter)();
}
initDev();
const compile = ()=>{
    (0, _runtimeDom.warn)(`Runtime compilation is not supported in this build of Vue.` + ` Configure your bundler to alias "vue" to "vue/dist/vue.esm-bundler.js".`);
};

},{"@vue/runtime-dom":"illZR","@parcel/transformer-js/src/esmodule-helpers.js":"boKlo"}],"illZR":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Transition", ()=>Transition);
parcelHelpers.export(exports, "TransitionGroup", ()=>TransitionGroup);
parcelHelpers.export(exports, "VueElement", ()=>VueElement);
parcelHelpers.export(exports, "createApp", ()=>createApp);
parcelHelpers.export(exports, "createSSRApp", ()=>createSSRApp);
parcelHelpers.export(exports, "defineCustomElement", ()=>defineCustomElement);
parcelHelpers.export(exports, "defineSSRCustomElement", ()=>defineSSRCustomElement);
parcelHelpers.export(exports, "hydrate", ()=>hydrate);
parcelHelpers.export(exports, "initDirectivesForSSR", ()=>initDirectivesForSSR);
parcelHelpers.export(exports, "render", ()=>render);
parcelHelpers.export(exports, "useCssModule", ()=>useCssModule);
parcelHelpers.export(exports, "useCssVars", ()=>useCssVars);
parcelHelpers.export(exports, "vModelCheckbox", ()=>vModelCheckbox);
parcelHelpers.export(exports, "vModelDynamic", ()=>vModelDynamic);
parcelHelpers.export(exports, "vModelRadio", ()=>vModelRadio);
parcelHelpers.export(exports, "vModelSelect", ()=>vModelSelect);
parcelHelpers.export(exports, "vModelText", ()=>vModelText);
parcelHelpers.export(exports, "vShow", ()=>vShow);
parcelHelpers.export(exports, "withKeys", ()=>withKeys);
parcelHelpers.export(exports, "withModifiers", ()=>withModifiers);
var _runtimeCore = require("@vue/runtime-core");
parcelHelpers.exportAll(_runtimeCore, exports);
var _shared = require("@vue/shared");
const svgNS = "http://www.w3.org/2000/svg";
const doc = typeof document !== "undefined" ? document : null;
const templateContainer = doc && /* @__PURE__ */ doc.createElement("template");
const nodeOps = {
    insert: (child, parent, anchor)=>{
        parent.insertBefore(child, anchor || null);
    },
    remove: (child)=>{
        const parent = child.parentNode;
        if (parent) parent.removeChild(child);
    },
    createElement: (tag, isSVG, is, props)=>{
        const el = isSVG ? doc.createElementNS(svgNS, tag) : doc.createElement(tag, is ? {
            is
        } : void 0);
        if (tag === "select" && props && props.multiple != null) el.setAttribute("multiple", props.multiple);
        return el;
    },
    createText: (text)=>doc.createTextNode(text),
    createComment: (text)=>doc.createComment(text),
    setText: (node, text)=>{
        node.nodeValue = text;
    },
    setElementText: (el, text)=>{
        el.textContent = text;
    },
    parentNode: (node)=>node.parentNode,
    nextSibling: (node)=>node.nextSibling,
    querySelector: (selector)=>doc.querySelector(selector),
    setScopeId (el, id) {
        el.setAttribute(id, "");
    },
    // __UNSAFE__
    // Reason: innerHTML.
    // Static content here can only come from compiled templates.
    // As long as the user only uses trusted templates, this is safe.
    insertStaticContent (content, parent, anchor, isSVG, start, end) {
        const before = anchor ? anchor.previousSibling : parent.lastChild;
        if (start && (start === end || start.nextSibling)) while(true){
            parent.insertBefore(start.cloneNode(true), anchor);
            if (start === end || !(start = start.nextSibling)) break;
        }
        else {
            templateContainer.innerHTML = isSVG ? `<svg>${content}</svg>` : content;
            const template = templateContainer.content;
            if (isSVG) {
                const wrapper = template.firstChild;
                while(wrapper.firstChild)template.appendChild(wrapper.firstChild);
                template.removeChild(wrapper);
            }
            parent.insertBefore(template, anchor);
        }
        return [
            // first
            before ? before.nextSibling : parent.firstChild,
            // last
            anchor ? anchor.previousSibling : parent.lastChild
        ];
    }
};
function patchClass(el, value, isSVG) {
    const transitionClasses = el._vtc;
    if (transitionClasses) value = (value ? [
        value,
        ...transitionClasses
    ] : [
        ...transitionClasses
    ]).join(" ");
    if (value == null) el.removeAttribute("class");
    else if (isSVG) el.setAttribute("class", value);
    else el.className = value;
}
function patchStyle(el, prev, next) {
    const style = el.style;
    const isCssString = (0, _shared.isString)(next);
    if (next && !isCssString) {
        if (prev && !(0, _shared.isString)(prev)) {
            for(const key in prev)if (next[key] == null) setStyle(style, key, "");
        }
        for(const key in next)setStyle(style, key, next[key]);
    } else {
        const currentDisplay = style.display;
        if (isCssString) {
            if (prev !== next) style.cssText = next;
        } else if (prev) el.removeAttribute("style");
        if ("_vod" in el) style.display = currentDisplay;
    }
}
const semicolonRE = /[^\\];\s*$/;
const importantRE = /\s*!important$/;
function setStyle(style, name, val) {
    if ((0, _shared.isArray)(val)) val.forEach((v)=>setStyle(style, name, v));
    else {
        if (val == null) val = "";
        if (semicolonRE.test(val)) (0, _runtimeCore.warn)(`Unexpected semicolon at the end of '${name}' style value: '${val}'`);
        if (name.startsWith("--")) style.setProperty(name, val);
        else {
            const prefixed = autoPrefix(style, name);
            if (importantRE.test(val)) style.setProperty((0, _shared.hyphenate)(prefixed), val.replace(importantRE, ""), "important");
            else style[prefixed] = val;
        }
    }
}
const prefixes = [
    "Webkit",
    "Moz",
    "ms"
];
const prefixCache = {};
function autoPrefix(style, rawName) {
    const cached = prefixCache[rawName];
    if (cached) return cached;
    let name = (0, _runtimeCore.camelize)(rawName);
    if (name !== "filter" && name in style) return prefixCache[rawName] = name;
    name = (0, _shared.capitalize)(name);
    for(let i = 0; i < prefixes.length; i++){
        const prefixed = prefixes[i] + name;
        if (prefixed in style) return prefixCache[rawName] = prefixed;
    }
    return rawName;
}
const xlinkNS = "http://www.w3.org/1999/xlink";
function patchAttr(el, key, value, isSVG, instance) {
    if (isSVG && key.startsWith("xlink:")) {
        if (value == null) el.removeAttributeNS(xlinkNS, key.slice(6, key.length));
        else el.setAttributeNS(xlinkNS, key, value);
    } else {
        const isBoolean = (0, _shared.isSpecialBooleanAttr)(key);
        if (value == null || isBoolean && !(0, _shared.includeBooleanAttr)(value)) el.removeAttribute(key);
        else el.setAttribute(key, isBoolean ? "" : value);
    }
}
function patchDOMProp(el, key, value, prevChildren, parentComponent, parentSuspense, unmountChildren) {
    if (key === "innerHTML" || key === "textContent") {
        if (prevChildren) unmountChildren(prevChildren, parentComponent, parentSuspense);
        el[key] = value == null ? "" : value;
        return;
    }
    const tag = el.tagName;
    if (key === "value" && tag !== "PROGRESS" && // custom elements may use _value internally
    !tag.includes("-")) {
        el._value = value;
        const oldValue = tag === "OPTION" ? el.getAttribute("value") : el.value;
        const newValue = value == null ? "" : value;
        if (oldValue !== newValue) el.value = newValue;
        if (value == null) el.removeAttribute(key);
        return;
    }
    let needRemove = false;
    if (value === "" || value == null) {
        const type = typeof el[key];
        if (type === "boolean") value = (0, _shared.includeBooleanAttr)(value);
        else if (value == null && type === "string") {
            value = "";
            needRemove = true;
        } else if (type === "number") {
            value = 0;
            needRemove = true;
        }
    }
    try {
        el[key] = value;
    } catch (e) {
        if (!needRemove) (0, _runtimeCore.warn)(`Failed setting prop "${key}" on <${tag.toLowerCase()}>: value ${value} is invalid.`, e);
    }
    needRemove && el.removeAttribute(key);
}
function addEventListener(el, event, handler, options) {
    el.addEventListener(event, handler, options);
}
function removeEventListener(el, event, handler, options) {
    el.removeEventListener(event, handler, options);
}
function patchEvent(el, rawName, prevValue, nextValue, instance = null) {
    const invokers = el._vei || (el._vei = {});
    const existingInvoker = invokers[rawName];
    if (nextValue && existingInvoker) existingInvoker.value = nextValue;
    else {
        const [name, options] = parseName(rawName);
        if (nextValue) {
            const invoker = invokers[rawName] = createInvoker(nextValue, instance);
            addEventListener(el, name, invoker, options);
        } else if (existingInvoker) {
            removeEventListener(el, name, existingInvoker, options);
            invokers[rawName] = void 0;
        }
    }
}
const optionsModifierRE = /(?:Once|Passive|Capture)$/;
function parseName(name) {
    let options;
    if (optionsModifierRE.test(name)) {
        options = {};
        let m;
        while(m = name.match(optionsModifierRE)){
            name = name.slice(0, name.length - m[0].length);
            options[m[0].toLowerCase()] = true;
        }
    }
    const event = name[2] === ":" ? name.slice(3) : (0, _shared.hyphenate)(name.slice(2));
    return [
        event,
        options
    ];
}
let cachedNow = 0;
const p = /* @__PURE__ */ Promise.resolve();
const getNow = ()=>cachedNow || (p.then(()=>cachedNow = 0), cachedNow = Date.now());
function createInvoker(initialValue, instance) {
    const invoker = (e)=>{
        if (!e._vts) e._vts = Date.now();
        else if (e._vts <= invoker.attached) return;
        (0, _runtimeCore.callWithAsyncErrorHandling)(patchStopImmediatePropagation(e, invoker.value), instance, 5, [
            e
        ]);
    };
    invoker.value = initialValue;
    invoker.attached = getNow();
    return invoker;
}
function patchStopImmediatePropagation(e, value) {
    if ((0, _shared.isArray)(value)) {
        const originalStop = e.stopImmediatePropagation;
        e.stopImmediatePropagation = ()=>{
            originalStop.call(e);
            e._stopped = true;
        };
        return value.map((fn)=>(e2)=>!e2._stopped && fn && fn(e2));
    } else return value;
}
const nativeOnRE = /^on[a-z]/;
const patchProp = (el, key, prevValue, nextValue, isSVG = false, prevChildren, parentComponent, parentSuspense, unmountChildren)=>{
    if (key === "class") patchClass(el, nextValue, isSVG);
    else if (key === "style") patchStyle(el, prevValue, nextValue);
    else if ((0, _shared.isOn)(key)) {
        if (!(0, _shared.isModelListener)(key)) patchEvent(el, key, prevValue, nextValue, parentComponent);
    } else if (key[0] === "." ? (key = key.slice(1), true) : key[0] === "^" ? (key = key.slice(1), false) : shouldSetAsProp(el, key, nextValue, isSVG)) patchDOMProp(el, key, nextValue, prevChildren, parentComponent, parentSuspense, unmountChildren);
    else {
        if (key === "true-value") el._trueValue = nextValue;
        else if (key === "false-value") el._falseValue = nextValue;
        patchAttr(el, key, nextValue, isSVG);
    }
};
function shouldSetAsProp(el, key, value, isSVG) {
    if (isSVG) {
        if (key === "innerHTML" || key === "textContent") return true;
        if (key in el && nativeOnRE.test(key) && (0, _shared.isFunction)(value)) return true;
        return false;
    }
    if (key === "spellcheck" || key === "draggable" || key === "translate") return false;
    if (key === "form") return false;
    if (key === "list" && el.tagName === "INPUT") return false;
    if (key === "type" && el.tagName === "TEXTAREA") return false;
    if (nativeOnRE.test(key) && (0, _shared.isString)(value)) return false;
    return key in el;
}
function defineCustomElement(options, hydrate2) {
    const Comp = (0, _runtimeCore.defineComponent)(options);
    class VueCustomElement extends VueElement {
        constructor(initialProps){
            super(Comp, initialProps, hydrate2);
        }
    }
    VueCustomElement.def = Comp;
    return VueCustomElement;
}
const defineSSRCustomElement = (options)=>{
    return defineCustomElement(options, hydrate);
};
const BaseClass = typeof HTMLElement !== "undefined" ? HTMLElement : class {
};
class VueElement extends BaseClass {
    constructor(_def, _props = {}, hydrate2){
        super();
        this._def = _def;
        this._props = _props;
        /**
     * @internal
     */ this._instance = null;
        this._connected = false;
        this._resolved = false;
        this._numberProps = null;
        if (this.shadowRoot && hydrate2) hydrate2(this._createVNode(), this.shadowRoot);
        else {
            if (0, this.shadowRoot) (0, _runtimeCore.warn)(`Custom element has pre-rendered declarative shadow root but is not defined as hydratable. Use \`defineSSRCustomElement\`.`);
            this.attachShadow({
                mode: "open"
            });
            if (!this._def.__asyncLoader) this._resolveProps(this._def);
        }
    }
    connectedCallback() {
        this._connected = true;
        if (!this._instance) {
            if (this._resolved) this._update();
            else this._resolveDef();
        }
    }
    disconnectedCallback() {
        this._connected = false;
        (0, _runtimeCore.nextTick)(()=>{
            if (!this._connected) {
                render(null, this.shadowRoot);
                this._instance = null;
            }
        });
    }
    /**
   * resolve inner component definition (handle possible async component)
   */ _resolveDef() {
        this._resolved = true;
        for(let i = 0; i < this.attributes.length; i++)this._setAttr(this.attributes[i].name);
        new MutationObserver((mutations)=>{
            for (const m of mutations)this._setAttr(m.attributeName);
        }).observe(this, {
            attributes: true
        });
        const resolve = (def, isAsync = false)=>{
            const { props, styles } = def;
            let numberProps;
            if (props && !(0, _shared.isArray)(props)) for(const key in props){
                const opt = props[key];
                if (opt === Number || opt && opt.type === Number) {
                    if (key in this._props) this._props[key] = (0, _shared.toNumber)(this._props[key]);
                    (numberProps || (numberProps = /* @__PURE__ */ Object.create(null)))[(0, _shared.camelize)(key)] = true;
                }
            }
            this._numberProps = numberProps;
            if (isAsync) this._resolveProps(def);
            this._applyStyles(styles);
            this._update();
        };
        const asyncDef = this._def.__asyncLoader;
        if (asyncDef) asyncDef().then((def)=>resolve(def, true));
        else resolve(this._def);
    }
    _resolveProps(def) {
        const { props } = def;
        const declaredPropKeys = (0, _shared.isArray)(props) ? props : Object.keys(props || {});
        for (const key of Object.keys(this))if (key[0] !== "_" && declaredPropKeys.includes(key)) this._setProp(key, this[key], true, false);
        for (const key of declaredPropKeys.map((0, _shared.camelize)))Object.defineProperty(this, key, {
            get () {
                return this._getProp(key);
            },
            set (val) {
                this._setProp(key, val);
            }
        });
    }
    _setAttr(key) {
        let value = this.getAttribute(key);
        const camelKey = (0, _shared.camelize)(key);
        if (this._numberProps && this._numberProps[camelKey]) value = (0, _shared.toNumber)(value);
        this._setProp(camelKey, value, false);
    }
    /**
   * @internal
   */ _getProp(key) {
        return this._props[key];
    }
    /**
   * @internal
   */ _setProp(key, val, shouldReflect = true, shouldUpdate = true) {
        if (val !== this._props[key]) {
            this._props[key] = val;
            if (shouldUpdate && this._instance) this._update();
            if (shouldReflect) {
                if (val === true) this.setAttribute((0, _shared.hyphenate)(key), "");
                else if (typeof val === "string" || typeof val === "number") this.setAttribute((0, _shared.hyphenate)(key), val + "");
                else if (!val) this.removeAttribute((0, _shared.hyphenate)(key));
            }
        }
    }
    _update() {
        render(this._createVNode(), this.shadowRoot);
    }
    _createVNode() {
        const vnode = (0, _runtimeCore.createVNode)(this._def, (0, _shared.extend)({}, this._props));
        if (!this._instance) vnode.ce = (instance)=>{
            this._instance = instance;
            instance.isCE = true;
            instance.ceReload = (newStyles)=>{
                if (this._styles) {
                    this._styles.forEach((s)=>this.shadowRoot.removeChild(s));
                    this._styles.length = 0;
                }
                this._applyStyles(newStyles);
                this._instance = null;
                this._update();
            };
            const dispatch = (event, args)=>{
                this.dispatchEvent(new CustomEvent(event, {
                    detail: args
                }));
            };
            instance.emit = (event, ...args)=>{
                dispatch(event, args);
                if ((0, _shared.hyphenate)(event) !== event) dispatch((0, _shared.hyphenate)(event), args);
            };
            let parent = this;
            while(parent = parent && (parent.parentNode || parent.host))if (parent instanceof VueElement) {
                instance.parent = parent._instance;
                instance.provides = parent._instance.provides;
                break;
            }
        };
        return vnode;
    }
    _applyStyles(styles) {
        if (styles) styles.forEach((css)=>{
            const s = document.createElement("style");
            s.textContent = css;
            this.shadowRoot.appendChild(s);
            (this._styles || (this._styles = [])).push(s);
        });
    }
}
function useCssModule(name = "$style") {
    {
        const instance = (0, _runtimeCore.getCurrentInstance)();
        if (!instance) {
            (0, _runtimeCore.warn)(`useCssModule must be called inside setup()`);
            return 0, _shared.EMPTY_OBJ;
        }
        const modules = instance.type.__cssModules;
        if (!modules) {
            (0, _runtimeCore.warn)(`Current instance does not have CSS modules injected.`);
            return 0, _shared.EMPTY_OBJ;
        }
        const mod = modules[name];
        if (!mod) {
            (0, _runtimeCore.warn)(`Current instance does not have CSS module named "${name}".`);
            return 0, _shared.EMPTY_OBJ;
        }
        return mod;
    }
}
function useCssVars(getter) {
    const instance = (0, _runtimeCore.getCurrentInstance)();
    if (!instance) {
        (0, _runtimeCore.warn)(`useCssVars is called without current active component instance.`);
        return;
    }
    const updateTeleports = instance.ut = (vars = getter(instance.proxy))=>{
        Array.from(document.querySelectorAll(`[data-v-owner="${instance.uid}"]`)).forEach((node)=>setVarsOnNode(node, vars));
    };
    const setVars = ()=>{
        const vars = getter(instance.proxy);
        setVarsOnVNode(instance.subTree, vars);
        updateTeleports(vars);
    };
    (0, _runtimeCore.watchPostEffect)(setVars);
    (0, _runtimeCore.onMounted)(()=>{
        const ob = new MutationObserver(setVars);
        ob.observe(instance.subTree.el.parentNode, {
            childList: true
        });
        (0, _runtimeCore.onUnmounted)(()=>ob.disconnect());
    });
}
function setVarsOnVNode(vnode, vars) {
    if (vnode.shapeFlag & 128) {
        const suspense = vnode.suspense;
        vnode = suspense.activeBranch;
        if (suspense.pendingBranch && !suspense.isHydrating) suspense.effects.push(()=>{
            setVarsOnVNode(suspense.activeBranch, vars);
        });
    }
    while(vnode.component)vnode = vnode.component.subTree;
    if (vnode.shapeFlag & 1 && vnode.el) setVarsOnNode(vnode.el, vars);
    else if (vnode.type === (0, _runtimeCore.Fragment)) vnode.children.forEach((c)=>setVarsOnVNode(c, vars));
    else if (vnode.type === (0, _runtimeCore.Static)) {
        let { el, anchor } = vnode;
        while(el){
            setVarsOnNode(el, vars);
            if (el === anchor) break;
            el = el.nextSibling;
        }
    }
}
function setVarsOnNode(el, vars) {
    if (el.nodeType === 1) {
        const style = el.style;
        for(const key in vars)style.setProperty(`--${key}`, vars[key]);
    }
}
const TRANSITION = "transition";
const ANIMATION = "animation";
const Transition = (props, { slots })=>(0, _runtimeCore.h)((0, _runtimeCore.BaseTransition), resolveTransitionProps(props), slots);
Transition.displayName = "Transition";
const DOMTransitionPropsValidators = {
    name: String,
    type: String,
    css: {
        type: Boolean,
        default: true
    },
    duration: [
        String,
        Number,
        Object
    ],
    enterFromClass: String,
    enterActiveClass: String,
    enterToClass: String,
    appearFromClass: String,
    appearActiveClass: String,
    appearToClass: String,
    leaveFromClass: String,
    leaveActiveClass: String,
    leaveToClass: String
};
const TransitionPropsValidators = Transition.props = /* @__PURE__ */ (0, _shared.extend)({}, (0, _runtimeCore.BaseTransitionPropsValidators), DOMTransitionPropsValidators);
const callHook = (hook, args = [])=>{
    if ((0, _shared.isArray)(hook)) hook.forEach((h2)=>h2(...args));
    else if (hook) hook(...args);
};
const hasExplicitCallback = (hook)=>{
    return hook ? (0, _shared.isArray)(hook) ? hook.some((h2)=>h2.length > 1) : hook.length > 1 : false;
};
function resolveTransitionProps(rawProps) {
    const baseProps = {};
    for(const key in rawProps)if (!(key in DOMTransitionPropsValidators)) baseProps[key] = rawProps[key];
    if (rawProps.css === false) return baseProps;
    const { name = "v", type, duration, enterFromClass = `${name}-enter-from`, enterActiveClass = `${name}-enter-active`, enterToClass = `${name}-enter-to`, appearFromClass = enterFromClass, appearActiveClass = enterActiveClass, appearToClass = enterToClass, leaveFromClass = `${name}-leave-from`, leaveActiveClass = `${name}-leave-active`, leaveToClass = `${name}-leave-to` } = rawProps;
    const durations = normalizeDuration(duration);
    const enterDuration = durations && durations[0];
    const leaveDuration = durations && durations[1];
    const { onBeforeEnter, onEnter, onEnterCancelled, onLeave, onLeaveCancelled, onBeforeAppear = onBeforeEnter, onAppear = onEnter, onAppearCancelled = onEnterCancelled } = baseProps;
    const finishEnter = (el, isAppear, done)=>{
        removeTransitionClass(el, isAppear ? appearToClass : enterToClass);
        removeTransitionClass(el, isAppear ? appearActiveClass : enterActiveClass);
        done && done();
    };
    const finishLeave = (el, done)=>{
        el._isLeaving = false;
        removeTransitionClass(el, leaveFromClass);
        removeTransitionClass(el, leaveToClass);
        removeTransitionClass(el, leaveActiveClass);
        done && done();
    };
    const makeEnterHook = (isAppear)=>{
        return (el, done)=>{
            const hook = isAppear ? onAppear : onEnter;
            const resolve = ()=>finishEnter(el, isAppear, done);
            callHook(hook, [
                el,
                resolve
            ]);
            nextFrame(()=>{
                removeTransitionClass(el, isAppear ? appearFromClass : enterFromClass);
                addTransitionClass(el, isAppear ? appearToClass : enterToClass);
                if (!hasExplicitCallback(hook)) whenTransitionEnds(el, type, enterDuration, resolve);
            });
        };
    };
    return (0, _shared.extend)(baseProps, {
        onBeforeEnter (el) {
            callHook(onBeforeEnter, [
                el
            ]);
            addTransitionClass(el, enterFromClass);
            addTransitionClass(el, enterActiveClass);
        },
        onBeforeAppear (el) {
            callHook(onBeforeAppear, [
                el
            ]);
            addTransitionClass(el, appearFromClass);
            addTransitionClass(el, appearActiveClass);
        },
        onEnter: makeEnterHook(false),
        onAppear: makeEnterHook(true),
        onLeave (el, done) {
            el._isLeaving = true;
            const resolve = ()=>finishLeave(el, done);
            addTransitionClass(el, leaveFromClass);
            forceReflow();
            addTransitionClass(el, leaveActiveClass);
            nextFrame(()=>{
                if (!el._isLeaving) return;
                removeTransitionClass(el, leaveFromClass);
                addTransitionClass(el, leaveToClass);
                if (!hasExplicitCallback(onLeave)) whenTransitionEnds(el, type, leaveDuration, resolve);
            });
            callHook(onLeave, [
                el,
                resolve
            ]);
        },
        onEnterCancelled (el) {
            finishEnter(el, false);
            callHook(onEnterCancelled, [
                el
            ]);
        },
        onAppearCancelled (el) {
            finishEnter(el, true);
            callHook(onAppearCancelled, [
                el
            ]);
        },
        onLeaveCancelled (el) {
            finishLeave(el);
            callHook(onLeaveCancelled, [
                el
            ]);
        }
    });
}
function normalizeDuration(duration) {
    if (duration == null) return null;
    else if ((0, _shared.isObject)(duration)) return [
        NumberOf(duration.enter),
        NumberOf(duration.leave)
    ];
    else {
        const n = NumberOf(duration);
        return [
            n,
            n
        ];
    }
}
function NumberOf(val) {
    const res = (0, _shared.toNumber)(val);
    (0, _runtimeCore.assertNumber)(res, "<transition> explicit duration");
    return res;
}
function addTransitionClass(el, cls) {
    cls.split(/\s+/).forEach((c)=>c && el.classList.add(c));
    (el._vtc || (el._vtc = /* @__PURE__ */ new Set())).add(cls);
}
function removeTransitionClass(el, cls) {
    cls.split(/\s+/).forEach((c)=>c && el.classList.remove(c));
    const { _vtc } = el;
    if (_vtc) {
        _vtc.delete(cls);
        if (!_vtc.size) el._vtc = void 0;
    }
}
function nextFrame(cb) {
    requestAnimationFrame(()=>{
        requestAnimationFrame(cb);
    });
}
let endId = 0;
function whenTransitionEnds(el, expectedType, explicitTimeout, resolve) {
    const id = el._endId = ++endId;
    const resolveIfNotStale = ()=>{
        if (id === el._endId) resolve();
    };
    if (explicitTimeout) return setTimeout(resolveIfNotStale, explicitTimeout);
    const { type, timeout, propCount } = getTransitionInfo(el, expectedType);
    if (!type) return resolve();
    const endEvent = type + "end";
    let ended = 0;
    const end = ()=>{
        el.removeEventListener(endEvent, onEnd);
        resolveIfNotStale();
    };
    const onEnd = (e)=>{
        if (e.target === el && ++ended >= propCount) end();
    };
    setTimeout(()=>{
        if (ended < propCount) end();
    }, timeout + 1);
    el.addEventListener(endEvent, onEnd);
}
function getTransitionInfo(el, expectedType) {
    const styles = window.getComputedStyle(el);
    const getStyleProperties = (key)=>(styles[key] || "").split(", ");
    const transitionDelays = getStyleProperties(`${TRANSITION}Delay`);
    const transitionDurations = getStyleProperties(`${TRANSITION}Duration`);
    const transitionTimeout = getTimeout(transitionDelays, transitionDurations);
    const animationDelays = getStyleProperties(`${ANIMATION}Delay`);
    const animationDurations = getStyleProperties(`${ANIMATION}Duration`);
    const animationTimeout = getTimeout(animationDelays, animationDurations);
    let type = null;
    let timeout = 0;
    let propCount = 0;
    if (expectedType === TRANSITION) {
        if (transitionTimeout > 0) {
            type = TRANSITION;
            timeout = transitionTimeout;
            propCount = transitionDurations.length;
        }
    } else if (expectedType === ANIMATION) {
        if (animationTimeout > 0) {
            type = ANIMATION;
            timeout = animationTimeout;
            propCount = animationDurations.length;
        }
    } else {
        timeout = Math.max(transitionTimeout, animationTimeout);
        type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;
        propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;
    }
    const hasTransform = type === TRANSITION && /\b(transform|all)(,|$)/.test(getStyleProperties(`${TRANSITION}Property`).toString());
    return {
        type,
        timeout,
        propCount,
        hasTransform
    };
}
function getTimeout(delays, durations) {
    while(delays.length < durations.length)delays = delays.concat(delays);
    return Math.max(...durations.map((d, i)=>toMs(d) + toMs(delays[i])));
}
function toMs(s) {
    return Number(s.slice(0, -1).replace(",", ".")) * 1e3;
}
function forceReflow() {
    return document.body.offsetHeight;
}
const positionMap = /* @__PURE__ */ new WeakMap();
const newPositionMap = /* @__PURE__ */ new WeakMap();
const TransitionGroupImpl = {
    name: "TransitionGroup",
    props: /* @__PURE__ */ (0, _shared.extend)({}, TransitionPropsValidators, {
        tag: String,
        moveClass: String
    }),
    setup (props, { slots }) {
        const instance = (0, _runtimeCore.getCurrentInstance)();
        const state = (0, _runtimeCore.useTransitionState)();
        let prevChildren;
        let children;
        (0, _runtimeCore.onUpdated)(()=>{
            if (!prevChildren.length) return;
            const moveClass = props.moveClass || `${props.name || "v"}-move`;
            if (!hasCSSTransform(prevChildren[0].el, instance.vnode.el, moveClass)) return;
            prevChildren.forEach(callPendingCbs);
            prevChildren.forEach(recordPosition);
            const movedChildren = prevChildren.filter(applyTranslation);
            forceReflow();
            movedChildren.forEach((c)=>{
                const el = c.el;
                const style = el.style;
                addTransitionClass(el, moveClass);
                style.transform = style.webkitTransform = style.transitionDuration = "";
                const cb = el._moveCb = (e)=>{
                    if (e && e.target !== el) return;
                    if (!e || /transform$/.test(e.propertyName)) {
                        el.removeEventListener("transitionend", cb);
                        el._moveCb = null;
                        removeTransitionClass(el, moveClass);
                    }
                };
                el.addEventListener("transitionend", cb);
            });
        });
        return ()=>{
            const rawProps = (0, _runtimeCore.toRaw)(props);
            const cssTransitionProps = resolveTransitionProps(rawProps);
            let tag = rawProps.tag || (0, _runtimeCore.Fragment);
            prevChildren = children;
            children = slots.default ? (0, _runtimeCore.getTransitionRawChildren)(slots.default()) : [];
            for(let i = 0; i < children.length; i++){
                const child = children[i];
                if (child.key != null) (0, _runtimeCore.setTransitionHooks)(child, (0, _runtimeCore.resolveTransitionHooks)(child, cssTransitionProps, state, instance));
                else (0, _runtimeCore.warn)(`<TransitionGroup> children must be keyed.`);
            }
            if (prevChildren) for(let i = 0; i < prevChildren.length; i++){
                const child = prevChildren[i];
                (0, _runtimeCore.setTransitionHooks)(child, (0, _runtimeCore.resolveTransitionHooks)(child, cssTransitionProps, state, instance));
                positionMap.set(child, child.el.getBoundingClientRect());
            }
            return (0, _runtimeCore.createVNode)(tag, null, children);
        };
    }
};
const removeMode = (props)=>delete props.mode;
/* @__PURE__ */ removeMode(TransitionGroupImpl.props);
const TransitionGroup = TransitionGroupImpl;
function callPendingCbs(c) {
    const el = c.el;
    if (el._moveCb) el._moveCb();
    if (el._enterCb) el._enterCb();
}
function recordPosition(c) {
    newPositionMap.set(c, c.el.getBoundingClientRect());
}
function applyTranslation(c) {
    const oldPos = positionMap.get(c);
    const newPos = newPositionMap.get(c);
    const dx = oldPos.left - newPos.left;
    const dy = oldPos.top - newPos.top;
    if (dx || dy) {
        const s = c.el.style;
        s.transform = s.webkitTransform = `translate(${dx}px,${dy}px)`;
        s.transitionDuration = "0s";
        return c;
    }
}
function hasCSSTransform(el, root, moveClass) {
    const clone = el.cloneNode();
    if (el._vtc) el._vtc.forEach((cls)=>{
        cls.split(/\s+/).forEach((c)=>c && clone.classList.remove(c));
    });
    moveClass.split(/\s+/).forEach((c)=>c && clone.classList.add(c));
    clone.style.display = "none";
    const container = root.nodeType === 1 ? root : root.parentNode;
    container.appendChild(clone);
    const { hasTransform } = getTransitionInfo(clone);
    container.removeChild(clone);
    return hasTransform;
}
const getModelAssigner = (vnode)=>{
    const fn = vnode.props["onUpdate:modelValue"] || false;
    return (0, _shared.isArray)(fn) ? (value)=>(0, _shared.invokeArrayFns)(fn, value) : fn;
};
function onCompositionStart(e) {
    e.target.composing = true;
}
function onCompositionEnd(e) {
    const target = e.target;
    if (target.composing) {
        target.composing = false;
        target.dispatchEvent(new Event("input"));
    }
}
const vModelText = {
    created (el, { modifiers: { lazy, trim, number } }, vnode) {
        el._assign = getModelAssigner(vnode);
        const castToNumber = number || vnode.props && vnode.props.type === "number";
        addEventListener(el, lazy ? "change" : "input", (e)=>{
            if (e.target.composing) return;
            let domValue = el.value;
            if (trim) domValue = domValue.trim();
            if (castToNumber) domValue = (0, _shared.looseToNumber)(domValue);
            el._assign(domValue);
        });
        if (trim) addEventListener(el, "change", ()=>{
            el.value = el.value.trim();
        });
        if (!lazy) {
            addEventListener(el, "compositionstart", onCompositionStart);
            addEventListener(el, "compositionend", onCompositionEnd);
            addEventListener(el, "change", onCompositionEnd);
        }
    },
    // set value on mounted so it's after min/max for type="range"
    mounted (el, { value }) {
        el.value = value == null ? "" : value;
    },
    beforeUpdate (el, { value, modifiers: { lazy, trim, number } }, vnode) {
        el._assign = getModelAssigner(vnode);
        if (el.composing) return;
        if (document.activeElement === el && el.type !== "range") {
            if (lazy) return;
            if (trim && el.value.trim() === value) return;
            if ((number || el.type === "number") && (0, _shared.looseToNumber)(el.value) === value) return;
        }
        const newValue = value == null ? "" : value;
        if (el.value !== newValue) el.value = newValue;
    }
};
const vModelCheckbox = {
    // #4096 array checkboxes need to be deep traversed
    deep: true,
    created (el, _, vnode) {
        el._assign = getModelAssigner(vnode);
        addEventListener(el, "change", ()=>{
            const modelValue = el._modelValue;
            const elementValue = getValue(el);
            const checked = el.checked;
            const assign = el._assign;
            if ((0, _shared.isArray)(modelValue)) {
                const index = (0, _shared.looseIndexOf)(modelValue, elementValue);
                const found = index !== -1;
                if (checked && !found) assign(modelValue.concat(elementValue));
                else if (!checked && found) {
                    const filtered = [
                        ...modelValue
                    ];
                    filtered.splice(index, 1);
                    assign(filtered);
                }
            } else if ((0, _shared.isSet)(modelValue)) {
                const cloned = new Set(modelValue);
                if (checked) cloned.add(elementValue);
                else cloned.delete(elementValue);
                assign(cloned);
            } else assign(getCheckboxValue(el, checked));
        });
    },
    // set initial checked on mount to wait for true-value/false-value
    mounted: setChecked,
    beforeUpdate (el, binding, vnode) {
        el._assign = getModelAssigner(vnode);
        setChecked(el, binding, vnode);
    }
};
function setChecked(el, { value, oldValue }, vnode) {
    el._modelValue = value;
    if ((0, _shared.isArray)(value)) el.checked = (0, _shared.looseIndexOf)(value, vnode.props.value) > -1;
    else if ((0, _shared.isSet)(value)) el.checked = value.has(vnode.props.value);
    else if (value !== oldValue) el.checked = (0, _shared.looseEqual)(value, getCheckboxValue(el, true));
}
const vModelRadio = {
    created (el, { value }, vnode) {
        el.checked = (0, _shared.looseEqual)(value, vnode.props.value);
        el._assign = getModelAssigner(vnode);
        addEventListener(el, "change", ()=>{
            el._assign(getValue(el));
        });
    },
    beforeUpdate (el, { value, oldValue }, vnode) {
        el._assign = getModelAssigner(vnode);
        if (value !== oldValue) el.checked = (0, _shared.looseEqual)(value, vnode.props.value);
    }
};
const vModelSelect = {
    // <select multiple> value need to be deep traversed
    deep: true,
    created (el, { value, modifiers: { number } }, vnode) {
        const isSetModel = (0, _shared.isSet)(value);
        addEventListener(el, "change", ()=>{
            const selectedVal = Array.prototype.filter.call(el.options, (o)=>o.selected).map((o)=>number ? (0, _shared.looseToNumber)(getValue(o)) : getValue(o));
            el._assign(el.multiple ? isSetModel ? new Set(selectedVal) : selectedVal : selectedVal[0]);
        });
        el._assign = getModelAssigner(vnode);
    },
    // set value in mounted & updated because <select> relies on its children
    // <option>s.
    mounted (el, { value }) {
        setSelected(el, value);
    },
    beforeUpdate (el, _binding, vnode) {
        el._assign = getModelAssigner(vnode);
    },
    updated (el, { value }) {
        setSelected(el, value);
    }
};
function setSelected(el, value) {
    const isMultiple = el.multiple;
    if (isMultiple && !(0, _shared.isArray)(value) && !(0, _shared.isSet)(value)) {
        (0, _runtimeCore.warn)(`<select multiple v-model> expects an Array or Set value for its binding, but got ${Object.prototype.toString.call(value).slice(8, -1)}.`);
        return;
    }
    for(let i = 0, l = el.options.length; i < l; i++){
        const option = el.options[i];
        const optionValue = getValue(option);
        if (isMultiple) {
            if ((0, _shared.isArray)(value)) option.selected = (0, _shared.looseIndexOf)(value, optionValue) > -1;
            else option.selected = value.has(optionValue);
        } else if ((0, _shared.looseEqual)(getValue(option), value)) {
            if (el.selectedIndex !== i) el.selectedIndex = i;
            return;
        }
    }
    if (!isMultiple && el.selectedIndex !== -1) el.selectedIndex = -1;
}
function getValue(el) {
    return "_value" in el ? el._value : el.value;
}
function getCheckboxValue(el, checked) {
    const key = checked ? "_trueValue" : "_falseValue";
    return key in el ? el[key] : checked;
}
const vModelDynamic = {
    created (el, binding, vnode) {
        callModelHook(el, binding, vnode, null, "created");
    },
    mounted (el, binding, vnode) {
        callModelHook(el, binding, vnode, null, "mounted");
    },
    beforeUpdate (el, binding, vnode, prevVNode) {
        callModelHook(el, binding, vnode, prevVNode, "beforeUpdate");
    },
    updated (el, binding, vnode, prevVNode) {
        callModelHook(el, binding, vnode, prevVNode, "updated");
    }
};
function resolveDynamicModel(tagName, type) {
    switch(tagName){
        case "SELECT":
            return vModelSelect;
        case "TEXTAREA":
            return vModelText;
        default:
            switch(type){
                case "checkbox":
                    return vModelCheckbox;
                case "radio":
                    return vModelRadio;
                default:
                    return vModelText;
            }
    }
}
function callModelHook(el, binding, vnode, prevVNode, hook) {
    const modelToUse = resolveDynamicModel(el.tagName, vnode.props && vnode.props.type);
    const fn = modelToUse[hook];
    fn && fn(el, binding, vnode, prevVNode);
}
function initVModelForSSR() {
    vModelText.getSSRProps = ({ value })=>({
            value
        });
    vModelRadio.getSSRProps = ({ value }, vnode)=>{
        if (vnode.props && (0, _shared.looseEqual)(vnode.props.value, value)) return {
            checked: true
        };
    };
    vModelCheckbox.getSSRProps = ({ value }, vnode)=>{
        if ((0, _shared.isArray)(value)) {
            if (vnode.props && (0, _shared.looseIndexOf)(value, vnode.props.value) > -1) return {
                checked: true
            };
        } else if ((0, _shared.isSet)(value)) {
            if (vnode.props && value.has(vnode.props.value)) return {
                checked: true
            };
        } else if (value) return {
            checked: true
        };
    };
    vModelDynamic.getSSRProps = (binding, vnode)=>{
        if (typeof vnode.type !== "string") return;
        const modelToUse = resolveDynamicModel(// resolveDynamicModel expects an uppercase tag name, but vnode.type is lowercase
        vnode.type.toUpperCase(), vnode.props && vnode.props.type);
        if (modelToUse.getSSRProps) return modelToUse.getSSRProps(binding, vnode);
    };
}
const systemModifiers = [
    "ctrl",
    "shift",
    "alt",
    "meta"
];
const modifierGuards = {
    stop: (e)=>e.stopPropagation(),
    prevent: (e)=>e.preventDefault(),
    self: (e)=>e.target !== e.currentTarget,
    ctrl: (e)=>!e.ctrlKey,
    shift: (e)=>!e.shiftKey,
    alt: (e)=>!e.altKey,
    meta: (e)=>!e.metaKey,
    left: (e)=>"button" in e && e.button !== 0,
    middle: (e)=>"button" in e && e.button !== 1,
    right: (e)=>"button" in e && e.button !== 2,
    exact: (e, modifiers)=>systemModifiers.some((m)=>e[`${m}Key`] && !modifiers.includes(m))
};
const withModifiers = (fn, modifiers)=>{
    return (event, ...args)=>{
        for(let i = 0; i < modifiers.length; i++){
            const guard = modifierGuards[modifiers[i]];
            if (guard && guard(event, modifiers)) return;
        }
        return fn(event, ...args);
    };
};
const keyNames = {
    esc: "escape",
    space: " ",
    up: "arrow-up",
    left: "arrow-left",
    right: "arrow-right",
    down: "arrow-down",
    delete: "backspace"
};
const withKeys = (fn, modifiers)=>{
    return (event)=>{
        if (!("key" in event)) return;
        const eventKey = (0, _shared.hyphenate)(event.key);
        if (modifiers.some((k)=>k === eventKey || keyNames[k] === eventKey)) return fn(event);
    };
};
const vShow = {
    beforeMount (el, { value }, { transition }) {
        el._vod = el.style.display === "none" ? "" : el.style.display;
        if (transition && value) transition.beforeEnter(el);
        else setDisplay(el, value);
    },
    mounted (el, { value }, { transition }) {
        if (transition && value) transition.enter(el);
    },
    updated (el, { value, oldValue }, { transition }) {
        if (!value === !oldValue) return;
        if (transition) {
            if (value) {
                transition.beforeEnter(el);
                setDisplay(el, true);
                transition.enter(el);
            } else transition.leave(el, ()=>{
                setDisplay(el, false);
            });
        } else setDisplay(el, value);
    },
    beforeUnmount (el, { value }) {
        setDisplay(el, value);
    }
};
function setDisplay(el, value) {
    el.style.display = value ? el._vod : "none";
}
function initVShowForSSR() {
    vShow.getSSRProps = ({ value })=>{
        if (!value) return {
            style: {
                display: "none"
            }
        };
    };
}
const rendererOptions = /* @__PURE__ */ (0, _shared.extend)({
    patchProp
}, nodeOps);
let renderer;
let enabledHydration = false;
function ensureRenderer() {
    return renderer || (renderer = (0, _runtimeCore.createRenderer)(rendererOptions));
}
function ensureHydrationRenderer() {
    renderer = enabledHydration ? renderer : (0, _runtimeCore.createHydrationRenderer)(rendererOptions);
    enabledHydration = true;
    return renderer;
}
const render = (...args)=>{
    ensureRenderer().render(...args);
};
const hydrate = (...args)=>{
    ensureHydrationRenderer().hydrate(...args);
};
const createApp = (...args)=>{
    const app = ensureRenderer().createApp(...args);
    injectNativeTagCheck(app);
    injectCompilerOptionsCheck(app);
    const { mount } = app;
    app.mount = (containerOrSelector)=>{
        const container = normalizeContainer(containerOrSelector);
        if (!container) return;
        const component = app._component;
        if (!(0, _shared.isFunction)(component) && !component.render && !component.template) component.template = container.innerHTML;
        container.innerHTML = "";
        const proxy = mount(container, false, container instanceof SVGElement);
        if (container instanceof Element) {
            container.removeAttribute("v-cloak");
            container.setAttribute("data-v-app", "");
        }
        return proxy;
    };
    return app;
};
const createSSRApp = (...args)=>{
    const app = ensureHydrationRenderer().createApp(...args);
    injectNativeTagCheck(app);
    injectCompilerOptionsCheck(app);
    const { mount } = app;
    app.mount = (containerOrSelector)=>{
        const container = normalizeContainer(containerOrSelector);
        if (container) return mount(container, true, container instanceof SVGElement);
    };
    return app;
};
function injectNativeTagCheck(app) {
    Object.defineProperty(app.config, "isNativeTag", {
        value: (tag)=>(0, _shared.isHTMLTag)(tag) || (0, _shared.isSVGTag)(tag),
        writable: false
    });
}
function injectCompilerOptionsCheck(app) {
    if ((0, _runtimeCore.isRuntimeOnly)()) {
        const isCustomElement = app.config.isCustomElement;
        Object.defineProperty(app.config, "isCustomElement", {
            get () {
                return isCustomElement;
            },
            set () {
                (0, _runtimeCore.warn)(`The \`isCustomElement\` config option is deprecated. Use \`compilerOptions.isCustomElement\` instead.`);
            }
        });
        const compilerOptions = app.config.compilerOptions;
        const msg = `The \`compilerOptions\` config option is only respected when using a build of Vue.js that includes the runtime compiler (aka "full build"). Since you are using the runtime-only build, \`compilerOptions\` must be passed to \`@vue/compiler-dom\` in the build setup instead.
- For vue-loader: pass it via vue-loader's \`compilerOptions\` loader option.
- For vue-cli: see https://cli.vuejs.org/guide/webpack.html#modifying-options-of-a-loader
- For vite: pass it via @vitejs/plugin-vue options. See https://github.com/vitejs/vite-plugin-vue/tree/main/packages/plugin-vue#example-for-passing-options-to-vuecompiler-sfc`;
        Object.defineProperty(app.config, "compilerOptions", {
            get () {
                (0, _runtimeCore.warn)(msg);
                return compilerOptions;
            },
            set () {
                (0, _runtimeCore.warn)(msg);
            }
        });
    }
}
function normalizeContainer(container) {
    if ((0, _shared.isString)(container)) {
        const res = document.querySelector(container);
        if (!res) (0, _runtimeCore.warn)(`Failed to mount app: mount target selector "${container}" returned null.`);
        return res;
    }
    if ((0, window.ShadowRoot) && container instanceof window.ShadowRoot && container.mode === "closed") (0, _runtimeCore.warn)(`mounting on a ShadowRoot with \`{mode: "closed"}\` may lead to unpredictable bugs`);
    return container;
}
let ssrDirectiveInitialized = false;
const initDirectivesForSSR = ()=>{
    if (!ssrDirectiveInitialized) {
        ssrDirectiveInitialized = true;
        initVModelForSSR();
        initVShowForSSR();
    }
};

},{"@vue/runtime-core":"6EA3u","@vue/shared":"5YL8y","@parcel/transformer-js/src/esmodule-helpers.js":"boKlo"}],"6EA3u":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "EffectScope", ()=>(0, _reactivity.EffectScope));
parcelHelpers.export(exports, "ReactiveEffect", ()=>(0, _reactivity.ReactiveEffect));
parcelHelpers.export(exports, "customRef", ()=>(0, _reactivity.customRef));
parcelHelpers.export(exports, "effect", ()=>(0, _reactivity.effect));
parcelHelpers.export(exports, "effectScope", ()=>(0, _reactivity.effectScope));
parcelHelpers.export(exports, "getCurrentScope", ()=>(0, _reactivity.getCurrentScope));
parcelHelpers.export(exports, "isProxy", ()=>(0, _reactivity.isProxy));
parcelHelpers.export(exports, "isReactive", ()=>(0, _reactivity.isReactive));
parcelHelpers.export(exports, "isReadonly", ()=>(0, _reactivity.isReadonly));
parcelHelpers.export(exports, "isRef", ()=>(0, _reactivity.isRef));
parcelHelpers.export(exports, "isShallow", ()=>(0, _reactivity.isShallow));
parcelHelpers.export(exports, "markRaw", ()=>(0, _reactivity.markRaw));
parcelHelpers.export(exports, "onScopeDispose", ()=>(0, _reactivity.onScopeDispose));
parcelHelpers.export(exports, "proxyRefs", ()=>(0, _reactivity.proxyRefs));
parcelHelpers.export(exports, "reactive", ()=>(0, _reactivity.reactive));
parcelHelpers.export(exports, "readonly", ()=>(0, _reactivity.readonly));
parcelHelpers.export(exports, "ref", ()=>(0, _reactivity.ref));
parcelHelpers.export(exports, "shallowReactive", ()=>(0, _reactivity.shallowReactive));
parcelHelpers.export(exports, "shallowReadonly", ()=>(0, _reactivity.shallowReadonly));
parcelHelpers.export(exports, "shallowRef", ()=>(0, _reactivity.shallowRef));
parcelHelpers.export(exports, "stop", ()=>(0, _reactivity.stop));
parcelHelpers.export(exports, "toRaw", ()=>(0, _reactivity.toRaw));
parcelHelpers.export(exports, "toRef", ()=>(0, _reactivity.toRef));
parcelHelpers.export(exports, "toRefs", ()=>(0, _reactivity.toRefs));
parcelHelpers.export(exports, "toValue", ()=>(0, _reactivity.toValue));
parcelHelpers.export(exports, "triggerRef", ()=>(0, _reactivity.triggerRef));
parcelHelpers.export(exports, "unref", ()=>(0, _reactivity.unref));
parcelHelpers.export(exports, "camelize", ()=>(0, _shared.camelize));
parcelHelpers.export(exports, "capitalize", ()=>(0, _shared.capitalize));
parcelHelpers.export(exports, "normalizeClass", ()=>(0, _shared.normalizeClass));
parcelHelpers.export(exports, "normalizeProps", ()=>(0, _shared.normalizeProps));
parcelHelpers.export(exports, "normalizeStyle", ()=>(0, _shared.normalizeStyle));
parcelHelpers.export(exports, "toDisplayString", ()=>(0, _shared.toDisplayString));
parcelHelpers.export(exports, "toHandlerKey", ()=>(0, _shared.toHandlerKey));
parcelHelpers.export(exports, "BaseTransition", ()=>BaseTransition);
parcelHelpers.export(exports, "BaseTransitionPropsValidators", ()=>BaseTransitionPropsValidators);
parcelHelpers.export(exports, "Comment", ()=>Comment);
parcelHelpers.export(exports, "Fragment", ()=>Fragment);
parcelHelpers.export(exports, "KeepAlive", ()=>KeepAlive);
parcelHelpers.export(exports, "Static", ()=>Static);
parcelHelpers.export(exports, "Suspense", ()=>Suspense);
parcelHelpers.export(exports, "Teleport", ()=>Teleport);
parcelHelpers.export(exports, "Text", ()=>Text);
parcelHelpers.export(exports, "assertNumber", ()=>assertNumber);
parcelHelpers.export(exports, "callWithAsyncErrorHandling", ()=>callWithAsyncErrorHandling);
parcelHelpers.export(exports, "callWithErrorHandling", ()=>callWithErrorHandling);
parcelHelpers.export(exports, "cloneVNode", ()=>cloneVNode);
parcelHelpers.export(exports, "compatUtils", ()=>compatUtils);
parcelHelpers.export(exports, "computed", ()=>computed);
parcelHelpers.export(exports, "createBlock", ()=>createBlock);
parcelHelpers.export(exports, "createCommentVNode", ()=>createCommentVNode);
parcelHelpers.export(exports, "createElementBlock", ()=>createElementBlock);
parcelHelpers.export(exports, "createElementVNode", ()=>createBaseVNode);
parcelHelpers.export(exports, "createHydrationRenderer", ()=>createHydrationRenderer);
parcelHelpers.export(exports, "createPropsRestProxy", ()=>createPropsRestProxy);
parcelHelpers.export(exports, "createRenderer", ()=>createRenderer);
parcelHelpers.export(exports, "createSlots", ()=>createSlots);
parcelHelpers.export(exports, "createStaticVNode", ()=>createStaticVNode);
parcelHelpers.export(exports, "createTextVNode", ()=>createTextVNode);
parcelHelpers.export(exports, "createVNode", ()=>createVNode);
parcelHelpers.export(exports, "defineAsyncComponent", ()=>defineAsyncComponent);
parcelHelpers.export(exports, "defineComponent", ()=>defineComponent);
parcelHelpers.export(exports, "defineEmits", ()=>defineEmits);
parcelHelpers.export(exports, "defineExpose", ()=>defineExpose);
parcelHelpers.export(exports, "defineModel", ()=>defineModel);
parcelHelpers.export(exports, "defineOptions", ()=>defineOptions);
parcelHelpers.export(exports, "defineProps", ()=>defineProps);
parcelHelpers.export(exports, "defineSlots", ()=>defineSlots);
parcelHelpers.export(exports, "devtools", ()=>devtools);
parcelHelpers.export(exports, "getCurrentInstance", ()=>getCurrentInstance);
parcelHelpers.export(exports, "getTransitionRawChildren", ()=>getTransitionRawChildren);
parcelHelpers.export(exports, "guardReactiveProps", ()=>guardReactiveProps);
parcelHelpers.export(exports, "h", ()=>h);
parcelHelpers.export(exports, "handleError", ()=>handleError);
parcelHelpers.export(exports, "hasInjectionContext", ()=>hasInjectionContext);
parcelHelpers.export(exports, "initCustomFormatter", ()=>initCustomFormatter);
parcelHelpers.export(exports, "inject", ()=>inject);
parcelHelpers.export(exports, "isMemoSame", ()=>isMemoSame);
parcelHelpers.export(exports, "isRuntimeOnly", ()=>isRuntimeOnly);
parcelHelpers.export(exports, "isVNode", ()=>isVNode);
parcelHelpers.export(exports, "mergeDefaults", ()=>mergeDefaults);
parcelHelpers.export(exports, "mergeModels", ()=>mergeModels);
parcelHelpers.export(exports, "mergeProps", ()=>mergeProps);
parcelHelpers.export(exports, "nextTick", ()=>nextTick);
parcelHelpers.export(exports, "onActivated", ()=>onActivated);
parcelHelpers.export(exports, "onBeforeMount", ()=>onBeforeMount);
parcelHelpers.export(exports, "onBeforeUnmount", ()=>onBeforeUnmount);
parcelHelpers.export(exports, "onBeforeUpdate", ()=>onBeforeUpdate);
parcelHelpers.export(exports, "onDeactivated", ()=>onDeactivated);
parcelHelpers.export(exports, "onErrorCaptured", ()=>onErrorCaptured);
parcelHelpers.export(exports, "onMounted", ()=>onMounted);
parcelHelpers.export(exports, "onRenderTracked", ()=>onRenderTracked);
parcelHelpers.export(exports, "onRenderTriggered", ()=>onRenderTriggered);
parcelHelpers.export(exports, "onServerPrefetch", ()=>onServerPrefetch);
parcelHelpers.export(exports, "onUnmounted", ()=>onUnmounted);
parcelHelpers.export(exports, "onUpdated", ()=>onUpdated);
parcelHelpers.export(exports, "openBlock", ()=>openBlock);
parcelHelpers.export(exports, "popScopeId", ()=>popScopeId);
parcelHelpers.export(exports, "provide", ()=>provide);
parcelHelpers.export(exports, "pushScopeId", ()=>pushScopeId);
parcelHelpers.export(exports, "queuePostFlushCb", ()=>queuePostFlushCb);
parcelHelpers.export(exports, "registerRuntimeCompiler", ()=>registerRuntimeCompiler);
parcelHelpers.export(exports, "renderList", ()=>renderList);
parcelHelpers.export(exports, "renderSlot", ()=>renderSlot);
parcelHelpers.export(exports, "resolveComponent", ()=>resolveComponent);
parcelHelpers.export(exports, "resolveDirective", ()=>resolveDirective);
parcelHelpers.export(exports, "resolveDynamicComponent", ()=>resolveDynamicComponent);
parcelHelpers.export(exports, "resolveFilter", ()=>resolveFilter);
parcelHelpers.export(exports, "resolveTransitionHooks", ()=>resolveTransitionHooks);
parcelHelpers.export(exports, "setBlockTracking", ()=>setBlockTracking);
parcelHelpers.export(exports, "setDevtoolsHook", ()=>setDevtoolsHook);
parcelHelpers.export(exports, "setTransitionHooks", ()=>setTransitionHooks);
parcelHelpers.export(exports, "ssrContextKey", ()=>ssrContextKey);
parcelHelpers.export(exports, "ssrUtils", ()=>ssrUtils);
parcelHelpers.export(exports, "toHandlers", ()=>toHandlers);
parcelHelpers.export(exports, "transformVNodeArgs", ()=>transformVNodeArgs);
parcelHelpers.export(exports, "useAttrs", ()=>useAttrs);
parcelHelpers.export(exports, "useModel", ()=>useModel);
parcelHelpers.export(exports, "useSSRContext", ()=>useSSRContext);
parcelHelpers.export(exports, "useSlots", ()=>useSlots);
parcelHelpers.export(exports, "useTransitionState", ()=>useTransitionState);
parcelHelpers.export(exports, "version", ()=>version);
parcelHelpers.export(exports, "warn", ()=>warn);
parcelHelpers.export(exports, "watch", ()=>watch);
parcelHelpers.export(exports, "watchEffect", ()=>watchEffect);
parcelHelpers.export(exports, "watchPostEffect", ()=>watchPostEffect);
parcelHelpers.export(exports, "watchSyncEffect", ()=>watchSyncEffect);
parcelHelpers.export(exports, "withAsyncContext", ()=>withAsyncContext);
parcelHelpers.export(exports, "withCtx", ()=>withCtx);
parcelHelpers.export(exports, "withDefaults", ()=>withDefaults);
parcelHelpers.export(exports, "withDirectives", ()=>withDirectives);
parcelHelpers.export(exports, "withMemo", ()=>withMemo);
parcelHelpers.export(exports, "withScopeId", ()=>withScopeId);
var _reactivity = require("@vue/reactivity");
var _shared = require("@vue/shared");
const stack = [];
function pushWarningContext(vnode) {
    stack.push(vnode);
}
function popWarningContext() {
    stack.pop();
}
function warn(msg, ...args) {
    (0, _reactivity.pauseTracking)();
    const instance = stack.length ? stack[stack.length - 1].component : null;
    const appWarnHandler = instance && instance.appContext.config.warnHandler;
    const trace = getComponentTrace();
    if (appWarnHandler) callWithErrorHandling(appWarnHandler, instance, 11, [
        msg + args.join(""),
        instance && instance.proxy,
        trace.map(({ vnode })=>`at <${formatComponentName(instance, vnode.type)}>`).join("\n"),
        trace
    ]);
    else {
        const warnArgs = [
            `[Vue warn]: ${msg}`,
            ...args
        ];
        if (trace.length && // avoid spamming console during tests
        true) warnArgs.push(`
`, ...formatTrace(trace));
        console.warn(...warnArgs);
    }
    (0, _reactivity.resetTracking)();
}
function getComponentTrace() {
    let currentVNode = stack[stack.length - 1];
    if (!currentVNode) return [];
    const normalizedStack = [];
    while(currentVNode){
        const last = normalizedStack[0];
        if (last && last.vnode === currentVNode) last.recurseCount++;
        else normalizedStack.push({
            vnode: currentVNode,
            recurseCount: 0
        });
        const parentInstance = currentVNode.component && currentVNode.component.parent;
        currentVNode = parentInstance && parentInstance.vnode;
    }
    return normalizedStack;
}
function formatTrace(trace) {
    const logs = [];
    trace.forEach((entry, i)=>{
        logs.push(...i === 0 ? [] : [
            `
`
        ], ...formatTraceEntry(entry));
    });
    return logs;
}
function formatTraceEntry({ vnode, recurseCount }) {
    const postfix = recurseCount > 0 ? `... (${recurseCount} recursive calls)` : ``;
    const isRoot = vnode.component ? vnode.component.parent == null : false;
    const open = ` at <${formatComponentName(vnode.component, vnode.type, isRoot)}`;
    const close = `>` + postfix;
    return vnode.props ? [
        open,
        ...formatProps(vnode.props),
        close
    ] : [
        open + close
    ];
}
function formatProps(props) {
    const res = [];
    const keys = Object.keys(props);
    keys.slice(0, 3).forEach((key)=>{
        res.push(...formatProp(key, props[key]));
    });
    if (keys.length > 3) res.push(` ...`);
    return res;
}
function formatProp(key, value1, raw) {
    if ((0, _shared.isString)(value1)) {
        value1 = JSON.stringify(value1);
        return raw ? value1 : [
            `${key}=${value1}`
        ];
    } else if (typeof value1 === "number" || typeof value1 === "boolean" || value1 == null) return raw ? value1 : [
        `${key}=${value1}`
    ];
    else if ((0, _reactivity.isRef)(value1)) {
        value1 = formatProp(key, (0, _reactivity.toRaw)(value1.value), true);
        return raw ? value1 : [
            `${key}=Ref<`,
            value1,
            `>`
        ];
    } else if ((0, _shared.isFunction)(value1)) return [
        `${key}=fn${value1.name ? `<${value1.name}>` : ``}`
    ];
    else {
        value1 = (0, _reactivity.toRaw)(value1);
        return raw ? value1 : [
            `${key}=`,
            value1
        ];
    }
}
function assertNumber(val, type) {
    if (val === void 0) return;
    else if (typeof val !== "number") warn(`${type} is not a valid number - got ${JSON.stringify(val)}.`);
    else if (isNaN(val)) warn(`${type} is NaN - the duration expression might be incorrect.`);
}
const ErrorTypeStrings = {
    ["sp"]: "serverPrefetch hook",
    ["bc"]: "beforeCreate hook",
    ["c"]: "created hook",
    ["bm"]: "beforeMount hook",
    ["m"]: "mounted hook",
    ["bu"]: "beforeUpdate hook",
    ["u"]: "updated",
    ["bum"]: "beforeUnmount hook",
    ["um"]: "unmounted hook",
    ["a"]: "activated hook",
    ["da"]: "deactivated hook",
    ["ec"]: "errorCaptured hook",
    ["rtc"]: "renderTracked hook",
    ["rtg"]: "renderTriggered hook",
    [0]: "setup function",
    [1]: "render function",
    [2]: "watcher getter",
    [3]: "watcher callback",
    [4]: "watcher cleanup function",
    [5]: "native event handler",
    [6]: "component event handler",
    [7]: "vnode hook",
    [8]: "directive hook",
    [9]: "transition hook",
    [10]: "app errorHandler",
    [11]: "app warnHandler",
    [12]: "ref function",
    [13]: "async component loader",
    [14]: "scheduler flush. This is likely a Vue internals bug. Please open an issue at https://new-issue.vuejs.org/?repo=vuejs/core"
};
function callWithErrorHandling(fn, instance, type, args) {
    let res;
    try {
        res = args ? fn(...args) : fn();
    } catch (err) {
        handleError(err, instance, type);
    }
    return res;
}
function callWithAsyncErrorHandling(fn, instance, type, args) {
    if ((0, _shared.isFunction)(fn)) {
        const res = callWithErrorHandling(fn, instance, type, args);
        if (res && (0, _shared.isPromise)(res)) res.catch((err)=>{
            handleError(err, instance, type);
        });
        return res;
    }
    const values = [];
    for(let i = 0; i < fn.length; i++)values.push(callWithAsyncErrorHandling(fn[i], instance, type, args));
    return values;
}
function handleError(err, instance, type, throwInDev = true) {
    const contextVNode = instance ? instance.vnode : null;
    if (instance) {
        let cur = instance.parent;
        const exposedInstance = instance.proxy;
        const errorInfo = (0, ErrorTypeStrings[type]);
        while(cur){
            const errorCapturedHooks = cur.ec;
            if (errorCapturedHooks) for(let i = 0; i < errorCapturedHooks.length; i++){
                if (errorCapturedHooks[i](err, exposedInstance, errorInfo) === false) return;
            }
            cur = cur.parent;
        }
        const appErrorHandler = instance.appContext.config.errorHandler;
        if (appErrorHandler) {
            callWithErrorHandling(appErrorHandler, null, 10, [
                err,
                exposedInstance,
                errorInfo
            ]);
            return;
        }
    }
    logError(err, type, contextVNode, throwInDev);
}
function logError(err, type, contextVNode, throwInDev = true) {
    {
        const info = ErrorTypeStrings[type];
        if (contextVNode) pushWarningContext(contextVNode);
        warn(`Unhandled error${info ? ` during execution of ${info}` : ``}`);
        if (contextVNode) popWarningContext();
        if (throwInDev) throw err;
        else console.error(err);
    }
}
let isFlushing = false;
let isFlushPending = false;
const queue = [];
let flushIndex = 0;
const pendingPostFlushCbs = [];
let activePostFlushCbs = null;
let postFlushIndex = 0;
const resolvedPromise = /* @__PURE__ */ Promise.resolve();
let currentFlushPromise = null;
const RECURSION_LIMIT = 100;
function nextTick(fn) {
    const p = currentFlushPromise || resolvedPromise;
    return fn ? p.then(this ? fn.bind(this) : fn) : p;
}
function findInsertionIndex(id) {
    let start = flushIndex + 1;
    let end = queue.length;
    while(start < end){
        const middle = start + end >>> 1;
        const middleJobId = getId(queue[middle]);
        middleJobId < id ? start = middle + 1 : end = middle;
    }
    return start;
}
function queueJob(job) {
    if (!queue.length || !queue.includes(job, isFlushing && job.allowRecurse ? flushIndex + 1 : flushIndex)) {
        if (job.id == null) queue.push(job);
        else queue.splice(findInsertionIndex(job.id), 0, job);
        queueFlush();
    }
}
function queueFlush() {
    if (!isFlushing && !isFlushPending) {
        isFlushPending = true;
        currentFlushPromise = resolvedPromise.then(flushJobs);
    }
}
function invalidateJob(job) {
    const i = queue.indexOf(job);
    if (i > flushIndex) queue.splice(i, 1);
}
function queuePostFlushCb(cb) {
    if (!(0, _shared.isArray)(cb)) {
        if (!activePostFlushCbs || !activePostFlushCbs.includes(cb, cb.allowRecurse ? postFlushIndex + 1 : postFlushIndex)) pendingPostFlushCbs.push(cb);
    } else pendingPostFlushCbs.push(...cb);
    queueFlush();
}
function flushPreFlushCbs(seen, i = isFlushing ? flushIndex + 1 : 0) {
    seen = seen || /* @__PURE__ */ new Map();
    for(; i < queue.length; i++){
        const cb = queue[i];
        if (cb && cb.pre) {
            if (checkRecursiveUpdates(seen, cb)) continue;
            queue.splice(i, 1);
            i--;
            cb();
        }
    }
}
function flushPostFlushCbs(seen) {
    if (pendingPostFlushCbs.length) {
        const deduped = [
            ...new Set(pendingPostFlushCbs)
        ];
        pendingPostFlushCbs.length = 0;
        if (activePostFlushCbs) {
            activePostFlushCbs.push(...deduped);
            return;
        }
        activePostFlushCbs = deduped;
        seen = seen || /* @__PURE__ */ new Map();
        activePostFlushCbs.sort((a, b)=>getId(a) - getId(b));
        for(postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++){
            if (checkRecursiveUpdates(seen, activePostFlushCbs[postFlushIndex])) continue;
            activePostFlushCbs[postFlushIndex]();
        }
        activePostFlushCbs = null;
        postFlushIndex = 0;
    }
}
const getId = (job)=>job.id == null ? Infinity : job.id;
const comparator = (a, b)=>{
    const diff = getId(a) - getId(b);
    if (diff === 0) {
        if (a.pre && !b.pre) return -1;
        if (b.pre && !a.pre) return 1;
    }
    return diff;
};
function flushJobs(seen) {
    isFlushPending = false;
    isFlushing = true;
    seen = seen || /* @__PURE__ */ new Map();
    queue.sort(comparator);
    const check = (job)=>checkRecursiveUpdates(seen, job);
    try {
        for(flushIndex = 0; flushIndex < queue.length; flushIndex++){
            const job = queue[flushIndex];
            if (job && job.active !== false) {
                if (check(job)) continue;
                callWithErrorHandling(job, null, 14);
            }
        }
    } finally{
        flushIndex = 0;
        queue.length = 0;
        flushPostFlushCbs(seen);
        isFlushing = false;
        currentFlushPromise = null;
        if (queue.length || pendingPostFlushCbs.length) flushJobs(seen);
    }
}
function checkRecursiveUpdates(seen, fn) {
    if (!seen.has(fn)) seen.set(fn, 1);
    else {
        const count = seen.get(fn);
        if (count > RECURSION_LIMIT) {
            const instance = fn.ownerInstance;
            const componentName = instance && getComponentName(instance.type);
            warn(`Maximum recursive updates exceeded${componentName ? ` in component <${componentName}>` : ``}. This means you have a reactive effect that is mutating its own dependencies and thus recursively triggering itself. Possible sources include component template, render function, updated hook or watcher source function.`);
            return true;
        } else seen.set(fn, count + 1);
    }
}
let isHmrUpdating = false;
const hmrDirtyComponents = /* @__PURE__ */ new Set();
(0, _shared.getGlobalThis)().__VUE_HMR_RUNTIME__ = {
    createRecord: tryWrap(createRecord),
    rerender: tryWrap(rerender),
    reload: tryWrap(reload)
};
const map = /* @__PURE__ */ new Map();
function registerHMR(instance) {
    const id = instance.type.__hmrId;
    let record = map.get(id);
    if (!record) {
        createRecord(id, instance.type);
        record = map.get(id);
    }
    record.instances.add(instance);
}
function unregisterHMR(instance) {
    map.get(instance.type.__hmrId).instances.delete(instance);
}
function createRecord(id, initialDef) {
    if (map.has(id)) return false;
    map.set(id, {
        initialDef: normalizeClassComponent(initialDef),
        instances: /* @__PURE__ */ new Set()
    });
    return true;
}
function normalizeClassComponent(component) {
    return isClassComponent(component) ? component.__vccOpts : component;
}
function rerender(id, newRender) {
    const record = map.get(id);
    if (!record) return;
    record.initialDef.render = newRender;
    [
        ...record.instances
    ].forEach((instance)=>{
        if (newRender) {
            instance.render = newRender;
            normalizeClassComponent(instance.type).render = newRender;
        }
        instance.renderCache = [];
        isHmrUpdating = true;
        instance.update();
        isHmrUpdating = false;
    });
}
function reload(id, newComp) {
    const record = map.get(id);
    if (!record) return;
    newComp = normalizeClassComponent(newComp);
    updateComponentDef(record.initialDef, newComp);
    const instances = [
        ...record.instances
    ];
    for (const instance of instances){
        const oldComp = normalizeClassComponent(instance.type);
        if (!hmrDirtyComponents.has(oldComp)) {
            if (oldComp !== record.initialDef) updateComponentDef(oldComp, newComp);
            hmrDirtyComponents.add(oldComp);
        }
        instance.appContext.propsCache.delete(instance.type);
        instance.appContext.emitsCache.delete(instance.type);
        instance.appContext.optionsCache.delete(instance.type);
        if (instance.ceReload) {
            hmrDirtyComponents.add(oldComp);
            instance.ceReload(newComp.styles);
            hmrDirtyComponents.delete(oldComp);
        } else if (instance.parent) queueJob(instance.parent.update);
        else if (instance.appContext.reload) instance.appContext.reload();
        else if (typeof window !== "undefined") window.location.reload();
        else console.warn("[HMR] Root or manually mounted instance modified. Full reload required.");
    }
    queuePostFlushCb(()=>{
        for (const instance of instances)hmrDirtyComponents.delete(normalizeClassComponent(instance.type));
    });
}
function updateComponentDef(oldComp, newComp) {
    (0, _shared.extend)(oldComp, newComp);
    for(const key in oldComp)if (key !== "__file" && !(key in newComp)) delete oldComp[key];
}
function tryWrap(fn) {
    return (id, arg)=>{
        try {
            return fn(id, arg);
        } catch (e) {
            console.error(e);
            console.warn(`[HMR] Something went wrong during Vue component hot-reload. Full reload required.`);
        }
    };
}
let devtools;
let buffer = [];
let devtoolsNotInstalled = false;
function emit$1(event, ...args) {
    if (devtools) devtools.emit(event, ...args);
    else if (!devtoolsNotInstalled) buffer.push({
        event,
        args
    });
}
function setDevtoolsHook(hook, target) {
    var _a, _b;
    devtools = hook;
    if (devtools) {
        devtools.enabled = true;
        buffer.forEach(({ event, args })=>devtools.emit(event, ...args));
        buffer = [];
    } else if (// handle late devtools injection - only do this if we are in an actual
    // browser environment to avoid the timer handle stalling test runner exit
    // (#4815)
    typeof window !== "undefined" && // some envs mock window but not fully
    window.HTMLElement && // also exclude jsdom
    !((_b = (_a = window.navigator) == null ? void 0 : _a.userAgent) == null ? void 0 : _b.includes("jsdom"))) {
        const replay = target.__VUE_DEVTOOLS_HOOK_REPLAY__ = target.__VUE_DEVTOOLS_HOOK_REPLAY__ || [];
        replay.push((newHook)=>{
            setDevtoolsHook(newHook, target);
        });
        setTimeout(()=>{
            if (!devtools) {
                target.__VUE_DEVTOOLS_HOOK_REPLAY__ = null;
                devtoolsNotInstalled = true;
                buffer = [];
            }
        }, 3e3);
    } else {
        devtoolsNotInstalled = true;
        buffer = [];
    }
}
function devtoolsInitApp(app, version) {
    emit$1("app:init" /* APP_INIT */ , app, version, {
        Fragment,
        Text,
        Comment,
        Static
    });
}
function devtoolsUnmountApp(app) {
    emit$1("app:unmount" /* APP_UNMOUNT */ , app);
}
const devtoolsComponentAdded = /* @__PURE__ */ createDevtoolsComponentHook("component:added" /* COMPONENT_ADDED */ );
const devtoolsComponentUpdated = /* @__PURE__ */ createDevtoolsComponentHook("component:updated" /* COMPONENT_UPDATED */ );
const _devtoolsComponentRemoved = /* @__PURE__ */ createDevtoolsComponentHook("component:removed" /* COMPONENT_REMOVED */ );
const devtoolsComponentRemoved = (component)=>{
    if (devtools && typeof devtools.cleanupBuffer === "function" && // remove the component if it wasn't buffered
    !devtools.cleanupBuffer(component)) _devtoolsComponentRemoved(component);
};
function createDevtoolsComponentHook(hook) {
    return (component)=>{
        emit$1(hook, component.appContext.app, component.uid, component.parent ? component.parent.uid : void 0, component);
    };
}
const devtoolsPerfStart = /* @__PURE__ */ createDevtoolsPerformanceHook("perf:start" /* PERFORMANCE_START */ );
const devtoolsPerfEnd = /* @__PURE__ */ createDevtoolsPerformanceHook("perf:end" /* PERFORMANCE_END */ );
function createDevtoolsPerformanceHook(hook) {
    return (component, type, time)=>{
        emit$1(hook, component.appContext.app, component.uid, component, type, time);
    };
}
function devtoolsComponentEmit(component, event, params) {
    emit$1("component:emit" /* COMPONENT_EMIT */ , component.appContext.app, component, event, params);
}
function emit(instance, event, ...rawArgs) {
    if (instance.isUnmounted) return;
    const props = instance.vnode.props || (0, _shared.EMPTY_OBJ);
    {
        const { emitsOptions, propsOptions: [propsOptions] } = instance;
        if (emitsOptions) {
            if (!(event in emitsOptions) && true) {
                if (!propsOptions || !((0, _shared.toHandlerKey)(event) in propsOptions)) warn(`Component emitted event "${event}" but it is neither declared in the emits option nor as an "${(0, _shared.toHandlerKey)(event)}" prop.`);
            } else {
                const validator = emitsOptions[event];
                if ((0, _shared.isFunction)(validator)) {
                    const isValid = validator(...rawArgs);
                    if (!isValid) warn(`Invalid event arguments: event validation failed for event "${event}".`);
                }
            }
        }
    }
    let args = rawArgs;
    const isModelListener = event.startsWith("update:");
    const modelArg = isModelListener && event.slice(7);
    if (modelArg && modelArg in props) {
        const modifiersKey = `${modelArg === "modelValue" ? "model" : modelArg}Modifiers`;
        const { number, trim } = props[modifiersKey] || (0, _shared.EMPTY_OBJ);
        if (trim) args = rawArgs.map((a)=>(0, _shared.isString)(a) ? a.trim() : a);
        if (number) args = rawArgs.map((0, _shared.looseToNumber));
    }
    devtoolsComponentEmit(instance, event, args);
    {
        const lowerCaseEvent = event.toLowerCase();
        if (lowerCaseEvent !== event && props[(0, _shared.toHandlerKey)(lowerCaseEvent)]) warn(`Event "${lowerCaseEvent}" is emitted in component ${formatComponentName(instance, instance.type)} but the handler is registered for "${event}". Note that HTML attributes are case-insensitive and you cannot use v-on to listen to camelCase events when using in-DOM templates. You should probably use "${(0, _shared.hyphenate)(event)}" instead of "${event}".`);
    }
    let handlerName;
    let handler = props[handlerName = (0, _shared.toHandlerKey)(event)] || // also try camelCase event handler (#2249)
    props[handlerName = (0, _shared.toHandlerKey)((0, _shared.camelize)(event))];
    if (!handler && isModelListener) handler = props[handlerName = (0, _shared.toHandlerKey)((0, _shared.hyphenate)(event))];
    if (handler) callWithAsyncErrorHandling(handler, instance, 6, args);
    const onceHandler = props[handlerName + `Once`];
    if (onceHandler) {
        if (!instance.emitted) instance.emitted = {};
        else if (instance.emitted[handlerName]) return;
        instance.emitted[handlerName] = true;
        callWithAsyncErrorHandling(onceHandler, instance, 6, args);
    }
}
function normalizeEmitsOptions(comp, appContext, asMixin = false) {
    const cache = appContext.emitsCache;
    const cached = cache.get(comp);
    if (cached !== void 0) return cached;
    const raw = comp.emits;
    let normalized = {};
    let hasExtends = false;
    if (__VUE_OPTIONS_API__ && !(0, _shared.isFunction)(comp)) {
        const extendEmits = (raw2)=>{
            const normalizedFromExtend = normalizeEmitsOptions(raw2, appContext, true);
            if (normalizedFromExtend) {
                hasExtends = true;
                (0, _shared.extend)(normalized, normalizedFromExtend);
            }
        };
        if (!asMixin && appContext.mixins.length) appContext.mixins.forEach(extendEmits);
        if (comp.extends) extendEmits(comp.extends);
        if (comp.mixins) comp.mixins.forEach(extendEmits);
    }
    if (!raw && !hasExtends) {
        if ((0, _shared.isObject)(comp)) cache.set(comp, null);
        return null;
    }
    if ((0, _shared.isArray)(raw)) raw.forEach((key)=>normalized[key] = null);
    else (0, _shared.extend)(normalized, raw);
    if ((0, _shared.isObject)(comp)) cache.set(comp, normalized);
    return normalized;
}
function isEmitListener(options, key) {
    if (!options || !(0, _shared.isOn)(key)) return false;
    key = key.slice(2).replace(/Once$/, "");
    return (0, _shared.hasOwn)(options, key[0].toLowerCase() + key.slice(1)) || (0, _shared.hasOwn)(options, (0, _shared.hyphenate)(key)) || (0, _shared.hasOwn)(options, key);
}
let currentRenderingInstance = null;
let currentScopeId = null;
function setCurrentRenderingInstance(instance) {
    const prev = currentRenderingInstance;
    currentRenderingInstance = instance;
    currentScopeId = instance && instance.type.__scopeId || null;
    return prev;
}
function pushScopeId(id) {
    currentScopeId = id;
}
function popScopeId() {
    currentScopeId = null;
}
const withScopeId = (_id)=>withCtx;
function withCtx(fn, ctx = currentRenderingInstance, isNonScopedSlot) {
    if (!ctx) return fn;
    if (fn._n) return fn;
    const renderFnWithContext = (...args)=>{
        if (renderFnWithContext._d) setBlockTracking(-1);
        const prevInstance = setCurrentRenderingInstance(ctx);
        let res;
        try {
            res = fn(...args);
        } finally{
            setCurrentRenderingInstance(prevInstance);
            if (renderFnWithContext._d) setBlockTracking(1);
        }
        devtoolsComponentUpdated(ctx);
        return res;
    };
    renderFnWithContext._n = true;
    renderFnWithContext._c = true;
    renderFnWithContext._d = true;
    return renderFnWithContext;
}
let accessedAttrs = false;
function markAttrsAccessed() {
    accessedAttrs = true;
}
function renderComponentRoot(instance) {
    const { type: Component, vnode, proxy, withProxy, props, propsOptions: [propsOptions], slots, attrs, emit, render, renderCache, data, setupState, ctx, inheritAttrs } = instance;
    let result;
    let fallthroughAttrs;
    const prev = setCurrentRenderingInstance(instance);
    accessedAttrs = false;
    try {
        if (vnode.shapeFlag & 4) {
            const proxyToUse = withProxy || proxy;
            result = normalizeVNode(render.call(proxyToUse, proxyToUse, renderCache, props, setupState, data, ctx));
            fallthroughAttrs = attrs;
        } else {
            const render2 = Component;
            if (attrs === props) markAttrsAccessed();
            result = normalizeVNode(render2.length > 1 ? render2(props, {
                get attrs () {
                    markAttrsAccessed();
                    return attrs;
                },
                slots,
                emit
            }) : render2(props, null));
            fallthroughAttrs = Component.props ? attrs : getFunctionalFallthrough(attrs);
        }
    } catch (err) {
        blockStack.length = 0;
        handleError(err, instance, 1);
        result = createVNode(Comment);
    }
    let root = result;
    let setRoot = void 0;
    if (result.patchFlag > 0 && result.patchFlag & 2048) [root, setRoot] = getChildRoot(result);
    if (fallthroughAttrs && inheritAttrs !== false) {
        const keys = Object.keys(fallthroughAttrs);
        const { shapeFlag } = root;
        if (keys.length) {
            if (shapeFlag & 7) {
                if (propsOptions && keys.some((0, _shared.isModelListener))) fallthroughAttrs = filterModelListeners(fallthroughAttrs, propsOptions);
                root = cloneVNode(root, fallthroughAttrs);
            } else if (!accessedAttrs && root.type !== Comment) {
                const allAttrs = Object.keys(attrs);
                const eventAttrs = [];
                const extraAttrs = [];
                for(let i = 0, l = allAttrs.length; i < l; i++){
                    const key = allAttrs[i];
                    if ((0, _shared.isOn)(key)) {
                        if (!(0, _shared.isModelListener)(key)) eventAttrs.push(key[2].toLowerCase() + key.slice(3));
                    } else extraAttrs.push(key);
                }
                if (extraAttrs.length) warn(`Extraneous non-props attributes (${extraAttrs.join(", ")}) were passed to component but could not be automatically inherited because component renders fragment or text root nodes.`);
                if (eventAttrs.length) warn(`Extraneous non-emits event listeners (${eventAttrs.join(", ")}) were passed to component but could not be automatically inherited because component renders fragment or text root nodes. If the listener is intended to be a component custom event listener only, declare it using the "emits" option.`);
            }
        }
    }
    if (vnode.dirs) {
        if (!isElementRoot(root)) warn(`Runtime directive used on component with non-element root node. The directives will not function as intended.`);
        root = cloneVNode(root);
        root.dirs = root.dirs ? root.dirs.concat(vnode.dirs) : vnode.dirs;
    }
    if (vnode.transition) {
        if (!isElementRoot(root)) warn(`Component inside <Transition> renders non-element root node that cannot be animated.`);
        root.transition = vnode.transition;
    }
    if (setRoot) setRoot(root);
    else result = root;
    setCurrentRenderingInstance(prev);
    return result;
}
const getChildRoot = (vnode)=>{
    const rawChildren = vnode.children;
    const dynamicChildren = vnode.dynamicChildren;
    const childRoot = filterSingleRoot(rawChildren);
    if (!childRoot) return [
        vnode,
        void 0
    ];
    const index = rawChildren.indexOf(childRoot);
    const dynamicIndex = dynamicChildren ? dynamicChildren.indexOf(childRoot) : -1;
    const setRoot = (updatedRoot)=>{
        rawChildren[index] = updatedRoot;
        if (dynamicChildren) {
            if (dynamicIndex > -1) dynamicChildren[dynamicIndex] = updatedRoot;
            else if (updatedRoot.patchFlag > 0) vnode.dynamicChildren = [
                ...dynamicChildren,
                updatedRoot
            ];
        }
    };
    return [
        normalizeVNode(childRoot),
        setRoot
    ];
};
function filterSingleRoot(children) {
    let singleRoot;
    for(let i = 0; i < children.length; i++){
        const child = children[i];
        if (isVNode(child)) {
            if (child.type !== Comment || child.children === "v-if") {
                if (singleRoot) return;
                else singleRoot = child;
            }
        } else return;
    }
    return singleRoot;
}
const getFunctionalFallthrough = (attrs)=>{
    let res;
    for(const key in attrs)if (key === "class" || key === "style" || (0, _shared.isOn)(key)) (res || (res = {}))[key] = attrs[key];
    return res;
};
const filterModelListeners = (attrs, props)=>{
    const res = {};
    for(const key in attrs)if (!(0, _shared.isModelListener)(key) || !(key.slice(9) in props)) res[key] = attrs[key];
    return res;
};
const isElementRoot = (vnode)=>{
    return vnode.shapeFlag & 7 || vnode.type === Comment;
};
function shouldUpdateComponent(prevVNode, nextVNode, optimized) {
    const { props: prevProps, children: prevChildren, component } = prevVNode;
    const { props: nextProps, children: nextChildren, patchFlag } = nextVNode;
    const emits = component.emitsOptions;
    if ((prevChildren || nextChildren) && isHmrUpdating) return true;
    if (nextVNode.dirs || nextVNode.transition) return true;
    if (optimized && patchFlag >= 0) {
        if (patchFlag & 1024) return true;
        if (patchFlag & 16) {
            if (!prevProps) return !!nextProps;
            return hasPropsChanged(prevProps, nextProps, emits);
        } else if (patchFlag & 8) {
            const dynamicProps = nextVNode.dynamicProps;
            for(let i = 0; i < dynamicProps.length; i++){
                const key = dynamicProps[i];
                if (nextProps[key] !== prevProps[key] && !isEmitListener(emits, key)) return true;
            }
        }
    } else {
        if (prevChildren || nextChildren) {
            if (!nextChildren || !nextChildren.$stable) return true;
        }
        if (prevProps === nextProps) return false;
        if (!prevProps) return !!nextProps;
        if (!nextProps) return true;
        return hasPropsChanged(prevProps, nextProps, emits);
    }
    return false;
}
function hasPropsChanged(prevProps, nextProps, emitsOptions) {
    const nextKeys = Object.keys(nextProps);
    if (nextKeys.length !== Object.keys(prevProps).length) return true;
    for(let i = 0; i < nextKeys.length; i++){
        const key = nextKeys[i];
        if (nextProps[key] !== prevProps[key] && !isEmitListener(emitsOptions, key)) return true;
    }
    return false;
}
function updateHOCHostEl({ vnode, parent }, el) {
    while(parent && parent.subTree === vnode){
        (vnode = parent.vnode).el = el;
        parent = parent.parent;
    }
}
const isSuspense = (type)=>type.__isSuspense;
const SuspenseImpl = {
    name: "Suspense",
    // In order to make Suspense tree-shakable, we need to avoid importing it
    // directly in the renderer. The renderer checks for the __isSuspense flag
    // on a vnode's type and calls the `process` method, passing in renderer
    // internals.
    __isSuspense: true,
    process (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals) {
        if (n1 == null) mountSuspense(n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals);
        else patchSuspense(n1, n2, container, anchor, parentComponent, isSVG, slotScopeIds, optimized, rendererInternals);
    },
    hydrate: hydrateSuspense,
    create: createSuspenseBoundary,
    normalize: normalizeSuspenseChildren
};
const Suspense = SuspenseImpl;
function triggerEvent(vnode, name) {
    const eventListener = vnode.props && vnode.props[name];
    if ((0, _shared.isFunction)(eventListener)) eventListener();
}
function mountSuspense(vnode, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals) {
    const { p: patch, o: { createElement } } = rendererInternals;
    const hiddenContainer = createElement("div");
    const suspense = vnode.suspense = createSuspenseBoundary(vnode, parentSuspense, parentComponent, container, hiddenContainer, anchor, isSVG, slotScopeIds, optimized, rendererInternals);
    patch(null, suspense.pendingBranch = vnode.ssContent, hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds);
    if (suspense.deps > 0) {
        triggerEvent(vnode, "onPending");
        triggerEvent(vnode, "onFallback");
        patch(null, vnode.ssFallback, container, anchor, parentComponent, null, // fallback tree will not have suspense context
        isSVG, slotScopeIds);
        setActiveBranch(suspense, vnode.ssFallback);
    } else suspense.resolve(false, true);
}
function patchSuspense(n1, n2, container, anchor, parentComponent, isSVG, slotScopeIds, optimized, { p: patch, um: unmount, o: { createElement } }) {
    const suspense = n2.suspense = n1.suspense;
    suspense.vnode = n2;
    n2.el = n1.el;
    const newBranch = n2.ssContent;
    const newFallback = n2.ssFallback;
    const { activeBranch, pendingBranch, isInFallback, isHydrating } = suspense;
    if (pendingBranch) {
        suspense.pendingBranch = newBranch;
        if (isSameVNodeType(newBranch, pendingBranch)) {
            patch(pendingBranch, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);
            if (suspense.deps <= 0) suspense.resolve();
            else if (isInFallback) {
                patch(activeBranch, newFallback, container, anchor, parentComponent, null, // fallback tree will not have suspense context
                isSVG, slotScopeIds, optimized);
                setActiveBranch(suspense, newFallback);
            }
        } else {
            suspense.pendingId++;
            if (isHydrating) {
                suspense.isHydrating = false;
                suspense.activeBranch = pendingBranch;
            } else unmount(pendingBranch, parentComponent, suspense);
            suspense.deps = 0;
            suspense.effects.length = 0;
            suspense.hiddenContainer = createElement("div");
            if (isInFallback) {
                patch(null, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);
                if (suspense.deps <= 0) suspense.resolve();
                else {
                    patch(activeBranch, newFallback, container, anchor, parentComponent, null, // fallback tree will not have suspense context
                    isSVG, slotScopeIds, optimized);
                    setActiveBranch(suspense, newFallback);
                }
            } else if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {
                patch(activeBranch, newBranch, container, anchor, parentComponent, suspense, isSVG, slotScopeIds, optimized);
                suspense.resolve(true);
            } else {
                patch(null, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);
                if (suspense.deps <= 0) suspense.resolve();
            }
        }
    } else if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {
        patch(activeBranch, newBranch, container, anchor, parentComponent, suspense, isSVG, slotScopeIds, optimized);
        setActiveBranch(suspense, newBranch);
    } else {
        triggerEvent(n2, "onPending");
        suspense.pendingBranch = newBranch;
        suspense.pendingId++;
        patch(null, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);
        if (suspense.deps <= 0) suspense.resolve();
        else {
            const { timeout, pendingId } = suspense;
            if (timeout > 0) setTimeout(()=>{
                if (suspense.pendingId === pendingId) suspense.fallback(newFallback);
            }, timeout);
            else if (timeout === 0) suspense.fallback(newFallback);
        }
    }
}
let hasWarned = false;
function createSuspenseBoundary(vnode, parentSuspense, parentComponent, container, hiddenContainer, anchor, isSVG, slotScopeIds, optimized, rendererInternals, isHydrating = false) {
    if (!hasWarned) {
        hasWarned = true;
        console[console.info ? "info" : "log"](`<Suspense> is an experimental feature and its API will likely change.`);
    }
    const { p: patch, m: move, um: unmount, n: next, o: { parentNode, remove } } = rendererInternals;
    let parentSuspenseId;
    const isSuspensible = isVNodeSuspensible(vnode);
    if (isSuspensible) {
        if (parentSuspense == null ? void 0 : parentSuspense.pendingBranch) {
            parentSuspenseId = parentSuspense.pendingId;
            parentSuspense.deps++;
        }
    }
    const timeout = vnode.props ? (0, _shared.toNumber)(vnode.props.timeout) : void 0;
    assertNumber(timeout, `Suspense timeout`);
    const suspense = {
        vnode,
        parent: parentSuspense,
        parentComponent,
        isSVG,
        container,
        hiddenContainer,
        anchor,
        deps: 0,
        pendingId: 0,
        timeout: typeof timeout === "number" ? timeout : -1,
        activeBranch: null,
        pendingBranch: null,
        isInFallback: true,
        isHydrating,
        isUnmounted: false,
        effects: [],
        resolve (resume = false, sync = false) {
            if (!resume && !suspense.pendingBranch) throw new Error(`suspense.resolve() is called without a pending branch.`);
            if (suspense.isUnmounted) throw new Error(`suspense.resolve() is called on an already unmounted suspense boundary.`);
            const { vnode: vnode2, activeBranch, pendingBranch, pendingId, effects, parentComponent: parentComponent2, container: container2 } = suspense;
            if (suspense.isHydrating) suspense.isHydrating = false;
            else if (!resume) {
                const delayEnter = activeBranch && pendingBranch.transition && pendingBranch.transition.mode === "out-in";
                if (delayEnter) activeBranch.transition.afterLeave = ()=>{
                    if (pendingId === suspense.pendingId) move(pendingBranch, container2, anchor2, 0);
                };
                let { anchor: anchor2 } = suspense;
                if (activeBranch) {
                    anchor2 = next(activeBranch);
                    unmount(activeBranch, parentComponent2, suspense, true);
                }
                if (!delayEnter) move(pendingBranch, container2, anchor2, 0);
            }
            setActiveBranch(suspense, pendingBranch);
            suspense.pendingBranch = null;
            suspense.isInFallback = false;
            let parent = suspense.parent;
            let hasUnresolvedAncestor = false;
            while(parent){
                if (parent.pendingBranch) {
                    parent.effects.push(...effects);
                    hasUnresolvedAncestor = true;
                    break;
                }
                parent = parent.parent;
            }
            if (!hasUnresolvedAncestor) queuePostFlushCb(effects);
            suspense.effects = [];
            if (isSuspensible) {
                if (parentSuspense && parentSuspense.pendingBranch && parentSuspenseId === parentSuspense.pendingId) {
                    parentSuspense.deps--;
                    if (parentSuspense.deps === 0 && !sync) parentSuspense.resolve();
                }
            }
            triggerEvent(vnode2, "onResolve");
        },
        fallback (fallbackVNode) {
            if (!suspense.pendingBranch) return;
            const { vnode: vnode2, activeBranch, parentComponent: parentComponent2, container: container2, isSVG: isSVG2 } = suspense;
            triggerEvent(vnode2, "onFallback");
            const anchor2 = next(activeBranch);
            const mountFallback = ()=>{
                if (!suspense.isInFallback) return;
                patch(null, fallbackVNode, container2, anchor2, parentComponent2, null, // fallback tree will not have suspense context
                isSVG2, slotScopeIds, optimized);
                setActiveBranch(suspense, fallbackVNode);
            };
            const delayEnter = fallbackVNode.transition && fallbackVNode.transition.mode === "out-in";
            if (delayEnter) activeBranch.transition.afterLeave = mountFallback;
            suspense.isInFallback = true;
            unmount(activeBranch, parentComponent2, null, // no suspense so unmount hooks fire now
            true);
            if (!delayEnter) mountFallback();
        },
        move (container2, anchor2, type) {
            suspense.activeBranch && move(suspense.activeBranch, container2, anchor2, type);
            suspense.container = container2;
        },
        next () {
            return suspense.activeBranch && next(suspense.activeBranch);
        },
        registerDep (instance, setupRenderEffect) {
            const isInPendingSuspense = !!suspense.pendingBranch;
            if (isInPendingSuspense) suspense.deps++;
            const hydratedEl = instance.vnode.el;
            instance.asyncDep.catch((err)=>{
                handleError(err, instance, 0);
            }).then((asyncSetupResult)=>{
                if (instance.isUnmounted || suspense.isUnmounted || suspense.pendingId !== instance.suspenseId) return;
                instance.asyncResolved = true;
                const { vnode: vnode2 } = instance;
                pushWarningContext(vnode2);
                handleSetupResult(instance, asyncSetupResult, false);
                if (hydratedEl) vnode2.el = hydratedEl;
                const placeholder = !hydratedEl && instance.subTree.el;
                setupRenderEffect(instance, vnode2, // component may have been moved before resolve.
                // if this is not a hydration, instance.subTree will be the comment
                // placeholder.
                parentNode(hydratedEl || instance.subTree.el), // anchor will not be used if this is hydration, so only need to
                // consider the comment placeholder case.
                hydratedEl ? null : next(instance.subTree), suspense, isSVG, optimized);
                if (placeholder) remove(placeholder);
                updateHOCHostEl(instance, vnode2.el);
                popWarningContext();
                if (isInPendingSuspense && --suspense.deps === 0) suspense.resolve();
            });
        },
        unmount (parentSuspense2, doRemove) {
            suspense.isUnmounted = true;
            if (suspense.activeBranch) unmount(suspense.activeBranch, parentComponent, parentSuspense2, doRemove);
            if (suspense.pendingBranch) unmount(suspense.pendingBranch, parentComponent, parentSuspense2, doRemove);
        }
    };
    return suspense;
}
function hydrateSuspense(node, vnode, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals, hydrateNode) {
    const suspense = vnode.suspense = createSuspenseBoundary(vnode, parentSuspense, parentComponent, node.parentNode, document.createElement("div"), null, isSVG, slotScopeIds, optimized, rendererInternals, true);
    const result = hydrateNode(node, suspense.pendingBranch = vnode.ssContent, parentComponent, suspense, slotScopeIds, optimized);
    if (suspense.deps === 0) suspense.resolve(false, true);
    return result;
}
function normalizeSuspenseChildren(vnode) {
    const { shapeFlag, children } = vnode;
    const isSlotChildren = shapeFlag & 32;
    vnode.ssContent = normalizeSuspenseSlot(isSlotChildren ? children.default : children);
    vnode.ssFallback = isSlotChildren ? normalizeSuspenseSlot(children.fallback) : createVNode(Comment);
}
function normalizeSuspenseSlot(s) {
    let block;
    if ((0, _shared.isFunction)(s)) {
        const trackBlock = isBlockTreeEnabled && s._c;
        if (trackBlock) {
            s._d = false;
            openBlock();
        }
        s = s();
        if (trackBlock) {
            s._d = true;
            block = currentBlock;
            closeBlock();
        }
    }
    if ((0, _shared.isArray)(s)) {
        const singleChild = filterSingleRoot(s);
        if (!singleChild) warn(`<Suspense> slots expect a single root node.`);
        s = singleChild;
    }
    s = normalizeVNode(s);
    if (block && !s.dynamicChildren) s.dynamicChildren = block.filter((c)=>c !== s);
    return s;
}
function queueEffectWithSuspense(fn, suspense) {
    if (suspense && suspense.pendingBranch) {
        if ((0, _shared.isArray)(fn)) suspense.effects.push(...fn);
        else suspense.effects.push(fn);
    } else queuePostFlushCb(fn);
}
function setActiveBranch(suspense, branch) {
    suspense.activeBranch = branch;
    const { vnode, parentComponent } = suspense;
    const el = vnode.el = branch.el;
    if (parentComponent && parentComponent.subTree === vnode) {
        parentComponent.vnode.el = el;
        updateHOCHostEl(parentComponent, el);
    }
}
function isVNodeSuspensible(vnode) {
    var _a;
    return ((_a = vnode.props) == null ? void 0 : _a.suspensible) != null && vnode.props.suspensible !== false;
}
function watchEffect(effect, options) {
    return doWatch(effect, null, options);
}
function watchPostEffect(effect, options) {
    return doWatch(effect, null, (0, _shared.extend)({}, options, {
        flush: "post"
    }));
}
function watchSyncEffect(effect, options) {
    return doWatch(effect, null, (0, _shared.extend)({}, options, {
        flush: "sync"
    }));
}
const INITIAL_WATCHER_VALUE = {};
function watch(source, cb, options) {
    if (!(0, _shared.isFunction)(cb)) warn(`\`watch(fn, options?)\` signature has been moved to a separate API. Use \`watchEffect(fn, options?)\` instead. \`watch\` now only supports \`watch(source, cb, options?) signature.`);
    return doWatch(source, cb, options);
}
function doWatch(source, cb, { immediate, deep, flush, onTrack, onTrigger } = (0, _shared.EMPTY_OBJ)) {
    var _a;
    if (!cb) {
        if (immediate !== void 0) warn(`watch() "immediate" option is only respected when using the watch(source, callback, options?) signature.`);
        if (deep !== void 0) warn(`watch() "deep" option is only respected when using the watch(source, callback, options?) signature.`);
    }
    const warnInvalidSource = (s)=>{
        warn(`Invalid watch source: `, s, `A watch source can only be a getter/effect function, a ref, a reactive object, or an array of these types.`);
    };
    const instance = (0, _reactivity.getCurrentScope)() === ((_a = currentInstance) == null ? void 0 : _a.scope) ? currentInstance : null;
    let getter;
    let forceTrigger = false;
    let isMultiSource = false;
    if ((0, _reactivity.isRef)(source)) {
        getter = ()=>source.value;
        forceTrigger = (0, _reactivity.isShallow)(source);
    } else if ((0, _reactivity.isReactive)(source)) {
        getter = ()=>source;
        deep = true;
    } else if ((0, _shared.isArray)(source)) {
        isMultiSource = true;
        forceTrigger = source.some((s)=>(0, _reactivity.isReactive)(s) || (0, _reactivity.isShallow)(s));
        getter = ()=>source.map((s)=>{
                if ((0, _reactivity.isRef)(s)) return s.value;
                else if ((0, _reactivity.isReactive)(s)) return traverse(s);
                else if ((0, _shared.isFunction)(s)) return callWithErrorHandling(s, instance, 2);
                else warnInvalidSource(s);
            });
    } else if ((0, _shared.isFunction)(source)) {
        if (cb) getter = ()=>callWithErrorHandling(source, instance, 2);
        else getter = ()=>{
            if (instance && instance.isUnmounted) return;
            if (cleanup) cleanup();
            return callWithAsyncErrorHandling(source, instance, 3, [
                onCleanup
            ]);
        };
    } else {
        getter = (0, _shared.NOOP);
        warnInvalidSource(source);
    }
    if (cb && deep) {
        const baseGetter = getter;
        getter = ()=>traverse(baseGetter());
    }
    let cleanup;
    let onCleanup = (fn)=>{
        cleanup = effect.onStop = ()=>{
            callWithErrorHandling(fn, instance, 4);
        };
    };
    let ssrCleanup;
    if (isInSSRComponentSetup) {
        onCleanup = (0, _shared.NOOP);
        if (!cb) getter();
        else if (immediate) callWithAsyncErrorHandling(cb, instance, 3, [
            getter(),
            isMultiSource ? [] : void 0,
            onCleanup
        ]);
        if (flush === "sync") {
            const ctx = useSSRContext();
            ssrCleanup = ctx.__watcherHandles || (ctx.__watcherHandles = []);
        } else return 0, _shared.NOOP;
    }
    let oldValue = isMultiSource ? new Array(source.length).fill(INITIAL_WATCHER_VALUE) : INITIAL_WATCHER_VALUE;
    const job = ()=>{
        if (!effect.active) return;
        if (cb) {
            const newValue = effect.run();
            if (deep || forceTrigger || (isMultiSource ? newValue.some((v1, i)=>(0, _shared.hasChanged)(v1, oldValue[i])) : (0, _shared.hasChanged)(newValue, oldValue)) || false) {
                if (cleanup) cleanup();
                callWithAsyncErrorHandling(cb, instance, 3, [
                    newValue,
                    // pass undefined as the old value when it's changed for the first time
                    oldValue === INITIAL_WATCHER_VALUE ? void 0 : isMultiSource && oldValue[0] === INITIAL_WATCHER_VALUE ? [] : oldValue,
                    onCleanup
                ]);
                oldValue = newValue;
            }
        } else effect.run();
    };
    job.allowRecurse = !!cb;
    let scheduler;
    if (flush === "sync") scheduler = job;
    else if (flush === "post") scheduler = ()=>queuePostRenderEffect(job, instance && instance.suspense);
    else {
        job.pre = true;
        if (instance) job.id = instance.uid;
        scheduler = ()=>queueJob(job);
    }
    const effect = new (0, _reactivity.ReactiveEffect)(getter, scheduler);
    effect.onTrack = onTrack;
    effect.onTrigger = onTrigger;
    if (cb) {
        if (immediate) job();
        else oldValue = effect.run();
    } else if (flush === "post") queuePostRenderEffect(effect.run.bind(effect), instance && instance.suspense);
    else effect.run();
    const unwatch = ()=>{
        effect.stop();
        if (instance && instance.scope) (0, _shared.remove)(instance.scope.effects, effect);
    };
    if (ssrCleanup) ssrCleanup.push(unwatch);
    return unwatch;
}
function instanceWatch(source, value1, options) {
    const publicThis = this.proxy;
    const getter = (0, _shared.isString)(source) ? source.includes(".") ? createPathGetter(publicThis, source) : ()=>publicThis[source] : source.bind(publicThis, publicThis);
    let cb;
    if ((0, _shared.isFunction)(value1)) cb = value1;
    else {
        cb = value1.handler;
        options = value1;
    }
    const cur = currentInstance;
    setCurrentInstance(this);
    const res = doWatch(getter, cb.bind(publicThis), options);
    if (cur) setCurrentInstance(cur);
    else unsetCurrentInstance();
    return res;
}
function createPathGetter(ctx, path) {
    const segments = path.split(".");
    return ()=>{
        let cur = ctx;
        for(let i = 0; i < segments.length && cur; i++)cur = cur[segments[i]];
        return cur;
    };
}
function traverse(value1, seen) {
    if (!(0, _shared.isObject)(value1) || value1["__v_skip"]) return value1;
    seen = seen || /* @__PURE__ */ new Set();
    if (seen.has(value1)) return value1;
    seen.add(value1);
    if ((0, _reactivity.isRef)(value1)) traverse(value1.value, seen);
    else if ((0, _shared.isArray)(value1)) for(let i = 0; i < value1.length; i++)traverse(value1[i], seen);
    else if ((0, _shared.isSet)(value1) || (0, _shared.isMap)(value1)) value1.forEach((v1)=>{
        traverse(v1, seen);
    });
    else if ((0, _shared.isPlainObject)(value1)) for(const key in value1)traverse(value1[key], seen);
    return value1;
}
function validateDirectiveName(name) {
    if ((0, _shared.isBuiltInDirective)(name)) warn("Do not use built-in directive ids as custom directive id: " + name);
}
function withDirectives(vnode, directives) {
    const internalInstance = currentRenderingInstance;
    if (internalInstance === null) {
        warn(`withDirectives can only be used inside render functions.`);
        return vnode;
    }
    const instance = getExposeProxy(internalInstance) || internalInstance.proxy;
    const bindings = vnode.dirs || (vnode.dirs = []);
    for(let i = 0; i < directives.length; i++){
        let [dir, value1, arg, modifiers = (0, _shared.EMPTY_OBJ)] = directives[i];
        if (dir) {
            if ((0, _shared.isFunction)(dir)) dir = {
                mounted: dir,
                updated: dir
            };
            if (dir.deep) traverse(value1);
            bindings.push({
                dir,
                instance,
                value: value1,
                oldValue: void 0,
                arg,
                modifiers
            });
        }
    }
    return vnode;
}
function invokeDirectiveHook(vnode, prevVNode, instance, name) {
    const bindings = vnode.dirs;
    const oldBindings = prevVNode && prevVNode.dirs;
    for(let i = 0; i < bindings.length; i++){
        const binding = bindings[i];
        if (oldBindings) binding.oldValue = oldBindings[i].value;
        let hook = binding.dir[name];
        if (hook) {
            (0, _reactivity.pauseTracking)();
            callWithAsyncErrorHandling(hook, instance, 8, [
                vnode.el,
                binding,
                vnode,
                prevVNode
            ]);
            (0, _reactivity.resetTracking)();
        }
    }
}
function useTransitionState() {
    const state = {
        isMounted: false,
        isLeaving: false,
        isUnmounting: false,
        leavingVNodes: /* @__PURE__ */ new Map()
    };
    onMounted(()=>{
        state.isMounted = true;
    });
    onBeforeUnmount(()=>{
        state.isUnmounting = true;
    });
    return state;
}
const TransitionHookValidator = [
    Function,
    Array
];
const BaseTransitionPropsValidators = {
    mode: String,
    appear: Boolean,
    persisted: Boolean,
    // enter
    onBeforeEnter: TransitionHookValidator,
    onEnter: TransitionHookValidator,
    onAfterEnter: TransitionHookValidator,
    onEnterCancelled: TransitionHookValidator,
    // leave
    onBeforeLeave: TransitionHookValidator,
    onLeave: TransitionHookValidator,
    onAfterLeave: TransitionHookValidator,
    onLeaveCancelled: TransitionHookValidator,
    // appear
    onBeforeAppear: TransitionHookValidator,
    onAppear: TransitionHookValidator,
    onAfterAppear: TransitionHookValidator,
    onAppearCancelled: TransitionHookValidator
};
const BaseTransitionImpl = {
    name: `BaseTransition`,
    props: BaseTransitionPropsValidators,
    setup (props, { slots }) {
        const instance = getCurrentInstance();
        const state = useTransitionState();
        let prevTransitionKey;
        return ()=>{
            const children = slots.default && getTransitionRawChildren(slots.default(), true);
            if (!children || !children.length) return;
            let child = children[0];
            if (children.length > 1) {
                let hasFound = false;
                for (const c of children)if (c.type !== Comment) {
                    if (hasFound) {
                        warn("<transition> can only be used on a single element or component. Use <transition-group> for lists.");
                        break;
                    }
                    child = c;
                    hasFound = true;
                }
            }
            const rawProps = (0, _reactivity.toRaw)(props);
            const { mode } = rawProps;
            if (mode && mode !== "in-out" && mode !== "out-in" && mode !== "default") warn(`invalid <transition> mode: ${mode}`);
            if (state.isLeaving) return emptyPlaceholder(child);
            const innerChild = getKeepAliveChild(child);
            if (!innerChild) return emptyPlaceholder(child);
            const enterHooks = resolveTransitionHooks(innerChild, rawProps, state, instance);
            setTransitionHooks(innerChild, enterHooks);
            const oldChild = instance.subTree;
            const oldInnerChild = oldChild && getKeepAliveChild(oldChild);
            let transitionKeyChanged = false;
            const { getTransitionKey } = innerChild.type;
            if (getTransitionKey) {
                const key = getTransitionKey();
                if (prevTransitionKey === void 0) prevTransitionKey = key;
                else if (key !== prevTransitionKey) {
                    prevTransitionKey = key;
                    transitionKeyChanged = true;
                }
            }
            if (oldInnerChild && oldInnerChild.type !== Comment && (!isSameVNodeType(innerChild, oldInnerChild) || transitionKeyChanged)) {
                const leavingHooks = resolveTransitionHooks(oldInnerChild, rawProps, state, instance);
                setTransitionHooks(oldInnerChild, leavingHooks);
                if (mode === "out-in") {
                    state.isLeaving = true;
                    leavingHooks.afterLeave = ()=>{
                        state.isLeaving = false;
                        if (instance.update.active !== false) instance.update();
                    };
                    return emptyPlaceholder(child);
                } else if (mode === "in-out" && innerChild.type !== Comment) leavingHooks.delayLeave = (el, earlyRemove, delayedLeave)=>{
                    const leavingVNodesCache = getLeavingNodesForType(state, oldInnerChild);
                    leavingVNodesCache[String(oldInnerChild.key)] = oldInnerChild;
                    el._leaveCb = ()=>{
                        earlyRemove();
                        el._leaveCb = void 0;
                        delete enterHooks.delayedLeave;
                    };
                    enterHooks.delayedLeave = delayedLeave;
                };
            }
            return child;
        };
    }
};
const BaseTransition = BaseTransitionImpl;
function getLeavingNodesForType(state, vnode) {
    const { leavingVNodes } = state;
    let leavingVNodesCache = leavingVNodes.get(vnode.type);
    if (!leavingVNodesCache) {
        leavingVNodesCache = /* @__PURE__ */ Object.create(null);
        leavingVNodes.set(vnode.type, leavingVNodesCache);
    }
    return leavingVNodesCache;
}
function resolveTransitionHooks(vnode, props, state, instance) {
    const { appear, mode, persisted = false, onBeforeEnter, onEnter, onAfterEnter, onEnterCancelled, onBeforeLeave, onLeave, onAfterLeave, onLeaveCancelled, onBeforeAppear, onAppear, onAfterAppear, onAppearCancelled } = props;
    const key = String(vnode.key);
    const leavingVNodesCache = getLeavingNodesForType(state, vnode);
    const callHook = (hook, args)=>{
        hook && callWithAsyncErrorHandling(hook, instance, 9, args);
    };
    const callAsyncHook = (hook, args)=>{
        const done = args[1];
        callHook(hook, args);
        if ((0, _shared.isArray)(hook)) {
            if (hook.every((hook2)=>hook2.length <= 1)) done();
        } else if (hook.length <= 1) done();
    };
    const hooks = {
        mode,
        persisted,
        beforeEnter (el) {
            let hook = onBeforeEnter;
            if (!state.isMounted) {
                if (appear) hook = onBeforeAppear || onBeforeEnter;
                else return;
            }
            if (el._leaveCb) el._leaveCb(true);
            const leavingVNode = leavingVNodesCache[key];
            if (leavingVNode && isSameVNodeType(vnode, leavingVNode) && leavingVNode.el._leaveCb) leavingVNode.el._leaveCb();
            callHook(hook, [
                el
            ]);
        },
        enter (el) {
            let hook = onEnter;
            let afterHook = onAfterEnter;
            let cancelHook = onEnterCancelled;
            if (!state.isMounted) {
                if (appear) {
                    hook = onAppear || onEnter;
                    afterHook = onAfterAppear || onAfterEnter;
                    cancelHook = onAppearCancelled || onEnterCancelled;
                } else return;
            }
            let called = false;
            const done = el._enterCb = (cancelled)=>{
                if (called) return;
                called = true;
                if (cancelled) callHook(cancelHook, [
                    el
                ]);
                else callHook(afterHook, [
                    el
                ]);
                if (hooks.delayedLeave) hooks.delayedLeave();
                el._enterCb = void 0;
            };
            if (hook) callAsyncHook(hook, [
                el,
                done
            ]);
            else done();
        },
        leave (el, remove) {
            const key2 = String(vnode.key);
            if (el._enterCb) el._enterCb(true);
            if (state.isUnmounting) return remove();
            callHook(onBeforeLeave, [
                el
            ]);
            let called = false;
            const done = el._leaveCb = (cancelled)=>{
                if (called) return;
                called = true;
                remove();
                if (cancelled) callHook(onLeaveCancelled, [
                    el
                ]);
                else callHook(onAfterLeave, [
                    el
                ]);
                el._leaveCb = void 0;
                if (leavingVNodesCache[key2] === vnode) delete leavingVNodesCache[key2];
            };
            leavingVNodesCache[key2] = vnode;
            if (onLeave) callAsyncHook(onLeave, [
                el,
                done
            ]);
            else done();
        },
        clone (vnode2) {
            return resolveTransitionHooks(vnode2, props, state, instance);
        }
    };
    return hooks;
}
function emptyPlaceholder(vnode) {
    if (isKeepAlive(vnode)) {
        vnode = cloneVNode(vnode);
        vnode.children = null;
        return vnode;
    }
}
function getKeepAliveChild(vnode) {
    return isKeepAlive(vnode) ? vnode.children ? vnode.children[0] : void 0 : vnode;
}
function setTransitionHooks(vnode, hooks) {
    if (vnode.shapeFlag & 6 && vnode.component) setTransitionHooks(vnode.component.subTree, hooks);
    else if (vnode.shapeFlag & 128) {
        vnode.ssContent.transition = hooks.clone(vnode.ssContent);
        vnode.ssFallback.transition = hooks.clone(vnode.ssFallback);
    } else vnode.transition = hooks;
}
function getTransitionRawChildren(children, keepComment = false, parentKey) {
    let ret = [];
    let keyedFragmentCount = 0;
    for(let i = 0; i < children.length; i++){
        let child = children[i];
        const key = parentKey == null ? child.key : String(parentKey) + String(child.key != null ? child.key : i);
        if (child.type === Fragment) {
            if (child.patchFlag & 128) keyedFragmentCount++;
            ret = ret.concat(getTransitionRawChildren(child.children, keepComment, key));
        } else if (keepComment || child.type !== Comment) ret.push(key != null ? cloneVNode(child, {
            key
        }) : child);
    }
    if (keyedFragmentCount > 1) for(let i = 0; i < ret.length; i++)ret[i].patchFlag = -2;
    return ret;
}
function defineComponent(options, extraOptions) {
    return (0, _shared.isFunction)(options) ? // #8326: extend call and options.name access are considered side-effects
    // by Rollup, so we have to wrap it in a pure-annotated IIFE.
    /* @__PURE__ */ (()=>(0, _shared.extend)({
            name: options.name
        }, extraOptions, {
            setup: options
        }))() : options;
}
const isAsyncWrapper = (i)=>!!i.type.__asyncLoader;
function defineAsyncComponent(source) {
    if ((0, _shared.isFunction)(source)) source = {
        loader: source
    };
    const { loader, loadingComponent, errorComponent, delay = 200, timeout, // undefined = never times out
    suspensible = true, onError: userOnError } = source;
    let pendingRequest = null;
    let resolvedComp;
    let retries = 0;
    const retry = ()=>{
        retries++;
        pendingRequest = null;
        return load();
    };
    const load = ()=>{
        let thisRequest;
        return pendingRequest || (thisRequest = pendingRequest = loader().catch((err)=>{
            err = err instanceof Error ? err : new Error(String(err));
            if (userOnError) return new Promise((resolve, reject)=>{
                const userRetry = ()=>resolve(retry());
                const userFail = ()=>reject(err);
                userOnError(err, userRetry, userFail, retries + 1);
            });
            else throw err;
        }).then((comp)=>{
            if (thisRequest !== pendingRequest && pendingRequest) return pendingRequest;
            if (!comp) warn(`Async component loader resolved to undefined. If you are using retry(), make sure to return its return value.`);
            if (comp && (comp.__esModule || comp[Symbol.toStringTag] === "Module")) comp = comp.default;
            if (comp && !(0, _shared.isObject)(comp) && !(0, _shared.isFunction)(comp)) throw new Error(`Invalid async component load result: ${comp}`);
            resolvedComp = comp;
            return comp;
        }));
    };
    return defineComponent({
        name: "AsyncComponentWrapper",
        __asyncLoader: load,
        get __asyncResolved () {
            return resolvedComp;
        },
        setup () {
            const instance = currentInstance;
            if (resolvedComp) return ()=>createInnerComp(resolvedComp, instance);
            const onError = (err)=>{
                pendingRequest = null;
                handleError(err, instance, 13, !errorComponent);
            };
            if (suspensible && instance.suspense || isInSSRComponentSetup) return load().then((comp)=>{
                return ()=>createInnerComp(comp, instance);
            }).catch((err)=>{
                onError(err);
                return ()=>errorComponent ? createVNode(errorComponent, {
                        error: err
                    }) : null;
            });
            const loaded = (0, _reactivity.ref)(false);
            const error = (0, _reactivity.ref)();
            const delayed = (0, _reactivity.ref)(!!delay);
            if (delay) setTimeout(()=>{
                delayed.value = false;
            }, delay);
            if (timeout != null) setTimeout(()=>{
                if (!loaded.value && !error.value) {
                    const err = new Error(`Async component timed out after ${timeout}ms.`);
                    onError(err);
                    error.value = err;
                }
            }, timeout);
            load().then(()=>{
                loaded.value = true;
                if (instance.parent && isKeepAlive(instance.parent.vnode)) queueJob(instance.parent.update);
            }).catch((err)=>{
                onError(err);
                error.value = err;
            });
            return ()=>{
                if (loaded.value && resolvedComp) return createInnerComp(resolvedComp, instance);
                else if (error.value && errorComponent) return createVNode(errorComponent, {
                    error: error.value
                });
                else if (loadingComponent && !delayed.value) return createVNode(loadingComponent);
            };
        }
    });
}
function createInnerComp(comp, parent) {
    const { ref: ref2, props, children, ce } = parent.vnode;
    const vnode = createVNode(comp, props, children);
    vnode.ref = ref2;
    vnode.ce = ce;
    delete parent.vnode.ce;
    return vnode;
}
const isKeepAlive = (vnode)=>vnode.type.__isKeepAlive;
const KeepAliveImpl = {
    name: `KeepAlive`,
    // Marker for special handling inside the renderer. We are not using a ===
    // check directly on KeepAlive in the renderer, because importing it directly
    // would prevent it from being tree-shaken.
    __isKeepAlive: true,
    props: {
        include: [
            String,
            RegExp,
            Array
        ],
        exclude: [
            String,
            RegExp,
            Array
        ],
        max: [
            String,
            Number
        ]
    },
    setup (props, { slots }) {
        const instance = getCurrentInstance();
        const sharedContext = instance.ctx;
        if (!sharedContext.renderer) return ()=>{
            const children = slots.default && slots.default();
            return children && children.length === 1 ? children[0] : children;
        };
        const cache = /* @__PURE__ */ new Map();
        const keys = /* @__PURE__ */ new Set();
        let current = null;
        instance.__v_cache = cache;
        const parentSuspense = instance.suspense;
        const { renderer: { p: patch, m: move, um: _unmount, o: { createElement } } } = sharedContext;
        const storageContainer = createElement("div");
        sharedContext.activate = (vnode, container, anchor, isSVG, optimized)=>{
            const instance2 = vnode.component;
            move(vnode, container, anchor, 0, parentSuspense);
            patch(instance2.vnode, vnode, container, anchor, instance2, parentSuspense, isSVG, vnode.slotScopeIds, optimized);
            queuePostRenderEffect(()=>{
                instance2.isDeactivated = false;
                if (instance2.a) (0, _shared.invokeArrayFns)(instance2.a);
                const vnodeHook = vnode.props && vnode.props.onVnodeMounted;
                if (vnodeHook) invokeVNodeHook(vnodeHook, instance2.parent, vnode);
            }, parentSuspense);
            devtoolsComponentAdded(instance2);
        };
        sharedContext.deactivate = (vnode)=>{
            const instance2 = vnode.component;
            move(vnode, storageContainer, null, 1, parentSuspense);
            queuePostRenderEffect(()=>{
                if (instance2.da) (0, _shared.invokeArrayFns)(instance2.da);
                const vnodeHook = vnode.props && vnode.props.onVnodeUnmounted;
                if (vnodeHook) invokeVNodeHook(vnodeHook, instance2.parent, vnode);
                instance2.isDeactivated = true;
            }, parentSuspense);
            devtoolsComponentAdded(instance2);
        };
        function unmount(vnode) {
            resetShapeFlag(vnode);
            _unmount(vnode, instance, parentSuspense, true);
        }
        function pruneCache(filter) {
            cache.forEach((vnode, key)=>{
                const name = getComponentName(vnode.type);
                if (name && (!filter || !filter(name))) pruneCacheEntry(key);
            });
        }
        function pruneCacheEntry(key) {
            const cached = cache.get(key);
            if (!current || !isSameVNodeType(cached, current)) unmount(cached);
            else if (current) resetShapeFlag(current);
            cache.delete(key);
            keys.delete(key);
        }
        watch(()=>[
                props.include,
                props.exclude
            ], ([include, exclude])=>{
            include && pruneCache((name)=>matches(include, name));
            exclude && pruneCache((name)=>!matches(exclude, name));
        }, // prune post-render after `current` has been updated
        {
            flush: "post",
            deep: true
        });
        let pendingCacheKey = null;
        const cacheSubtree = ()=>{
            if (pendingCacheKey != null) cache.set(pendingCacheKey, getInnerChild(instance.subTree));
        };
        onMounted(cacheSubtree);
        onUpdated(cacheSubtree);
        onBeforeUnmount(()=>{
            cache.forEach((cached)=>{
                const { subTree, suspense } = instance;
                const vnode = getInnerChild(subTree);
                if (cached.type === vnode.type && cached.key === vnode.key) {
                    resetShapeFlag(vnode);
                    const da = vnode.component.da;
                    da && queuePostRenderEffect(da, suspense);
                    return;
                }
                unmount(cached);
            });
        });
        return ()=>{
            pendingCacheKey = null;
            if (!slots.default) return null;
            const children = slots.default();
            const rawVNode = children[0];
            if (children.length > 1) {
                warn(`KeepAlive should contain exactly one component child.`);
                current = null;
                return children;
            } else if (!isVNode(rawVNode) || !(rawVNode.shapeFlag & 4) && !(rawVNode.shapeFlag & 128)) {
                current = null;
                return rawVNode;
            }
            let vnode = getInnerChild(rawVNode);
            const comp = vnode.type;
            const name = getComponentName(isAsyncWrapper(vnode) ? vnode.type.__asyncResolved || {} : comp);
            const { include, exclude, max } = props;
            if (include && (!name || !matches(include, name)) || exclude && name && matches(exclude, name)) {
                current = vnode;
                return rawVNode;
            }
            const key = vnode.key == null ? comp : vnode.key;
            const cachedVNode = cache.get(key);
            if (vnode.el) {
                vnode = cloneVNode(vnode);
                if (rawVNode.shapeFlag & 128) rawVNode.ssContent = vnode;
            }
            pendingCacheKey = key;
            if (cachedVNode) {
                vnode.el = cachedVNode.el;
                vnode.component = cachedVNode.component;
                if (vnode.transition) setTransitionHooks(vnode, vnode.transition);
                vnode.shapeFlag |= 512;
                keys.delete(key);
                keys.add(key);
            } else {
                keys.add(key);
                if (max && keys.size > parseInt(max, 10)) pruneCacheEntry(keys.values().next().value);
            }
            vnode.shapeFlag |= 256;
            current = vnode;
            return isSuspense(rawVNode.type) ? rawVNode : vnode;
        };
    }
};
const KeepAlive = KeepAliveImpl;
function matches(pattern, name) {
    if ((0, _shared.isArray)(pattern)) return pattern.some((p)=>matches(p, name));
    else if ((0, _shared.isString)(pattern)) return pattern.split(",").includes(name);
    else if ((0, _shared.isRegExp)(pattern)) return pattern.test(name);
    return false;
}
function onActivated(hook, target) {
    registerKeepAliveHook(hook, "a", target);
}
function onDeactivated(hook, target) {
    registerKeepAliveHook(hook, "da", target);
}
function registerKeepAliveHook(hook, type, target = currentInstance) {
    const wrappedHook = hook.__wdc || (hook.__wdc = ()=>{
        let current = target;
        while(current){
            if (current.isDeactivated) return;
            current = current.parent;
        }
        return hook();
    });
    injectHook(type, wrappedHook, target);
    if (target) {
        let current = target.parent;
        while(current && current.parent){
            if (isKeepAlive(current.parent.vnode)) injectToKeepAliveRoot(wrappedHook, type, target, current);
            current = current.parent;
        }
    }
}
function injectToKeepAliveRoot(hook, type, target, keepAliveRoot) {
    const injected = injectHook(type, hook, keepAliveRoot, true);
    onUnmounted(()=>{
        (0, _shared.remove)(keepAliveRoot[type], injected);
    }, target);
}
function resetShapeFlag(vnode) {
    vnode.shapeFlag &= -257;
    vnode.shapeFlag &= -513;
}
function getInnerChild(vnode) {
    return vnode.shapeFlag & 128 ? vnode.ssContent : vnode;
}
function injectHook(type, hook, target = currentInstance, prepend = false) {
    if (target) {
        const hooks = target[type] || (target[type] = []);
        const wrappedHook = hook.__weh || (hook.__weh = (...args)=>{
            if (target.isUnmounted) return;
            (0, _reactivity.pauseTracking)();
            setCurrentInstance(target);
            const res = callWithAsyncErrorHandling(hook, target, type, args);
            unsetCurrentInstance();
            (0, _reactivity.resetTracking)();
            return res;
        });
        if (prepend) hooks.unshift(wrappedHook);
        else hooks.push(wrappedHook);
        return wrappedHook;
    } else {
        const apiName = (0, _shared.toHandlerKey)(ErrorTypeStrings[type].replace(/ hook$/, ""));
        warn(`${apiName} is called when there is no active component instance to be associated with. Lifecycle injection APIs can only be used during execution of setup().` + ` If you are using async setup(), make sure to register lifecycle hooks before the first await statement.`);
    }
}
const createHook = (lifecycle)=>(hook, target = currentInstance)=>// post-create lifecycle registrations are noops during SSR (except for serverPrefetch)
        (!isInSSRComponentSetup || lifecycle === "sp") && injectHook(lifecycle, (...args)=>hook(...args), target);
const onBeforeMount = createHook("bm");
const onMounted = createHook("m");
const onBeforeUpdate = createHook("bu");
const onUpdated = createHook("u");
const onBeforeUnmount = createHook("bum");
const onUnmounted = createHook("um");
const onServerPrefetch = createHook("sp");
const onRenderTriggered = createHook("rtg");
const onRenderTracked = createHook("rtc");
function onErrorCaptured(hook, target = currentInstance) {
    injectHook("ec", hook, target);
}
const COMPONENTS = "components";
const DIRECTIVES = "directives";
function resolveComponent(name, maybeSelfReference) {
    return resolveAsset(COMPONENTS, name, true, maybeSelfReference) || name;
}
const NULL_DYNAMIC_COMPONENT = Symbol.for("v-ndc");
function resolveDynamicComponent(component) {
    if ((0, _shared.isString)(component)) return resolveAsset(COMPONENTS, component, false) || component;
    else return component || NULL_DYNAMIC_COMPONENT;
}
function resolveDirective(name) {
    return resolveAsset(DIRECTIVES, name);
}
function resolveAsset(type, name, warnMissing = true, maybeSelfReference = false) {
    const instance = currentRenderingInstance || currentInstance;
    if (instance) {
        const Component = instance.type;
        if (type === COMPONENTS) {
            const selfName = getComponentName(Component, false);
            if (selfName && (selfName === name || selfName === (0, _shared.camelize)(name) || selfName === (0, _shared.capitalize)((0, _shared.camelize)(name)))) return Component;
        }
        const res = // local registration
        // check instance[type] first which is resolved for options API
        resolve(instance[type] || Component[type], name) || // global registration
        resolve(instance.appContext[type], name);
        if (!res && maybeSelfReference) return Component;
        if (warnMissing && !res) {
            const extra = type === COMPONENTS ? `
If this is a native custom element, make sure to exclude it from component resolution via compilerOptions.isCustomElement.` : ``;
            warn(`Failed to resolve ${type.slice(0, -1)}: ${name}${extra}`);
        }
        return res;
    } else warn(`resolve${(0, _shared.capitalize)(type.slice(0, -1))} can only be used in render() or setup().`);
}
function resolve(registry, name) {
    return registry && (registry[name] || registry[(0, _shared.camelize)(name)] || registry[(0, _shared.capitalize)((0, _shared.camelize)(name))]);
}
function renderList(source, renderItem, cache, index) {
    let ret;
    const cached = cache && cache[index];
    if ((0, _shared.isArray)(source) || (0, _shared.isString)(source)) {
        ret = new Array(source.length);
        for(let i = 0, l = source.length; i < l; i++)ret[i] = renderItem(source[i], i, void 0, cached && cached[i]);
    } else if (typeof source === "number") {
        if (!Number.isInteger(source)) warn(`The v-for range expect an integer value but got ${source}.`);
        ret = new Array(source);
        for(let i = 0; i < source; i++)ret[i] = renderItem(i + 1, i, void 0, cached && cached[i]);
    } else if ((0, _shared.isObject)(source)) {
        if (source[Symbol.iterator]) ret = Array.from(source, (item, i)=>renderItem(item, i, void 0, cached && cached[i]));
        else {
            const keys = Object.keys(source);
            ret = new Array(keys.length);
            for(let i = 0, l = keys.length; i < l; i++){
                const key = keys[i];
                ret[i] = renderItem(source[key], key, i, cached && cached[i]);
            }
        }
    } else ret = [];
    if (cache) cache[index] = ret;
    return ret;
}
function createSlots(slots, dynamicSlots) {
    for(let i = 0; i < dynamicSlots.length; i++){
        const slot = dynamicSlots[i];
        if ((0, _shared.isArray)(slot)) for(let j = 0; j < slot.length; j++)slots[slot[j].name] = slot[j].fn;
        else if (slot) slots[slot.name] = slot.key ? (...args)=>{
            const res = slot.fn(...args);
            if (res) res.key = slot.key;
            return res;
        } : slot.fn;
    }
    return slots;
}
function renderSlot(slots, name, props = {}, fallback, noSlotted) {
    if (currentRenderingInstance.isCE || currentRenderingInstance.parent && isAsyncWrapper(currentRenderingInstance.parent) && currentRenderingInstance.parent.isCE) {
        if (name !== "default") props.name = name;
        return createVNode("slot", props, fallback && fallback());
    }
    let slot = slots[name];
    if (slot && slot.length > 1) {
        warn(`SSR-optimized slot function detected in a non-SSR-optimized render function. You need to mark this component with $dynamic-slots in the parent template.`);
        slot = ()=>[];
    }
    if (slot && slot._c) slot._d = false;
    openBlock();
    const validSlotContent = slot && ensureValidVNode(slot(props));
    const rendered = createBlock(Fragment, {
        key: props.key || // slot content array of a dynamic conditional slot may have a branch
        // key attached in the `createSlots` helper, respect that
        validSlotContent && validSlotContent.key || `_${name}`
    }, validSlotContent || (fallback ? fallback() : []), validSlotContent && slots._ === 1 ? 64 : -2);
    if (!noSlotted && rendered.scopeId) rendered.slotScopeIds = [
        rendered.scopeId + "-s"
    ];
    if (slot && slot._c) slot._d = true;
    return rendered;
}
function ensureValidVNode(vnodes) {
    return vnodes.some((child)=>{
        if (!isVNode(child)) return true;
        if (child.type === Comment) return false;
        if (child.type === Fragment && !ensureValidVNode(child.children)) return false;
        return true;
    }) ? vnodes : null;
}
function toHandlers(obj, preserveCaseIfNecessary) {
    const ret = {};
    if (!(0, _shared.isObject)(obj)) {
        warn(`v-on with no argument expects an object value.`);
        return ret;
    }
    for(const key in obj)ret[preserveCaseIfNecessary && /[A-Z]/.test(key) ? `on:${key}` : (0, _shared.toHandlerKey)(key)] = obj[key];
    return ret;
}
const getPublicInstance = (i)=>{
    if (!i) return null;
    if (isStatefulComponent(i)) return getExposeProxy(i) || i.proxy;
    return getPublicInstance(i.parent);
};
const publicPropertiesMap = // Move PURE marker to new line to workaround compiler discarding it
// due to type annotation
/* @__PURE__ */ (0, _shared.extend)(/* @__PURE__ */ Object.create(null), {
    $: (i)=>i,
    $el: (i)=>i.vnode.el,
    $data: (i)=>i.data,
    $props: (i)=>(0, _reactivity.shallowReadonly)(i.props),
    $attrs: (i)=>(0, _reactivity.shallowReadonly)(i.attrs),
    $slots: (i)=>(0, _reactivity.shallowReadonly)(i.slots),
    $refs: (i)=>(0, _reactivity.shallowReadonly)(i.refs),
    $parent: (i)=>getPublicInstance(i.parent),
    $root: (i)=>getPublicInstance(i.root),
    $emit: (i)=>i.emit,
    $options: (i)=>__VUE_OPTIONS_API__ ? resolveMergedOptions(i) : i.type,
    $forceUpdate: (i)=>i.f || (i.f = ()=>queueJob(i.update)),
    $nextTick: (i)=>i.n || (i.n = nextTick.bind(i.proxy)),
    $watch: (i)=>__VUE_OPTIONS_API__ ? instanceWatch.bind(i) : (0, _shared.NOOP)
});
const isReservedPrefix = (key)=>key === "_" || key === "$";
const hasSetupBinding = (state, key)=>state !== (0, _shared.EMPTY_OBJ) && !state.__isScriptSetup && (0, _shared.hasOwn)(state, key);
const PublicInstanceProxyHandlers = {
    get ({ _: instance }, key) {
        const { ctx, setupState, data, props, accessCache, type, appContext } = instance;
        if (key === "__isVue") return true;
        let normalizedProps;
        if (key[0] !== "$") {
            const n = accessCache[key];
            if (n !== void 0) switch(n){
                case 1 /* SETUP */ :
                    return setupState[key];
                case 2 /* DATA */ :
                    return data[key];
                case 4 /* CONTEXT */ :
                    return ctx[key];
                case 3 /* PROPS */ :
                    return props[key];
            }
            else if (hasSetupBinding(setupState, key)) {
                accessCache[key] = 1 /* SETUP */ ;
                return setupState[key];
            } else if (data !== (0, _shared.EMPTY_OBJ) && (0, _shared.hasOwn)(data, key)) {
                accessCache[key] = 2 /* DATA */ ;
                return data[key];
            } else if (// only cache other properties when instance has declared (thus stable)
            // props
            (normalizedProps = instance.propsOptions[0]) && (0, _shared.hasOwn)(normalizedProps, key)) {
                accessCache[key] = 3 /* PROPS */ ;
                return props[key];
            } else if (ctx !== (0, _shared.EMPTY_OBJ) && (0, _shared.hasOwn)(ctx, key)) {
                accessCache[key] = 4 /* CONTEXT */ ;
                return ctx[key];
            } else if (!__VUE_OPTIONS_API__ || shouldCacheAccess) accessCache[key] = 0 /* OTHER */ ;
        }
        const publicGetter = publicPropertiesMap[key];
        let cssModule, globalProperties;
        if (publicGetter) {
            if (key === "$attrs") {
                (0, _reactivity.track)(instance, "get", key);
                markAttrsAccessed();
            } else if (key === "$slots") (0, _reactivity.track)(instance, "get", key);
            return publicGetter(instance);
        } else if (// css module (injected by vue-loader)
        (cssModule = type.__cssModules) && (cssModule = cssModule[key])) return cssModule;
        else if (ctx !== (0, _shared.EMPTY_OBJ) && (0, _shared.hasOwn)(ctx, key)) {
            accessCache[key] = 4 /* CONTEXT */ ;
            return ctx[key];
        } else if (// global properties
        globalProperties = appContext.config.globalProperties, (0, _shared.hasOwn)(globalProperties, key)) return globalProperties[key];
        else if (currentRenderingInstance && (!(0, _shared.isString)(key) || // #1091 avoid internal isRef/isVNode checks on component instance leading
        // to infinite warning loop
        key.indexOf("__v") !== 0)) {
            if (data !== (0, _shared.EMPTY_OBJ) && isReservedPrefix(key[0]) && (0, _shared.hasOwn)(data, key)) warn(`Property ${JSON.stringify(key)} must be accessed via $data because it starts with a reserved character ("$" or "_") and is not proxied on the render context.`);
            else if (instance === currentRenderingInstance) warn(`Property ${JSON.stringify(key)} was accessed during render but is not defined on instance.`);
        }
    },
    set ({ _: instance }, key, value1) {
        const { data, setupState, ctx } = instance;
        if (hasSetupBinding(setupState, key)) {
            setupState[key] = value1;
            return true;
        } else if ((0, setupState.__isScriptSetup) && (0, _shared.hasOwn)(setupState, key)) {
            warn(`Cannot mutate <script setup> binding "${key}" from Options API.`);
            return false;
        } else if (data !== (0, _shared.EMPTY_OBJ) && (0, _shared.hasOwn)(data, key)) {
            data[key] = value1;
            return true;
        } else if ((0, _shared.hasOwn)(instance.props, key)) {
            warn(`Attempting to mutate prop "${key}". Props are readonly.`);
            return false;
        }
        if (key[0] === "$" && key.slice(1) in instance) {
            warn(`Attempting to mutate public property "${key}". Properties starting with $ are reserved and readonly.`);
            return false;
        } else if (key in instance.appContext.config.globalProperties) Object.defineProperty(ctx, key, {
            enumerable: true,
            configurable: true,
            value: value1
        });
        else ctx[key] = value1;
        return true;
    },
    has ({ _: { data, setupState, accessCache, ctx, appContext, propsOptions } }, key) {
        let normalizedProps;
        return !!accessCache[key] || data !== (0, _shared.EMPTY_OBJ) && (0, _shared.hasOwn)(data, key) || hasSetupBinding(setupState, key) || (normalizedProps = propsOptions[0]) && (0, _shared.hasOwn)(normalizedProps, key) || (0, _shared.hasOwn)(ctx, key) || (0, _shared.hasOwn)(publicPropertiesMap, key) || (0, _shared.hasOwn)(appContext.config.globalProperties, key);
    },
    defineProperty (target, key, descriptor) {
        if (descriptor.get != null) target._.accessCache[key] = 0;
        else if ((0, _shared.hasOwn)(descriptor, "value")) this.set(target, key, descriptor.value, null);
        return Reflect.defineProperty(target, key, descriptor);
    }
};
PublicInstanceProxyHandlers.ownKeys = (target)=>{
    warn(`Avoid app logic that relies on enumerating keys on a component instance. The keys will be empty in production mode to avoid performance overhead.`);
    return Reflect.ownKeys(target);
};
const RuntimeCompiledPublicInstanceProxyHandlers = /* @__PURE__ */ (0, _shared.extend)({}, PublicInstanceProxyHandlers, {
    get (target, key) {
        if (key === Symbol.unscopables) return;
        return PublicInstanceProxyHandlers.get(target, key, target);
    },
    has (_, key) {
        const has = key[0] !== "_" && !(0, _shared.isGloballyWhitelisted)(key);
        if (!has && PublicInstanceProxyHandlers.has(_, key)) warn(`Property ${JSON.stringify(key)} should not start with _ which is a reserved prefix for Vue internals.`);
        return has;
    }
});
function createDevRenderContext(instance) {
    const target = {};
    Object.defineProperty(target, `_`, {
        configurable: true,
        enumerable: false,
        get: ()=>instance
    });
    Object.keys(publicPropertiesMap).forEach((key)=>{
        Object.defineProperty(target, key, {
            configurable: true,
            enumerable: false,
            get: ()=>publicPropertiesMap[key](instance),
            // intercepted by the proxy so no need for implementation,
            // but needed to prevent set errors
            set: (0, _shared.NOOP)
        });
    });
    return target;
}
function exposePropsOnRenderContext(instance) {
    const { ctx, propsOptions: [propsOptions] } = instance;
    if (propsOptions) Object.keys(propsOptions).forEach((key)=>{
        Object.defineProperty(ctx, key, {
            enumerable: true,
            configurable: true,
            get: ()=>instance.props[key],
            set: (0, _shared.NOOP)
        });
    });
}
function exposeSetupStateOnRenderContext(instance) {
    const { ctx, setupState } = instance;
    Object.keys((0, _reactivity.toRaw)(setupState)).forEach((key)=>{
        if (!setupState.__isScriptSetup) {
            if (isReservedPrefix(key[0])) {
                warn(`setup() return property ${JSON.stringify(key)} should not start with "$" or "_" which are reserved prefixes for Vue internals.`);
                return;
            }
            Object.defineProperty(ctx, key, {
                enumerable: true,
                configurable: true,
                get: ()=>setupState[key],
                set: (0, _shared.NOOP)
            });
        }
    });
}
const warnRuntimeUsage = (method)=>warn(`${method}() is a compiler-hint helper that is only usable inside <script setup> of a single file component. Its arguments should be compiled away and passing it at runtime has no effect.`);
function defineProps() {
    warnRuntimeUsage(`defineProps`);
    return null;
}
function defineEmits() {
    warnRuntimeUsage(`defineEmits`);
    return null;
}
function defineExpose(exposed) {
    warnRuntimeUsage(`defineExpose`);
}
function defineOptions(options) {
    warnRuntimeUsage(`defineOptions`);
}
function defineSlots() {
    warnRuntimeUsage(`defineSlots`);
    return null;
}
function defineModel() {
    warnRuntimeUsage("defineModel");
}
function withDefaults(props, defaults) {
    warnRuntimeUsage(`withDefaults`);
    return null;
}
function useSlots() {
    return getContext().slots;
}
function useAttrs() {
    return getContext().attrs;
}
function useModel(props, name, options) {
    const i = getCurrentInstance();
    if (!i) {
        warn(`useModel() called without active instance.`);
        return (0, _reactivity.ref)();
    }
    if (!i.propsOptions[0][name]) {
        warn(`useModel() called with prop "${name}" which is not declared.`);
        return (0, _reactivity.ref)();
    }
    if (options && options.local) {
        const proxy = (0, _reactivity.ref)(props[name]);
        watch(()=>props[name], (v1)=>proxy.value = v1);
        watch(proxy, (value1)=>{
            if (value1 !== props[name]) i.emit(`update:${name}`, value1);
        });
        return proxy;
    } else return {
        __v_isRef: true,
        get value () {
            return props[name];
        },
        set value (value){
            i.emit(`update:${name}`, value);
        }
    };
}
function getContext() {
    const i = getCurrentInstance();
    if (!i) warn(`useContext() called without active instance.`);
    return i.setupContext || (i.setupContext = createSetupContext(i));
}
function normalizePropsOrEmits(props) {
    return (0, _shared.isArray)(props) ? props.reduce((normalized, p)=>(normalized[p] = null, normalized), {}) : props;
}
function mergeDefaults(raw, defaults) {
    const props = normalizePropsOrEmits(raw);
    for(const key in defaults){
        if (key.startsWith("__skip")) continue;
        let opt = props[key];
        if (opt) {
            if ((0, _shared.isArray)(opt) || (0, _shared.isFunction)(opt)) opt = props[key] = {
                type: opt,
                default: defaults[key]
            };
            else opt.default = defaults[key];
        } else if (opt === null) opt = props[key] = {
            default: defaults[key]
        };
        else warn(`props default key "${key}" has no corresponding declaration.`);
        if (opt && defaults[`__skip_${key}`]) opt.skipFactory = true;
    }
    return props;
}
function mergeModels(a, b) {
    if (!a || !b) return a || b;
    if ((0, _shared.isArray)(a) && (0, _shared.isArray)(b)) return a.concat(b);
    return (0, _shared.extend)({}, normalizePropsOrEmits(a), normalizePropsOrEmits(b));
}
function createPropsRestProxy(props, excludedKeys) {
    const ret = {};
    for(const key in props)if (!excludedKeys.includes(key)) Object.defineProperty(ret, key, {
        enumerable: true,
        get: ()=>props[key]
    });
    return ret;
}
function withAsyncContext(getAwaitable) {
    const ctx = getCurrentInstance();
    if (!ctx) warn(`withAsyncContext called without active current instance. This is likely a bug.`);
    let awaitable = getAwaitable();
    unsetCurrentInstance();
    if ((0, _shared.isPromise)(awaitable)) awaitable = awaitable.catch((e)=>{
        setCurrentInstance(ctx);
        throw e;
    });
    return [
        awaitable,
        ()=>setCurrentInstance(ctx)
    ];
}
function createDuplicateChecker() {
    const cache = /* @__PURE__ */ Object.create(null);
    return (type, key)=>{
        if (cache[key]) warn(`${type} property "${key}" is already defined in ${cache[key]}.`);
        else cache[key] = type;
    };
}
let shouldCacheAccess = true;
function applyOptions(instance) {
    const options = resolveMergedOptions(instance);
    const publicThis = instance.proxy;
    const ctx = instance.ctx;
    shouldCacheAccess = false;
    if (options.beforeCreate) callHook(options.beforeCreate, instance, "bc");
    const { // state
    data: dataOptions, computed: computedOptions, methods, watch: watchOptions, provide: provideOptions, inject: injectOptions, // lifecycle
    created, beforeMount, mounted, beforeUpdate, updated, activated, deactivated, beforeDestroy, beforeUnmount, destroyed, unmounted, render, renderTracked, renderTriggered, errorCaptured, serverPrefetch, // public API
    expose, inheritAttrs, // assets
    components, directives, filters } = options;
    const checkDuplicateProperties = createDuplicateChecker();
    {
        const [propsOptions] = instance.propsOptions;
        if (propsOptions) for(const key in propsOptions)checkDuplicateProperties("Props" /* PROPS */ , key);
    }
    if (injectOptions) resolveInjections(injectOptions, ctx, checkDuplicateProperties);
    if (methods) for(const key in methods){
        const methodHandler = methods[key];
        if ((0, _shared.isFunction)(methodHandler)) {
            Object.defineProperty(ctx, key, {
                value: methodHandler.bind(publicThis),
                configurable: true,
                enumerable: true,
                writable: true
            });
            checkDuplicateProperties("Methods" /* METHODS */ , key);
        } else warn(`Method "${key}" has type "${typeof methodHandler}" in the component definition. Did you reference the function correctly?`);
    }
    if (dataOptions) {
        if (!(0, _shared.isFunction)(dataOptions)) warn(`The data option must be a function. Plain object usage is no longer supported.`);
        const data = dataOptions.call(publicThis, publicThis);
        if ((0, _shared.isPromise)(data)) warn(`data() returned a Promise - note data() cannot be async; If you intend to perform data fetching before component renders, use async setup() + <Suspense>.`);
        if (!(0, _shared.isObject)(data)) warn(`data() should return an object.`);
        else {
            instance.data = (0, _reactivity.reactive)(data);
            for(const key in data){
                checkDuplicateProperties("Data" /* DATA */ , key);
                if (!isReservedPrefix(key[0])) Object.defineProperty(ctx, key, {
                    configurable: true,
                    enumerable: true,
                    get: ()=>data[key],
                    set: (0, _shared.NOOP)
                });
            }
        }
    }
    shouldCacheAccess = true;
    if (computedOptions) for(const key in computedOptions){
        const opt = computedOptions[key];
        const get = (0, _shared.isFunction)(opt) ? opt.bind(publicThis, publicThis) : (0, _shared.isFunction)(opt.get) ? opt.get.bind(publicThis, publicThis) : (0, _shared.NOOP);
        if (get === (0, _shared.NOOP)) warn(`Computed property "${key}" has no getter.`);
        const set = !(0, _shared.isFunction)(opt) && (0, _shared.isFunction)(opt.set) ? opt.set.bind(publicThis) : ()=>{
            warn(`Write operation failed: computed property "${key}" is readonly.`);
        };
        const c = computed({
            get,
            set
        });
        Object.defineProperty(ctx, key, {
            enumerable: true,
            configurable: true,
            get: ()=>c.value,
            set: (v1)=>c.value = v1
        });
        checkDuplicateProperties("Computed" /* COMPUTED */ , key);
    }
    if (watchOptions) for(const key in watchOptions)createWatcher(watchOptions[key], ctx, publicThis, key);
    if (provideOptions) {
        const provides = (0, _shared.isFunction)(provideOptions) ? provideOptions.call(publicThis) : provideOptions;
        Reflect.ownKeys(provides).forEach((key)=>{
            provide(key, provides[key]);
        });
    }
    if (created) callHook(created, instance, "c");
    function registerLifecycleHook(register, hook) {
        if ((0, _shared.isArray)(hook)) hook.forEach((_hook)=>register(_hook.bind(publicThis)));
        else if (hook) register(hook.bind(publicThis));
    }
    registerLifecycleHook(onBeforeMount, beforeMount);
    registerLifecycleHook(onMounted, mounted);
    registerLifecycleHook(onBeforeUpdate, beforeUpdate);
    registerLifecycleHook(onUpdated, updated);
    registerLifecycleHook(onActivated, activated);
    registerLifecycleHook(onDeactivated, deactivated);
    registerLifecycleHook(onErrorCaptured, errorCaptured);
    registerLifecycleHook(onRenderTracked, renderTracked);
    registerLifecycleHook(onRenderTriggered, renderTriggered);
    registerLifecycleHook(onBeforeUnmount, beforeUnmount);
    registerLifecycleHook(onUnmounted, unmounted);
    registerLifecycleHook(onServerPrefetch, serverPrefetch);
    if ((0, _shared.isArray)(expose)) {
        if (expose.length) {
            const exposed = instance.exposed || (instance.exposed = {});
            expose.forEach((key)=>{
                Object.defineProperty(exposed, key, {
                    get: ()=>publicThis[key],
                    set: (val)=>publicThis[key] = val
                });
            });
        } else if (!instance.exposed) instance.exposed = {};
    }
    if (render && instance.render === (0, _shared.NOOP)) instance.render = render;
    if (inheritAttrs != null) instance.inheritAttrs = inheritAttrs;
    if (components) instance.components = components;
    if (directives) instance.directives = directives;
}
function resolveInjections(injectOptions, ctx, checkDuplicateProperties = (0, _shared.NOOP)) {
    if ((0, _shared.isArray)(injectOptions)) injectOptions = normalizeInject(injectOptions);
    for(const key in injectOptions){
        const opt = injectOptions[key];
        let injected;
        if ((0, _shared.isObject)(opt)) {
            if ("default" in opt) injected = inject(opt.from || key, opt.default, true);
            else injected = inject(opt.from || key);
        } else injected = inject(opt);
        if ((0, _reactivity.isRef)(injected)) Object.defineProperty(ctx, key, {
            enumerable: true,
            configurable: true,
            get: ()=>injected.value,
            set: (v1)=>injected.value = v1
        });
        else ctx[key] = injected;
        checkDuplicateProperties("Inject" /* INJECT */ , key);
    }
}
function callHook(hook, instance, type) {
    callWithAsyncErrorHandling((0, _shared.isArray)(hook) ? hook.map((h)=>h.bind(instance.proxy)) : hook.bind(instance.proxy), instance, type);
}
function createWatcher(raw, ctx, publicThis, key) {
    const getter = key.includes(".") ? createPathGetter(publicThis, key) : ()=>publicThis[key];
    if ((0, _shared.isString)(raw)) {
        const handler = ctx[raw];
        if ((0, _shared.isFunction)(handler)) watch(getter, handler);
        else warn(`Invalid watch handler specified by key "${raw}"`, handler);
    } else if ((0, _shared.isFunction)(raw)) watch(getter, raw.bind(publicThis));
    else if ((0, _shared.isObject)(raw)) {
        if ((0, _shared.isArray)(raw)) raw.forEach((r)=>createWatcher(r, ctx, publicThis, key));
        else {
            const handler = (0, _shared.isFunction)(raw.handler) ? raw.handler.bind(publicThis) : ctx[raw.handler];
            if ((0, _shared.isFunction)(handler)) watch(getter, handler, raw);
            else warn(`Invalid watch handler specified by key "${raw.handler}"`, handler);
        }
    } else warn(`Invalid watch option: "${key}"`, raw);
}
function resolveMergedOptions(instance) {
    const base = instance.type;
    const { mixins, extends: extendsOptions } = base;
    const { mixins: globalMixins, optionsCache: cache, config: { optionMergeStrategies } } = instance.appContext;
    const cached = cache.get(base);
    let resolved;
    if (cached) resolved = cached;
    else if (!globalMixins.length && !mixins && !extendsOptions) resolved = base;
    else {
        resolved = {};
        if (globalMixins.length) globalMixins.forEach((m)=>mergeOptions(resolved, m, optionMergeStrategies, true));
        mergeOptions(resolved, base, optionMergeStrategies);
    }
    if ((0, _shared.isObject)(base)) cache.set(base, resolved);
    return resolved;
}
function mergeOptions(to, from, strats, asMixin = false) {
    const { mixins, extends: extendsOptions } = from;
    if (extendsOptions) mergeOptions(to, extendsOptions, strats, true);
    if (mixins) mixins.forEach((m)=>mergeOptions(to, m, strats, true));
    for(const key in from)if (asMixin && key === "expose") warn(`"expose" option is ignored when declared in mixins or extends. It should only be declared in the base component itself.`);
    else {
        const strat = internalOptionMergeStrats[key] || strats && strats[key];
        to[key] = strat ? strat(to[key], from[key]) : from[key];
    }
    return to;
}
const internalOptionMergeStrats = {
    data: mergeDataFn,
    props: mergeEmitsOrPropsOptions,
    emits: mergeEmitsOrPropsOptions,
    // objects
    methods: mergeObjectOptions,
    computed: mergeObjectOptions,
    // lifecycle
    beforeCreate: mergeAsArray,
    created: mergeAsArray,
    beforeMount: mergeAsArray,
    mounted: mergeAsArray,
    beforeUpdate: mergeAsArray,
    updated: mergeAsArray,
    beforeDestroy: mergeAsArray,
    beforeUnmount: mergeAsArray,
    destroyed: mergeAsArray,
    unmounted: mergeAsArray,
    activated: mergeAsArray,
    deactivated: mergeAsArray,
    errorCaptured: mergeAsArray,
    serverPrefetch: mergeAsArray,
    // assets
    components: mergeObjectOptions,
    directives: mergeObjectOptions,
    // watch
    watch: mergeWatchOptions,
    // provide / inject
    provide: mergeDataFn,
    inject: mergeInject
};
function mergeDataFn(to, from) {
    if (!from) return to;
    if (!to) return from;
    return function mergedDataFn() {
        return (0, _shared.extend)((0, _shared.isFunction)(to) ? to.call(this, this) : to, (0, _shared.isFunction)(from) ? from.call(this, this) : from);
    };
}
function mergeInject(to, from) {
    return mergeObjectOptions(normalizeInject(to), normalizeInject(from));
}
function normalizeInject(raw) {
    if ((0, _shared.isArray)(raw)) {
        const res = {};
        for(let i = 0; i < raw.length; i++)res[raw[i]] = raw[i];
        return res;
    }
    return raw;
}
function mergeAsArray(to, from) {
    return to ? [
        ...new Set([].concat(to, from))
    ] : from;
}
function mergeObjectOptions(to, from) {
    return to ? (0, _shared.extend)(/* @__PURE__ */ Object.create(null), to, from) : from;
}
function mergeEmitsOrPropsOptions(to, from) {
    if (to) {
        if ((0, _shared.isArray)(to) && (0, _shared.isArray)(from)) return [
            .../* @__PURE__ */ new Set([
                ...to,
                ...from
            ])
        ];
        return (0, _shared.extend)(/* @__PURE__ */ Object.create(null), normalizePropsOrEmits(to), normalizePropsOrEmits(from != null ? from : {}));
    } else return from;
}
function mergeWatchOptions(to, from) {
    if (!to) return from;
    if (!from) return to;
    const merged = (0, _shared.extend)(/* @__PURE__ */ Object.create(null), to);
    for(const key in from)merged[key] = mergeAsArray(to[key], from[key]);
    return merged;
}
function createAppContext() {
    return {
        app: null,
        config: {
            isNativeTag: (0, _shared.NO),
            performance: false,
            globalProperties: {},
            optionMergeStrategies: {},
            errorHandler: void 0,
            warnHandler: void 0,
            compilerOptions: {}
        },
        mixins: [],
        components: {},
        directives: {},
        provides: /* @__PURE__ */ Object.create(null),
        optionsCache: /* @__PURE__ */ new WeakMap(),
        propsCache: /* @__PURE__ */ new WeakMap(),
        emitsCache: /* @__PURE__ */ new WeakMap()
    };
}
let uid$1 = 0;
function createAppAPI(render, hydrate) {
    return function createApp(rootComponent, rootProps = null) {
        if (!(0, _shared.isFunction)(rootComponent)) rootComponent = (0, _shared.extend)({}, rootComponent);
        if (rootProps != null && !(0, _shared.isObject)(rootProps)) {
            warn(`root props passed to app.mount() must be an object.`);
            rootProps = null;
        }
        const context = createAppContext();
        Object.defineProperty(context.config, "unwrapInjectedRef", {
            get () {
                return true;
            },
            set () {
                warn(`app.config.unwrapInjectedRef has been deprecated. 3.3 now alawys unwraps injected refs in Options API.`);
            }
        });
        const installedPlugins = /* @__PURE__ */ new Set();
        let isMounted = false;
        const app = context.app = {
            _uid: uid$1++,
            _component: rootComponent,
            _props: rootProps,
            _container: null,
            _context: context,
            _instance: null,
            version,
            get config () {
                return context.config;
            },
            set config (v){
                warn(`app.config cannot be replaced. Modify individual options instead.`);
            },
            use (plugin, ...options) {
                if (installedPlugins.has(plugin)) warn(`Plugin has already been applied to target app.`);
                else if (plugin && (0, _shared.isFunction)(plugin.install)) {
                    installedPlugins.add(plugin);
                    plugin.install(app, ...options);
                } else if ((0, _shared.isFunction)(plugin)) {
                    installedPlugins.add(plugin);
                    plugin(app, ...options);
                } else warn(`A plugin must either be a function or an object with an "install" function.`);
                return app;
            },
            mixin (mixin) {
                if (__VUE_OPTIONS_API__) {
                    if (!context.mixins.includes(mixin)) context.mixins.push(mixin);
                    else warn("Mixin has already been applied to target app" + (mixin.name ? `: ${mixin.name}` : ""));
                } else warn("Mixins are only available in builds supporting Options API");
                return app;
            },
            component (name, component) {
                validateComponentName(name, context.config);
                if (!component) return context.components[name];
                if (0, context.components[name]) warn(`Component "${name}" has already been registered in target app.`);
                context.components[name] = component;
                return app;
            },
            directive (name, directive) {
                validateDirectiveName(name);
                if (!directive) return context.directives[name];
                if (0, context.directives[name]) warn(`Directive "${name}" has already been registered in target app.`);
                context.directives[name] = directive;
                return app;
            },
            mount (rootContainer, isHydrate, isSVG) {
                if (!isMounted) {
                    if (0, rootContainer.__vue_app__) warn(`There is already an app instance mounted on the host container.
 If you want to mount another app on the same host container, you need to unmount the previous app by calling \`app.unmount()\` first.`);
                    const vnode = createVNode(rootComponent, rootProps);
                    vnode.appContext = context;
                    context.reload = ()=>{
                        render(cloneVNode(vnode), rootContainer, isSVG);
                    };
                    if (isHydrate && hydrate) hydrate(vnode, rootContainer);
                    else render(vnode, rootContainer, isSVG);
                    isMounted = true;
                    app._container = rootContainer;
                    rootContainer.__vue_app__ = app;
                    app._instance = vnode.component;
                    devtoolsInitApp(app, version);
                    return getExposeProxy(vnode.component) || vnode.component.proxy;
                } else warn(`App has already been mounted.
If you want to remount the same app, move your app creation logic into a factory function and create fresh app instances for each mount - e.g. \`const createMyApp = () => createApp(App)\``);
            },
            unmount () {
                if (isMounted) {
                    render(null, app._container);
                    app._instance = null;
                    devtoolsUnmountApp(app);
                    delete app._container.__vue_app__;
                } else warn(`Cannot unmount an app that is not mounted.`);
            },
            provide (key, value1) {
                if (key in context.provides) warn(`App already provides property with key "${String(key)}". It will be overwritten with the new value.`);
                context.provides[key] = value1;
                return app;
            },
            runWithContext (fn) {
                currentApp = app;
                try {
                    return fn();
                } finally{
                    currentApp = null;
                }
            }
        };
        return app;
    };
}
let currentApp = null;
function provide(key, value1) {
    if (!currentInstance) warn(`provide() can only be used inside setup().`);
    else {
        let provides = currentInstance.provides;
        const parentProvides = currentInstance.parent && currentInstance.parent.provides;
        if (parentProvides === provides) provides = currentInstance.provides = Object.create(parentProvides);
        provides[key] = value1;
    }
}
function inject(key, defaultValue, treatDefaultAsFactory = false) {
    const instance = currentInstance || currentRenderingInstance;
    if (instance || currentApp) {
        const provides = instance ? instance.parent == null ? instance.vnode.appContext && instance.vnode.appContext.provides : instance.parent.provides : currentApp._context.provides;
        if (provides && key in provides) return provides[key];
        else if (arguments.length > 1) return treatDefaultAsFactory && (0, _shared.isFunction)(defaultValue) ? defaultValue.call(instance && instance.proxy) : defaultValue;
        else warn(`injection "${String(key)}" not found.`);
    } else warn(`inject() can only be used inside setup() or functional components.`);
}
function hasInjectionContext() {
    return !!(currentInstance || currentRenderingInstance || currentApp);
}
function initProps(instance, rawProps, isStateful, isSSR = false) {
    const props = {};
    const attrs = {};
    (0, _shared.def)(attrs, InternalObjectKey, 1);
    instance.propsDefaults = /* @__PURE__ */ Object.create(null);
    setFullProps(instance, rawProps, props, attrs);
    for(const key in instance.propsOptions[0])if (!(key in props)) props[key] = void 0;
    validateProps(rawProps || {}, props, instance);
    if (isStateful) instance.props = isSSR ? props : (0, _reactivity.shallowReactive)(props);
    else if (!instance.type.props) instance.props = attrs;
    else instance.props = props;
    instance.attrs = attrs;
}
function isInHmrContext(instance) {
    while(instance){
        if (instance.type.__hmrId) return true;
        instance = instance.parent;
    }
}
function updateProps(instance, rawProps, rawPrevProps, optimized) {
    const { props, attrs, vnode: { patchFlag } } = instance;
    const rawCurrentProps = (0, _reactivity.toRaw)(props);
    const [options] = instance.propsOptions;
    let hasAttrsChanged = false;
    if (// always force full diff in dev
    // - #1942 if hmr is enabled with sfc component
    // - vite#872 non-sfc component used by sfc component
    !isInHmrContext(instance) && (optimized || patchFlag > 0) && !(patchFlag & 16)) {
        if (patchFlag & 8) {
            const propsToUpdate = instance.vnode.dynamicProps;
            for(let i = 0; i < propsToUpdate.length; i++){
                let key = propsToUpdate[i];
                if (isEmitListener(instance.emitsOptions, key)) continue;
                const value1 = rawProps[key];
                if (options) {
                    if ((0, _shared.hasOwn)(attrs, key)) {
                        if (value1 !== attrs[key]) {
                            attrs[key] = value1;
                            hasAttrsChanged = true;
                        }
                    } else {
                        const camelizedKey = (0, _shared.camelize)(key);
                        props[camelizedKey] = resolvePropValue(options, rawCurrentProps, camelizedKey, value1, instance, false);
                    }
                } else if (value1 !== attrs[key]) {
                    attrs[key] = value1;
                    hasAttrsChanged = true;
                }
            }
        }
    } else {
        if (setFullProps(instance, rawProps, props, attrs)) hasAttrsChanged = true;
        let kebabKey;
        for(const key in rawCurrentProps)if (!rawProps || // for camelCase
        !(0, _shared.hasOwn)(rawProps, key) && // it's possible the original props was passed in as kebab-case
        // and converted to camelCase (#955)
        ((kebabKey = (0, _shared.hyphenate)(key)) === key || !(0, _shared.hasOwn)(rawProps, kebabKey))) {
            if (options) {
                if (rawPrevProps && // for camelCase
                (rawPrevProps[key] !== void 0 || // for kebab-case
                rawPrevProps[kebabKey] !== void 0)) props[key] = resolvePropValue(options, rawCurrentProps, key, void 0, instance, true);
            } else delete props[key];
        }
        if (attrs !== rawCurrentProps) {
            for(const key in attrs)if (!rawProps || !(0, _shared.hasOwn)(rawProps, key) && true) {
                delete attrs[key];
                hasAttrsChanged = true;
            }
        }
    }
    if (hasAttrsChanged) (0, _reactivity.trigger)(instance, "set", "$attrs");
    validateProps(rawProps || {}, props, instance);
}
function setFullProps(instance, rawProps, props, attrs) {
    const [options, needCastKeys] = instance.propsOptions;
    let hasAttrsChanged = false;
    let rawCastValues;
    if (rawProps) for(let key in rawProps){
        if ((0, _shared.isReservedProp)(key)) continue;
        const value1 = rawProps[key];
        let camelKey;
        if (options && (0, _shared.hasOwn)(options, camelKey = (0, _shared.camelize)(key))) {
            if (!needCastKeys || !needCastKeys.includes(camelKey)) props[camelKey] = value1;
            else (rawCastValues || (rawCastValues = {}))[camelKey] = value1;
        } else if (!isEmitListener(instance.emitsOptions, key)) {
            if (!(key in attrs) || value1 !== attrs[key]) {
                attrs[key] = value1;
                hasAttrsChanged = true;
            }
        }
    }
    if (needCastKeys) {
        const rawCurrentProps = (0, _reactivity.toRaw)(props);
        const castValues = rawCastValues || (0, _shared.EMPTY_OBJ);
        for(let i = 0; i < needCastKeys.length; i++){
            const key = needCastKeys[i];
            props[key] = resolvePropValue(options, rawCurrentProps, key, castValues[key], instance, !(0, _shared.hasOwn)(castValues, key));
        }
    }
    return hasAttrsChanged;
}
function resolvePropValue(options, props, key, value1, instance, isAbsent) {
    const opt = options[key];
    if (opt != null) {
        const hasDefault = (0, _shared.hasOwn)(opt, "default");
        if (hasDefault && value1 === void 0) {
            const defaultValue = opt.default;
            if (opt.type !== Function && !opt.skipFactory && (0, _shared.isFunction)(defaultValue)) {
                const { propsDefaults } = instance;
                if (key in propsDefaults) value1 = propsDefaults[key];
                else {
                    setCurrentInstance(instance);
                    value1 = propsDefaults[key] = defaultValue.call(null, props);
                    unsetCurrentInstance();
                }
            } else value1 = defaultValue;
        }
        if (opt[0 /* shouldCast */ ]) {
            if (isAbsent && !hasDefault) value1 = false;
            else if (opt[1 /* shouldCastTrue */ ] && (value1 === "" || value1 === (0, _shared.hyphenate)(key))) value1 = true;
        }
    }
    return value1;
}
function normalizePropsOptions(comp, appContext, asMixin = false) {
    const cache = appContext.propsCache;
    const cached = cache.get(comp);
    if (cached) return cached;
    const raw = comp.props;
    const normalized = {};
    const needCastKeys = [];
    let hasExtends = false;
    if (__VUE_OPTIONS_API__ && !(0, _shared.isFunction)(comp)) {
        const extendProps = (raw2)=>{
            hasExtends = true;
            const [props, keys] = normalizePropsOptions(raw2, appContext, true);
            (0, _shared.extend)(normalized, props);
            if (keys) needCastKeys.push(...keys);
        };
        if (!asMixin && appContext.mixins.length) appContext.mixins.forEach(extendProps);
        if (comp.extends) extendProps(comp.extends);
        if (comp.mixins) comp.mixins.forEach(extendProps);
    }
    if (!raw && !hasExtends) {
        if ((0, _shared.isObject)(comp)) cache.set(comp, (0, _shared.EMPTY_ARR));
        return 0, _shared.EMPTY_ARR;
    }
    if ((0, _shared.isArray)(raw)) for(let i = 0; i < raw.length; i++){
        if (!(0, _shared.isString)(raw[i])) warn(`props must be strings when using array syntax.`, raw[i]);
        const normalizedKey = (0, _shared.camelize)(raw[i]);
        if (validatePropName(normalizedKey)) normalized[normalizedKey] = (0, _shared.EMPTY_OBJ);
    }
    else if (raw) {
        if (!(0, _shared.isObject)(raw)) warn(`invalid props options`, raw);
        for(const key in raw){
            const normalizedKey = (0, _shared.camelize)(key);
            if (validatePropName(normalizedKey)) {
                const opt = raw[key];
                const prop = normalized[normalizedKey] = (0, _shared.isArray)(opt) || (0, _shared.isFunction)(opt) ? {
                    type: opt
                } : (0, _shared.extend)({}, opt);
                if (prop) {
                    const booleanIndex = getTypeIndex(Boolean, prop.type);
                    const stringIndex = getTypeIndex(String, prop.type);
                    prop[0 /* shouldCast */ ] = booleanIndex > -1;
                    prop[1 /* shouldCastTrue */ ] = stringIndex < 0 || booleanIndex < stringIndex;
                    if (booleanIndex > -1 || (0, _shared.hasOwn)(prop, "default")) needCastKeys.push(normalizedKey);
                }
            }
        }
    }
    const res = [
        normalized,
        needCastKeys
    ];
    if ((0, _shared.isObject)(comp)) cache.set(comp, res);
    return res;
}
function validatePropName(key) {
    if (key[0] !== "$") return true;
    else warn(`Invalid prop name: "${key}" is a reserved property.`);
    return false;
}
function getType(ctor) {
    const match = ctor && ctor.toString().match(/^\s*(function|class) (\w+)/);
    return match ? match[2] : ctor === null ? "null" : "";
}
function isSameType(a, b) {
    return getType(a) === getType(b);
}
function getTypeIndex(type, expectedTypes) {
    if ((0, _shared.isArray)(expectedTypes)) return expectedTypes.findIndex((t)=>isSameType(t, type));
    else if ((0, _shared.isFunction)(expectedTypes)) return isSameType(expectedTypes, type) ? 0 : -1;
    return -1;
}
function validateProps(rawProps, props, instance) {
    const resolvedValues = (0, _reactivity.toRaw)(props);
    const options = instance.propsOptions[0];
    for(const key in options){
        let opt = options[key];
        if (opt == null) continue;
        validateProp(key, resolvedValues[key], opt, !(0, _shared.hasOwn)(rawProps, key) && !(0, _shared.hasOwn)(rawProps, (0, _shared.hyphenate)(key)));
    }
}
function validateProp(name, value1, prop, isAbsent) {
    const { type, required, validator, skipCheck } = prop;
    if (required && isAbsent) {
        warn('Missing required prop: "' + name + '"');
        return;
    }
    if (value1 == null && !required) return;
    if (type != null && type !== true && !skipCheck) {
        let isValid = false;
        const types = (0, _shared.isArray)(type) ? type : [
            type
        ];
        const expectedTypes = [];
        for(let i = 0; i < types.length && !isValid; i++){
            const { valid, expectedType } = assertType(value1, types[i]);
            expectedTypes.push(expectedType || "");
            isValid = valid;
        }
        if (!isValid) {
            warn(getInvalidTypeMessage(name, value1, expectedTypes));
            return;
        }
    }
    if (validator && !validator(value1)) warn('Invalid prop: custom validator check failed for prop "' + name + '".');
}
const isSimpleType = /* @__PURE__ */ (0, _shared.makeMap)("String,Number,Boolean,Function,Symbol,BigInt");
function assertType(value1, type) {
    let valid;
    const expectedType = getType(type);
    if (isSimpleType(expectedType)) {
        const t = typeof value1;
        valid = t === expectedType.toLowerCase();
        if (!valid && t === "object") valid = value1 instanceof type;
    } else if (expectedType === "Object") valid = (0, _shared.isObject)(value1);
    else if (expectedType === "Array") valid = (0, _shared.isArray)(value1);
    else if (expectedType === "null") valid = value1 === null;
    else valid = value1 instanceof type;
    return {
        valid,
        expectedType
    };
}
function getInvalidTypeMessage(name, value1, expectedTypes) {
    let message = `Invalid prop: type check failed for prop "${name}". Expected ${expectedTypes.map((0, _shared.capitalize)).join(" | ")}`;
    const expectedType = expectedTypes[0];
    const receivedType = (0, _shared.toRawType)(value1);
    const expectedValue = styleValue(value1, expectedType);
    const receivedValue = styleValue(value1, receivedType);
    if (expectedTypes.length === 1 && isExplicable(expectedType) && !isBoolean(expectedType, receivedType)) message += ` with value ${expectedValue}`;
    message += `, got ${receivedType} `;
    if (isExplicable(receivedType)) message += `with value ${receivedValue}.`;
    return message;
}
function styleValue(value1, type) {
    if (type === "String") return `"${value1}"`;
    else if (type === "Number") return `${Number(value1)}`;
    else return `${value1}`;
}
function isExplicable(type) {
    const explicitTypes = [
        "string",
        "number",
        "boolean"
    ];
    return explicitTypes.some((elem)=>type.toLowerCase() === elem);
}
function isBoolean(...args) {
    return args.some((elem)=>elem.toLowerCase() === "boolean");
}
const isInternalKey = (key)=>key[0] === "_" || key === "$stable";
const normalizeSlotValue = (value1)=>(0, _shared.isArray)(value1) ? value1.map(normalizeVNode) : [
        normalizeVNode(value1)
    ];
const normalizeSlot = (key, rawSlot, ctx)=>{
    if (rawSlot._n) return rawSlot;
    const normalized = withCtx((...args)=>{
        if (currentInstance) warn(`Slot "${key}" invoked outside of the render function: this will not track dependencies used in the slot. Invoke the slot function inside the render function instead.`);
        return normalizeSlotValue(rawSlot(...args));
    }, ctx);
    normalized._c = false;
    return normalized;
};
const normalizeObjectSlots = (rawSlots, slots, instance)=>{
    const ctx = rawSlots._ctx;
    for(const key in rawSlots){
        if (isInternalKey(key)) continue;
        const value1 = rawSlots[key];
        if ((0, _shared.isFunction)(value1)) slots[key] = normalizeSlot(key, value1, ctx);
        else if (value1 != null) {
            warn(`Non-function value encountered for slot "${key}". Prefer function slots for better performance.`);
            const normalized = normalizeSlotValue(value1);
            slots[key] = ()=>normalized;
        }
    }
};
const normalizeVNodeSlots = (instance, children)=>{
    if (!isKeepAlive(instance.vnode) && true) warn(`Non-function value encountered for default slot. Prefer function slots for better performance.`);
    const normalized = normalizeSlotValue(children);
    instance.slots.default = ()=>normalized;
};
const initSlots = (instance, children)=>{
    if (instance.vnode.shapeFlag & 32) {
        const type = children._;
        if (type) {
            instance.slots = (0, _reactivity.toRaw)(children);
            (0, _shared.def)(children, "_", type);
        } else normalizeObjectSlots(children, instance.slots = {});
    } else {
        instance.slots = {};
        if (children) normalizeVNodeSlots(instance, children);
    }
    (0, _shared.def)(instance.slots, InternalObjectKey, 1);
};
const updateSlots = (instance, children, optimized)=>{
    const { vnode, slots } = instance;
    let needDeletionCheck = true;
    let deletionComparisonTarget = (0, _shared.EMPTY_OBJ);
    if (vnode.shapeFlag & 32) {
        const type = children._;
        if (type) {
            if (isHmrUpdating) {
                (0, _shared.extend)(slots, children);
                (0, _reactivity.trigger)(instance, "set", "$slots");
            } else if (optimized && type === 1) needDeletionCheck = false;
            else {
                (0, _shared.extend)(slots, children);
                if (!optimized && type === 1) delete slots._;
            }
        } else {
            needDeletionCheck = !children.$stable;
            normalizeObjectSlots(children, slots);
        }
        deletionComparisonTarget = children;
    } else if (children) {
        normalizeVNodeSlots(instance, children);
        deletionComparisonTarget = {
            default: 1
        };
    }
    if (needDeletionCheck) {
        for(const key in slots)if (!isInternalKey(key) && !(key in deletionComparisonTarget)) delete slots[key];
    }
};
function setRef(rawRef, oldRawRef, parentSuspense, vnode, isUnmount = false) {
    if ((0, _shared.isArray)(rawRef)) {
        rawRef.forEach((r, i)=>setRef(r, oldRawRef && ((0, _shared.isArray)(oldRawRef) ? oldRawRef[i] : oldRawRef), parentSuspense, vnode, isUnmount));
        return;
    }
    if (isAsyncWrapper(vnode) && !isUnmount) return;
    const refValue = vnode.shapeFlag & 4 ? getExposeProxy(vnode.component) || vnode.component.proxy : vnode.el;
    const value1 = isUnmount ? null : refValue;
    const { i: owner, r: ref } = rawRef;
    if (!owner) {
        warn(`Missing ref owner context. ref cannot be used on hoisted vnodes. A vnode with ref must be created inside the render function.`);
        return;
    }
    const oldRef = oldRawRef && oldRawRef.r;
    const refs = owner.refs === (0, _shared.EMPTY_OBJ) ? owner.refs = {} : owner.refs;
    const setupState = owner.setupState;
    if (oldRef != null && oldRef !== ref) {
        if ((0, _shared.isString)(oldRef)) {
            refs[oldRef] = null;
            if ((0, _shared.hasOwn)(setupState, oldRef)) setupState[oldRef] = null;
        } else if ((0, _reactivity.isRef)(oldRef)) oldRef.value = null;
    }
    if ((0, _shared.isFunction)(ref)) callWithErrorHandling(ref, owner, 12, [
        value1,
        refs
    ]);
    else {
        const _isString = (0, _shared.isString)(ref);
        const _isRef = (0, _reactivity.isRef)(ref);
        if (_isString || _isRef) {
            const doSet = ()=>{
                if (rawRef.f) {
                    const existing = _isString ? (0, _shared.hasOwn)(setupState, ref) ? setupState[ref] : refs[ref] : ref.value;
                    if (isUnmount) (0, _shared.isArray)(existing) && (0, _shared.remove)(existing, refValue);
                    else {
                        if (!(0, _shared.isArray)(existing)) {
                            if (_isString) {
                                refs[ref] = [
                                    refValue
                                ];
                                if ((0, _shared.hasOwn)(setupState, ref)) setupState[ref] = refs[ref];
                            } else {
                                ref.value = [
                                    refValue
                                ];
                                if (rawRef.k) refs[rawRef.k] = ref.value;
                            }
                        } else if (!existing.includes(refValue)) existing.push(refValue);
                    }
                } else if (_isString) {
                    refs[ref] = value1;
                    if ((0, _shared.hasOwn)(setupState, ref)) setupState[ref] = value1;
                } else if (_isRef) {
                    ref.value = value1;
                    if (rawRef.k) refs[rawRef.k] = value1;
                } else warn("Invalid template ref type:", ref, `(${typeof ref})`);
            };
            if (value1) {
                doSet.id = -1;
                queuePostRenderEffect(doSet, parentSuspense);
            } else doSet();
        } else warn("Invalid template ref type:", ref, `(${typeof ref})`);
    }
}
let hasMismatch = false;
const isSVGContainer = (container)=>/svg/.test(container.namespaceURI) && container.tagName !== "foreignObject";
const isComment = (node)=>node.nodeType === 8 /* COMMENT */ ;
function createHydrationFunctions(rendererInternals) {
    const { mt: mountComponent, p: patch, o: { patchProp, createText, nextSibling, parentNode, remove, insert, createComment } } = rendererInternals;
    const hydrate = (vnode, container)=>{
        if (!container.hasChildNodes()) {
            warn(`Attempting to hydrate existing markup but container is empty. Performing full mount instead.`);
            patch(null, vnode, container);
            flushPostFlushCbs();
            container._vnode = vnode;
            return;
        }
        hasMismatch = false;
        hydrateNode(container.firstChild, vnode, null, null, null);
        flushPostFlushCbs();
        container._vnode = vnode;
        if (hasMismatch && true) console.error(`Hydration completed but contains mismatches.`);
    };
    const hydrateNode = (node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized = false)=>{
        const isFragmentStart = isComment(node) && node.data === "[";
        const onMismatch = ()=>handleMismatch(node, vnode, parentComponent, parentSuspense, slotScopeIds, isFragmentStart);
        const { type, ref, shapeFlag, patchFlag } = vnode;
        let domType = node.nodeType;
        vnode.el = node;
        if (patchFlag === -2) {
            optimized = false;
            vnode.dynamicChildren = null;
        }
        let nextNode = null;
        switch(type){
            case Text:
                if (domType !== 3 /* TEXT */ ) {
                    if (vnode.children === "") {
                        insert(vnode.el = createText(""), parentNode(node), node);
                        nextNode = node;
                    } else nextNode = onMismatch();
                } else {
                    if (node.data !== vnode.children) {
                        hasMismatch = true;
                        warn(`Hydration text mismatch:
- Client: ${JSON.stringify(node.data)}
- Server: ${JSON.stringify(vnode.children)}`);
                        node.data = vnode.children;
                    }
                    nextNode = nextSibling(node);
                }
                break;
            case Comment:
                if (domType !== 8 /* COMMENT */  || isFragmentStart) nextNode = onMismatch();
                else nextNode = nextSibling(node);
                break;
            case Static:
                if (isFragmentStart) {
                    node = nextSibling(node);
                    domType = node.nodeType;
                }
                if (domType === 1 /* ELEMENT */  || domType === 3 /* TEXT */ ) {
                    nextNode = node;
                    const needToAdoptContent = !vnode.children.length;
                    for(let i = 0; i < vnode.staticCount; i++){
                        if (needToAdoptContent) vnode.children += nextNode.nodeType === 1 /* ELEMENT */  ? nextNode.outerHTML : nextNode.data;
                        if (i === vnode.staticCount - 1) vnode.anchor = nextNode;
                        nextNode = nextSibling(nextNode);
                    }
                    return isFragmentStart ? nextSibling(nextNode) : nextNode;
                } else onMismatch();
                break;
            case Fragment:
                if (!isFragmentStart) nextNode = onMismatch();
                else nextNode = hydrateFragment(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized);
                break;
            default:
                if (shapeFlag & 1) {
                    if (domType !== 1 /* ELEMENT */  || vnode.type.toLowerCase() !== node.tagName.toLowerCase()) nextNode = onMismatch();
                    else nextNode = hydrateElement(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized);
                } else if (shapeFlag & 6) {
                    vnode.slotScopeIds = slotScopeIds;
                    const container = parentNode(node);
                    mountComponent(vnode, container, null, parentComponent, parentSuspense, isSVGContainer(container), optimized);
                    nextNode = isFragmentStart ? locateClosingAsyncAnchor(node) : nextSibling(node);
                    if (nextNode && isComment(nextNode) && nextNode.data === "teleport end") nextNode = nextSibling(nextNode);
                    if (isAsyncWrapper(vnode)) {
                        let subTree;
                        if (isFragmentStart) {
                            subTree = createVNode(Fragment);
                            subTree.anchor = nextNode ? nextNode.previousSibling : container.lastChild;
                        } else subTree = node.nodeType === 3 ? createTextVNode("") : createVNode("div");
                        subTree.el = node;
                        vnode.component.subTree = subTree;
                    }
                } else if (shapeFlag & 64) {
                    if (domType !== 8 /* COMMENT */ ) nextNode = onMismatch();
                    else nextNode = vnode.type.hydrate(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, rendererInternals, hydrateChildren);
                } else if (shapeFlag & 128) nextNode = vnode.type.hydrate(node, vnode, parentComponent, parentSuspense, isSVGContainer(parentNode(node)), slotScopeIds, optimized, rendererInternals, hydrateNode);
                else warn("Invalid HostVNode type:", type, `(${typeof type})`);
        }
        if (ref != null) setRef(ref, null, parentSuspense, vnode);
        return nextNode;
    };
    const hydrateElement = (el, vnode, parentComponent, parentSuspense, slotScopeIds, optimized)=>{
        optimized = optimized || !!vnode.dynamicChildren;
        const { type, props, patchFlag, shapeFlag, dirs } = vnode;
        const forcePatchValue = type === "input" && dirs || type === "option";
        {
            if (dirs) invokeDirectiveHook(vnode, null, parentComponent, "created");
            if (props) {
                if (forcePatchValue || !optimized || patchFlag & 48) {
                    for(const key in props)if (forcePatchValue && key.endsWith("value") || (0, _shared.isOn)(key) && !(0, _shared.isReservedProp)(key)) patchProp(el, key, null, props[key], false, void 0, parentComponent);
                } else if (props.onClick) patchProp(el, "onClick", null, props.onClick, false, void 0, parentComponent);
            }
            let vnodeHooks;
            if (vnodeHooks = props && props.onVnodeBeforeMount) invokeVNodeHook(vnodeHooks, parentComponent, vnode);
            if (dirs) invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
            if ((vnodeHooks = props && props.onVnodeMounted) || dirs) queueEffectWithSuspense(()=>{
                vnodeHooks && invokeVNodeHook(vnodeHooks, parentComponent, vnode);
                dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
            }, parentSuspense);
            if (shapeFlag & 16 && // skip if element has innerHTML / textContent
            !(props && (props.innerHTML || props.textContent))) {
                let next = hydrateChildren(el.firstChild, vnode, el, parentComponent, parentSuspense, slotScopeIds, optimized);
                let hasWarned = false;
                while(next){
                    hasMismatch = true;
                    if (!hasWarned) {
                        warn(`Hydration children mismatch in <${vnode.type}>: server rendered element contains more child nodes than client vdom.`);
                        hasWarned = true;
                    }
                    const cur = next;
                    next = next.nextSibling;
                    remove(cur);
                }
            } else if (shapeFlag & 8) {
                if (el.textContent !== vnode.children) {
                    hasMismatch = true;
                    warn(`Hydration text content mismatch in <${vnode.type}>:
- Client: ${el.textContent}
- Server: ${vnode.children}`);
                    el.textContent = vnode.children;
                }
            }
        }
        return el.nextSibling;
    };
    const hydrateChildren = (node, parentVNode, container, parentComponent, parentSuspense, slotScopeIds, optimized)=>{
        optimized = optimized || !!parentVNode.dynamicChildren;
        const children = parentVNode.children;
        const l = children.length;
        let hasWarned = false;
        for(let i = 0; i < l; i++){
            const vnode = optimized ? children[i] : children[i] = normalizeVNode(children[i]);
            if (node) node = hydrateNode(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized);
            else if (vnode.type === Text && !vnode.children) continue;
            else {
                hasMismatch = true;
                if (!hasWarned) {
                    warn(`Hydration children mismatch in <${container.tagName.toLowerCase()}>: server rendered element contains fewer child nodes than client vdom.`);
                    hasWarned = true;
                }
                patch(null, vnode, container, null, parentComponent, parentSuspense, isSVGContainer(container), slotScopeIds);
            }
        }
        return node;
    };
    const hydrateFragment = (node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized)=>{
        const { slotScopeIds: fragmentSlotScopeIds } = vnode;
        if (fragmentSlotScopeIds) slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
        const container = parentNode(node);
        const next = hydrateChildren(nextSibling(node), vnode, container, parentComponent, parentSuspense, slotScopeIds, optimized);
        if (next && isComment(next) && next.data === "]") return nextSibling(vnode.anchor = next);
        else {
            hasMismatch = true;
            insert(vnode.anchor = createComment(`]`), container, next);
            return next;
        }
    };
    const handleMismatch = (node, vnode, parentComponent, parentSuspense, slotScopeIds, isFragment)=>{
        hasMismatch = true;
        warn(`Hydration node mismatch:
- Client vnode:`, vnode.type, `
- Server rendered DOM:`, node, node.nodeType === 3 /* TEXT */  ? `(text)` : isComment(node) && node.data === "[" ? `(start of fragment)` : ``);
        vnode.el = null;
        if (isFragment) {
            const end = locateClosingAsyncAnchor(node);
            while(true){
                const next2 = nextSibling(node);
                if (next2 && next2 !== end) remove(next2);
                else break;
            }
        }
        const next = nextSibling(node);
        const container = parentNode(node);
        remove(node);
        patch(null, vnode, container, next, parentComponent, parentSuspense, isSVGContainer(container), slotScopeIds);
        return next;
    };
    const locateClosingAsyncAnchor = (node)=>{
        let match = 0;
        while(node){
            node = nextSibling(node);
            if (node && isComment(node)) {
                if (node.data === "[") match++;
                if (node.data === "]") {
                    if (match === 0) return nextSibling(node);
                    else match--;
                }
            }
        }
        return node;
    };
    return [
        hydrate,
        hydrateNode
    ];
}
let supported;
let perf;
function startMeasure(instance, type) {
    if (instance.appContext.config.performance && isSupported()) perf.mark(`vue-${type}-${instance.uid}`);
    devtoolsPerfStart(instance, type, isSupported() ? perf.now() : Date.now());
}
function endMeasure(instance, type) {
    if (instance.appContext.config.performance && isSupported()) {
        const startTag = `vue-${type}-${instance.uid}`;
        const endTag = startTag + `:end`;
        perf.mark(endTag);
        perf.measure(`<${formatComponentName(instance, instance.type)}> ${type}`, startTag, endTag);
        perf.clearMarks(startTag);
        perf.clearMarks(endTag);
    }
    devtoolsPerfEnd(instance, type, isSupported() ? perf.now() : Date.now());
}
function isSupported() {
    if (supported !== void 0) return supported;
    if (typeof window !== "undefined" && window.performance) {
        supported = true;
        perf = window.performance;
    } else supported = false;
    return supported;
}
function initFeatureFlags() {
    const needWarn = [];
    if (typeof __VUE_OPTIONS_API__ !== "boolean") {
        needWarn.push(`__VUE_OPTIONS_API__`);
        (0, _shared.getGlobalThis)().__VUE_OPTIONS_API__ = true;
    }
    if (typeof __VUE_PROD_DEVTOOLS__ !== "boolean") {
        needWarn.push(`__VUE_PROD_DEVTOOLS__`);
        (0, _shared.getGlobalThis)().__VUE_PROD_DEVTOOLS__ = false;
    }
    if (0, needWarn.length) {
        const multi = needWarn.length > 1;
        console.warn(`Feature flag${multi ? `s` : ``} ${needWarn.join(", ")} ${multi ? `are` : `is`} not explicitly defined. You are running the esm-bundler build of Vue, which expects these compile-time feature flags to be globally injected via the bundler config in order to get better tree-shaking in the production bundle.

For more details, see https://link.vuejs.org/feature-flags.`);
    }
}
const queuePostRenderEffect = queueEffectWithSuspense;
function createRenderer(options) {
    return baseCreateRenderer(options);
}
function createHydrationRenderer(options) {
    return baseCreateRenderer(options, createHydrationFunctions);
}
function baseCreateRenderer(options, createHydrationFns) {
    initFeatureFlags();
    const target = (0, _shared.getGlobalThis)();
    target.__VUE__ = true;
    setDevtoolsHook(target.__VUE_DEVTOOLS_GLOBAL_HOOK__, target);
    const { insert: hostInsert, remove: hostRemove, patchProp: hostPatchProp, createElement: hostCreateElement, createText: hostCreateText, createComment: hostCreateComment, setText: hostSetText, setElementText: hostSetElementText, parentNode: hostParentNode, nextSibling: hostNextSibling, setScopeId: hostSetScopeId = (0, _shared.NOOP), insertStaticContent: hostInsertStaticContent } = options;
    const patch = (n1, n2, container, anchor = null, parentComponent = null, parentSuspense = null, isSVG = false, slotScopeIds = null, optimized = isHmrUpdating ? false : !!n2.dynamicChildren)=>{
        if (n1 === n2) return;
        if (n1 && !isSameVNodeType(n1, n2)) {
            anchor = getNextHostNode(n1);
            unmount(n1, parentComponent, parentSuspense, true);
            n1 = null;
        }
        if (n2.patchFlag === -2) {
            optimized = false;
            n2.dynamicChildren = null;
        }
        const { type, ref, shapeFlag } = n2;
        switch(type){
            case Text:
                processText(n1, n2, container, anchor);
                break;
            case Comment:
                processCommentNode(n1, n2, container, anchor);
                break;
            case Static:
                if (n1 == null) mountStaticNode(n2, container, anchor, isSVG);
                else patchStaticNode(n1, n2, container, isSVG);
                break;
            case Fragment:
                processFragment(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
                break;
            default:
                if (shapeFlag & 1) processElement(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
                else if (shapeFlag & 6) processComponent(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
                else if (shapeFlag & 64) type.process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals);
                else if (shapeFlag & 128) type.process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals);
                else warn("Invalid VNode type:", type, `(${typeof type})`);
        }
        if (ref != null && parentComponent) setRef(ref, n1 && n1.ref, parentSuspense, n2 || n1, !n2);
    };
    const processText = (n1, n2, container, anchor)=>{
        if (n1 == null) hostInsert(n2.el = hostCreateText(n2.children), container, anchor);
        else {
            const el = n2.el = n1.el;
            if (n2.children !== n1.children) hostSetText(el, n2.children);
        }
    };
    const processCommentNode = (n1, n2, container, anchor)=>{
        if (n1 == null) hostInsert(n2.el = hostCreateComment(n2.children || ""), container, anchor);
        else n2.el = n1.el;
    };
    const mountStaticNode = (n2, container, anchor, isSVG)=>{
        [n2.el, n2.anchor] = hostInsertStaticContent(n2.children, container, anchor, isSVG, n2.el, n2.anchor);
    };
    const patchStaticNode = (n1, n2, container, isSVG)=>{
        if (n2.children !== n1.children) {
            const anchor = hostNextSibling(n1.anchor);
            removeStaticNode(n1);
            [n2.el, n2.anchor] = hostInsertStaticContent(n2.children, container, anchor, isSVG);
        } else {
            n2.el = n1.el;
            n2.anchor = n1.anchor;
        }
    };
    const moveStaticNode = ({ el, anchor }, container, nextSibling)=>{
        let next;
        while(el && el !== anchor){
            next = hostNextSibling(el);
            hostInsert(el, container, nextSibling);
            el = next;
        }
        hostInsert(anchor, container, nextSibling);
    };
    const removeStaticNode = ({ el, anchor })=>{
        let next;
        while(el && el !== anchor){
            next = hostNextSibling(el);
            hostRemove(el);
            el = next;
        }
        hostRemove(anchor);
    };
    const processElement = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized)=>{
        isSVG = isSVG || n2.type === "svg";
        if (n1 == null) mountElement(n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        else patchElement(n1, n2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
    };
    const mountElement = (vnode, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized)=>{
        let el;
        let vnodeHook;
        const { type, props, shapeFlag, transition, dirs } = vnode;
        el = vnode.el = hostCreateElement(vnode.type, isSVG, props && props.is, props);
        if (shapeFlag & 8) hostSetElementText(el, vnode.children);
        else if (shapeFlag & 16) mountChildren(vnode.children, el, null, parentComponent, parentSuspense, isSVG && type !== "foreignObject", slotScopeIds, optimized);
        if (dirs) invokeDirectiveHook(vnode, null, parentComponent, "created");
        setScopeId(el, vnode, vnode.scopeId, slotScopeIds, parentComponent);
        if (props) {
            for(const key in props)if (key !== "value" && !(0, _shared.isReservedProp)(key)) hostPatchProp(el, key, null, props[key], isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);
            if ("value" in props) hostPatchProp(el, "value", null, props.value);
            if (vnodeHook = props.onVnodeBeforeMount) invokeVNodeHook(vnodeHook, parentComponent, vnode);
        }
        Object.defineProperty(el, "__vnode", {
            value: vnode,
            enumerable: false
        });
        Object.defineProperty(el, "__vueParentComponent", {
            value: parentComponent,
            enumerable: false
        });
        if (dirs) invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
        const needCallTransitionHooks = (!parentSuspense || parentSuspense && !parentSuspense.pendingBranch) && transition && !transition.persisted;
        if (needCallTransitionHooks) transition.beforeEnter(el);
        hostInsert(el, container, anchor);
        if ((vnodeHook = props && props.onVnodeMounted) || needCallTransitionHooks || dirs) queuePostRenderEffect(()=>{
            vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
            needCallTransitionHooks && transition.enter(el);
            dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
        }, parentSuspense);
    };
    const setScopeId = (el, vnode, scopeId, slotScopeIds, parentComponent)=>{
        if (scopeId) hostSetScopeId(el, scopeId);
        if (slotScopeIds) for(let i = 0; i < slotScopeIds.length; i++)hostSetScopeId(el, slotScopeIds[i]);
        if (parentComponent) {
            let subTree = parentComponent.subTree;
            if (subTree.patchFlag > 0 && subTree.patchFlag & 2048) subTree = filterSingleRoot(subTree.children) || subTree;
            if (vnode === subTree) {
                const parentVNode = parentComponent.vnode;
                setScopeId(el, parentVNode, parentVNode.scopeId, parentVNode.slotScopeIds, parentComponent.parent);
            }
        }
    };
    const mountChildren = (children, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, start = 0)=>{
        for(let i = start; i < children.length; i++){
            const child = children[i] = optimized ? cloneIfMounted(children[i]) : normalizeVNode(children[i]);
            patch(null, child, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        }
    };
    const patchElement = (n1, n2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized)=>{
        const el = n2.el = n1.el;
        let { patchFlag, dynamicChildren, dirs } = n2;
        patchFlag |= n1.patchFlag & 16;
        const oldProps = n1.props || (0, _shared.EMPTY_OBJ);
        const newProps = n2.props || (0, _shared.EMPTY_OBJ);
        let vnodeHook;
        parentComponent && toggleRecurse(parentComponent, false);
        if (vnodeHook = newProps.onVnodeBeforeUpdate) invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
        if (dirs) invokeDirectiveHook(n2, n1, parentComponent, "beforeUpdate");
        parentComponent && toggleRecurse(parentComponent, true);
        if (isHmrUpdating) {
            patchFlag = 0;
            optimized = false;
            dynamicChildren = null;
        }
        const areChildrenSVG = isSVG && n2.type !== "foreignObject";
        if (dynamicChildren) {
            patchBlockChildren(n1.dynamicChildren, dynamicChildren, el, parentComponent, parentSuspense, areChildrenSVG, slotScopeIds);
            traverseStaticChildren(n1, n2);
        } else if (!optimized) patchChildren(n1, n2, el, null, parentComponent, parentSuspense, areChildrenSVG, slotScopeIds, false);
        if (patchFlag > 0) {
            if (patchFlag & 16) patchProps(el, n2, oldProps, newProps, parentComponent, parentSuspense, isSVG);
            else {
                if (patchFlag & 2) {
                    if (oldProps.class !== newProps.class) hostPatchProp(el, "class", null, newProps.class, isSVG);
                }
                if (patchFlag & 4) hostPatchProp(el, "style", oldProps.style, newProps.style, isSVG);
                if (patchFlag & 8) {
                    const propsToUpdate = n2.dynamicProps;
                    for(let i = 0; i < propsToUpdate.length; i++){
                        const key = propsToUpdate[i];
                        const prev = oldProps[key];
                        const next = newProps[key];
                        if (next !== prev || key === "value") hostPatchProp(el, key, prev, next, isSVG, n1.children, parentComponent, parentSuspense, unmountChildren);
                    }
                }
            }
            if (patchFlag & 1) {
                if (n1.children !== n2.children) hostSetElementText(el, n2.children);
            }
        } else if (!optimized && dynamicChildren == null) patchProps(el, n2, oldProps, newProps, parentComponent, parentSuspense, isSVG);
        if ((vnodeHook = newProps.onVnodeUpdated) || dirs) queuePostRenderEffect(()=>{
            vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
            dirs && invokeDirectiveHook(n2, n1, parentComponent, "updated");
        }, parentSuspense);
    };
    const patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, isSVG, slotScopeIds)=>{
        for(let i = 0; i < newChildren.length; i++){
            const oldVNode = oldChildren[i];
            const newVNode = newChildren[i];
            const container = // oldVNode may be an errored async setup() component inside Suspense
            // which will not have a mounted element
            oldVNode.el && // - In the case of a Fragment, we need to provide the actual parent
            // of the Fragment itself so it can move its children.
            (oldVNode.type === Fragment || // - In the case of different nodes, there is going to be a replacement
            // which also requires the correct parent container
            !isSameVNodeType(oldVNode, newVNode) || // - In the case of a component, it could contain anything.
            oldVNode.shapeFlag & 70) ? hostParentNode(oldVNode.el) : // In other cases, the parent container is not actually used so we
            // just pass the block element here to avoid a DOM parentNode call.
            fallbackContainer;
            patch(oldVNode, newVNode, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, true);
        }
    };
    const patchProps = (el, vnode, oldProps, newProps, parentComponent, parentSuspense, isSVG)=>{
        if (oldProps !== newProps) {
            if (oldProps !== (0, _shared.EMPTY_OBJ)) {
                for(const key in oldProps)if (!(0, _shared.isReservedProp)(key) && !(key in newProps)) hostPatchProp(el, key, oldProps[key], null, isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);
            }
            for(const key in newProps){
                if ((0, _shared.isReservedProp)(key)) continue;
                const next = newProps[key];
                const prev = oldProps[key];
                if (next !== prev && key !== "value") hostPatchProp(el, key, prev, next, isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);
            }
            if ("value" in newProps) hostPatchProp(el, "value", oldProps.value, newProps.value);
        }
    };
    const processFragment = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized)=>{
        const fragmentStartAnchor = n2.el = n1 ? n1.el : hostCreateText("");
        const fragmentEndAnchor = n2.anchor = n1 ? n1.anchor : hostCreateText("");
        let { patchFlag, dynamicChildren, slotScopeIds: fragmentSlotScopeIds } = n2;
        if (// #5523 dev root fragment may inherit directives
        isHmrUpdating || patchFlag & 2048) {
            patchFlag = 0;
            optimized = false;
            dynamicChildren = null;
        }
        if (fragmentSlotScopeIds) slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
        if (n1 == null) {
            hostInsert(fragmentStartAnchor, container, anchor);
            hostInsert(fragmentEndAnchor, container, anchor);
            mountChildren(n2.children, container, fragmentEndAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        } else if (patchFlag > 0 && patchFlag & 64 && dynamicChildren && // #2715 the previous fragment could've been a BAILed one as a result
        // of renderSlot() with no valid children
        n1.dynamicChildren) {
            patchBlockChildren(n1.dynamicChildren, dynamicChildren, container, parentComponent, parentSuspense, isSVG, slotScopeIds);
            traverseStaticChildren(n1, n2);
        } else patchChildren(n1, n2, container, fragmentEndAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
    };
    const processComponent = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized)=>{
        n2.slotScopeIds = slotScopeIds;
        if (n1 == null) {
            if (n2.shapeFlag & 512) parentComponent.ctx.activate(n2, container, anchor, isSVG, optimized);
            else mountComponent(n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized);
        } else updateComponent(n1, n2, optimized);
    };
    const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, isSVG, optimized)=>{
        const instance = initialVNode.component = createComponentInstance(initialVNode, parentComponent, parentSuspense);
        if (0, instance.type.__hmrId) registerHMR(instance);
        pushWarningContext(initialVNode);
        startMeasure(instance, `mount`);
        if (isKeepAlive(initialVNode)) instance.ctx.renderer = internals;
        startMeasure(instance, `init`);
        setupComponent(instance);
        endMeasure(instance, `init`);
        if (instance.asyncDep) {
            parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect);
            if (!initialVNode.el) {
                const placeholder = instance.subTree = createVNode(Comment);
                processCommentNode(null, placeholder, container, anchor);
            }
            return;
        }
        setupRenderEffect(instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized);
        popWarningContext();
        endMeasure(instance, `mount`);
    };
    const updateComponent = (n1, n2, optimized)=>{
        const instance = n2.component = n1.component;
        if (shouldUpdateComponent(n1, n2, optimized)) {
            if (instance.asyncDep && !instance.asyncResolved) {
                pushWarningContext(n2);
                updateComponentPreRender(instance, n2, optimized);
                popWarningContext();
                return;
            } else {
                instance.next = n2;
                invalidateJob(instance.update);
                instance.update();
            }
        } else {
            n2.el = n1.el;
            instance.vnode = n2;
        }
    };
    const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized)=>{
        const componentUpdateFn = ()=>{
            if (!instance.isMounted) {
                let vnodeHook;
                const { el, props } = initialVNode;
                const { bm, m, parent } = instance;
                const isAsyncWrapperVNode = isAsyncWrapper(initialVNode);
                toggleRecurse(instance, false);
                if (bm) (0, _shared.invokeArrayFns)(bm);
                if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeBeforeMount)) invokeVNodeHook(vnodeHook, parent, initialVNode);
                toggleRecurse(instance, true);
                if (el && hydrateNode) {
                    const hydrateSubTree = ()=>{
                        startMeasure(instance, `render`);
                        instance.subTree = renderComponentRoot(instance);
                        endMeasure(instance, `render`);
                        startMeasure(instance, `hydrate`);
                        hydrateNode(el, instance.subTree, instance, parentSuspense, null);
                        endMeasure(instance, `hydrate`);
                    };
                    if (isAsyncWrapperVNode) initialVNode.type.__asyncLoader().then(// note: we are moving the render call into an async callback,
                    // which means it won't track dependencies - but it's ok because
                    // a server-rendered async wrapper is already in resolved state
                    // and it will never need to change.
                    ()=>!instance.isUnmounted && hydrateSubTree());
                    else hydrateSubTree();
                } else {
                    startMeasure(instance, `render`);
                    const subTree = instance.subTree = renderComponentRoot(instance);
                    endMeasure(instance, `render`);
                    startMeasure(instance, `patch`);
                    patch(null, subTree, container, anchor, instance, parentSuspense, isSVG);
                    endMeasure(instance, `patch`);
                    initialVNode.el = subTree.el;
                }
                if (m) queuePostRenderEffect(m, parentSuspense);
                if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeMounted)) {
                    const scopedInitialVNode = initialVNode;
                    queuePostRenderEffect(()=>invokeVNodeHook(vnodeHook, parent, scopedInitialVNode), parentSuspense);
                }
                if (initialVNode.shapeFlag & 256 || parent && isAsyncWrapper(parent.vnode) && parent.vnode.shapeFlag & 256) instance.a && queuePostRenderEffect(instance.a, parentSuspense);
                instance.isMounted = true;
                devtoolsComponentAdded(instance);
                initialVNode = container = anchor = null;
            } else {
                let { next, bu, u, parent, vnode } = instance;
                let originNext = next;
                let vnodeHook;
                pushWarningContext(next || instance.vnode);
                toggleRecurse(instance, false);
                if (next) {
                    next.el = vnode.el;
                    updateComponentPreRender(instance, next, optimized);
                } else next = vnode;
                if (bu) (0, _shared.invokeArrayFns)(bu);
                if (vnodeHook = next.props && next.props.onVnodeBeforeUpdate) invokeVNodeHook(vnodeHook, parent, next, vnode);
                toggleRecurse(instance, true);
                startMeasure(instance, `render`);
                const nextTree = renderComponentRoot(instance);
                endMeasure(instance, `render`);
                const prevTree = instance.subTree;
                instance.subTree = nextTree;
                startMeasure(instance, `patch`);
                patch(prevTree, nextTree, // parent may have changed if it's in a teleport
                hostParentNode(prevTree.el), // anchor may have changed if it's in a fragment
                getNextHostNode(prevTree), instance, parentSuspense, isSVG);
                endMeasure(instance, `patch`);
                next.el = nextTree.el;
                if (originNext === null) updateHOCHostEl(instance, nextTree.el);
                if (u) queuePostRenderEffect(u, parentSuspense);
                if (vnodeHook = next.props && next.props.onVnodeUpdated) queuePostRenderEffect(()=>invokeVNodeHook(vnodeHook, parent, next, vnode), parentSuspense);
                devtoolsComponentUpdated(instance);
                popWarningContext();
            }
        };
        const effect = instance.effect = new (0, _reactivity.ReactiveEffect)(componentUpdateFn, ()=>queueJob(update), instance.scope);
        const update = instance.update = ()=>effect.run();
        update.id = instance.uid;
        toggleRecurse(instance, true);
        effect.onTrack = instance.rtc ? (e)=>(0, _shared.invokeArrayFns)(instance.rtc, e) : void 0;
        effect.onTrigger = instance.rtg ? (e)=>(0, _shared.invokeArrayFns)(instance.rtg, e) : void 0;
        update.ownerInstance = instance;
        update();
    };
    const updateComponentPreRender = (instance, nextVNode, optimized)=>{
        nextVNode.component = instance;
        const prevProps = instance.vnode.props;
        instance.vnode = nextVNode;
        instance.next = null;
        updateProps(instance, nextVNode.props, prevProps, optimized);
        updateSlots(instance, nextVNode.children, optimized);
        (0, _reactivity.pauseTracking)();
        flushPreFlushCbs();
        (0, _reactivity.resetTracking)();
    };
    const patchChildren = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized = false)=>{
        const c1 = n1 && n1.children;
        const prevShapeFlag = n1 ? n1.shapeFlag : 0;
        const c2 = n2.children;
        const { patchFlag, shapeFlag } = n2;
        if (patchFlag > 0) {
            if (patchFlag & 128) {
                patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
                return;
            } else if (patchFlag & 256) {
                patchUnkeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
                return;
            }
        }
        if (shapeFlag & 8) {
            if (prevShapeFlag & 16) unmountChildren(c1, parentComponent, parentSuspense);
            if (c2 !== c1) hostSetElementText(container, c2);
        } else if (prevShapeFlag & 16) {
            if (shapeFlag & 16) patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
            else unmountChildren(c1, parentComponent, parentSuspense, true);
        } else {
            if (prevShapeFlag & 8) hostSetElementText(container, "");
            if (shapeFlag & 16) mountChildren(c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        }
    };
    const patchUnkeyedChildren = (c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized)=>{
        c1 = c1 || (0, _shared.EMPTY_ARR);
        c2 = c2 || (0, _shared.EMPTY_ARR);
        const oldLength = c1.length;
        const newLength = c2.length;
        const commonLength = Math.min(oldLength, newLength);
        let i;
        for(i = 0; i < commonLength; i++){
            const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
            patch(c1[i], nextChild, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        }
        if (oldLength > newLength) unmountChildren(c1, parentComponent, parentSuspense, true, false, commonLength);
        else mountChildren(c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, commonLength);
    };
    const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized)=>{
        let i = 0;
        const l2 = c2.length;
        let e1 = c1.length - 1;
        let e2 = l2 - 1;
        while(i <= e1 && i <= e2){
            const n1 = c1[i];
            const n2 = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
            if (isSameVNodeType(n1, n2)) patch(n1, n2, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
            else break;
            i++;
        }
        while(i <= e1 && i <= e2){
            const n1 = c1[e1];
            const n2 = c2[e2] = optimized ? cloneIfMounted(c2[e2]) : normalizeVNode(c2[e2]);
            if (isSameVNodeType(n1, n2)) patch(n1, n2, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
            else break;
            e1--;
            e2--;
        }
        if (i > e1) {
            if (i <= e2) {
                const nextPos = e2 + 1;
                const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;
                while(i <= e2){
                    patch(null, c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]), container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
                    i++;
                }
            }
        } else if (i > e2) while(i <= e1){
            unmount(c1[i], parentComponent, parentSuspense, true);
            i++;
        }
        else {
            const s1 = i;
            const s2 = i;
            const keyToNewIndexMap = /* @__PURE__ */ new Map();
            for(i = s2; i <= e2; i++){
                const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
                if (nextChild.key != null) {
                    if (keyToNewIndexMap.has(nextChild.key)) warn(`Duplicate keys found during update:`, JSON.stringify(nextChild.key), `Make sure keys are unique.`);
                    keyToNewIndexMap.set(nextChild.key, i);
                }
            }
            let j;
            let patched = 0;
            const toBePatched = e2 - s2 + 1;
            let moved = false;
            let maxNewIndexSoFar = 0;
            const newIndexToOldIndexMap = new Array(toBePatched);
            for(i = 0; i < toBePatched; i++)newIndexToOldIndexMap[i] = 0;
            for(i = s1; i <= e1; i++){
                const prevChild = c1[i];
                if (patched >= toBePatched) {
                    unmount(prevChild, parentComponent, parentSuspense, true);
                    continue;
                }
                let newIndex;
                if (prevChild.key != null) newIndex = keyToNewIndexMap.get(prevChild.key);
                else {
                    for(j = s2; j <= e2; j++)if (newIndexToOldIndexMap[j - s2] === 0 && isSameVNodeType(prevChild, c2[j])) {
                        newIndex = j;
                        break;
                    }
                }
                if (newIndex === void 0) unmount(prevChild, parentComponent, parentSuspense, true);
                else {
                    newIndexToOldIndexMap[newIndex - s2] = i + 1;
                    if (newIndex >= maxNewIndexSoFar) maxNewIndexSoFar = newIndex;
                    else moved = true;
                    patch(prevChild, c2[newIndex], container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
                    patched++;
                }
            }
            const increasingNewIndexSequence = moved ? getSequence(newIndexToOldIndexMap) : (0, _shared.EMPTY_ARR);
            j = increasingNewIndexSequence.length - 1;
            for(i = toBePatched - 1; i >= 0; i--){
                const nextIndex = s2 + i;
                const nextChild = c2[nextIndex];
                const anchor = nextIndex + 1 < l2 ? c2[nextIndex + 1].el : parentAnchor;
                if (newIndexToOldIndexMap[i] === 0) patch(null, nextChild, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
                else if (moved) {
                    if (j < 0 || i !== increasingNewIndexSequence[j]) move(nextChild, container, anchor, 2);
                    else j--;
                }
            }
        }
    };
    const move = (vnode, container, anchor, moveType, parentSuspense = null)=>{
        const { el, type, transition, children, shapeFlag } = vnode;
        if (shapeFlag & 6) {
            move(vnode.component.subTree, container, anchor, moveType);
            return;
        }
        if (shapeFlag & 128) {
            vnode.suspense.move(container, anchor, moveType);
            return;
        }
        if (shapeFlag & 64) {
            type.move(vnode, container, anchor, internals);
            return;
        }
        if (type === Fragment) {
            hostInsert(el, container, anchor);
            for(let i = 0; i < children.length; i++)move(children[i], container, anchor, moveType);
            hostInsert(vnode.anchor, container, anchor);
            return;
        }
        if (type === Static) {
            moveStaticNode(vnode, container, anchor);
            return;
        }
        const needTransition = moveType !== 2 && shapeFlag & 1 && transition;
        if (needTransition) {
            if (moveType === 0) {
                transition.beforeEnter(el);
                hostInsert(el, container, anchor);
                queuePostRenderEffect(()=>transition.enter(el), parentSuspense);
            } else {
                const { leave, delayLeave, afterLeave } = transition;
                const remove2 = ()=>hostInsert(el, container, anchor);
                const performLeave = ()=>{
                    leave(el, ()=>{
                        remove2();
                        afterLeave && afterLeave();
                    });
                };
                if (delayLeave) delayLeave(el, remove2, performLeave);
                else performLeave();
            }
        } else hostInsert(el, container, anchor);
    };
    const unmount = (vnode, parentComponent, parentSuspense, doRemove = false, optimized = false)=>{
        const { type, props, ref, children, dynamicChildren, shapeFlag, patchFlag, dirs } = vnode;
        if (ref != null) setRef(ref, null, parentSuspense, vnode, true);
        if (shapeFlag & 256) {
            parentComponent.ctx.deactivate(vnode);
            return;
        }
        const shouldInvokeDirs = shapeFlag & 1 && dirs;
        const shouldInvokeVnodeHook = !isAsyncWrapper(vnode);
        let vnodeHook;
        if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeBeforeUnmount)) invokeVNodeHook(vnodeHook, parentComponent, vnode);
        if (shapeFlag & 6) unmountComponent(vnode.component, parentSuspense, doRemove);
        else {
            if (shapeFlag & 128) {
                vnode.suspense.unmount(parentSuspense, doRemove);
                return;
            }
            if (shouldInvokeDirs) invokeDirectiveHook(vnode, null, parentComponent, "beforeUnmount");
            if (shapeFlag & 64) vnode.type.remove(vnode, parentComponent, parentSuspense, optimized, internals, doRemove);
            else if (dynamicChildren && // #1153: fast path should not be taken for non-stable (v-for) fragments
            (type !== Fragment || patchFlag > 0 && patchFlag & 64)) unmountChildren(dynamicChildren, parentComponent, parentSuspense, false, true);
            else if (type === Fragment && patchFlag & 384 || !optimized && shapeFlag & 16) unmountChildren(children, parentComponent, parentSuspense);
            if (doRemove) remove(vnode);
        }
        if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeUnmounted) || shouldInvokeDirs) queuePostRenderEffect(()=>{
            vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
            shouldInvokeDirs && invokeDirectiveHook(vnode, null, parentComponent, "unmounted");
        }, parentSuspense);
    };
    const remove = (vnode)=>{
        const { type, el, anchor, transition } = vnode;
        if (type === Fragment) {
            if (vnode.patchFlag > 0 && vnode.patchFlag & 2048 && transition && !transition.persisted) vnode.children.forEach((child)=>{
                if (child.type === Comment) hostRemove(child.el);
                else remove(child);
            });
            else removeFragment(el, anchor);
            return;
        }
        if (type === Static) {
            removeStaticNode(vnode);
            return;
        }
        const performRemove = ()=>{
            hostRemove(el);
            if (transition && !transition.persisted && transition.afterLeave) transition.afterLeave();
        };
        if (vnode.shapeFlag & 1 && transition && !transition.persisted) {
            const { leave, delayLeave } = transition;
            const performLeave = ()=>leave(el, performRemove);
            if (delayLeave) delayLeave(vnode.el, performRemove, performLeave);
            else performLeave();
        } else performRemove();
    };
    const removeFragment = (cur, end)=>{
        let next;
        while(cur !== end){
            next = hostNextSibling(cur);
            hostRemove(cur);
            cur = next;
        }
        hostRemove(end);
    };
    const unmountComponent = (instance, parentSuspense, doRemove)=>{
        if (0, instance.type.__hmrId) unregisterHMR(instance);
        const { bum, scope, update, subTree, um } = instance;
        if (bum) (0, _shared.invokeArrayFns)(bum);
        scope.stop();
        if (update) {
            update.active = false;
            unmount(subTree, instance, parentSuspense, doRemove);
        }
        if (um) queuePostRenderEffect(um, parentSuspense);
        queuePostRenderEffect(()=>{
            instance.isUnmounted = true;
        }, parentSuspense);
        if (parentSuspense && parentSuspense.pendingBranch && !parentSuspense.isUnmounted && instance.asyncDep && !instance.asyncResolved && instance.suspenseId === parentSuspense.pendingId) {
            parentSuspense.deps--;
            if (parentSuspense.deps === 0) parentSuspense.resolve();
        }
        devtoolsComponentRemoved(instance);
    };
    const unmountChildren = (children, parentComponent, parentSuspense, doRemove = false, optimized = false, start = 0)=>{
        for(let i = start; i < children.length; i++)unmount(children[i], parentComponent, parentSuspense, doRemove, optimized);
    };
    const getNextHostNode = (vnode)=>{
        if (vnode.shapeFlag & 6) return getNextHostNode(vnode.component.subTree);
        if (vnode.shapeFlag & 128) return vnode.suspense.next();
        return hostNextSibling(vnode.anchor || vnode.el);
    };
    const render = (vnode, container, isSVG)=>{
        if (vnode == null) {
            if (container._vnode) unmount(container._vnode, null, null, true);
        } else patch(container._vnode || null, vnode, container, null, null, null, isSVG);
        flushPreFlushCbs();
        flushPostFlushCbs();
        container._vnode = vnode;
    };
    const internals = {
        p: patch,
        um: unmount,
        m: move,
        r: remove,
        mt: mountComponent,
        mc: mountChildren,
        pc: patchChildren,
        pbc: patchBlockChildren,
        n: getNextHostNode,
        o: options
    };
    let hydrate;
    let hydrateNode;
    if (createHydrationFns) [hydrate, hydrateNode] = createHydrationFns(internals);
    return {
        render,
        hydrate,
        createApp: createAppAPI(render, hydrate)
    };
}
function toggleRecurse({ effect, update }, allowed) {
    effect.allowRecurse = update.allowRecurse = allowed;
}
function traverseStaticChildren(n1, n2, shallow = false) {
    const ch1 = n1.children;
    const ch2 = n2.children;
    if ((0, _shared.isArray)(ch1) && (0, _shared.isArray)(ch2)) for(let i = 0; i < ch1.length; i++){
        const c1 = ch1[i];
        let c2 = ch2[i];
        if (c2.shapeFlag & 1 && !c2.dynamicChildren) {
            if (c2.patchFlag <= 0 || c2.patchFlag === 32) {
                c2 = ch2[i] = cloneIfMounted(ch2[i]);
                c2.el = c1.el;
            }
            if (!shallow) traverseStaticChildren(c1, c2);
        }
        if (c2.type === Text) c2.el = c1.el;
        if (c2.type === Comment && !c2.el) c2.el = c1.el;
    }
}
function getSequence(arr) {
    const p = arr.slice();
    const result = [
        0
    ];
    let i, j, u, v1, c;
    const len = arr.length;
    for(i = 0; i < len; i++){
        const arrI = arr[i];
        if (arrI !== 0) {
            j = result[result.length - 1];
            if (arr[j] < arrI) {
                p[i] = j;
                result.push(i);
                continue;
            }
            u = 0;
            v1 = result.length - 1;
            while(u < v1){
                c = u + v1 >> 1;
                if (arr[result[c]] < arrI) u = c + 1;
                else v1 = c;
            }
            if (arrI < arr[result[u]]) {
                if (u > 0) p[i] = result[u - 1];
                result[u] = i;
            }
        }
    }
    u = result.length;
    v1 = result[u - 1];
    while(u-- > 0){
        result[u] = v1;
        v1 = p[v1];
    }
    return result;
}
const isTeleport = (type)=>type.__isTeleport;
const isTeleportDisabled = (props)=>props && (props.disabled || props.disabled === "");
const isTargetSVG = (target)=>typeof SVGElement !== "undefined" && target instanceof SVGElement;
const resolveTarget = (props, select)=>{
    const targetSelector = props && props.to;
    if ((0, _shared.isString)(targetSelector)) {
        if (!select) {
            warn(`Current renderer does not support string target for Teleports. (missing querySelector renderer option)`);
            return null;
        } else {
            const target = select(targetSelector);
            if (!target) warn(`Failed to locate Teleport target with selector "${targetSelector}". Note the target element must exist before the component is mounted - i.e. the target cannot be rendered by the component itself, and ideally should be outside of the entire Vue component tree.`);
            return target;
        }
    } else {
        if (!targetSelector && !isTeleportDisabled(props)) warn(`Invalid Teleport target: ${targetSelector}`);
        return targetSelector;
    }
};
const TeleportImpl = {
    __isTeleport: true,
    process (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals) {
        const { mc: mountChildren, pc: patchChildren, pbc: patchBlockChildren, o: { insert, querySelector, createText, createComment } } = internals;
        const disabled = isTeleportDisabled(n2.props);
        let { shapeFlag, children, dynamicChildren } = n2;
        if (isHmrUpdating) {
            optimized = false;
            dynamicChildren = null;
        }
        if (n1 == null) {
            const placeholder = n2.el = createComment("teleport start");
            const mainAnchor = n2.anchor = createComment("teleport end");
            insert(placeholder, container, anchor);
            insert(mainAnchor, container, anchor);
            const target = n2.target = resolveTarget(n2.props, querySelector);
            const targetAnchor = n2.targetAnchor = createText("");
            if (target) {
                insert(targetAnchor, target);
                isSVG = isSVG || isTargetSVG(target);
            } else if (!disabled) warn("Invalid Teleport target on mount:", target, `(${typeof target})`);
            const mount = (container2, anchor2)=>{
                if (shapeFlag & 16) mountChildren(children, container2, anchor2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
            };
            if (disabled) mount(container, mainAnchor);
            else if (target) mount(target, targetAnchor);
        } else {
            n2.el = n1.el;
            const mainAnchor = n2.anchor = n1.anchor;
            const target = n2.target = n1.target;
            const targetAnchor = n2.targetAnchor = n1.targetAnchor;
            const wasDisabled = isTeleportDisabled(n1.props);
            const currentContainer = wasDisabled ? container : target;
            const currentAnchor = wasDisabled ? mainAnchor : targetAnchor;
            isSVG = isSVG || isTargetSVG(target);
            if (dynamicChildren) {
                patchBlockChildren(n1.dynamicChildren, dynamicChildren, currentContainer, parentComponent, parentSuspense, isSVG, slotScopeIds);
                traverseStaticChildren(n1, n2, true);
            } else if (!optimized) patchChildren(n1, n2, currentContainer, currentAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, false);
            if (disabled) {
                if (!wasDisabled) moveTeleport(n2, container, mainAnchor, internals, 1);
            } else {
                if ((n2.props && n2.props.to) !== (n1.props && n1.props.to)) {
                    const nextTarget = n2.target = resolveTarget(n2.props, querySelector);
                    if (nextTarget) moveTeleport(n2, nextTarget, null, internals, 0);
                    else warn("Invalid Teleport target on update:", target, `(${typeof target})`);
                } else if (wasDisabled) moveTeleport(n2, target, targetAnchor, internals, 1);
            }
        }
        updateCssVars(n2);
    },
    remove (vnode, parentComponent, parentSuspense, optimized, { um: unmount, o: { remove: hostRemove } }, doRemove) {
        const { shapeFlag, children, anchor, targetAnchor, target, props } = vnode;
        if (target) hostRemove(targetAnchor);
        if (doRemove || !isTeleportDisabled(props)) {
            hostRemove(anchor);
            if (shapeFlag & 16) for(let i = 0; i < children.length; i++){
                const child = children[i];
                unmount(child, parentComponent, parentSuspense, true, !!child.dynamicChildren);
            }
        }
    },
    move: moveTeleport,
    hydrate: hydrateTeleport
};
function moveTeleport(vnode, container, parentAnchor, { o: { insert }, m: move }, moveType = 2) {
    if (moveType === 0) insert(vnode.targetAnchor, container, parentAnchor);
    const { el, anchor, shapeFlag, children, props } = vnode;
    const isReorder = moveType === 2;
    if (isReorder) insert(el, container, parentAnchor);
    if (!isReorder || isTeleportDisabled(props)) {
        if (shapeFlag & 16) for(let i = 0; i < children.length; i++)move(children[i], container, parentAnchor, 2);
    }
    if (isReorder) insert(anchor, container, parentAnchor);
}
function hydrateTeleport(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, { o: { nextSibling, parentNode, querySelector } }, hydrateChildren) {
    const target = vnode.target = resolveTarget(vnode.props, querySelector);
    if (target) {
        const targetNode = target._lpa || target.firstChild;
        if (vnode.shapeFlag & 16) {
            if (isTeleportDisabled(vnode.props)) {
                vnode.anchor = hydrateChildren(nextSibling(node), vnode, parentNode(node), parentComponent, parentSuspense, slotScopeIds, optimized);
                vnode.targetAnchor = targetNode;
            } else {
                vnode.anchor = nextSibling(node);
                let targetAnchor = targetNode;
                while(targetAnchor){
                    targetAnchor = nextSibling(targetAnchor);
                    if (targetAnchor && targetAnchor.nodeType === 8 && targetAnchor.data === "teleport anchor") {
                        vnode.targetAnchor = targetAnchor;
                        target._lpa = vnode.targetAnchor && nextSibling(vnode.targetAnchor);
                        break;
                    }
                }
                hydrateChildren(targetNode, vnode, target, parentComponent, parentSuspense, slotScopeIds, optimized);
            }
        }
        updateCssVars(vnode);
    }
    return vnode.anchor && nextSibling(vnode.anchor);
}
const Teleport = TeleportImpl;
function updateCssVars(vnode) {
    const ctx = vnode.ctx;
    if (ctx && ctx.ut) {
        let node = vnode.children[0].el;
        while(node !== vnode.targetAnchor){
            if (node.nodeType === 1) node.setAttribute("data-v-owner", ctx.uid);
            node = node.nextSibling;
        }
        ctx.ut();
    }
}
const Fragment = Symbol.for("v-fgt");
const Text = Symbol.for("v-txt");
const Comment = Symbol.for("v-cmt");
const Static = Symbol.for("v-stc");
const blockStack = [];
let currentBlock = null;
function openBlock(disableTracking = false) {
    blockStack.push(currentBlock = disableTracking ? null : []);
}
function closeBlock() {
    blockStack.pop();
    currentBlock = blockStack[blockStack.length - 1] || null;
}
let isBlockTreeEnabled = 1;
function setBlockTracking(value1) {
    isBlockTreeEnabled += value1;
}
function setupBlock(vnode) {
    vnode.dynamicChildren = isBlockTreeEnabled > 0 ? currentBlock || (0, _shared.EMPTY_ARR) : null;
    closeBlock();
    if (isBlockTreeEnabled > 0 && currentBlock) currentBlock.push(vnode);
    return vnode;
}
function createElementBlock(type, props, children, patchFlag, dynamicProps, shapeFlag) {
    return setupBlock(createBaseVNode(type, props, children, patchFlag, dynamicProps, shapeFlag, true));
}
function createBlock(type, props, children, patchFlag, dynamicProps) {
    return setupBlock(createVNode(type, props, children, patchFlag, dynamicProps, true));
}
function isVNode(value1) {
    return value1 ? value1.__v_isVNode === true : false;
}
function isSameVNodeType(n1, n2) {
    if (n2.shapeFlag & 6 && hmrDirtyComponents.has(n2.type)) {
        n1.shapeFlag &= -257;
        n2.shapeFlag &= -513;
        return false;
    }
    return n1.type === n2.type && n1.key === n2.key;
}
let vnodeArgsTransformer;
function transformVNodeArgs(transformer) {
    vnodeArgsTransformer = transformer;
}
const createVNodeWithArgsTransform = (...args)=>{
    return _createVNode(...vnodeArgsTransformer ? vnodeArgsTransformer(args, currentRenderingInstance) : args);
};
const InternalObjectKey = `__vInternal`;
const normalizeKey = ({ key })=>key != null ? key : null;
const normalizeRef = ({ ref, ref_key, ref_for })=>{
    if (typeof ref === "number") ref = "" + ref;
    return ref != null ? (0, _shared.isString)(ref) || (0, _reactivity.isRef)(ref) || (0, _shared.isFunction)(ref) ? {
        i: currentRenderingInstance,
        r: ref,
        k: ref_key,
        f: !!ref_for
    } : ref : null;
};
function createBaseVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, shapeFlag = type === Fragment ? 0 : 1, isBlockNode = false, needFullChildrenNormalization = false) {
    const vnode = {
        __v_isVNode: true,
        __v_skip: true,
        type,
        props,
        key: props && normalizeKey(props),
        ref: props && normalizeRef(props),
        scopeId: currentScopeId,
        slotScopeIds: null,
        children,
        component: null,
        suspense: null,
        ssContent: null,
        ssFallback: null,
        dirs: null,
        transition: null,
        el: null,
        anchor: null,
        target: null,
        targetAnchor: null,
        staticCount: 0,
        shapeFlag,
        patchFlag,
        dynamicProps,
        dynamicChildren: null,
        appContext: null,
        ctx: currentRenderingInstance
    };
    if (needFullChildrenNormalization) {
        normalizeChildren(vnode, children);
        if (shapeFlag & 128) type.normalize(vnode);
    } else if (children) vnode.shapeFlag |= (0, _shared.isString)(children) ? 8 : 16;
    if (vnode.key !== vnode.key) warn(`VNode created with invalid key (NaN). VNode type:`, vnode.type);
    if (isBlockTreeEnabled > 0 && // avoid a block node from tracking itself
    !isBlockNode && // has current parent block
    currentBlock && // presence of a patch flag indicates this node needs patching on updates.
    // component nodes also should always be patched, because even if the
    // component doesn't need to update, it needs to persist the instance on to
    // the next vnode so that it can be properly unmounted later.
    (vnode.patchFlag > 0 || shapeFlag & 6) && // the EVENTS flag is only for hydration and if it is the only flag, the
    // vnode should not be considered dynamic due to handler caching.
    vnode.patchFlag !== 32) currentBlock.push(vnode);
    return vnode;
}
const createVNode = createVNodeWithArgsTransform;
function _createVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {
    if (!type || type === NULL_DYNAMIC_COMPONENT) {
        if (!type) warn(`Invalid vnode type when creating vnode: ${type}.`);
        type = Comment;
    }
    if (isVNode(type)) {
        const cloned = cloneVNode(type, props, true);
        if (children) normalizeChildren(cloned, children);
        if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock) {
            if (cloned.shapeFlag & 6) currentBlock[currentBlock.indexOf(type)] = cloned;
            else currentBlock.push(cloned);
        }
        cloned.patchFlag |= -2;
        return cloned;
    }
    if (isClassComponent(type)) type = type.__vccOpts;
    if (props) {
        props = guardReactiveProps(props);
        let { class: klass, style } = props;
        if (klass && !(0, _shared.isString)(klass)) props.class = (0, _shared.normalizeClass)(klass);
        if ((0, _shared.isObject)(style)) {
            if ((0, _reactivity.isProxy)(style) && !(0, _shared.isArray)(style)) style = (0, _shared.extend)({}, style);
            props.style = (0, _shared.normalizeStyle)(style);
        }
    }
    const shapeFlag = (0, _shared.isString)(type) ? 1 : isSuspense(type) ? 128 : isTeleport(type) ? 64 : (0, _shared.isObject)(type) ? 4 : (0, _shared.isFunction)(type) ? 2 : 0;
    if (shapeFlag & 4 && (0, _reactivity.isProxy)(type)) {
        type = (0, _reactivity.toRaw)(type);
        warn(`Vue received a Component which was made a reactive object. This can lead to unnecessary performance overhead, and should be avoided by marking the component with \`markRaw\` or using \`shallowRef\` instead of \`ref\`.`, `
Component that was made reactive: `, type);
    }
    return createBaseVNode(type, props, children, patchFlag, dynamicProps, shapeFlag, isBlockNode, true);
}
function guardReactiveProps(props) {
    if (!props) return null;
    return (0, _reactivity.isProxy)(props) || InternalObjectKey in props ? (0, _shared.extend)({}, props) : props;
}
function cloneVNode(vnode, extraProps, mergeRef = false) {
    const { props, ref, patchFlag, children } = vnode;
    const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;
    const cloned = {
        __v_isVNode: true,
        __v_skip: true,
        type: vnode.type,
        props: mergedProps,
        key: mergedProps && normalizeKey(mergedProps),
        ref: extraProps && extraProps.ref ? // #2078 in the case of <component :is="vnode" ref="extra"/>
        // if the vnode itself already has a ref, cloneVNode will need to merge
        // the refs so the single vnode can be set on multiple refs
        mergeRef && ref ? (0, _shared.isArray)(ref) ? ref.concat(normalizeRef(extraProps)) : [
            ref,
            normalizeRef(extraProps)
        ] : normalizeRef(extraProps) : ref,
        scopeId: vnode.scopeId,
        slotScopeIds: vnode.slotScopeIds,
        children: patchFlag === -1 && (0, _shared.isArray)(children) ? children.map(deepCloneVNode) : children,
        target: vnode.target,
        targetAnchor: vnode.targetAnchor,
        staticCount: vnode.staticCount,
        shapeFlag: vnode.shapeFlag,
        // if the vnode is cloned with extra props, we can no longer assume its
        // existing patch flag to be reliable and need to add the FULL_PROPS flag.
        // note: preserve flag for fragments since they use the flag for children
        // fast paths only.
        patchFlag: extraProps && vnode.type !== Fragment ? patchFlag === -1 ? 16 : patchFlag | 16 : patchFlag,
        dynamicProps: vnode.dynamicProps,
        dynamicChildren: vnode.dynamicChildren,
        appContext: vnode.appContext,
        dirs: vnode.dirs,
        transition: vnode.transition,
        // These should technically only be non-null on mounted VNodes. However,
        // they *should* be copied for kept-alive vnodes. So we just always copy
        // them since them being non-null during a mount doesn't affect the logic as
        // they will simply be overwritten.
        component: vnode.component,
        suspense: vnode.suspense,
        ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),
        ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),
        el: vnode.el,
        anchor: vnode.anchor,
        ctx: vnode.ctx,
        ce: vnode.ce
    };
    return cloned;
}
function deepCloneVNode(vnode) {
    const cloned = cloneVNode(vnode);
    if ((0, _shared.isArray)(vnode.children)) cloned.children = vnode.children.map(deepCloneVNode);
    return cloned;
}
function createTextVNode(text = " ", flag = 0) {
    return createVNode(Text, null, text, flag);
}
function createStaticVNode(content, numberOfNodes) {
    const vnode = createVNode(Static, null, content);
    vnode.staticCount = numberOfNodes;
    return vnode;
}
function createCommentVNode(text = "", asBlock = false) {
    return asBlock ? (openBlock(), createBlock(Comment, null, text)) : createVNode(Comment, null, text);
}
function normalizeVNode(child) {
    if (child == null || typeof child === "boolean") return createVNode(Comment);
    else if ((0, _shared.isArray)(child)) return createVNode(Fragment, null, // #3666, avoid reference pollution when reusing vnode
    child.slice());
    else if (typeof child === "object") return cloneIfMounted(child);
    else return createVNode(Text, null, String(child));
}
function cloneIfMounted(child) {
    return child.el === null && child.patchFlag !== -1 || child.memo ? child : cloneVNode(child);
}
function normalizeChildren(vnode, children) {
    let type = 0;
    const { shapeFlag } = vnode;
    if (children == null) children = null;
    else if ((0, _shared.isArray)(children)) type = 16;
    else if (typeof children === "object") {
        if (shapeFlag & 65) {
            const slot = children.default;
            if (slot) {
                slot._c && (slot._d = false);
                normalizeChildren(vnode, slot());
                slot._c && (slot._d = true);
            }
            return;
        } else {
            type = 32;
            const slotFlag = children._;
            if (!slotFlag && !(InternalObjectKey in children)) children._ctx = currentRenderingInstance;
            else if (slotFlag === 3 && currentRenderingInstance) {
                if (currentRenderingInstance.slots._ === 1) children._ = 1;
                else {
                    children._ = 2;
                    vnode.patchFlag |= 1024;
                }
            }
        }
    } else if ((0, _shared.isFunction)(children)) {
        children = {
            default: children,
            _ctx: currentRenderingInstance
        };
        type = 32;
    } else {
        children = String(children);
        if (shapeFlag & 64) {
            type = 16;
            children = [
                createTextVNode(children)
            ];
        } else type = 8;
    }
    vnode.children = children;
    vnode.shapeFlag |= type;
}
function mergeProps(...args) {
    const ret = {};
    for(let i = 0; i < args.length; i++){
        const toMerge = args[i];
        for(const key in toMerge){
            if (key === "class") {
                if (ret.class !== toMerge.class) ret.class = (0, _shared.normalizeClass)([
                    ret.class,
                    toMerge.class
                ]);
            } else if (key === "style") ret.style = (0, _shared.normalizeStyle)([
                ret.style,
                toMerge.style
            ]);
            else if ((0, _shared.isOn)(key)) {
                const existing = ret[key];
                const incoming = toMerge[key];
                if (incoming && existing !== incoming && !((0, _shared.isArray)(existing) && existing.includes(incoming))) ret[key] = existing ? [].concat(existing, incoming) : incoming;
            } else if (key !== "") ret[key] = toMerge[key];
        }
    }
    return ret;
}
function invokeVNodeHook(hook, instance, vnode, prevVNode = null) {
    callWithAsyncErrorHandling(hook, instance, 7, [
        vnode,
        prevVNode
    ]);
}
const emptyAppContext = createAppContext();
let uid = 0;
function createComponentInstance(vnode, parent, suspense) {
    const type = vnode.type;
    const appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;
    const instance = {
        uid: uid++,
        vnode,
        type,
        parent,
        appContext,
        root: null,
        // to be immediately set
        next: null,
        subTree: null,
        // will be set synchronously right after creation
        effect: null,
        update: null,
        // will be set synchronously right after creation
        scope: new (0, _reactivity.EffectScope)(true),
        render: null,
        proxy: null,
        exposed: null,
        exposeProxy: null,
        withProxy: null,
        provides: parent ? parent.provides : Object.create(appContext.provides),
        accessCache: null,
        renderCache: [],
        // local resolved assets
        components: null,
        directives: null,
        // resolved props and emits options
        propsOptions: normalizePropsOptions(type, appContext),
        emitsOptions: normalizeEmitsOptions(type, appContext),
        // emit
        emit: null,
        // to be set immediately
        emitted: null,
        // props default value
        propsDefaults: (0, _shared.EMPTY_OBJ),
        // inheritAttrs
        inheritAttrs: type.inheritAttrs,
        // state
        ctx: (0, _shared.EMPTY_OBJ),
        data: (0, _shared.EMPTY_OBJ),
        props: (0, _shared.EMPTY_OBJ),
        attrs: (0, _shared.EMPTY_OBJ),
        slots: (0, _shared.EMPTY_OBJ),
        refs: (0, _shared.EMPTY_OBJ),
        setupState: (0, _shared.EMPTY_OBJ),
        setupContext: null,
        attrsProxy: null,
        slotsProxy: null,
        // suspense related
        suspense,
        suspenseId: suspense ? suspense.pendingId : 0,
        asyncDep: null,
        asyncResolved: false,
        // lifecycle hooks
        // not using enums here because it results in computed properties
        isMounted: false,
        isUnmounted: false,
        isDeactivated: false,
        bc: null,
        c: null,
        bm: null,
        m: null,
        bu: null,
        u: null,
        um: null,
        bum: null,
        da: null,
        a: null,
        rtg: null,
        rtc: null,
        ec: null,
        sp: null
    };
    instance.ctx = createDevRenderContext(instance);
    instance.root = parent ? parent.root : instance;
    instance.emit = emit.bind(null, instance);
    if (vnode.ce) vnode.ce(instance);
    return instance;
}
let currentInstance = null;
const getCurrentInstance = ()=>currentInstance || currentRenderingInstance;
let internalSetCurrentInstance;
let globalCurrentInstanceSetters;
let settersKey = "__VUE_INSTANCE_SETTERS__";
if (!(globalCurrentInstanceSetters = (0, _shared.getGlobalThis)()[settersKey])) globalCurrentInstanceSetters = (0, _shared.getGlobalThis)()[settersKey] = [];
globalCurrentInstanceSetters.push((i)=>currentInstance = i);
internalSetCurrentInstance = (instance)=>{
    if (globalCurrentInstanceSetters.length > 1) globalCurrentInstanceSetters.forEach((s)=>s(instance));
    else globalCurrentInstanceSetters[0](instance);
};
const setCurrentInstance = (instance)=>{
    internalSetCurrentInstance(instance);
    instance.scope.on();
};
const unsetCurrentInstance = ()=>{
    currentInstance && currentInstance.scope.off();
    internalSetCurrentInstance(null);
};
const isBuiltInTag = /* @__PURE__ */ (0, _shared.makeMap)("slot,component");
function validateComponentName(name, config) {
    const appIsNativeTag = config.isNativeTag || (0, _shared.NO);
    if (isBuiltInTag(name) || appIsNativeTag(name)) warn("Do not use built-in or reserved HTML elements as component id: " + name);
}
function isStatefulComponent(instance) {
    return instance.vnode.shapeFlag & 4;
}
let isInSSRComponentSetup = false;
function setupComponent(instance, isSSR = false) {
    isInSSRComponentSetup = isSSR;
    const { props, children } = instance.vnode;
    const isStateful = isStatefulComponent(instance);
    initProps(instance, props, isStateful, isSSR);
    initSlots(instance, children);
    const setupResult = isStateful ? setupStatefulComponent(instance, isSSR) : void 0;
    isInSSRComponentSetup = false;
    return setupResult;
}
function setupStatefulComponent(instance, isSSR) {
    var _a;
    const Component = instance.type;
    if (Component.name) validateComponentName(Component.name, instance.appContext.config);
    if (Component.components) {
        const names = Object.keys(Component.components);
        for(let i = 0; i < names.length; i++)validateComponentName(names[i], instance.appContext.config);
    }
    if (Component.directives) {
        const names = Object.keys(Component.directives);
        for(let i = 0; i < names.length; i++)validateDirectiveName(names[i]);
    }
    if (Component.compilerOptions && isRuntimeOnly()) warn(`"compilerOptions" is only supported when using a build of Vue that includes the runtime compiler. Since you are using a runtime-only build, the options should be passed via your build tool config instead.`);
    instance.accessCache = /* @__PURE__ */ Object.create(null);
    instance.proxy = (0, _reactivity.markRaw)(new Proxy(instance.ctx, PublicInstanceProxyHandlers));
    exposePropsOnRenderContext(instance);
    const { setup } = Component;
    if (setup) {
        const setupContext = instance.setupContext = setup.length > 1 ? createSetupContext(instance) : null;
        setCurrentInstance(instance);
        (0, _reactivity.pauseTracking)();
        const setupResult = callWithErrorHandling(setup, instance, 0, [
            (0, _reactivity.shallowReadonly)(instance.props),
            setupContext
        ]);
        (0, _reactivity.resetTracking)();
        unsetCurrentInstance();
        if ((0, _shared.isPromise)(setupResult)) {
            setupResult.then(unsetCurrentInstance, unsetCurrentInstance);
            if (isSSR) return setupResult.then((resolvedResult)=>{
                handleSetupResult(instance, resolvedResult, isSSR);
            }).catch((e)=>{
                handleError(e, instance, 0);
            });
            else {
                instance.asyncDep = setupResult;
                if (!instance.suspense) {
                    const name = (_a = Component.name) != null ? _a : "Anonymous";
                    warn(`Component <${name}>: setup function returned a promise, but no <Suspense> boundary was found in the parent component tree. A component with async setup() must be nested in a <Suspense> in order to be rendered.`);
                }
            }
        } else handleSetupResult(instance, setupResult, isSSR);
    } else finishComponentSetup(instance, isSSR);
}
function handleSetupResult(instance, setupResult, isSSR) {
    if ((0, _shared.isFunction)(setupResult)) {
        if (instance.type.__ssrInlineRender) instance.ssrRender = setupResult;
        else instance.render = setupResult;
    } else if ((0, _shared.isObject)(setupResult)) {
        if (isVNode(setupResult)) warn(`setup() should not return VNodes directly - return a render function instead.`);
        instance.devtoolsRawSetupState = setupResult;
        instance.setupState = (0, _reactivity.proxyRefs)(setupResult);
        exposeSetupStateOnRenderContext(instance);
    } else if (setupResult !== void 0) warn(`setup() should return an object. Received: ${setupResult === null ? "null" : typeof setupResult}`);
    finishComponentSetup(instance, isSSR);
}
let compile;
let installWithProxy;
function registerRuntimeCompiler(_compile) {
    compile = _compile;
    installWithProxy = (i)=>{
        if (i.render._rc) i.withProxy = new Proxy(i.ctx, RuntimeCompiledPublicInstanceProxyHandlers);
    };
}
const isRuntimeOnly = ()=>!compile;
function finishComponentSetup(instance, isSSR, skipOptions) {
    const Component = instance.type;
    if (!instance.render) {
        if (!isSSR && compile && !Component.render) {
            const template = Component.template || resolveMergedOptions(instance).template;
            if (template) {
                startMeasure(instance, `compile`);
                const { isCustomElement, compilerOptions } = instance.appContext.config;
                const { delimiters, compilerOptions: componentCompilerOptions } = Component;
                const finalCompilerOptions = (0, _shared.extend)((0, _shared.extend)({
                    isCustomElement,
                    delimiters
                }, compilerOptions), componentCompilerOptions);
                Component.render = compile(template, finalCompilerOptions);
                endMeasure(instance, `compile`);
            }
        }
        instance.render = Component.render || (0, _shared.NOOP);
        if (installWithProxy) installWithProxy(instance);
    }
    if (__VUE_OPTIONS_API__ && true) {
        setCurrentInstance(instance);
        (0, _reactivity.pauseTracking)();
        applyOptions(instance);
        (0, _reactivity.resetTracking)();
        unsetCurrentInstance();
    }
    if (!Component.render && instance.render === (0, _shared.NOOP) && !isSSR) {
        if (!compile && Component.template) warn(`Component provided template option but runtime compilation is not supported in this build of Vue.` + ` Configure your bundler to alias "vue" to "vue/dist/vue.esm-bundler.js".`);
        else warn(`Component is missing template or render function.`);
    }
}
function getAttrsProxy(instance) {
    return instance.attrsProxy || (instance.attrsProxy = new Proxy(instance.attrs, {
        get (target, key) {
            markAttrsAccessed();
            (0, _reactivity.track)(instance, "get", "$attrs");
            return target[key];
        },
        set () {
            warn(`setupContext.attrs is readonly.`);
            return false;
        },
        deleteProperty () {
            warn(`setupContext.attrs is readonly.`);
            return false;
        }
    }));
}
function getSlotsProxy(instance) {
    return instance.slotsProxy || (instance.slotsProxy = new Proxy(instance.slots, {
        get (target, key) {
            (0, _reactivity.track)(instance, "get", "$slots");
            return target[key];
        }
    }));
}
function createSetupContext(instance) {
    const expose = (exposed)=>{
        if (instance.exposed) warn(`expose() should be called only once per setup().`);
        if (exposed != null) {
            let exposedType = typeof exposed;
            if (exposedType === "object") {
                if ((0, _shared.isArray)(exposed)) exposedType = "array";
                else if ((0, _reactivity.isRef)(exposed)) exposedType = "ref";
            }
            if (exposedType !== "object") warn(`expose() should be passed a plain object, received ${exposedType}.`);
        }
        instance.exposed = exposed || {};
    };
    return Object.freeze({
        get attrs () {
            return getAttrsProxy(instance);
        },
        get slots () {
            return getSlotsProxy(instance);
        },
        get emit () {
            return (event, ...args)=>instance.emit(event, ...args);
        },
        expose
    });
}
function getExposeProxy(instance) {
    if (instance.exposed) return instance.exposeProxy || (instance.exposeProxy = new Proxy((0, _reactivity.proxyRefs)((0, _reactivity.markRaw)(instance.exposed)), {
        get (target, key) {
            if (key in target) return target[key];
            else if (key in publicPropertiesMap) return publicPropertiesMap[key](instance);
        },
        has (target, key) {
            return key in target || key in publicPropertiesMap;
        }
    }));
}
const classifyRE = /(?:^|[-_])(\w)/g;
const classify = (str)=>str.replace(classifyRE, (c)=>c.toUpperCase()).replace(/[-_]/g, "");
function getComponentName(Component, includeInferred = true) {
    return (0, _shared.isFunction)(Component) ? Component.displayName || Component.name : Component.name || includeInferred && Component.__name;
}
function formatComponentName(instance, Component, isRoot = false) {
    let name = getComponentName(Component);
    if (!name && Component.__file) {
        const match = Component.__file.match(/([^/\\]+)\.\w+$/);
        if (match) name = match[1];
    }
    if (!name && instance && instance.parent) {
        const inferFromRegistry = (registry)=>{
            for(const key in registry){
                if (registry[key] === Component) return key;
            }
        };
        name = inferFromRegistry(instance.components || instance.parent.type.components) || inferFromRegistry(instance.appContext.components);
    }
    return name ? classify(name) : isRoot ? `App` : `Anonymous`;
}
function isClassComponent(value1) {
    return (0, _shared.isFunction)(value1) && "__vccOpts" in value1;
}
const computed = (getterOrOptions, debugOptions)=>{
    return (0, _reactivity.computed)(getterOrOptions, debugOptions, isInSSRComponentSetup);
};
function h(type, propsOrChildren, children) {
    const l = arguments.length;
    if (l === 2) {
        if ((0, _shared.isObject)(propsOrChildren) && !(0, _shared.isArray)(propsOrChildren)) {
            if (isVNode(propsOrChildren)) return createVNode(type, null, [
                propsOrChildren
            ]);
            return createVNode(type, propsOrChildren);
        } else return createVNode(type, null, propsOrChildren);
    } else {
        if (l > 3) children = Array.prototype.slice.call(arguments, 2);
        else if (l === 3 && isVNode(children)) children = [
            children
        ];
        return createVNode(type, propsOrChildren, children);
    }
}
const ssrContextKey = Symbol.for("v-scx");
const useSSRContext = ()=>{
    {
        const ctx = inject(ssrContextKey);
        if (!ctx) warn(`Server rendering context not provided. Make sure to only call useSSRContext() conditionally in the server build.`);
        return ctx;
    }
};
function isShallow(value1) {
    return !!(value1 && value1["__v_isShallow"]);
}
function initCustomFormatter() {
    if (typeof window === "undefined") return;
    const vueStyle = {
        style: "color:#3ba776"
    };
    const numberStyle = {
        style: "color:#0b1bc9"
    };
    const stringStyle = {
        style: "color:#b62e24"
    };
    const keywordStyle = {
        style: "color:#9d288c"
    };
    const formatter = {
        header (obj) {
            if (!(0, _shared.isObject)(obj)) return null;
            if (obj.__isVue) return [
                "div",
                vueStyle,
                `VueInstance`
            ];
            else if ((0, _reactivity.isRef)(obj)) return [
                "div",
                {},
                [
                    "span",
                    vueStyle,
                    genRefFlag(obj)
                ],
                "<",
                formatValue(obj.value),
                `>`
            ];
            else if ((0, _reactivity.isReactive)(obj)) return [
                "div",
                {},
                [
                    "span",
                    vueStyle,
                    isShallow(obj) ? "ShallowReactive" : "Reactive"
                ],
                "<",
                formatValue(obj),
                `>${(0, _reactivity.isReadonly)(obj) ? ` (readonly)` : ``}`
            ];
            else if ((0, _reactivity.isReadonly)(obj)) return [
                "div",
                {},
                [
                    "span",
                    vueStyle,
                    isShallow(obj) ? "ShallowReadonly" : "Readonly"
                ],
                "<",
                formatValue(obj),
                ">"
            ];
            return null;
        },
        hasBody (obj) {
            return obj && obj.__isVue;
        },
        body (obj) {
            if (obj && obj.__isVue) return [
                "div",
                {},
                ...formatInstance(obj.$)
            ];
        }
    };
    function formatInstance(instance) {
        const blocks = [];
        if (instance.type.props && instance.props) blocks.push(createInstanceBlock("props", (0, _reactivity.toRaw)(instance.props)));
        if (instance.setupState !== (0, _shared.EMPTY_OBJ)) blocks.push(createInstanceBlock("setup", instance.setupState));
        if (instance.data !== (0, _shared.EMPTY_OBJ)) blocks.push(createInstanceBlock("data", (0, _reactivity.toRaw)(instance.data)));
        const computed = extractKeys(instance, "computed");
        if (computed) blocks.push(createInstanceBlock("computed", computed));
        const injected = extractKeys(instance, "inject");
        if (injected) blocks.push(createInstanceBlock("injected", injected));
        blocks.push([
            "div",
            {},
            [
                "span",
                {
                    style: keywordStyle.style + ";opacity:0.66"
                },
                "$ (internal): "
            ],
            [
                "object",
                {
                    object: instance
                }
            ]
        ]);
        return blocks;
    }
    function createInstanceBlock(type, target) {
        target = (0, _shared.extend)({}, target);
        if (!Object.keys(target).length) return [
            "span",
            {}
        ];
        return [
            "div",
            {
                style: "line-height:1.25em;margin-bottom:0.6em"
            },
            [
                "div",
                {
                    style: "color:#476582"
                },
                type
            ],
            [
                "div",
                {
                    style: "padding-left:1.25em"
                },
                ...Object.keys(target).map((key)=>{
                    return [
                        "div",
                        {},
                        [
                            "span",
                            keywordStyle,
                            key + ": "
                        ],
                        formatValue(target[key], false)
                    ];
                })
            ]
        ];
    }
    function formatValue(v1, asRaw = true) {
        if (typeof v1 === "number") return [
            "span",
            numberStyle,
            v1
        ];
        else if (typeof v1 === "string") return [
            "span",
            stringStyle,
            JSON.stringify(v1)
        ];
        else if (typeof v1 === "boolean") return [
            "span",
            keywordStyle,
            v1
        ];
        else if ((0, _shared.isObject)(v1)) return [
            "object",
            {
                object: asRaw ? (0, _reactivity.toRaw)(v1) : v1
            }
        ];
        else return [
            "span",
            stringStyle,
            String(v1)
        ];
    }
    function extractKeys(instance, type) {
        const Comp = instance.type;
        if ((0, _shared.isFunction)(Comp)) return;
        const extracted = {};
        for(const key in instance.ctx)if (isKeyOfType(Comp, key, type)) extracted[key] = instance.ctx[key];
        return extracted;
    }
    function isKeyOfType(Comp, key, type) {
        const opts = Comp[type];
        if ((0, _shared.isArray)(opts) && opts.includes(key) || (0, _shared.isObject)(opts) && key in opts) return true;
        if (Comp.extends && isKeyOfType(Comp.extends, key, type)) return true;
        if (Comp.mixins && Comp.mixins.some((m)=>isKeyOfType(m, key, type))) return true;
    }
    function genRefFlag(v1) {
        if (isShallow(v1)) return `ShallowRef`;
        if (v1.effect) return `ComputedRef`;
        return `Ref`;
    }
    if (window.devtoolsFormatters) window.devtoolsFormatters.push(formatter);
    else window.devtoolsFormatters = [
        formatter
    ];
}
function withMemo(memo, render, cache, index) {
    const cached = cache[index];
    if (cached && isMemoSame(cached, memo)) return cached;
    const ret = render();
    ret.memo = memo.slice();
    return cache[index] = ret;
}
function isMemoSame(cached, memo) {
    const prev = cached.memo;
    if (prev.length != memo.length) return false;
    for(let i = 0; i < prev.length; i++){
        if ((0, _shared.hasChanged)(prev[i], memo[i])) return false;
    }
    if (isBlockTreeEnabled > 0 && currentBlock) currentBlock.push(cached);
    return true;
}
const version = "3.3.4";
const _ssrUtils = {
    createComponentInstance,
    setupComponent,
    renderComponentRoot,
    setCurrentRenderingInstance,
    isVNode: isVNode,
    normalizeVNode
};
const ssrUtils = _ssrUtils;
const resolveFilter = null;
const compatUtils = null;

},{"@vue/reactivity":"fQHlL","@vue/shared":"5YL8y","@parcel/transformer-js/src/esmodule-helpers.js":"boKlo"}],"fQHlL":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "EffectScope", ()=>EffectScope);
parcelHelpers.export(exports, "ITERATE_KEY", ()=>ITERATE_KEY);
parcelHelpers.export(exports, "ReactiveEffect", ()=>ReactiveEffect);
parcelHelpers.export(exports, "computed", ()=>computed);
parcelHelpers.export(exports, "customRef", ()=>customRef);
parcelHelpers.export(exports, "deferredComputed", ()=>deferredComputed);
parcelHelpers.export(exports, "effect", ()=>effect);
parcelHelpers.export(exports, "effectScope", ()=>effectScope);
parcelHelpers.export(exports, "enableTracking", ()=>enableTracking);
parcelHelpers.export(exports, "getCurrentScope", ()=>getCurrentScope);
parcelHelpers.export(exports, "isProxy", ()=>isProxy);
parcelHelpers.export(exports, "isReactive", ()=>isReactive);
parcelHelpers.export(exports, "isReadonly", ()=>isReadonly);
parcelHelpers.export(exports, "isRef", ()=>isRef);
parcelHelpers.export(exports, "isShallow", ()=>isShallow);
parcelHelpers.export(exports, "markRaw", ()=>markRaw);
parcelHelpers.export(exports, "onScopeDispose", ()=>onScopeDispose);
parcelHelpers.export(exports, "pauseTracking", ()=>pauseTracking);
parcelHelpers.export(exports, "proxyRefs", ()=>proxyRefs);
parcelHelpers.export(exports, "reactive", ()=>reactive);
parcelHelpers.export(exports, "readonly", ()=>readonly);
parcelHelpers.export(exports, "ref", ()=>ref);
parcelHelpers.export(exports, "resetTracking", ()=>resetTracking);
parcelHelpers.export(exports, "shallowReactive", ()=>shallowReactive);
parcelHelpers.export(exports, "shallowReadonly", ()=>shallowReadonly);
parcelHelpers.export(exports, "shallowRef", ()=>shallowRef);
parcelHelpers.export(exports, "stop", ()=>stop);
parcelHelpers.export(exports, "toRaw", ()=>toRaw);
parcelHelpers.export(exports, "toRef", ()=>toRef);
parcelHelpers.export(exports, "toRefs", ()=>toRefs);
parcelHelpers.export(exports, "toValue", ()=>toValue);
parcelHelpers.export(exports, "track", ()=>track);
parcelHelpers.export(exports, "trigger", ()=>trigger);
parcelHelpers.export(exports, "triggerRef", ()=>triggerRef);
parcelHelpers.export(exports, "unref", ()=>unref);
var _shared = require("@vue/shared");
function warn(msg, ...args) {
    console.warn(`[Vue warn] ${msg}`, ...args);
}
let activeEffectScope;
class EffectScope {
    constructor(detached = false){
        this.detached = detached;
        /**
     * @internal
     */ this._active = true;
        /**
     * @internal
     */ this.effects = [];
        /**
     * @internal
     */ this.cleanups = [];
        this.parent = activeEffectScope;
        if (!detached && activeEffectScope) this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(this) - 1;
    }
    get active() {
        return this._active;
    }
    run(fn) {
        if (this._active) {
            const currentEffectScope = activeEffectScope;
            try {
                activeEffectScope = this;
                return fn();
            } finally{
                activeEffectScope = currentEffectScope;
            }
        } else warn(`cannot run an inactive effect scope.`);
    }
    /**
   * This should only be called on non-detached scopes
   * @internal
   */ on() {
        activeEffectScope = this;
    }
    /**
   * This should only be called on non-detached scopes
   * @internal
   */ off() {
        activeEffectScope = this.parent;
    }
    stop(fromParent) {
        if (this._active) {
            let i, l;
            for(i = 0, l = this.effects.length; i < l; i++)this.effects[i].stop();
            for(i = 0, l = this.cleanups.length; i < l; i++)this.cleanups[i]();
            if (this.scopes) for(i = 0, l = this.scopes.length; i < l; i++)this.scopes[i].stop(true);
            if (!this.detached && this.parent && !fromParent) {
                const last = this.parent.scopes.pop();
                if (last && last !== this) {
                    this.parent.scopes[this.index] = last;
                    last.index = this.index;
                }
            }
            this.parent = void 0;
            this._active = false;
        }
    }
}
function effectScope(detached) {
    return new EffectScope(detached);
}
function recordEffectScope(effect, scope = activeEffectScope) {
    if (scope && scope.active) scope.effects.push(effect);
}
function getCurrentScope() {
    return activeEffectScope;
}
function onScopeDispose(fn) {
    if (activeEffectScope) activeEffectScope.cleanups.push(fn);
    else warn(`onScopeDispose() is called when there is no active effect scope to be associated with.`);
}
const createDep = (effects)=>{
    const dep = new Set(effects);
    dep.w = 0;
    dep.n = 0;
    return dep;
};
const wasTracked = (dep)=>(dep.w & trackOpBit) > 0;
const newTracked = (dep)=>(dep.n & trackOpBit) > 0;
const initDepMarkers = ({ deps })=>{
    if (deps.length) for(let i = 0; i < deps.length; i++)deps[i].w |= trackOpBit;
};
const finalizeDepMarkers = (effect)=>{
    const { deps } = effect;
    if (deps.length) {
        let ptr = 0;
        for(let i = 0; i < deps.length; i++){
            const dep = deps[i];
            if (wasTracked(dep) && !newTracked(dep)) dep.delete(effect);
            else deps[ptr++] = dep;
            dep.w &= ~trackOpBit;
            dep.n &= ~trackOpBit;
        }
        deps.length = ptr;
    }
};
const targetMap = /* @__PURE__ */ new WeakMap();
let effectTrackDepth = 0;
let trackOpBit = 1;
const maxMarkerBits = 30;
let activeEffect;
const ITERATE_KEY = Symbol("iterate");
const MAP_KEY_ITERATE_KEY = Symbol("Map key iterate");
class ReactiveEffect {
    constructor(fn, scheduler = null, scope){
        this.fn = fn;
        this.scheduler = scheduler;
        this.active = true;
        this.deps = [];
        this.parent = void 0;
        recordEffectScope(this, scope);
    }
    run() {
        if (!this.active) return this.fn();
        let parent = activeEffect;
        let lastShouldTrack = shouldTrack;
        while(parent){
            if (parent === this) return;
            parent = parent.parent;
        }
        try {
            this.parent = activeEffect;
            activeEffect = this;
            shouldTrack = true;
            trackOpBit = 1 << ++effectTrackDepth;
            if (effectTrackDepth <= maxMarkerBits) initDepMarkers(this);
            else cleanupEffect(this);
            return this.fn();
        } finally{
            if (effectTrackDepth <= maxMarkerBits) finalizeDepMarkers(this);
            trackOpBit = 1 << --effectTrackDepth;
            activeEffect = this.parent;
            shouldTrack = lastShouldTrack;
            this.parent = void 0;
            if (this.deferStop) this.stop();
        }
    }
    stop() {
        if (activeEffect === this) this.deferStop = true;
        else if (this.active) {
            cleanupEffect(this);
            if (this.onStop) this.onStop();
            this.active = false;
        }
    }
}
function cleanupEffect(effect2) {
    const { deps } = effect2;
    if (deps.length) {
        for(let i = 0; i < deps.length; i++)deps[i].delete(effect2);
        deps.length = 0;
    }
}
function effect(fn, options) {
    if (fn.effect) fn = fn.effect.fn;
    const _effect = new ReactiveEffect(fn);
    if (options) {
        (0, _shared.extend)(_effect, options);
        if (options.scope) recordEffectScope(_effect, options.scope);
    }
    if (!options || !options.lazy) _effect.run();
    const runner = _effect.run.bind(_effect);
    runner.effect = _effect;
    return runner;
}
function stop(runner) {
    runner.effect.stop();
}
let shouldTrack = true;
const trackStack = [];
function pauseTracking() {
    trackStack.push(shouldTrack);
    shouldTrack = false;
}
function enableTracking() {
    trackStack.push(shouldTrack);
    shouldTrack = true;
}
function resetTracking() {
    const last = trackStack.pop();
    shouldTrack = last === void 0 ? true : last;
}
function track(target, type, key) {
    if (shouldTrack && activeEffect) {
        let depsMap = targetMap.get(target);
        if (!depsMap) targetMap.set(target, depsMap = /* @__PURE__ */ new Map());
        let dep = depsMap.get(key);
        if (!dep) depsMap.set(key, dep = createDep());
        const eventInfo = {
            effect: activeEffect,
            target,
            type,
            key
        };
        trackEffects(dep, eventInfo);
    }
}
function trackEffects(dep, debuggerEventExtraInfo) {
    let shouldTrack2 = false;
    if (effectTrackDepth <= maxMarkerBits) {
        if (!newTracked(dep)) {
            dep.n |= trackOpBit;
            shouldTrack2 = !wasTracked(dep);
        }
    } else shouldTrack2 = !dep.has(activeEffect);
    if (shouldTrack2) {
        dep.add(activeEffect);
        activeEffect.deps.push(dep);
        if (0, activeEffect.onTrack) activeEffect.onTrack((0, _shared.extend)({
            effect: activeEffect
        }, debuggerEventExtraInfo));
    }
}
function trigger(target, type, key, newValue, oldValue, oldTarget) {
    const depsMap = targetMap.get(target);
    if (!depsMap) return;
    let deps = [];
    if (type === "clear") deps = [
        ...depsMap.values()
    ];
    else if (key === "length" && (0, _shared.isArray)(target)) {
        const newLength = Number(newValue);
        depsMap.forEach((dep, key2)=>{
            if (key2 === "length" || key2 >= newLength) deps.push(dep);
        });
    } else {
        if (key !== void 0) deps.push(depsMap.get(key));
        switch(type){
            case "add":
                if (!(0, _shared.isArray)(target)) {
                    deps.push(depsMap.get(ITERATE_KEY));
                    if ((0, _shared.isMap)(target)) deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
                } else if ((0, _shared.isIntegerKey)(key)) deps.push(depsMap.get("length"));
                break;
            case "delete":
                if (!(0, _shared.isArray)(target)) {
                    deps.push(depsMap.get(ITERATE_KEY));
                    if ((0, _shared.isMap)(target)) deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
                }
                break;
            case "set":
                if ((0, _shared.isMap)(target)) deps.push(depsMap.get(ITERATE_KEY));
                break;
        }
    }
    const eventInfo = {
        target,
        type,
        key,
        newValue,
        oldValue,
        oldTarget
    };
    if (deps.length === 1) {
        if (deps[0]) triggerEffects(deps[0], eventInfo);
    } else {
        const effects = [];
        for (const dep of deps)if (dep) effects.push(...dep);
        triggerEffects(createDep(effects), eventInfo);
    }
}
function triggerEffects(dep, debuggerEventExtraInfo) {
    const effects = (0, _shared.isArray)(dep) ? dep : [
        ...dep
    ];
    for (const effect2 of effects)if (effect2.computed) triggerEffect(effect2, debuggerEventExtraInfo);
    for (const effect2 of effects)if (!effect2.computed) triggerEffect(effect2, debuggerEventExtraInfo);
}
function triggerEffect(effect2, debuggerEventExtraInfo) {
    if (effect2 !== activeEffect || effect2.allowRecurse) {
        if (0, effect2.onTrigger) effect2.onTrigger((0, _shared.extend)({
            effect: effect2
        }, debuggerEventExtraInfo));
        if (effect2.scheduler) effect2.scheduler();
        else effect2.run();
    }
}
function getDepFromReactive(object, key) {
    var _a;
    return (_a = targetMap.get(object)) == null ? void 0 : _a.get(key);
}
const isNonTrackableKeys = /* @__PURE__ */ (0, _shared.makeMap)(`__proto__,__v_isRef,__isVue`);
const builtInSymbols = new Set(/* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((key)=>key !== "arguments" && key !== "caller").map((key)=>Symbol[key]).filter((0, _shared.isSymbol)));
const get$1 = /* @__PURE__ */ createGetter();
const shallowGet = /* @__PURE__ */ createGetter(false, true);
const readonlyGet = /* @__PURE__ */ createGetter(true);
const shallowReadonlyGet = /* @__PURE__ */ createGetter(true, true);
const arrayInstrumentations = /* @__PURE__ */ createArrayInstrumentations();
function createArrayInstrumentations() {
    const instrumentations = {};
    [
        "includes",
        "indexOf",
        "lastIndexOf"
    ].forEach((key)=>{
        instrumentations[key] = function(...args) {
            const arr = toRaw(this);
            for(let i = 0, l = this.length; i < l; i++)track(arr, "get", i + "");
            const res = arr[key](...args);
            if (res === -1 || res === false) return arr[key](...args.map(toRaw));
            else return res;
        };
    });
    [
        "push",
        "pop",
        "shift",
        "unshift",
        "splice"
    ].forEach((key)=>{
        instrumentations[key] = function(...args) {
            pauseTracking();
            const res = toRaw(this)[key].apply(this, args);
            resetTracking();
            return res;
        };
    });
    return instrumentations;
}
function hasOwnProperty(key) {
    const obj = toRaw(this);
    track(obj, "has", key);
    return obj.hasOwnProperty(key);
}
function createGetter(isReadonly2 = false, shallow = false) {
    return function get2(target, key, receiver) {
        if (key === "__v_isReactive") return !isReadonly2;
        else if (key === "__v_isReadonly") return isReadonly2;
        else if (key === "__v_isShallow") return shallow;
        else if (key === "__v_raw" && receiver === (isReadonly2 ? shallow ? shallowReadonlyMap : readonlyMap : shallow ? shallowReactiveMap : reactiveMap).get(target)) return target;
        const targetIsArray = (0, _shared.isArray)(target);
        if (!isReadonly2) {
            if (targetIsArray && (0, _shared.hasOwn)(arrayInstrumentations, key)) return Reflect.get(arrayInstrumentations, key, receiver);
            if (key === "hasOwnProperty") return hasOwnProperty;
        }
        const res = Reflect.get(target, key, receiver);
        if ((0, _shared.isSymbol)(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) return res;
        if (!isReadonly2) track(target, "get", key);
        if (shallow) return res;
        if (isRef(res)) return targetIsArray && (0, _shared.isIntegerKey)(key) ? res : res.value;
        if ((0, _shared.isObject)(res)) return isReadonly2 ? readonly(res) : reactive(res);
        return res;
    };
}
const set$1 = /* @__PURE__ */ createSetter();
const shallowSet = /* @__PURE__ */ createSetter(true);
function createSetter(shallow = false) {
    return function set2(target, key, value, receiver) {
        let oldValue = target[key];
        if (isReadonly(oldValue) && isRef(oldValue) && !isRef(value)) return false;
        if (!shallow) {
            if (!isShallow(value) && !isReadonly(value)) {
                oldValue = toRaw(oldValue);
                value = toRaw(value);
            }
            if (!(0, _shared.isArray)(target) && isRef(oldValue) && !isRef(value)) {
                oldValue.value = value;
                return true;
            }
        }
        const hadKey = (0, _shared.isArray)(target) && (0, _shared.isIntegerKey)(key) ? Number(key) < target.length : (0, _shared.hasOwn)(target, key);
        const result = Reflect.set(target, key, value, receiver);
        if (target === toRaw(receiver)) {
            if (!hadKey) trigger(target, "add", key, value);
            else if ((0, _shared.hasChanged)(value, oldValue)) trigger(target, "set", key, value, oldValue);
        }
        return result;
    };
}
function deleteProperty(target, key) {
    const hadKey = (0, _shared.hasOwn)(target, key);
    const oldValue = target[key];
    const result = Reflect.deleteProperty(target, key);
    if (result && hadKey) trigger(target, "delete", key, void 0, oldValue);
    return result;
}
function has$1(target, key) {
    const result = Reflect.has(target, key);
    if (!(0, _shared.isSymbol)(key) || !builtInSymbols.has(key)) track(target, "has", key);
    return result;
}
function ownKeys(target) {
    track(target, "iterate", (0, _shared.isArray)(target) ? "length" : ITERATE_KEY);
    return Reflect.ownKeys(target);
}
const mutableHandlers = {
    get: get$1,
    set: set$1,
    deleteProperty,
    has: has$1,
    ownKeys
};
const readonlyHandlers = {
    get: readonlyGet,
    set (target, key) {
        warn(`Set operation on key "${String(key)}" failed: target is readonly.`, target);
        return true;
    },
    deleteProperty (target, key) {
        warn(`Delete operation on key "${String(key)}" failed: target is readonly.`, target);
        return true;
    }
};
const shallowReactiveHandlers = /* @__PURE__ */ (0, _shared.extend)({}, mutableHandlers, {
    get: shallowGet,
    set: shallowSet
});
const shallowReadonlyHandlers = /* @__PURE__ */ (0, _shared.extend)({}, readonlyHandlers, {
    get: shallowReadonlyGet
});
const toShallow = (value)=>value;
const getProto = (v)=>Reflect.getPrototypeOf(v);
function get(target, key, isReadonly = false, isShallow = false) {
    target = target["__v_raw"];
    const rawTarget = toRaw(target);
    const rawKey = toRaw(key);
    if (!isReadonly) {
        if (key !== rawKey) track(rawTarget, "get", key);
        track(rawTarget, "get", rawKey);
    }
    const { has: has2 } = getProto(rawTarget);
    const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;
    if (has2.call(rawTarget, key)) return wrap(target.get(key));
    else if (has2.call(rawTarget, rawKey)) return wrap(target.get(rawKey));
    else if (target !== rawTarget) target.get(key);
}
function has(key, isReadonly = false) {
    const target = this["__v_raw"];
    const rawTarget = toRaw(target);
    const rawKey = toRaw(key);
    if (!isReadonly) {
        if (key !== rawKey) track(rawTarget, "has", key);
        track(rawTarget, "has", rawKey);
    }
    return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);
}
function size(target, isReadonly = false) {
    target = target["__v_raw"];
    !isReadonly && track(toRaw(target), "iterate", ITERATE_KEY);
    return Reflect.get(target, "size", target);
}
function add(value) {
    value = toRaw(value);
    const target = toRaw(this);
    const proto = getProto(target);
    const hadKey = proto.has.call(target, value);
    if (!hadKey) {
        target.add(value);
        trigger(target, "add", value, value);
    }
    return this;
}
function set(key, value) {
    value = toRaw(value);
    const target = toRaw(this);
    const { has: has2, get: get2 } = getProto(target);
    let hadKey = has2.call(target, key);
    if (!hadKey) {
        key = toRaw(key);
        hadKey = has2.call(target, key);
    } else checkIdentityKeys(target, has2, key);
    const oldValue = get2.call(target, key);
    target.set(key, value);
    if (!hadKey) trigger(target, "add", key, value);
    else if ((0, _shared.hasChanged)(value, oldValue)) trigger(target, "set", key, value, oldValue);
    return this;
}
function deleteEntry(key) {
    const target = toRaw(this);
    const { has: has2, get: get2 } = getProto(target);
    let hadKey = has2.call(target, key);
    if (!hadKey) {
        key = toRaw(key);
        hadKey = has2.call(target, key);
    } else checkIdentityKeys(target, has2, key);
    const oldValue = get2 ? get2.call(target, key) : void 0;
    const result = target.delete(key);
    if (hadKey) trigger(target, "delete", key, void 0, oldValue);
    return result;
}
function clear() {
    const target = toRaw(this);
    const hadItems = target.size !== 0;
    const oldTarget = (0, _shared.isMap)(target) ? new Map(target) : new Set(target);
    const result = target.clear();
    if (hadItems) trigger(target, "clear", void 0, void 0, oldTarget);
    return result;
}
function createForEach(isReadonly, isShallow) {
    return function forEach(callback, thisArg) {
        const observed = this;
        const target = observed["__v_raw"];
        const rawTarget = toRaw(target);
        const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;
        !isReadonly && track(rawTarget, "iterate", ITERATE_KEY);
        return target.forEach((value, key)=>{
            return callback.call(thisArg, wrap(value), wrap(key), observed);
        });
    };
}
function createIterableMethod(method, isReadonly, isShallow) {
    return function(...args) {
        const target = this["__v_raw"];
        const rawTarget = toRaw(target);
        const targetIsMap = (0, _shared.isMap)(rawTarget);
        const isPair = method === "entries" || method === Symbol.iterator && targetIsMap;
        const isKeyOnly = method === "keys" && targetIsMap;
        const innerIterator = target[method](...args);
        const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;
        !isReadonly && track(rawTarget, "iterate", isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY);
        return {
            // iterator protocol
            next () {
                const { value, done } = innerIterator.next();
                return done ? {
                    value,
                    done
                } : {
                    value: isPair ? [
                        wrap(value[0]),
                        wrap(value[1])
                    ] : wrap(value),
                    done
                };
            },
            // iterable protocol
            [Symbol.iterator] () {
                return this;
            }
        };
    };
}
function createReadonlyMethod(type) {
    return function(...args) {
        {
            const key = args[0] ? `on key "${args[0]}" ` : ``;
            console.warn(`${(0, _shared.capitalize)(type)} operation ${key}failed: target is readonly.`, toRaw(this));
        }
        return type === "delete" ? false : this;
    };
}
function createInstrumentations() {
    const mutableInstrumentations2 = {
        get (key) {
            return get(this, key);
        },
        get size () {
            return size(this);
        },
        has,
        add,
        set,
        delete: deleteEntry,
        clear,
        forEach: createForEach(false, false)
    };
    const shallowInstrumentations2 = {
        get (key) {
            return get(this, key, false, true);
        },
        get size () {
            return size(this);
        },
        has,
        add,
        set,
        delete: deleteEntry,
        clear,
        forEach: createForEach(false, true)
    };
    const readonlyInstrumentations2 = {
        get (key) {
            return get(this, key, true);
        },
        get size () {
            return size(this, true);
        },
        has (key) {
            return has.call(this, key, true);
        },
        add: createReadonlyMethod("add"),
        set: createReadonlyMethod("set"),
        delete: createReadonlyMethod("delete"),
        clear: createReadonlyMethod("clear"),
        forEach: createForEach(true, false)
    };
    const shallowReadonlyInstrumentations2 = {
        get (key) {
            return get(this, key, true, true);
        },
        get size () {
            return size(this, true);
        },
        has (key) {
            return has.call(this, key, true);
        },
        add: createReadonlyMethod("add"),
        set: createReadonlyMethod("set"),
        delete: createReadonlyMethod("delete"),
        clear: createReadonlyMethod("clear"),
        forEach: createForEach(true, true)
    };
    const iteratorMethods = [
        "keys",
        "values",
        "entries",
        Symbol.iterator
    ];
    iteratorMethods.forEach((method)=>{
        mutableInstrumentations2[method] = createIterableMethod(method, false, false);
        readonlyInstrumentations2[method] = createIterableMethod(method, true, false);
        shallowInstrumentations2[method] = createIterableMethod(method, false, true);
        shallowReadonlyInstrumentations2[method] = createIterableMethod(method, true, true);
    });
    return [
        mutableInstrumentations2,
        readonlyInstrumentations2,
        shallowInstrumentations2,
        shallowReadonlyInstrumentations2
    ];
}
const [mutableInstrumentations, readonlyInstrumentations, shallowInstrumentations, shallowReadonlyInstrumentations] = /* @__PURE__ */ createInstrumentations();
function createInstrumentationGetter(isReadonly, shallow) {
    const instrumentations = shallow ? isReadonly ? shallowReadonlyInstrumentations : shallowInstrumentations : isReadonly ? readonlyInstrumentations : mutableInstrumentations;
    return (target, key, receiver)=>{
        if (key === "__v_isReactive") return !isReadonly;
        else if (key === "__v_isReadonly") return isReadonly;
        else if (key === "__v_raw") return target;
        return Reflect.get((0, _shared.hasOwn)(instrumentations, key) && key in target ? instrumentations : target, key, receiver);
    };
}
const mutableCollectionHandlers = {
    get: /* @__PURE__ */ createInstrumentationGetter(false, false)
};
const shallowCollectionHandlers = {
    get: /* @__PURE__ */ createInstrumentationGetter(false, true)
};
const readonlyCollectionHandlers = {
    get: /* @__PURE__ */ createInstrumentationGetter(true, false)
};
const shallowReadonlyCollectionHandlers = {
    get: /* @__PURE__ */ createInstrumentationGetter(true, true)
};
function checkIdentityKeys(target, has2, key) {
    const rawKey = toRaw(key);
    if (rawKey !== key && has2.call(target, rawKey)) {
        const type = (0, _shared.toRawType)(target);
        console.warn(`Reactive ${type} contains both the raw and reactive versions of the same object${type === `Map` ? ` as keys` : ``}, which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.`);
    }
}
const reactiveMap = /* @__PURE__ */ new WeakMap();
const shallowReactiveMap = /* @__PURE__ */ new WeakMap();
const readonlyMap = /* @__PURE__ */ new WeakMap();
const shallowReadonlyMap = /* @__PURE__ */ new WeakMap();
function targetTypeMap(rawType) {
    switch(rawType){
        case "Object":
        case "Array":
            return 1 /* COMMON */ ;
        case "Map":
        case "Set":
        case "WeakMap":
        case "WeakSet":
            return 2 /* COLLECTION */ ;
        default:
            return 0 /* INVALID */ ;
    }
}
function getTargetType(value) {
    return value["__v_skip"] || !Object.isExtensible(value) ? 0 /* INVALID */  : targetTypeMap((0, _shared.toRawType)(value));
}
function reactive(target) {
    if (isReadonly(target)) return target;
    return createReactiveObject(target, false, mutableHandlers, mutableCollectionHandlers, reactiveMap);
}
function shallowReactive(target) {
    return createReactiveObject(target, false, shallowReactiveHandlers, shallowCollectionHandlers, shallowReactiveMap);
}
function readonly(target) {
    return createReactiveObject(target, true, readonlyHandlers, readonlyCollectionHandlers, readonlyMap);
}
function shallowReadonly(target) {
    return createReactiveObject(target, true, shallowReadonlyHandlers, shallowReadonlyCollectionHandlers, shallowReadonlyMap);
}
function createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {
    if (!(0, _shared.isObject)(target)) {
        console.warn(`value cannot be made reactive: ${String(target)}`);
        return target;
    }
    if (target["__v_raw"] && !(isReadonly2 && target["__v_isReactive"])) return target;
    const existingProxy = proxyMap.get(target);
    if (existingProxy) return existingProxy;
    const targetType = getTargetType(target);
    if (targetType === 0 /* INVALID */ ) return target;
    const proxy = new Proxy(target, targetType === 2 /* COLLECTION */  ? collectionHandlers : baseHandlers);
    proxyMap.set(target, proxy);
    return proxy;
}
function isReactive(value) {
    if (isReadonly(value)) return isReactive(value["__v_raw"]);
    return !!(value && value["__v_isReactive"]);
}
function isReadonly(value) {
    return !!(value && value["__v_isReadonly"]);
}
function isShallow(value) {
    return !!(value && value["__v_isShallow"]);
}
function isProxy(value) {
    return isReactive(value) || isReadonly(value);
}
function toRaw(observed) {
    const raw = observed && observed["__v_raw"];
    return raw ? toRaw(raw) : observed;
}
function markRaw(value) {
    (0, _shared.def)(value, "__v_skip", true);
    return value;
}
const toReactive = (value)=>(0, _shared.isObject)(value) ? reactive(value) : value;
const toReadonly = (value)=>(0, _shared.isObject)(value) ? readonly(value) : value;
function trackRefValue(ref2) {
    if (shouldTrack && activeEffect) {
        ref2 = toRaw(ref2);
        trackEffects(ref2.dep || (ref2.dep = createDep()), {
            target: ref2,
            type: "get",
            key: "value"
        });
    }
}
function triggerRefValue(ref2, newVal) {
    ref2 = toRaw(ref2);
    const dep = ref2.dep;
    if (dep) triggerEffects(dep, {
        target: ref2,
        type: "set",
        key: "value",
        newValue: newVal
    });
}
function isRef(r) {
    return !!(r && r.__v_isRef === true);
}
function ref(value) {
    return createRef(value, false);
}
function shallowRef(value) {
    return createRef(value, true);
}
function createRef(rawValue, shallow) {
    if (isRef(rawValue)) return rawValue;
    return new RefImpl(rawValue, shallow);
}
class RefImpl {
    constructor(value, __v_isShallow){
        this.__v_isShallow = __v_isShallow;
        this.dep = void 0;
        this.__v_isRef = true;
        this._rawValue = __v_isShallow ? value : toRaw(value);
        this._value = __v_isShallow ? value : toReactive(value);
    }
    get value() {
        trackRefValue(this);
        return this._value;
    }
    set value(newVal) {
        const useDirectValue = this.__v_isShallow || isShallow(newVal) || isReadonly(newVal);
        newVal = useDirectValue ? newVal : toRaw(newVal);
        if ((0, _shared.hasChanged)(newVal, this._rawValue)) {
            this._rawValue = newVal;
            this._value = useDirectValue ? newVal : toReactive(newVal);
            triggerRefValue(this, newVal);
        }
    }
}
function triggerRef(ref2) {
    triggerRefValue(ref2, (0, ref2.value));
}
function unref(ref2) {
    return isRef(ref2) ? ref2.value : ref2;
}
function toValue(source) {
    return (0, _shared.isFunction)(source) ? source() : unref(source);
}
const shallowUnwrapHandlers = {
    get: (target, key, receiver)=>unref(Reflect.get(target, key, receiver)),
    set: (target, key, value, receiver)=>{
        const oldValue = target[key];
        if (isRef(oldValue) && !isRef(value)) {
            oldValue.value = value;
            return true;
        } else return Reflect.set(target, key, value, receiver);
    }
};
function proxyRefs(objectWithRefs) {
    return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);
}
class CustomRefImpl {
    constructor(factory){
        this.dep = void 0;
        this.__v_isRef = true;
        const { get, set } = factory(()=>trackRefValue(this), ()=>triggerRefValue(this));
        this._get = get;
        this._set = set;
    }
    get value() {
        return this._get();
    }
    set value(newVal) {
        this._set(newVal);
    }
}
function customRef(factory) {
    return new CustomRefImpl(factory);
}
function toRefs(object) {
    if (!isProxy(object)) console.warn(`toRefs() expects a reactive object but received a plain one.`);
    const ret = (0, _shared.isArray)(object) ? new Array(object.length) : {};
    for(const key in object)ret[key] = propertyToRef(object, key);
    return ret;
}
class ObjectRefImpl {
    constructor(_object, _key, _defaultValue){
        this._object = _object;
        this._key = _key;
        this._defaultValue = _defaultValue;
        this.__v_isRef = true;
    }
    get value() {
        const val = this._object[this._key];
        return val === void 0 ? this._defaultValue : val;
    }
    set value(newVal) {
        this._object[this._key] = newVal;
    }
    get dep() {
        return getDepFromReactive(toRaw(this._object), this._key);
    }
}
class GetterRefImpl {
    constructor(_getter){
        this._getter = _getter;
        this.__v_isRef = true;
        this.__v_isReadonly = true;
    }
    get value() {
        return this._getter();
    }
}
function toRef(source, key, defaultValue) {
    if (isRef(source)) return source;
    else if ((0, _shared.isFunction)(source)) return new GetterRefImpl(source);
    else if ((0, _shared.isObject)(source) && arguments.length > 1) return propertyToRef(source, key, defaultValue);
    else return ref(source);
}
function propertyToRef(source, key, defaultValue) {
    const val = source[key];
    return isRef(val) ? val : new ObjectRefImpl(source, key, defaultValue);
}
class ComputedRefImpl {
    constructor(getter, _setter, isReadonly, isSSR){
        this._setter = _setter;
        this.dep = void 0;
        this.__v_isRef = true;
        this["__v_isReadonly"] = false;
        this._dirty = true;
        this.effect = new ReactiveEffect(getter, ()=>{
            if (!this._dirty) {
                this._dirty = true;
                triggerRefValue(this);
            }
        });
        this.effect.computed = this;
        this.effect.active = this._cacheable = !isSSR;
        this["__v_isReadonly"] = isReadonly;
    }
    get value() {
        const self = toRaw(this);
        trackRefValue(self);
        if (self._dirty || !self._cacheable) {
            self._dirty = false;
            self._value = self.effect.run();
        }
        return self._value;
    }
    set value(newValue) {
        this._setter(newValue);
    }
}
function computed(getterOrOptions, debugOptions, isSSR = false) {
    let getter;
    let setter;
    const onlyGetter = (0, _shared.isFunction)(getterOrOptions);
    if (onlyGetter) {
        getter = getterOrOptions;
        setter = ()=>{
            console.warn("Write operation failed: computed value is readonly");
        };
    } else {
        getter = getterOrOptions.get;
        setter = getterOrOptions.set;
    }
    const cRef = new ComputedRefImpl(getter, setter, onlyGetter || !setter, isSSR);
    if (debugOptions && !isSSR) {
        cRef.effect.onTrack = debugOptions.onTrack;
        cRef.effect.onTrigger = debugOptions.onTrigger;
    }
    return cRef;
}
const tick = /* @__PURE__ */ Promise.resolve();
const queue = [];
let queued = false;
const scheduler = (fn)=>{
    queue.push(fn);
    if (!queued) {
        queued = true;
        tick.then(flush);
    }
};
const flush = ()=>{
    for(let i = 0; i < queue.length; i++)queue[i]();
    queue.length = 0;
    queued = false;
};
class DeferredComputedRefImpl {
    constructor(getter){
        this.dep = void 0;
        this._dirty = true;
        this.__v_isRef = true;
        this["__v_isReadonly"] = true;
        let compareTarget;
        let hasCompareTarget = false;
        let scheduled = false;
        this.effect = new ReactiveEffect(getter, (computedTrigger)=>{
            if (this.dep) {
                if (computedTrigger) {
                    compareTarget = this._value;
                    hasCompareTarget = true;
                } else if (!scheduled) {
                    const valueToCompare = hasCompareTarget ? compareTarget : this._value;
                    scheduled = true;
                    hasCompareTarget = false;
                    scheduler(()=>{
                        if (this.effect.active && this._get() !== valueToCompare) triggerRefValue(this);
                        scheduled = false;
                    });
                }
                for (const e of this.dep)if (e.computed instanceof DeferredComputedRefImpl) e.scheduler(true);
            }
            this._dirty = true;
        });
        this.effect.computed = this;
    }
    _get() {
        if (this._dirty) {
            this._dirty = false;
            return this._value = this.effect.run();
        }
        return this._value;
    }
    get value() {
        trackRefValue(this);
        return toRaw(this)._get();
    }
}
function deferredComputed(getter) {
    return new DeferredComputedRefImpl(getter);
}

},{"@vue/shared":"5YL8y","@parcel/transformer-js/src/esmodule-helpers.js":"boKlo"}],"5YL8y":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "EMPTY_ARR", ()=>EMPTY_ARR);
parcelHelpers.export(exports, "EMPTY_OBJ", ()=>EMPTY_OBJ);
parcelHelpers.export(exports, "NO", ()=>NO);
parcelHelpers.export(exports, "NOOP", ()=>NOOP);
parcelHelpers.export(exports, "PatchFlagNames", ()=>PatchFlagNames);
parcelHelpers.export(exports, "camelize", ()=>camelize);
parcelHelpers.export(exports, "capitalize", ()=>capitalize);
parcelHelpers.export(exports, "def", ()=>def);
parcelHelpers.export(exports, "escapeHtml", ()=>escapeHtml);
parcelHelpers.export(exports, "escapeHtmlComment", ()=>escapeHtmlComment);
parcelHelpers.export(exports, "extend", ()=>extend);
parcelHelpers.export(exports, "genPropsAccessExp", ()=>genPropsAccessExp);
parcelHelpers.export(exports, "generateCodeFrame", ()=>generateCodeFrame);
parcelHelpers.export(exports, "getGlobalThis", ()=>getGlobalThis);
parcelHelpers.export(exports, "hasChanged", ()=>hasChanged);
parcelHelpers.export(exports, "hasOwn", ()=>hasOwn);
parcelHelpers.export(exports, "hyphenate", ()=>hyphenate);
parcelHelpers.export(exports, "includeBooleanAttr", ()=>includeBooleanAttr);
parcelHelpers.export(exports, "invokeArrayFns", ()=>invokeArrayFns);
parcelHelpers.export(exports, "isArray", ()=>isArray);
parcelHelpers.export(exports, "isBooleanAttr", ()=>isBooleanAttr);
parcelHelpers.export(exports, "isBuiltInDirective", ()=>isBuiltInDirective);
parcelHelpers.export(exports, "isDate", ()=>isDate);
parcelHelpers.export(exports, "isFunction", ()=>isFunction);
parcelHelpers.export(exports, "isGloballyWhitelisted", ()=>isGloballyWhitelisted);
parcelHelpers.export(exports, "isHTMLTag", ()=>isHTMLTag);
parcelHelpers.export(exports, "isIntegerKey", ()=>isIntegerKey);
parcelHelpers.export(exports, "isKnownHtmlAttr", ()=>isKnownHtmlAttr);
parcelHelpers.export(exports, "isKnownSvgAttr", ()=>isKnownSvgAttr);
parcelHelpers.export(exports, "isMap", ()=>isMap);
parcelHelpers.export(exports, "isModelListener", ()=>isModelListener);
parcelHelpers.export(exports, "isObject", ()=>isObject);
parcelHelpers.export(exports, "isOn", ()=>isOn);
parcelHelpers.export(exports, "isPlainObject", ()=>isPlainObject);
parcelHelpers.export(exports, "isPromise", ()=>isPromise);
parcelHelpers.export(exports, "isRegExp", ()=>isRegExp);
parcelHelpers.export(exports, "isReservedProp", ()=>isReservedProp);
parcelHelpers.export(exports, "isSSRSafeAttrName", ()=>isSSRSafeAttrName);
parcelHelpers.export(exports, "isSVGTag", ()=>isSVGTag);
parcelHelpers.export(exports, "isSet", ()=>isSet);
parcelHelpers.export(exports, "isSpecialBooleanAttr", ()=>isSpecialBooleanAttr);
parcelHelpers.export(exports, "isString", ()=>isString);
parcelHelpers.export(exports, "isSymbol", ()=>isSymbol);
parcelHelpers.export(exports, "isVoidTag", ()=>isVoidTag);
parcelHelpers.export(exports, "looseEqual", ()=>looseEqual);
parcelHelpers.export(exports, "looseIndexOf", ()=>looseIndexOf);
parcelHelpers.export(exports, "looseToNumber", ()=>looseToNumber);
parcelHelpers.export(exports, "makeMap", ()=>makeMap);
parcelHelpers.export(exports, "normalizeClass", ()=>normalizeClass);
parcelHelpers.export(exports, "normalizeProps", ()=>normalizeProps);
parcelHelpers.export(exports, "normalizeStyle", ()=>normalizeStyle);
parcelHelpers.export(exports, "objectToString", ()=>objectToString);
parcelHelpers.export(exports, "parseStringStyle", ()=>parseStringStyle);
parcelHelpers.export(exports, "propsToAttrMap", ()=>propsToAttrMap);
parcelHelpers.export(exports, "remove", ()=>remove);
parcelHelpers.export(exports, "slotFlagsText", ()=>slotFlagsText);
parcelHelpers.export(exports, "stringifyStyle", ()=>stringifyStyle);
parcelHelpers.export(exports, "toDisplayString", ()=>toDisplayString);
parcelHelpers.export(exports, "toHandlerKey", ()=>toHandlerKey);
parcelHelpers.export(exports, "toNumber", ()=>toNumber);
parcelHelpers.export(exports, "toRawType", ()=>toRawType);
parcelHelpers.export(exports, "toTypeString", ()=>toTypeString);
var global = arguments[3];
function makeMap(str, expectsLowerCase) {
    const map = /* @__PURE__ */ Object.create(null);
    const list = str.split(",");
    for(let i = 0; i < list.length; i++)map[list[i]] = true;
    return expectsLowerCase ? (val)=>!!map[val.toLowerCase()] : (val)=>!!map[val];
}
const EMPTY_OBJ = Object.freeze({});
const EMPTY_ARR = Object.freeze([]);
const NOOP = ()=>{};
const NO = ()=>false;
const onRE = /^on[^a-z]/;
const isOn = (key)=>onRE.test(key);
const isModelListener = (key)=>key.startsWith("onUpdate:");
const extend = Object.assign;
const remove = (arr, el)=>{
    const i = arr.indexOf(el);
    if (i > -1) arr.splice(i, 1);
};
const hasOwnProperty = Object.prototype.hasOwnProperty;
const hasOwn = (val, key)=>hasOwnProperty.call(val, key);
const isArray = Array.isArray;
const isMap = (val)=>toTypeString(val) === "[object Map]";
const isSet = (val)=>toTypeString(val) === "[object Set]";
const isDate = (val)=>toTypeString(val) === "[object Date]";
const isRegExp = (val)=>toTypeString(val) === "[object RegExp]";
const isFunction = (val)=>typeof val === "function";
const isString = (val)=>typeof val === "string";
const isSymbol = (val)=>typeof val === "symbol";
const isObject = (val)=>val !== null && typeof val === "object";
const isPromise = (val)=>{
    return isObject(val) && isFunction(val.then) && isFunction(val.catch);
};
const objectToString = Object.prototype.toString;
const toTypeString = (value)=>objectToString.call(value);
const toRawType = (value)=>{
    return toTypeString(value).slice(8, -1);
};
const isPlainObject = (val)=>toTypeString(val) === "[object Object]";
const isIntegerKey = (key)=>isString(key) && key !== "NaN" && key[0] !== "-" && "" + parseInt(key, 10) === key;
const isReservedProp = /* @__PURE__ */ makeMap(// the leading comma is intentional so empty string "" is also included
",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted");
const isBuiltInDirective = /* @__PURE__ */ makeMap("bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo");
const cacheStringFunction = (fn)=>{
    const cache = /* @__PURE__ */ Object.create(null);
    return (str)=>{
        const hit = cache[str];
        return hit || (cache[str] = fn(str));
    };
};
const camelizeRE = /-(\w)/g;
const camelize = cacheStringFunction((str)=>{
    return str.replace(camelizeRE, (_, c)=>c ? c.toUpperCase() : "");
});
const hyphenateRE = /\B([A-Z])/g;
const hyphenate = cacheStringFunction((str)=>str.replace(hyphenateRE, "-$1").toLowerCase());
const capitalize = cacheStringFunction((str)=>str.charAt(0).toUpperCase() + str.slice(1));
const toHandlerKey = cacheStringFunction((str)=>str ? `on${capitalize(str)}` : ``);
const hasChanged = (value, oldValue)=>!Object.is(value, oldValue);
const invokeArrayFns = (fns, arg)=>{
    for(let i = 0; i < fns.length; i++)fns[i](arg);
};
const def = (obj, key, value)=>{
    Object.defineProperty(obj, key, {
        configurable: true,
        enumerable: false,
        value
    });
};
const looseToNumber = (val)=>{
    const n = parseFloat(val);
    return isNaN(n) ? val : n;
};
const toNumber = (val)=>{
    const n = isString(val) ? Number(val) : NaN;
    return isNaN(n) ? val : n;
};
let _globalThis;
const getGlobalThis = ()=>{
    return _globalThis || (_globalThis = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
};
const identRE = /^[_$a-zA-Z\xA0-\uFFFF][_$a-zA-Z0-9\xA0-\uFFFF]*$/;
function genPropsAccessExp(name) {
    return identRE.test(name) ? `__props.${name}` : `__props[${JSON.stringify(name)}]`;
}
const PatchFlagNames = {
    [1]: `TEXT`,
    [2]: `CLASS`,
    [4]: `STYLE`,
    [8]: `PROPS`,
    [16]: `FULL_PROPS`,
    [32]: `HYDRATE_EVENTS`,
    [64]: `STABLE_FRAGMENT`,
    [128]: `KEYED_FRAGMENT`,
    [256]: `UNKEYED_FRAGMENT`,
    [512]: `NEED_PATCH`,
    [1024]: `DYNAMIC_SLOTS`,
    [2048]: `DEV_ROOT_FRAGMENT`,
    [-1]: `HOISTED`,
    [-2]: `BAIL`
};
const slotFlagsText = {
    [1]: "STABLE",
    [2]: "DYNAMIC",
    [3]: "FORWARDED"
};
const GLOBALS_WHITE_LISTED = "Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt,console";
const isGloballyWhitelisted = /* @__PURE__ */ makeMap(GLOBALS_WHITE_LISTED);
const range = 2;
function generateCodeFrame(source, start = 0, end = source.length) {
    let lines = source.split(/(\r?\n)/);
    const newlineSequences = lines.filter((_, idx)=>idx % 2 === 1);
    lines = lines.filter((_, idx)=>idx % 2 === 0);
    let count = 0;
    const res = [];
    for(let i = 0; i < lines.length; i++){
        count += lines[i].length + (newlineSequences[i] && newlineSequences[i].length || 0);
        if (count >= start) {
            for(let j = i - range; j <= i + range || end > count; j++){
                if (j < 0 || j >= lines.length) continue;
                const line = j + 1;
                res.push(`${line}${" ".repeat(Math.max(3 - String(line).length, 0))}|  ${lines[j]}`);
                const lineLength = lines[j].length;
                const newLineSeqLength = newlineSequences[j] && newlineSequences[j].length || 0;
                if (j === i) {
                    const pad = start - (count - (lineLength + newLineSeqLength));
                    const length = Math.max(1, end > count ? lineLength - pad : end - start);
                    res.push(`   |  ` + " ".repeat(pad) + "^".repeat(length));
                } else if (j > i) {
                    if (end > count) {
                        const length = Math.max(Math.min(end - count, lineLength), 1);
                        res.push(`   |  ` + "^".repeat(length));
                    }
                    count += lineLength + newLineSeqLength;
                }
            }
            break;
        }
    }
    return res.join("\n");
}
function normalizeStyle(value) {
    if (isArray(value)) {
        const res = {};
        for(let i = 0; i < value.length; i++){
            const item = value[i];
            const normalized = isString(item) ? parseStringStyle(item) : normalizeStyle(item);
            if (normalized) for(const key in normalized)res[key] = normalized[key];
        }
        return res;
    } else if (isString(value)) return value;
    else if (isObject(value)) return value;
}
const listDelimiterRE = /;(?![^(]*\))/g;
const propertyDelimiterRE = /:([^]+)/;
const styleCommentRE = /\/\*[^]*?\*\//g;
function parseStringStyle(cssText) {
    const ret = {};
    cssText.replace(styleCommentRE, "").split(listDelimiterRE).forEach((item)=>{
        if (item) {
            const tmp = item.split(propertyDelimiterRE);
            tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
        }
    });
    return ret;
}
function stringifyStyle(styles) {
    let ret = "";
    if (!styles || isString(styles)) return ret;
    for(const key in styles){
        const value = styles[key];
        const normalizedKey = key.startsWith(`--`) ? key : hyphenate(key);
        if (isString(value) || typeof value === "number") ret += `${normalizedKey}:${value};`;
    }
    return ret;
}
function normalizeClass(value) {
    let res = "";
    if (isString(value)) res = value;
    else if (isArray(value)) for(let i = 0; i < value.length; i++){
        const normalized = normalizeClass(value[i]);
        if (normalized) res += normalized + " ";
    }
    else if (isObject(value)) {
        for(const name in value)if (value[name]) res += name + " ";
    }
    return res.trim();
}
function normalizeProps(props) {
    if (!props) return null;
    let { class: klass, style } = props;
    if (klass && !isString(klass)) props.class = normalizeClass(klass);
    if (style) props.style = normalizeStyle(style);
    return props;
}
const HTML_TAGS = "html,body,base,head,link,meta,style,title,address,article,aside,footer,header,hgroup,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot";
const SVG_TAGS = "svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistantLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,text,textPath,title,tspan,unknown,use,view";
const VOID_TAGS = "area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr";
const isHTMLTag = /* @__PURE__ */ makeMap(HTML_TAGS);
const isSVGTag = /* @__PURE__ */ makeMap(SVG_TAGS);
const isVoidTag = /* @__PURE__ */ makeMap(VOID_TAGS);
const specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
const isSpecialBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs);
const isBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs + `,async,autofocus,autoplay,controls,default,defer,disabled,hidden,inert,loop,open,required,reversed,scoped,seamless,checked,muted,multiple,selected`);
function includeBooleanAttr(value) {
    return !!value || value === "";
}
const unsafeAttrCharRE = /[>/="'\u0009\u000a\u000c\u0020]/;
const attrValidationCache = {};
function isSSRSafeAttrName(name) {
    if (attrValidationCache.hasOwnProperty(name)) return attrValidationCache[name];
    const isUnsafe = unsafeAttrCharRE.test(name);
    if (isUnsafe) console.error(`unsafe attribute name: ${name}`);
    return attrValidationCache[name] = !isUnsafe;
}
const propsToAttrMap = {
    acceptCharset: "accept-charset",
    className: "class",
    htmlFor: "for",
    httpEquiv: "http-equiv"
};
const isKnownHtmlAttr = /* @__PURE__ */ makeMap(`accept,accept-charset,accesskey,action,align,allow,alt,async,autocapitalize,autocomplete,autofocus,autoplay,background,bgcolor,border,buffered,capture,challenge,charset,checked,cite,class,code,codebase,color,cols,colspan,content,contenteditable,contextmenu,controls,coords,crossorigin,csp,data,datetime,decoding,default,defer,dir,dirname,disabled,download,draggable,dropzone,enctype,enterkeyhint,for,form,formaction,formenctype,formmethod,formnovalidate,formtarget,headers,height,hidden,high,href,hreflang,http-equiv,icon,id,importance,inert,integrity,ismap,itemprop,keytype,kind,label,lang,language,loading,list,loop,low,manifest,max,maxlength,minlength,media,min,multiple,muted,name,novalidate,open,optimum,pattern,ping,placeholder,poster,preload,radiogroup,readonly,referrerpolicy,rel,required,reversed,rows,rowspan,sandbox,scope,scoped,selected,shape,size,sizes,slot,span,spellcheck,src,srcdoc,srclang,srcset,start,step,style,summary,tabindex,target,title,translate,type,usemap,value,width,wrap`);
const isKnownSvgAttr = /* @__PURE__ */ makeMap(`xmlns,accent-height,accumulate,additive,alignment-baseline,alphabetic,amplitude,arabic-form,ascent,attributeName,attributeType,azimuth,baseFrequency,baseline-shift,baseProfile,bbox,begin,bias,by,calcMode,cap-height,class,clip,clipPathUnits,clip-path,clip-rule,color,color-interpolation,color-interpolation-filters,color-profile,color-rendering,contentScriptType,contentStyleType,crossorigin,cursor,cx,cy,d,decelerate,descent,diffuseConstant,direction,display,divisor,dominant-baseline,dur,dx,dy,edgeMode,elevation,enable-background,end,exponent,fill,fill-opacity,fill-rule,filter,filterRes,filterUnits,flood-color,flood-opacity,font-family,font-size,font-size-adjust,font-stretch,font-style,font-variant,font-weight,format,from,fr,fx,fy,g1,g2,glyph-name,glyph-orientation-horizontal,glyph-orientation-vertical,glyphRef,gradientTransform,gradientUnits,hanging,height,href,hreflang,horiz-adv-x,horiz-origin-x,id,ideographic,image-rendering,in,in2,intercept,k,k1,k2,k3,k4,kernelMatrix,kernelUnitLength,kerning,keyPoints,keySplines,keyTimes,lang,lengthAdjust,letter-spacing,lighting-color,limitingConeAngle,local,marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,mask,maskContentUnits,maskUnits,mathematical,max,media,method,min,mode,name,numOctaves,offset,opacity,operator,order,orient,orientation,origin,overflow,overline-position,overline-thickness,panose-1,paint-order,path,pathLength,patternContentUnits,patternTransform,patternUnits,ping,pointer-events,points,pointsAtX,pointsAtY,pointsAtZ,preserveAlpha,preserveAspectRatio,primitiveUnits,r,radius,referrerPolicy,refX,refY,rel,rendering-intent,repeatCount,repeatDur,requiredExtensions,requiredFeatures,restart,result,rotate,rx,ry,scale,seed,shape-rendering,slope,spacing,specularConstant,specularExponent,speed,spreadMethod,startOffset,stdDeviation,stemh,stemv,stitchTiles,stop-color,stop-opacity,strikethrough-position,strikethrough-thickness,string,stroke,stroke-dasharray,stroke-dashoffset,stroke-linecap,stroke-linejoin,stroke-miterlimit,stroke-opacity,stroke-width,style,surfaceScale,systemLanguage,tabindex,tableValues,target,targetX,targetY,text-anchor,text-decoration,text-rendering,textLength,to,transform,transform-origin,type,u1,u2,underline-position,underline-thickness,unicode,unicode-bidi,unicode-range,units-per-em,v-alphabetic,v-hanging,v-ideographic,v-mathematical,values,vector-effect,version,vert-adv-y,vert-origin-x,vert-origin-y,viewBox,viewTarget,visibility,width,widths,word-spacing,writing-mode,x,x-height,x1,x2,xChannelSelector,xlink:actuate,xlink:arcrole,xlink:href,xlink:role,xlink:show,xlink:title,xlink:type,xml:base,xml:lang,xml:space,y,y1,y2,yChannelSelector,z,zoomAndPan`);
const escapeRE = /["'&<>]/;
function escapeHtml(string) {
    const str = "" + string;
    const match = escapeRE.exec(str);
    if (!match) return str;
    let html = "";
    let escaped;
    let index;
    let lastIndex = 0;
    for(index = match.index; index < str.length; index++){
        switch(str.charCodeAt(index)){
            case 34:
                escaped = "&quot;";
                break;
            case 38:
                escaped = "&amp;";
                break;
            case 39:
                escaped = "&#39;";
                break;
            case 60:
                escaped = "&lt;";
                break;
            case 62:
                escaped = "&gt;";
                break;
            default:
                continue;
        }
        if (lastIndex !== index) html += str.slice(lastIndex, index);
        lastIndex = index + 1;
        html += escaped;
    }
    return lastIndex !== index ? html + str.slice(lastIndex, index) : html;
}
const commentStripRE = /^-?>|<!--|-->|--!>|<!-$/g;
function escapeHtmlComment(src) {
    return src.replace(commentStripRE, "");
}
function looseCompareArrays(a, b) {
    if (a.length !== b.length) return false;
    let equal = true;
    for(let i = 0; equal && i < a.length; i++)equal = looseEqual(a[i], b[i]);
    return equal;
}
function looseEqual(a, b) {
    if (a === b) return true;
    let aValidType = isDate(a);
    let bValidType = isDate(b);
    if (aValidType || bValidType) return aValidType && bValidType ? a.getTime() === b.getTime() : false;
    aValidType = isSymbol(a);
    bValidType = isSymbol(b);
    if (aValidType || bValidType) return a === b;
    aValidType = isArray(a);
    bValidType = isArray(b);
    if (aValidType || bValidType) return aValidType && bValidType ? looseCompareArrays(a, b) : false;
    aValidType = isObject(a);
    bValidType = isObject(b);
    if (aValidType || bValidType) {
        if (!aValidType || !bValidType) return false;
        const aKeysCount = Object.keys(a).length;
        const bKeysCount = Object.keys(b).length;
        if (aKeysCount !== bKeysCount) return false;
        for(const key in a){
            const aHasKey = a.hasOwnProperty(key);
            const bHasKey = b.hasOwnProperty(key);
            if (aHasKey && !bHasKey || !aHasKey && bHasKey || !looseEqual(a[key], b[key])) return false;
        }
    }
    return String(a) === String(b);
}
function looseIndexOf(arr, val) {
    return arr.findIndex((item)=>looseEqual(item, val));
}
const toDisplayString = (val)=>{
    return isString(val) ? val : val == null ? "" : isArray(val) || isObject(val) && (val.toString === objectToString || !isFunction(val.toString)) ? JSON.stringify(val, replacer, 2) : String(val);
};
const replacer = (_key, val)=>{
    if (val && val.__v_isRef) return replacer(_key, val.value);
    else if (isMap(val)) return {
        [`Map(${val.size})`]: [
            ...val.entries()
        ].reduce((entries, [key, val2])=>{
            entries[`${key} =>`] = val2;
            return entries;
        }, {})
    };
    else if (isSet(val)) return {
        [`Set(${val.size})`]: [
            ...val.values()
        ]
    };
    else if (isObject(val) && !isArray(val) && !isPlainObject(val)) return String(val);
    return val;
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"boKlo"}],"boKlo":[function(require,module,exports) {
exports.interopDefault = function(a) {
    return a && a.__esModule ? a : {
        default: a
    };
};
exports.defineInteropFlag = function(a) {
    Object.defineProperty(a, "__esModule", {
        value: true
    });
};
exports.exportAll = function(source, dest) {
    Object.keys(source).forEach(function(key) {
        if (key === "default" || key === "__esModule" || dest.hasOwnProperty(key)) return;
        Object.defineProperty(dest, key, {
            enumerable: true,
            get: function() {
                return source[key];
            }
        });
    });
    return dest;
};
exports.export = function(dest, destName, get) {
    Object.defineProperty(dest, destName, {
        enumerable: true,
        get: get
    });
};

},{}],"b2Mq6":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "createShadowContainer", ()=>createShadowContainer);
parcelHelpers.export(exports, "createAnchorObserver", ()=>createAnchorObserver);
parcelHelpers.export(exports, "createRender", ()=>createRender);
async function createShadowDOM(Mount) {
    const shadowHost = document.createElement("plasmo-csui");
    const shadowRoot = typeof Mount.createShadowRoot === "function" ? await Mount.createShadowRoot(shadowHost) : shadowHost.attachShadow({
        mode: "open"
    });
    const shadowContainer = document.createElement("div");
    shadowContainer.id = "plasmo-shadow-container";
    shadowContainer.style.zIndex = "2147483647";
    shadowContainer.style.position = "relative";
    shadowRoot.appendChild(shadowContainer);
    return {
        shadowHost,
        shadowRoot,
        shadowContainer
    };
}
async function injectAnchor(Mount, anchor, { shadowHost, shadowRoot }, mountState) {
    if (typeof Mount.getStyle === "function") {
        const sfcStyleContent = typeof Mount.getSfcStyleContent === "function" ? await Mount.getSfcStyleContent() : "";
        shadowRoot.prepend(await Mount.getStyle({
            ...anchor,
            sfcStyleContent
        }));
    }
    if (typeof Mount.getShadowHostId === "function") shadowHost.id = await Mount.getShadowHostId(anchor);
    if (typeof Mount.mountShadowHost === "function") await Mount.mountShadowHost({
        shadowHost,
        anchor,
        mountState
    });
    else if (anchor.type === "inline") anchor.element.insertAdjacentElement("afterend", shadowHost);
    else document.documentElement.prepend(shadowHost);
}
async function createShadowContainer(Mount, anchor, mountState) {
    const shadowDom = await createShadowDOM(Mount);
    mountState?.hostSet.add(shadowDom.shadowHost);
    mountState?.hostMap.set(shadowDom.shadowHost, anchor);
    await injectAnchor(Mount, anchor, shadowDom, mountState);
    return shadowDom.shadowContainer;
}
const isVisible = (el)=>{
    if (!el) return false;
    const elementRect = el.getBoundingClientRect();
    const elementStyle = globalThis.getComputedStyle(el);
    // console.log(elementRect, elementStyle)
    if (elementStyle.display === "none") return false;
    if (elementStyle.visibility === "hidden") return false;
    if (elementStyle.opacity === "0") return false;
    if (elementRect.width === 0 && elementRect.height === 0 && elementStyle.overflow !== "hidden") return false;
    // Check if the element is irrevocably off-screen:
    if (elementRect.x + elementRect.width < 0 || elementRect.y + elementRect.height < 0) return false;
    return true;
};
function createAnchorObserver(Mount) {
    const mountState = {
        document: document || window.document,
        observer: null,
        mountInterval: null,
        isMounting: false,
        isMutated: false,
        hostSet: new Set(),
        hostMap: new WeakMap(),
        overlayTargetList: []
    };
    const isMounted = (el)=>el?.id ? !!document.getElementById(el.id) : el?.getRootNode({
            composed: true
        }) === mountState.document;
    const hasInlineAnchor = typeof Mount.getInlineAnchor === "function";
    const hasOverlayAnchor = typeof Mount.getOverlayAnchor === "function";
    const hasInlineAnchorList = typeof Mount.getInlineAnchorList === "function";
    const hasOverlayAnchorList = typeof Mount.getOverlayAnchorList === "function";
    const shouldObserve = hasInlineAnchor || hasOverlayAnchor || hasInlineAnchorList || hasOverlayAnchorList;
    if (!shouldObserve) return null;
    async function mountAnchors(render) {
        mountState.isMounting = true;
        const mountedInlineAnchorSet = new WeakSet();
        // There should only be 1 overlay mount
        let overlayHost = null;
        // Go through mounted sets and check if they are still mounted
        for (const el of mountState.hostSet)if (isMounted(el)) {
            const anchor = mountState.hostMap.get(el);
            if (!!anchor) {
                if (anchor.type === "inline") mountedInlineAnchorSet.add(anchor.element);
                else if (anchor.type === "overlay") overlayHost = el;
            }
        } else mountState.hostSet.delete(el);
        const [inlineAnchor, inlineAnchorList, overlayAnchor, overlayAnchorList] = await Promise.all([
            hasInlineAnchor ? Mount.getInlineAnchor() : null,
            hasInlineAnchorList ? Mount.getInlineAnchorList() : null,
            hasOverlayAnchor ? Mount.getOverlayAnchor() : null,
            hasOverlayAnchorList ? Mount.getOverlayAnchorList() : null
        ]);
        const renderList = [];
        if (!!inlineAnchor && !mountedInlineAnchorSet.has(inlineAnchor)) renderList.push({
            element: inlineAnchor,
            type: "inline"
        });
        if ((inlineAnchorList?.length || 0) > 0) inlineAnchorList.forEach((inlineAnchor)=>{
            if (inlineAnchor instanceof Element && !mountedInlineAnchorSet.has(inlineAnchor)) renderList.push({
                element: inlineAnchor,
                type: "inline"
            });
        });
        const overlayTargetList = [];
        if (!!overlayAnchor && isVisible(overlayAnchor)) overlayTargetList.push(overlayAnchor);
        if ((overlayAnchorList?.length || 0) > 0) overlayAnchorList.forEach((el)=>{
            if (el instanceof Element && isVisible(el)) overlayTargetList.push(el);
        });
        if (overlayTargetList.length > 0) {
            mountState.overlayTargetList = overlayTargetList;
            if (!overlayHost) renderList.push({
                element: document.documentElement,
                type: "overlay"
            });
        } else {
            overlayHost?.remove();
            mountState.hostSet.delete(overlayHost);
        }
        await Promise.all(renderList.map(render));
        if (mountState.isMutated) {
            mountState.isMutated = false;
            await mountAnchors(render);
        }
        mountState.isMounting = false;
    }
    const start = (render)=>{
        mountState.observer = new MutationObserver(()=>{
            if (mountState.isMounting) {
                mountState.isMutated = true;
                return;
            }
            mountAnchors(render);
        });
        // Need to watch the subtree for shadowDOM
        mountState.observer.observe(document.documentElement, {
            childList: true,
            subtree: true
        });
        mountState.mountInterval = setInterval(()=>{
            if (mountState.isMounting) {
                mountState.isMutated = true;
                return;
            }
            mountAnchors(render);
        }, 142);
    };
    return {
        start,
        mountState
    };
}
const createRender = (Mount, containers, mountState, renderFx)=>{
    const createRootContainer = (anchor)=>typeof Mount.getRootContainer === "function" ? Mount.getRootContainer({
            anchor,
            mountState
        }) : createShadowContainer(Mount, anchor, mountState);
    if (typeof Mount.render === "function") return (anchor)=>Mount.render({
            anchor,
            createRootContainer
        }, ...containers);
    return async (anchor)=>{
        const rootContainer = await createRootContainer(anchor);
        return renderFx(anchor, rootContainer);
    };
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"boKlo"}],"7z4EY":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "createOverlayCSUIContainer", ()=>createOverlayCSUIContainer);
parcelHelpers.export(exports, "createInlineCSUIContainer", ()=>createInlineCSUIContainer);
const createOverlayCSUIContainer = (props)=>{
    const container = document.createElement("div");
    container.className = "plasmo-csui-container";
    container.id = props.id;
    container.style.cssText = `
    display: flex;
    position: relative;
    top: 0px;
    left: 0px;
  `;
    if (props.anchor.type === "overlay") {
        const updatePosition = async ()=>{
            const rect = props.anchor.element.getBoundingClientRect();
            if (!rect) return;
            const pos = {
                left: rect.left + window.scrollX,
                top: rect.top + window.scrollY
            };
            container.style.top = `${pos.top}px`;
            container.style.left = `${pos.left}px`;
        };
        updatePosition();
        props.watchOverlayAnchor?.(updatePosition);
        window.addEventListener("scroll", updatePosition);
        window.addEventListener("resize", updatePosition);
    }
    return container;
};
const createInlineCSUIContainer = (props)=>{
    const container = document.createElement("div");
    container.className = "plasmo-csui-container";
    container.id = "plasmo-inline";
    container.style.cssText = `
    display: flex;
    position: relative;
    top: 0px;
    left: 0px;
  `;
    return container;
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"boKlo"}],"4j7Mh":[function(require,module,exports) {
globalThis.__VUE_OPTIONS_API__ = true;
globalThis.__VUE_PROD_DEVTOOLS__ = true;

},{}],"2pena":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
let script;
let initialize = ()=>{
    script = require("300e6113f3060f78");
    if (script.__esModule) script = script.default;
    script.render = require("52bd1bbe0cf8ef0e").render;
    require("e7e0204b23d35d34").default(script);
    script.__scopeId = "data-v-82ee5e";
    script.__file = "/Users/davidzimberknopf/Documents/Apps/vue-plasmo-text/src/contents/plasmo-inline.vue";
};
initialize();
if (module.hot) {
    script.__hmrId = "82ee5e-hmr";
    module.hot.accept(()=>{
        setTimeout(()=>{
            initialize();
            if (!__VUE_HMR_RUNTIME__.createRecord("82ee5e-hmr", script)) __VUE_HMR_RUNTIME__.reload("82ee5e-hmr", script);
        }, 0);
    });
}
exports.default = script;

},{"300e6113f3060f78":"ibu7u","52bd1bbe0cf8ef0e":"lbuq0","e7e0204b23d35d34":"1QPI6","@parcel/transformer-js/src/esmodule-helpers.js":"boKlo"}],"ibu7u":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "config", ()=>config);
const config = {
    matches: [
        "https://www.plasmo.com/*"
    ]
};
const getInlineAnchor = ()=>document.querySelector("#supercharge > h3 > span");
const mountShadowHost = ({ anchor, shadowHost })=>{
    anchor.element.insertBefore(shadowHost, anchor.element.firstChild);
};
exports.default = {
    plasmo: {
        getInlineAnchor,
        mountShadowHost
    },
    data () {
        return {
            count: 0
        };
    },
    setup () {},
    mounted () {}
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"boKlo"}],"lbuq0":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "render", ()=>render);
var _vue = require("vue");
const _hoisted_1 = {
    style: {
        "color": "red"
    }
};
function render(_ctx, _cache, $props, $setup, $data, $options) {
    return (0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", null, [
        (0, _vue.createElementVNode)("span", _hoisted_1, (0, _vue.toDisplayString)($data.count), 1 /* TEXT */ ),
        (0, _vue.createElementVNode)("button", {
            onClick: _cache[0] || (_cache[0] = ($event)=>$data.count++)
        }, "Many Myths are based on truth")
    ]);
}
if (module.hot) module.hot.accept(()=>{
    __VUE_HMR_RUNTIME__.rerender("82ee5e-hmr", render);
});

},{"vue":"dmrjI","@parcel/transformer-js/src/esmodule-helpers.js":"boKlo"}],"1QPI6":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
let NOOP = ()=>{};
exports.default = (script)=>{};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"boKlo"}],"lwGre":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const styleRawString = ``;
exports.default = styleRawString;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"boKlo"}]},["beKS4","8znIH"], "8znIH", "parcelRequire05f1")

//# sourceMappingURL=data:application/json;charset=utf-8;base64,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UyxTQUFLLE1BQUEsQ0FBQSxFQUFBLElBQUEsQ0FBQSxNQUFBLENBQUEsRUFBQSxHQUFBLENBQUEsU0FBRSxNQUFBLE9BQVA7UUFBZ0IsR0FBQTtLO0E7QSxJLE8sSyxPLEksTztJLG9CLFMsYztBOzs7OztBQW5DNUIsSUFBSSxPQUFPLEtBQU87a0JBRUgsQ0FBQSxVQUVmOzs7OztBQUpELE1BQU0saUJBQWlCLENBQUMsQ0FBQztrQkFDViIsInNvdXJjZXMiOlsibm9kZV9tb2R1bGVzL0BwbGFzbW9ocS9wYXJjZWwtcnVudGltZS9kaXN0L3J1bnRpbWUtNzljNTNjMDI4MDU4NzM4Yy5qcyIsIi5wbGFzbW8vc3RhdGljL2NvbnRlbnRzL3BsYXNtby1pbmxpbmUudHMiLCJub2RlX21vZHVsZXMvdnVlL2Rpc3QvdnVlLnJ1bnRpbWUuZXNtLWJ1bmRsZXIuanMiLCJub2RlX21vZHVsZXMvQHZ1ZS9ydW50aW1lLWRvbS9kaXN0L3J1bnRpbWUtZG9tLmVzbS1idW5kbGVyLmpzIiwibm9kZV9tb2R1bGVzL0B2dWUvcnVudGltZS1jb3JlL2Rpc3QvcnVudGltZS1jb3JlLmVzbS1idW5kbGVyLmpzIiwibm9kZV9tb2R1bGVzL0B2dWUvcmVhY3Rpdml0eS9kaXN0L3JlYWN0aXZpdHkuZXNtLWJ1bmRsZXIuanMiLCJub2RlX21vZHVsZXMvQHZ1ZS9zaGFyZWQvZGlzdC9zaGFyZWQuZXNtLWJ1bmRsZXIuanMiLCJub2RlX21vZHVsZXMvQHBhcmNlbC90cmFuc2Zvcm1lci1qcy9zcmMvZXNtb2R1bGUtaGVscGVycy5qcyIsIi5wbGFzbW8vc3RhdGljL2NvbW1vbi9jc3VpLnRzIiwiLnBsYXNtby9zdGF0aWMvY29tbW9uL2NzdWktY29udGFpbmVyLXZhbmlsbGEudHN4IiwiLnBsYXNtby9zdGF0aWMvY29tbW9uL3Z1ZS50cyIsInNyYy9jb250ZW50cy9wbGFzbW8taW5saW5lLnZ1ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgcD10eXBlb2YgZ2xvYmFsVGhpcy5wcm9jZXNzPFwidVwiP2dsb2JhbFRoaXMucHJvY2Vzcy5hcmd2OltdO3ZhciB5PSgpPT50eXBlb2YgZ2xvYmFsVGhpcy5wcm9jZXNzPFwidVwiP2dsb2JhbFRoaXMucHJvY2Vzcy5lbnY6e307dmFyIE09bmV3IFNldChwKSxfPWU9Pk0uaGFzKGUpLHo9cC5maWx0ZXIoZT0+ZS5zdGFydHNXaXRoKFwiLS1cIikmJmUuaW5jbHVkZXMoXCI9XCIpKS5tYXAoZT0+ZS5zcGxpdChcIj1cIikpLnJlZHVjZSgoZSxbdCxvXSk9PihlW3RdPW8sZSkse30pO3ZhciBYPV8oXCItLWRyeS1ydW5cIiksZD0oKT0+XyhcIi0tdmVyYm9zZVwiKXx8eSgpLlZFUkJPU0U9PT1cInRydWVcIixHPWQoKTt2YXIgdT0oZT1cIlwiLC4uLnQpPT5jb25zb2xlLmxvZyhlLnBhZEVuZCg5KSxcInxcIiwuLi50KTt2YXIgdj0oLi4uZSk9PmNvbnNvbGUuZXJyb3IoXCJcXHV7MUY1MzR9IEVSUk9SXCIucGFkRW5kKDkpLFwifFwiLC4uLmUpLHg9KC4uLmUpPT51KFwiXFx1ezFGNTM1fSBJTkZPXCIsLi4uZSksZz0oLi4uZSk9PnUoXCJcXHV7MUY3RTB9IFdBUk5cIiwuLi5lKSxEPTAsYz0oLi4uZSk9PmQoKSYmdShgXFx1ezFGN0UxfSAke0QrK31gLC4uLmUpO3ZhciBzPXtcImlzQ29udGVudFNjcmlwdFwiOnRydWUsXCJpc0JhY2tncm91bmRcIjpmYWxzZSxcImlzUmVhY3RcIjpmYWxzZSxcInJ1bnRpbWVzXCI6W1wic2NyaXB0LXJ1bnRpbWVcIl0sXCJob3N0XCI6XCJsb2NhbGhvc3RcIixcInBvcnRcIjoxODE1LFwiZW50cnlGaWxlUGF0aFwiOlwiL1VzZXJzL2RhdmlkemltYmVya25vcGYvRG9jdW1lbnRzL0FwcHMvdnVlLXBsYXNtby10ZXh0Ly5wbGFzbW8vc3RhdGljL2NvbnRlbnRzL3BsYXNtby1pbmxpbmUudHNcIixcImJ1bmRsZUlkXCI6XCIwZDY4MThhYWQ1N2I2ZTlmXCIsXCJlbnZIYXNoXCI6XCJlNzkyZmJiZGFhNzhlZTg0XCIsXCJ2ZXJib3NlXCI6XCJmYWxzZVwiLFwic2VjdXJlXCI6ZmFsc2UsXCJzZXJ2ZXJQb3J0XCI6NTI3MTJ9O21vZHVsZS5idW5kbGUuSE1SX0JVTkRMRV9JRD1zLmJ1bmRsZUlkO2dsb2JhbFRoaXMucHJvY2Vzcz17YXJndjpbXSxlbnY6e1ZFUkJPU0U6cy52ZXJib3NlfX07dmFyIEg9bW9kdWxlLmJ1bmRsZS5Nb2R1bGU7ZnVuY3Rpb24gSShlKXtILmNhbGwodGhpcyxlKSx0aGlzLmhvdD17ZGF0YTptb2R1bGUuYnVuZGxlLmhvdERhdGFbZV0sX2FjY2VwdENhbGxiYWNrczpbXSxfZGlzcG9zZUNhbGxiYWNrczpbXSxhY2NlcHQ6ZnVuY3Rpb24odCl7dGhpcy5fYWNjZXB0Q2FsbGJhY2tzLnB1c2godHx8ZnVuY3Rpb24oKXt9KX0sZGlzcG9zZTpmdW5jdGlvbih0KXt0aGlzLl9kaXNwb3NlQ2FsbGJhY2tzLnB1c2godCl9fSxtb2R1bGUuYnVuZGxlLmhvdERhdGFbZV09dm9pZCAwfW1vZHVsZS5idW5kbGUuTW9kdWxlPUk7bW9kdWxlLmJ1bmRsZS5ob3REYXRhPXt9O3ZhciBsPWdsb2JhbFRoaXMuYnJvd3Nlcnx8Z2xvYmFsVGhpcy5jaHJvbWV8fG51bGw7ZnVuY3Rpb24gYigpe3JldHVybiFzLmhvc3R8fHMuaG9zdD09PVwiMC4wLjAuMFwiP2xvY2F0aW9uLnByb3RvY29sLmluZGV4T2YoXCJodHRwXCIpPT09MD9sb2NhdGlvbi5ob3N0bmFtZTpcImxvY2FsaG9zdFwiOnMuaG9zdH1mdW5jdGlvbiBDKCl7cmV0dXJuIHMucG9ydHx8bG9jYXRpb24ucG9ydH12YXIgRT1cIl9fcGxhc21vX3J1bnRpbWVfc2NyaXB0X1wiO2Z1bmN0aW9uIEwoZSx0KXtsZXR7bW9kdWxlczpvfT1lO3JldHVybiBvPyEhb1t0XTohMX1mdW5jdGlvbiBTKGU9QygpKXtsZXQgdD1iKCk7cmV0dXJuYCR7cy5zZWN1cmV8fGxvY2F0aW9uLnByb3RvY29sPT09XCJodHRwczpcIiYmIS9sb2NhbGhvc3R8MTI3LjAuMC4xfDAuMC4wLjAvLnRlc3QodCk/XCJ3c3NcIjpcIndzXCJ9Oi8vJHt0fToke2V9L2B9ZnVuY3Rpb24gTyhlKXt0eXBlb2YgZS5tZXNzYWdlPT1cInN0cmluZ1wiJiZ2KFwiW3BsYXNtby9wYXJjZWwtcnVudGltZV06IFwiK2UubWVzc2FnZSl9ZnVuY3Rpb24gUChlKXtpZih0eXBlb2YgZ2xvYmFsVGhpcy5XZWJTb2NrZXQ+XCJ1XCIpcmV0dXJuO2xldCB0PW5ldyBXZWJTb2NrZXQoUygpKTtyZXR1cm4gdC5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLGFzeW5jIGZ1bmN0aW9uKG8pe2xldCByPUpTT04ucGFyc2Uoby5kYXRhKTtpZihyLnR5cGU9PT1cInVwZGF0ZVwiJiZhd2FpdCBlKHIuYXNzZXRzKSxyLnR5cGU9PT1cImVycm9yXCIpZm9yKGxldCBpIG9mIHIuZGlhZ25vc3RpY3MuYW5zaSl7bGV0IHc9aS5jb2RlZnJhbWV8fGkuc3RhY2s7ZyhcIltwbGFzbW8vcGFyY2VsLXJ1bnRpbWVdOiBcIitpLm1lc3NhZ2UrYFxuYCt3K2BcblxuYCtpLmhpbnRzLmpvaW4oYFxuYCkpfX0pLHQuYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsTyksdC5hZGRFdmVudExpc3RlbmVyKFwib3BlblwiLCgpPT57eChgW3BsYXNtby9wYXJjZWwtcnVudGltZV06IENvbm5lY3RlZCB0byBITVIgc2VydmVyIGZvciAke3MuZW50cnlGaWxlUGF0aH1gKX0pLHQuYWRkRXZlbnRMaXN0ZW5lcihcImNsb3NlXCIsKCk9PntnKGBbcGxhc21vL3BhcmNlbC1ydW50aW1lXTogQ29ubmVjdGlvbiB0byB0aGUgSE1SIHNlcnZlciBpcyBjbG9zZWQgZm9yICR7cy5lbnRyeUZpbGVQYXRofWApfSksdH12YXIgbj1cIl9fcGxhc21vLWxvYWRpbmdfX1wiO2Z1bmN0aW9uIG0oKXtyZXR1cm4gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQobil9ZnVuY3Rpb24gZigpe3JldHVybiFtKCl9ZnVuY3Rpb24gQigpe2xldCBlPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7cmV0dXJuIGUuaWQ9bixlLmlubmVySFRNTD1gXG4gIDxzdHlsZT5cbiAgICAjJHtufSB7XG4gICAgICBiYWNrZ3JvdW5kOiAjZjNmM2YzO1xuICAgICAgY29sb3I6ICMzMzM7XG4gICAgICBib3JkZXI6IDFweCBzb2xpZCAjMzMzO1xuICAgICAgYm94LXNoYWRvdzogIzMzMyA0LjdweCA0LjdweDtcbiAgICB9XG5cbiAgICAjJHtufTpob3ZlciB7XG4gICAgICBiYWNrZ3JvdW5kOiAjZTNlM2UzO1xuICAgICAgY29sb3I6ICM0NDQ7XG4gICAgfVxuXG4gICAgQGtleWZyYW1lcyBwbGFzbW8tbG9hZGluZy1hbmltYXRlLXN2Zy1maWxsIHtcbiAgICAgIDAlIHtcbiAgICAgICAgZmlsbDogdHJhbnNwYXJlbnQ7XG4gICAgICB9XG4gICAgXG4gICAgICAxMDAlIHtcbiAgICAgICAgZmlsbDogIzMzMztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAjJHtufSAuc3ZnLWVsZW0tMSB7XG4gICAgICBhbmltYXRpb246IHBsYXNtby1sb2FkaW5nLWFuaW1hdGUtc3ZnLWZpbGwgMS40N3MgY3ViaWMtYmV6aWVyKDAuNDcsIDAsIDAuNzQ1LCAwLjcxNSkgMC44cyBib3RoIGluZmluaXRlO1xuICAgIH1cblxuICAgICMke259IC5zdmctZWxlbS0yIHtcbiAgICAgIGFuaW1hdGlvbjogcGxhc21vLWxvYWRpbmctYW5pbWF0ZS1zdmctZmlsbCAxLjQ3cyBjdWJpYy1iZXppZXIoMC40NywgMCwgMC43NDUsIDAuNzE1KSAwLjlzIGJvdGggaW5maW5pdGU7XG4gICAgfVxuICAgIFxuICAgICMke259IC5zdmctZWxlbS0zIHtcbiAgICAgIGFuaW1hdGlvbjogcGxhc21vLWxvYWRpbmctYW5pbWF0ZS1zdmctZmlsbCAxLjQ3cyBjdWJpYy1iZXppZXIoMC40NywgMCwgMC43NDUsIDAuNzE1KSAxcyBib3RoIGluZmluaXRlO1xuICAgIH1cblxuICAgICMke259IC5oaWRkZW4ge1xuICAgICAgZGlzcGxheTogbm9uZTtcbiAgICB9XG5cbiAgPC9zdHlsZT5cbiAgXG4gIDxzdmcgaGVpZ2h0PVwiMzJcIiB3aWR0aD1cIjMyXCIgdmlld0JveD1cIjAgMCAyNjQgMzU0XCIgZmlsbD1cIm5vbmVcIiB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCI+XG4gICAgPHBhdGggZD1cIk0xMzkuMjIxIDI4Mi4yNDNDMTU0LjI1MiAyODIuMjQzIDE2Ni45MDMgMjk0Ljg0OSAxNjEuMzM4IDMwOC44MTJDMTU5LjQ4OSAzMTMuNDU0IDE1Ny4xNSAzMTcuOTEzIDE1NC4zNDcgMzIyLjEwOUMxNDYuNDY0IDMzMy45MDkgMTM1LjI2IDM0My4xMDcgMTIyLjE1MSAzNDguNTM4QzEwOS4wNDMgMzUzLjk2OSA5NC42MTgyIDM1NS4zOSA4MC43MDIyIDM1Mi42MjFDNjYuNzg2MSAzNDkuODUyIDU0LjAwMzQgMzQzLjAxOCA0My45NzA1IDMzMi45ODNDMzMuOTM3NSAzMjIuOTQ3IDI3LjEwNSAzMTAuMTYyIDI0LjMzNjkgMjk2LjI0MkMyMS41Njg5IDI4Mi4zMjMgMjIuOTg5NSAyNjcuODk1IDI4LjQxOTMgMjU0Ljc4M0MzMy44NDkxIDI0MS42NzEgNDMuMDQ0MSAyMzAuNDY0IDU0Ljg0MTYgMjIyLjU3OUM1OS4wMzUzIDIxOS43NzcgNjMuNDkwOCAyMTcuNDM4IDY4LjEyOTUgMjE1LjU4OEM4Mi4wOTE1IDIxMC4wMjEgOTQuNjk3OCAyMjIuNjcxIDk0LjY5NzggMjM3LjcwM0w5NC42OTc4IDI1NS4wMjdDOTQuNjk3OCAyNzAuMDU4IDEwNi44ODMgMjgyLjI0MyAxMjEuOTE0IDI4Mi4yNDNIMTM5LjIyMVpcIiBmaWxsPVwiIzMzM1wiIGNsYXNzPVwic3ZnLWVsZW0tMVwiID48L3BhdGg+XG4gICAgPHBhdGggZD1cIk0xOTIuMjYxIDE0Mi4wMjhDMTkyLjI2MSAxMjYuOTk2IDIwNC44NjcgMTE0LjM0NiAyMTguODI5IDExOS45MTNDMjIzLjQ2OCAxMjEuNzYzIDIyNy45MjMgMTI0LjEwMiAyMzIuMTE3IDEyNi45MDRDMjQzLjkxNSAxMzQuNzg5IDI1My4xMSAxNDUuOTk2IDI1OC41MzkgMTU5LjEwOEMyNjMuOTY5IDE3Mi4yMiAyNjUuMzkgMTg2LjY0OCAyNjIuNjIyIDIwMC41NjdDMjU5Ljg1NCAyMTQuNDg3IDI1My4wMjEgMjI3LjI3MiAyNDIuOTg4IDIzNy4zMDhDMjMyLjk1NSAyNDcuMzQzIDIyMC4xNzMgMjU0LjE3NyAyMDYuMjU2IDI1Ni45NDZDMTkyLjM0IDI1OS43MTUgMTc3LjkxNiAyNTguMjk0IDE2NC44MDcgMjUyLjg2M0MxNTEuNjk5IDI0Ny40MzIgMTQwLjQ5NSAyMzguMjM0IDEzMi42MTIgMjI2LjQzNEMxMjkuODA4IDIyMi4yMzggMTI3LjQ3IDIxNy43NzkgMTI1LjYyIDIxMy4xMzdDMTIwLjA1NiAxOTkuMTc0IDEzMi43MDcgMTg2LjU2OCAxNDcuNzM4IDE4Ni41NjhMMTY1LjA0NCAxODYuNTY4QzE4MC4wNzYgMTg2LjU2OCAxOTIuMjYxIDE3NC4zODMgMTkyLjI2MSAxNTkuMzUyTDE5Mi4yNjEgMTQyLjAyOFpcIiBmaWxsPVwiIzMzM1wiIGNsYXNzPVwic3ZnLWVsZW0tMlwiID48L3BhdGg+XG4gICAgPHBhdGggZD1cIk05NS42NTIyIDE2NC4xMzVDOTUuNjUyMiAxNzkuMTY3IDgzLjIyNzkgMTkxLjcyNSA2OC44MDEzIDE4Ny41MDVDNTkuNTE0NSAxODQuNzg4IDUwLjY0MzIgMTgwLjY2MyA0Mi41MTA2IDE3NS4yMjdDMjYuNzgwNiAxNjQuNzE0IDE0LjUyMDYgMTQ5Ljc3MiA3LjI4MDg5IDEzMi4yODlDMC4wNDExODMgMTE0LjgwNyAtMS44NTMwNSA5NS41Njk3IDEuODM3NzIgNzcuMDEwNEM1LjUyODQ5IDU4LjQ1MTEgMTQuNjM4NSA0MS40MDMzIDI4LjAxNTcgMjguMDIyOEM0MS4zOTMgMTQuNjQyMyA1OC40MzY2IDUuNTMwMDYgNzYuOTkxNCAxLjgzODM5Qzk1LjU0NjEgLTEuODUzMjkgMTE0Ljc3OSAwLjA0MTQxNjIgMTMyLjI1NyA3LjI4MjlDMTQ5LjczNSAxNC41MjQ0IDE2NC42NzQgMjYuNzg3NCAxNzUuMTg0IDQyLjUyMTJDMTgwLjYyIDUwLjY1NzYgMTg0Ljc0NCA1OS41MzMyIDE4Ny40NiA2OC44MjQ1QzE5MS42NzggODMuMjUxOSAxNzkuMTE5IDk1LjY3NTkgMTY0LjA4OCA5NS42NzU5TDEyMi44NjkgOTUuNjc1OUMxMDcuODM3IDk1LjY3NTkgOTUuNjUyMiAxMDcuODYxIDk1LjY1MjIgMTIyLjg5Mkw5NS42NTIyIDE2NC4xMzVaXCIgZmlsbD1cIiMzMzNcIiBjbGFzcz1cInN2Zy1lbGVtLTNcIj48L3BhdGg+XG4gIDwvc3ZnPlxuICA8c3BhbiBjbGFzcz1cImhpZGRlblwiPkNvbnRleHQgSW52YWxpZGF0ZWQsIFByZXNzIHRvIFJlbG9hZDwvc3Bhbj5cbiAgYCxlLnN0eWxlLnBvaW50ZXJFdmVudHM9XCJub25lXCIsZS5zdHlsZS5wb3NpdGlvbj1cImZpeGVkXCIsZS5zdHlsZS5ib3R0b209XCIxNC43cHhcIixlLnN0eWxlLnJpZ2h0PVwiMTQuN3B4XCIsZS5zdHlsZS5mb250RmFtaWx5PVwic2Fucy1zZXJpZlwiLGUuc3R5bGUuZGlzcGxheT1cImZsZXhcIixlLnN0eWxlLmp1c3RpZnlDb250ZW50PVwiY2VudGVyXCIsZS5zdHlsZS5hbGlnbkl0ZW1zPVwiY2VudGVyXCIsZS5zdHlsZS5wYWRkaW5nPVwiMTQuN3B4XCIsZS5zdHlsZS5nYXA9XCIxNC43cHhcIixlLnN0eWxlLmJvcmRlclJhZGl1cz1cIjQuN3B4XCIsZS5zdHlsZS56SW5kZXg9XCIyMTQ3NDgzNjQ3XCIsZS5zdHlsZS5vcGFjaXR5PVwiMFwiLGUuc3R5bGUudHJhbnNpdGlvbj1cImFsbCAwLjQ3cyBlYXNlLWluLW91dFwiLGV9ZnVuY3Rpb24gJChlKXtyZXR1cm4gbmV3IFByb21pc2UodD0+e2RvY3VtZW50LmRvY3VtZW50RWxlbWVudD8oZigpJiYoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmFwcGVuZENoaWxkKGUpLHQoKSksdCgpKTpnbG9iYWxUaGlzLmFkZEV2ZW50TGlzdGVuZXIoXCJET01Db250ZW50TG9hZGVkXCIsKCk9PntmKCkmJmRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5hcHBlbmRDaGlsZChlKSx0KCl9KX0pfXZhciBSPSgpPT57bGV0IGU7aWYoZigpKXtsZXQgdD1CKCk7ZT0kKHQpfXJldHVybntzaG93OmFzeW5jKHtyZWxvYWRCdXR0b246dD0hMX09e30pPT57YXdhaXQgZTtsZXQgbz1tKCk7by5zdHlsZS5vcGFjaXR5PVwiMVwiLHQmJihvLm9uY2xpY2s9cj0+e3Iuc3RvcFByb3BhZ2F0aW9uKCksZ2xvYmFsVGhpcy5sb2NhdGlvbi5yZWxvYWQoKX0sby5xdWVyeVNlbGVjdG9yKFwic3BhblwiKS5jbGFzc0xpc3QucmVtb3ZlKFwiaGlkZGVuXCIpLG8uc3R5bGUuY3Vyc29yPVwicG9pbnRlclwiLG8uc3R5bGUucG9pbnRlckV2ZW50cz1cImFsbFwiKX0saGlkZTphc3luYygpPT57YXdhaXQgZTtsZXQgdD1tKCk7dC5zdHlsZS5vcGFjaXR5PVwiMFwifX19O3ZhciBGPWAke0V9JHttb2R1bGUuaWR9X19gLGEsVD0hMSxBPVIoKTthc3luYyBmdW5jdGlvbiBoKCl7YyhcIlNjcmlwdCBSdW50aW1lIC0gcmVsb2FkaW5nXCIpLFQ/Z2xvYmFsVGhpcy5sb2NhdGlvbj8ucmVsb2FkPy4oKTpBLnNob3coe3JlbG9hZEJ1dHRvbjohMH0pfWZ1bmN0aW9uIGsoKXthPy5kaXNjb25uZWN0KCksYT1sPy5ydW50aW1lLmNvbm5lY3Qoe25hbWU6Rn0pLGEub25EaXNjb25uZWN0LmFkZExpc3RlbmVyKCgpPT57aCgpfSksYS5vbk1lc3NhZ2UuYWRkTGlzdGVuZXIoZT0+e2UuX19wbGFzbW9fY3NfcmVsb2FkX18mJmgoKSxlLl9fcGxhc21vX2NzX2FjdGl2ZV90YWJfXyYmKFQ9ITApfSl9ZnVuY3Rpb24gTigpe2lmKGw/LnJ1bnRpbWUpdHJ5e2soKSxzZXRJbnRlcnZhbChrLDI0ZTMpfWNhdGNoe3JldHVybn19TigpO1AoYXN5bmMgZT0+e2MoXCJTY3JpcHQgcnVudGltZSAtIG9uIHVwZGF0ZWQgYXNzZXRzXCIpLGUuZmlsdGVyKG89Pm8uZW52SGFzaD09PXMuZW52SGFzaCkuc29tZShvPT5MKG1vZHVsZS5idW5kbGUsby5pZCkpJiYoQS5zaG93KCksbD8ucnVudGltZT9hLnBvc3RNZXNzYWdlKHtfX3BsYXNtb19jc19jaGFuZ2VkX186ITB9KTpzZXRUaW1lb3V0KCgpPT57aCgpfSw0NzAwKSl9KTtcbiIsImltcG9ydCB7IGNyZWF0ZUFwcCB9IGZyb20gXCJ2dWVcIlxuXG5pbXBvcnQgeyBjcmVhdGVBbmNob3JPYnNlcnZlciwgY3JlYXRlUmVuZGVyIH0gZnJvbSBcIkBwbGFzbW8tc3RhdGljLWNvbW1vbi9jc3VpXCJcbmltcG9ydCB7XG4gIGNyZWF0ZUlubGluZUNTVUlDb250YWluZXIsXG4gIGNyZWF0ZU92ZXJsYXlDU1VJQ29udGFpbmVyXG59IGZyb20gXCJAcGxhc21vLXN0YXRpYy1jb21tb24vY3N1aS1jb250YWluZXItdmFuaWxsYVwiXG5cbmltcG9ydCB0eXBlIHtcbiAgUGxhc21vQ1NVSSxcbiAgUGxhc21vQ1NVSUFuY2hvcixcbiAgUGxhc21vQ1NVSUhUTUxDb250YWluZXJcbn0gZnJvbSBcIn50eXBlXCJcblxuaW1wb3J0IFwiQHBsYXNtby1zdGF0aWMtY29tbW9uL3Z1ZVwiXG5cbi8vIEB0cy1pZ25vcmVcbmltcG9ydCBSYXdNb3VudCBmcm9tIFwifmNvbnRlbnRzL3BsYXNtby1pbmxpbmVcIlxuLy8gQHRzLWlnbm9yZVxuaW1wb3J0IFNmY1N0eWxlQ29udGVudCBmcm9tIFwic3R5bGUtcmF3On5jb250ZW50cy9wbGFzbW8taW5saW5lXCJcblxuLy8gRXNjYXBlIHBhcmNlbCdzIHN0YXRpYyBhbmFseXplclxuY29uc3QgTW91bnQgPSAoUmF3TW91bnQucGxhc21vIHx8IHt9KSBhcyBQbGFzbW9DU1VJPFBsYXNtb0NTVUlIVE1MQ29udGFpbmVyPlxuXG5pZiAodHlwZW9mIFNmY1N0eWxlQ29udGVudCA9PT0gXCJzdHJpbmdcIikge1xuICBNb3VudC5nZXRTZmNTdHlsZUNvbnRlbnQgPSAoKSA9PiBTZmNTdHlsZUNvbnRlbnRcblxuICBpZiAodHlwZW9mIE1vdW50LmdldFN0eWxlICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBNb3VudC5nZXRTdHlsZSA9ICh7IHNmY1N0eWxlQ29udGVudCB9KSA9PiB7XG4gICAgICBjb25zdCBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpXG4gICAgICBlbGVtZW50LnRleHRDb250ZW50ID0gc2ZjU3R5bGVDb250ZW50XG4gICAgICByZXR1cm4gZWxlbWVudFxuICAgIH1cbiAgfVxufVxuXG5jb25zdCBvYnNlcnZlciA9IGNyZWF0ZUFuY2hvck9ic2VydmVyKE1vdW50KVxuXG5jb25zdCByZW5kZXIgPSBjcmVhdGVSZW5kZXIoXG4gIE1vdW50LFxuICBbY3JlYXRlSW5saW5lQ1NVSUNvbnRhaW5lciwgY3JlYXRlT3ZlcmxheUNTVUlDb250YWluZXJdLFxuICBvYnNlcnZlcj8ubW91bnRTdGF0ZSxcbiAgYXN5bmMgKGFuY2hvciwgcm9vdENvbnRhaW5lcikgPT4ge1xuICAgIHN3aXRjaCAoYW5jaG9yLnR5cGUpIHtcbiAgICAgIGNhc2UgXCJpbmxpbmVcIjoge1xuICAgICAgICBjb25zdCBtb3VudFBvaW50ID0gY3JlYXRlSW5saW5lQ1NVSUNvbnRhaW5lcih7IGFuY2hvciB9KVxuICAgICAgICByb290Q29udGFpbmVyLmFwcGVuZENoaWxkKG1vdW50UG9pbnQpXG5cbiAgICAgICAgY29uc3QgYXBwID0gY3JlYXRlQXBwKFJhd01vdW50KVxuICAgICAgICBhcHAuY29uZmlnLmdsb2JhbFByb3BlcnRpZXMuJGFuY2hvciA9IGFuY2hvclxuICAgICAgICBhcHAubW91bnQobW91bnRQb2ludClcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJvdmVybGF5XCI6IHtcbiAgICAgICAgY29uc3QgdGFyZ2V0TGlzdCA9IG9ic2VydmVyPy5tb3VudFN0YXRlLm92ZXJsYXlUYXJnZXRMaXN0IHx8IFtcbiAgICAgICAgICBhbmNob3IuZWxlbWVudFxuICAgICAgICBdXG5cbiAgICAgICAgdGFyZ2V0TGlzdC5mb3JFYWNoKCh0YXJnZXQsIGkpID0+IHtcbiAgICAgICAgICBjb25zdCBpZCA9IGBwbGFzbW8tb3ZlcmxheS0ke2l9YFxuICAgICAgICAgIGNvbnN0IGlubmVyQW5jaG9yOiBQbGFzbW9DU1VJQW5jaG9yID0ge1xuICAgICAgICAgICAgZWxlbWVudDogdGFyZ2V0LFxuICAgICAgICAgICAgdHlwZTogXCJvdmVybGF5XCJcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBtb3VudFBvaW50ID0gY3JlYXRlT3ZlcmxheUNTVUlDb250YWluZXIoe1xuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICBhbmNob3I6IGlubmVyQW5jaG9yLFxuICAgICAgICAgICAgd2F0Y2hPdmVybGF5QW5jaG9yOiBNb3VudC53YXRjaE92ZXJsYXlBbmNob3JcbiAgICAgICAgICB9KVxuXG4gICAgICAgICAgcm9vdENvbnRhaW5lci5hcHBlbmRDaGlsZChtb3VudFBvaW50KVxuXG4gICAgICAgICAgY29uc3QgYXBwID0gY3JlYXRlQXBwKFJhd01vdW50KVxuICAgICAgICAgIGFwcC5jb25maWcuZ2xvYmFsUHJvcGVydGllcy4kYW5jaG9yID0gaW5uZXJBbmNob3JcbiAgICAgICAgICBhcHAubW91bnQobW91bnRQb2ludClcbiAgICAgICAgfSlcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gIH1cbilcblxuaWYgKCEhb2JzZXJ2ZXIpIHtcbiAgb2JzZXJ2ZXIuc3RhcnQocmVuZGVyKVxufSBlbHNlIHtcbiAgcmVuZGVyKHtcbiAgICBlbGVtZW50OiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsXG4gICAgdHlwZTogXCJvdmVybGF5XCJcbiAgfSlcbn1cblxuaWYgKHR5cGVvZiBNb3VudC53YXRjaCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gIE1vdW50LndhdGNoKHtcbiAgICBvYnNlcnZlcixcbiAgICByZW5kZXJcbiAgfSlcbn1cbiIsImltcG9ydCB7IGluaXRDdXN0b21Gb3JtYXR0ZXIsIHdhcm4gfSBmcm9tICdAdnVlL3J1bnRpbWUtZG9tJztcbmV4cG9ydCAqIGZyb20gJ0B2dWUvcnVudGltZS1kb20nO1xuXG5mdW5jdGlvbiBpbml0RGV2KCkge1xuICB7XG4gICAgaW5pdEN1c3RvbUZvcm1hdHRlcigpO1xuICB9XG59XG5cbmlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gIGluaXREZXYoKTtcbn1cbmNvbnN0IGNvbXBpbGUgPSAoKSA9PiB7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgd2FybihcbiAgICAgIGBSdW50aW1lIGNvbXBpbGF0aW9uIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBidWlsZCBvZiBWdWUuYCArIChgIENvbmZpZ3VyZSB5b3VyIGJ1bmRsZXIgdG8gYWxpYXMgXCJ2dWVcIiB0byBcInZ1ZS9kaXN0L3Z1ZS5lc20tYnVuZGxlci5qc1wiLmAgKVxuICAgICAgLyogc2hvdWxkIG5vdCBoYXBwZW4gKi9cbiAgICApO1xuICB9XG59O1xuXG5leHBvcnQgeyBjb21waWxlIH07XG4iLCJpbXBvcnQgeyB3YXJuLCBjYW1lbGl6ZSwgY2FsbFdpdGhBc3luY0Vycm9ySGFuZGxpbmcsIGRlZmluZUNvbXBvbmVudCwgbmV4dFRpY2ssIGNyZWF0ZVZOb2RlLCBnZXRDdXJyZW50SW5zdGFuY2UsIHdhdGNoUG9zdEVmZmVjdCwgb25Nb3VudGVkLCBvblVubW91bnRlZCwgRnJhZ21lbnQsIFN0YXRpYywgaCwgQmFzZVRyYW5zaXRpb24sIEJhc2VUcmFuc2l0aW9uUHJvcHNWYWxpZGF0b3JzLCBhc3NlcnROdW1iZXIsIHVzZVRyYW5zaXRpb25TdGF0ZSwgb25VcGRhdGVkLCB0b1JhdywgZ2V0VHJhbnNpdGlvblJhd0NoaWxkcmVuLCBzZXRUcmFuc2l0aW9uSG9va3MsIHJlc29sdmVUcmFuc2l0aW9uSG9va3MsIGlzUnVudGltZU9ubHksIGNyZWF0ZVJlbmRlcmVyLCBjcmVhdGVIeWRyYXRpb25SZW5kZXJlciB9IGZyb20gJ0B2dWUvcnVudGltZS1jb3JlJztcbmV4cG9ydCAqIGZyb20gJ0B2dWUvcnVudGltZS1jb3JlJztcbmltcG9ydCB7IGlzU3RyaW5nLCBpc0FycmF5LCBoeXBoZW5hdGUsIGNhcGl0YWxpemUsIGlzU3BlY2lhbEJvb2xlYW5BdHRyLCBpbmNsdWRlQm9vbGVhbkF0dHIsIGlzT24sIGlzTW9kZWxMaXN0ZW5lciwgaXNGdW5jdGlvbiwgY2FtZWxpemUgYXMgY2FtZWxpemUkMSwgdG9OdW1iZXIsIGV4dGVuZCwgRU1QVFlfT0JKLCBpc09iamVjdCwgbG9vc2VUb051bWJlciwgbG9vc2VJbmRleE9mLCBpc1NldCwgbG9vc2VFcXVhbCwgaW52b2tlQXJyYXlGbnMsIGlzSFRNTFRhZywgaXNTVkdUYWcgfSBmcm9tICdAdnVlL3NoYXJlZCc7XG5cbmNvbnN0IHN2Z05TID0gXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiO1xuY29uc3QgZG9jID0gdHlwZW9mIGRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiID8gZG9jdW1lbnQgOiBudWxsO1xuY29uc3QgdGVtcGxhdGVDb250YWluZXIgPSBkb2MgJiYgLyogQF9fUFVSRV9fICovIGRvYy5jcmVhdGVFbGVtZW50KFwidGVtcGxhdGVcIik7XG5jb25zdCBub2RlT3BzID0ge1xuICBpbnNlcnQ6IChjaGlsZCwgcGFyZW50LCBhbmNob3IpID0+IHtcbiAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKGNoaWxkLCBhbmNob3IgfHwgbnVsbCk7XG4gIH0sXG4gIHJlbW92ZTogKGNoaWxkKSA9PiB7XG4gICAgY29uc3QgcGFyZW50ID0gY2hpbGQucGFyZW50Tm9kZTtcbiAgICBpZiAocGFyZW50KSB7XG4gICAgICBwYXJlbnQucmVtb3ZlQ2hpbGQoY2hpbGQpO1xuICAgIH1cbiAgfSxcbiAgY3JlYXRlRWxlbWVudDogKHRhZywgaXNTVkcsIGlzLCBwcm9wcykgPT4ge1xuICAgIGNvbnN0IGVsID0gaXNTVkcgPyBkb2MuY3JlYXRlRWxlbWVudE5TKHN2Z05TLCB0YWcpIDogZG9jLmNyZWF0ZUVsZW1lbnQodGFnLCBpcyA/IHsgaXMgfSA6IHZvaWQgMCk7XG4gICAgaWYgKHRhZyA9PT0gXCJzZWxlY3RcIiAmJiBwcm9wcyAmJiBwcm9wcy5tdWx0aXBsZSAhPSBudWxsKSB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoXCJtdWx0aXBsZVwiLCBwcm9wcy5tdWx0aXBsZSk7XG4gICAgfVxuICAgIHJldHVybiBlbDtcbiAgfSxcbiAgY3JlYXRlVGV4dDogKHRleHQpID0+IGRvYy5jcmVhdGVUZXh0Tm9kZSh0ZXh0KSxcbiAgY3JlYXRlQ29tbWVudDogKHRleHQpID0+IGRvYy5jcmVhdGVDb21tZW50KHRleHQpLFxuICBzZXRUZXh0OiAobm9kZSwgdGV4dCkgPT4ge1xuICAgIG5vZGUubm9kZVZhbHVlID0gdGV4dDtcbiAgfSxcbiAgc2V0RWxlbWVudFRleHQ6IChlbCwgdGV4dCkgPT4ge1xuICAgIGVsLnRleHRDb250ZW50ID0gdGV4dDtcbiAgfSxcbiAgcGFyZW50Tm9kZTogKG5vZGUpID0+IG5vZGUucGFyZW50Tm9kZSxcbiAgbmV4dFNpYmxpbmc6IChub2RlKSA9PiBub2RlLm5leHRTaWJsaW5nLFxuICBxdWVyeVNlbGVjdG9yOiAoc2VsZWN0b3IpID0+IGRvYy5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKSxcbiAgc2V0U2NvcGVJZChlbCwgaWQpIHtcbiAgICBlbC5zZXRBdHRyaWJ1dGUoaWQsIFwiXCIpO1xuICB9LFxuICAvLyBfX1VOU0FGRV9fXG4gIC8vIFJlYXNvbjogaW5uZXJIVE1MLlxuICAvLyBTdGF0aWMgY29udGVudCBoZXJlIGNhbiBvbmx5IGNvbWUgZnJvbSBjb21waWxlZCB0ZW1wbGF0ZXMuXG4gIC8vIEFzIGxvbmcgYXMgdGhlIHVzZXIgb25seSB1c2VzIHRydXN0ZWQgdGVtcGxhdGVzLCB0aGlzIGlzIHNhZmUuXG4gIGluc2VydFN0YXRpY0NvbnRlbnQoY29udGVudCwgcGFyZW50LCBhbmNob3IsIGlzU1ZHLCBzdGFydCwgZW5kKSB7XG4gICAgY29uc3QgYmVmb3JlID0gYW5jaG9yID8gYW5jaG9yLnByZXZpb3VzU2libGluZyA6IHBhcmVudC5sYXN0Q2hpbGQ7XG4gICAgaWYgKHN0YXJ0ICYmIChzdGFydCA9PT0gZW5kIHx8IHN0YXJ0Lm5leHRTaWJsaW5nKSkge1xuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgcGFyZW50Lmluc2VydEJlZm9yZShzdGFydC5jbG9uZU5vZGUodHJ1ZSksIGFuY2hvcik7XG4gICAgICAgIGlmIChzdGFydCA9PT0gZW5kIHx8ICEoc3RhcnQgPSBzdGFydC5uZXh0U2libGluZykpXG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRlbXBsYXRlQ29udGFpbmVyLmlubmVySFRNTCA9IGlzU1ZHID8gYDxzdmc+JHtjb250ZW50fTwvc3ZnPmAgOiBjb250ZW50O1xuICAgICAgY29uc3QgdGVtcGxhdGUgPSB0ZW1wbGF0ZUNvbnRhaW5lci5jb250ZW50O1xuICAgICAgaWYgKGlzU1ZHKSB7XG4gICAgICAgIGNvbnN0IHdyYXBwZXIgPSB0ZW1wbGF0ZS5maXJzdENoaWxkO1xuICAgICAgICB3aGlsZSAod3JhcHBlci5maXJzdENoaWxkKSB7XG4gICAgICAgICAgdGVtcGxhdGUuYXBwZW5kQ2hpbGQod3JhcHBlci5maXJzdENoaWxkKTtcbiAgICAgICAgfVxuICAgICAgICB0ZW1wbGF0ZS5yZW1vdmVDaGlsZCh3cmFwcGVyKTtcbiAgICAgIH1cbiAgICAgIHBhcmVudC5pbnNlcnRCZWZvcmUodGVtcGxhdGUsIGFuY2hvcik7XG4gICAgfVxuICAgIHJldHVybiBbXG4gICAgICAvLyBmaXJzdFxuICAgICAgYmVmb3JlID8gYmVmb3JlLm5leHRTaWJsaW5nIDogcGFyZW50LmZpcnN0Q2hpbGQsXG4gICAgICAvLyBsYXN0XG4gICAgICBhbmNob3IgPyBhbmNob3IucHJldmlvdXNTaWJsaW5nIDogcGFyZW50Lmxhc3RDaGlsZFxuICAgIF07XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHBhdGNoQ2xhc3MoZWwsIHZhbHVlLCBpc1NWRykge1xuICBjb25zdCB0cmFuc2l0aW9uQ2xhc3NlcyA9IGVsLl92dGM7XG4gIGlmICh0cmFuc2l0aW9uQ2xhc3Nlcykge1xuICAgIHZhbHVlID0gKHZhbHVlID8gW3ZhbHVlLCAuLi50cmFuc2l0aW9uQ2xhc3Nlc10gOiBbLi4udHJhbnNpdGlvbkNsYXNzZXNdKS5qb2luKFwiIFwiKTtcbiAgfVxuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShcImNsYXNzXCIpO1xuICB9IGVsc2UgaWYgKGlzU1ZHKSB7XG4gICAgZWwuc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgdmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIGVsLmNsYXNzTmFtZSA9IHZhbHVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHBhdGNoU3R5bGUoZWwsIHByZXYsIG5leHQpIHtcbiAgY29uc3Qgc3R5bGUgPSBlbC5zdHlsZTtcbiAgY29uc3QgaXNDc3NTdHJpbmcgPSBpc1N0cmluZyhuZXh0KTtcbiAgaWYgKG5leHQgJiYgIWlzQ3NzU3RyaW5nKSB7XG4gICAgaWYgKHByZXYgJiYgIWlzU3RyaW5nKHByZXYpKSB7XG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiBwcmV2KSB7XG4gICAgICAgIGlmIChuZXh0W2tleV0gPT0gbnVsbCkge1xuICAgICAgICAgIHNldFN0eWxlKHN0eWxlLCBrZXksIFwiXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAoY29uc3Qga2V5IGluIG5leHQpIHtcbiAgICAgIHNldFN0eWxlKHN0eWxlLCBrZXksIG5leHRba2V5XSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGNvbnN0IGN1cnJlbnREaXNwbGF5ID0gc3R5bGUuZGlzcGxheTtcbiAgICBpZiAoaXNDc3NTdHJpbmcpIHtcbiAgICAgIGlmIChwcmV2ICE9PSBuZXh0KSB7XG4gICAgICAgIHN0eWxlLmNzc1RleHQgPSBuZXh0O1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocHJldikge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKFwic3R5bGVcIik7XG4gICAgfVxuICAgIGlmIChcIl92b2RcIiBpbiBlbCkge1xuICAgICAgc3R5bGUuZGlzcGxheSA9IGN1cnJlbnREaXNwbGF5O1xuICAgIH1cbiAgfVxufVxuY29uc3Qgc2VtaWNvbG9uUkUgPSAvW15cXFxcXTtcXHMqJC87XG5jb25zdCBpbXBvcnRhbnRSRSA9IC9cXHMqIWltcG9ydGFudCQvO1xuZnVuY3Rpb24gc2V0U3R5bGUoc3R5bGUsIG5hbWUsIHZhbCkge1xuICBpZiAoaXNBcnJheSh2YWwpKSB7XG4gICAgdmFsLmZvckVhY2goKHYpID0+IHNldFN0eWxlKHN0eWxlLCBuYW1lLCB2KSk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHZhbCA9PSBudWxsKVxuICAgICAgdmFsID0gXCJcIjtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgaWYgKHNlbWljb2xvblJFLnRlc3QodmFsKSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIGBVbmV4cGVjdGVkIHNlbWljb2xvbiBhdCB0aGUgZW5kIG9mICcke25hbWV9JyBzdHlsZSB2YWx1ZTogJyR7dmFsfSdgXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChuYW1lLnN0YXJ0c1dpdGgoXCItLVwiKSkge1xuICAgICAgc3R5bGUuc2V0UHJvcGVydHkobmFtZSwgdmFsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgcHJlZml4ZWQgPSBhdXRvUHJlZml4KHN0eWxlLCBuYW1lKTtcbiAgICAgIGlmIChpbXBvcnRhbnRSRS50ZXN0KHZhbCkpIHtcbiAgICAgICAgc3R5bGUuc2V0UHJvcGVydHkoXG4gICAgICAgICAgaHlwaGVuYXRlKHByZWZpeGVkKSxcbiAgICAgICAgICB2YWwucmVwbGFjZShpbXBvcnRhbnRSRSwgXCJcIiksXG4gICAgICAgICAgXCJpbXBvcnRhbnRcIlxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3R5bGVbcHJlZml4ZWRdID0gdmFsO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuY29uc3QgcHJlZml4ZXMgPSBbXCJXZWJraXRcIiwgXCJNb3pcIiwgXCJtc1wiXTtcbmNvbnN0IHByZWZpeENhY2hlID0ge307XG5mdW5jdGlvbiBhdXRvUHJlZml4KHN0eWxlLCByYXdOYW1lKSB7XG4gIGNvbnN0IGNhY2hlZCA9IHByZWZpeENhY2hlW3Jhd05hbWVdO1xuICBpZiAoY2FjaGVkKSB7XG4gICAgcmV0dXJuIGNhY2hlZDtcbiAgfVxuICBsZXQgbmFtZSA9IGNhbWVsaXplKHJhd05hbWUpO1xuICBpZiAobmFtZSAhPT0gXCJmaWx0ZXJcIiAmJiBuYW1lIGluIHN0eWxlKSB7XG4gICAgcmV0dXJuIHByZWZpeENhY2hlW3Jhd05hbWVdID0gbmFtZTtcbiAgfVxuICBuYW1lID0gY2FwaXRhbGl6ZShuYW1lKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcmVmaXhlcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHByZWZpeGVkID0gcHJlZml4ZXNbaV0gKyBuYW1lO1xuICAgIGlmIChwcmVmaXhlZCBpbiBzdHlsZSkge1xuICAgICAgcmV0dXJuIHByZWZpeENhY2hlW3Jhd05hbWVdID0gcHJlZml4ZWQ7XG4gICAgfVxuICB9XG4gIHJldHVybiByYXdOYW1lO1xufVxuXG5jb25zdCB4bGlua05TID0gXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXCI7XG5mdW5jdGlvbiBwYXRjaEF0dHIoZWwsIGtleSwgdmFsdWUsIGlzU1ZHLCBpbnN0YW5jZSkge1xuICBpZiAoaXNTVkcgJiYga2V5LnN0YXJ0c1dpdGgoXCJ4bGluazpcIikpIHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlTlMoeGxpbmtOUywga2V5LnNsaWNlKDYsIGtleS5sZW5ndGgpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwuc2V0QXR0cmlidXRlTlMoeGxpbmtOUywga2V5LCB2YWx1ZSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGNvbnN0IGlzQm9vbGVhbiA9IGlzU3BlY2lhbEJvb2xlYW5BdHRyKGtleSk7XG4gICAgaWYgKHZhbHVlID09IG51bGwgfHwgaXNCb29sZWFuICYmICFpbmNsdWRlQm9vbGVhbkF0dHIodmFsdWUpKSB7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwuc2V0QXR0cmlidXRlKGtleSwgaXNCb29sZWFuID8gXCJcIiA6IHZhbHVlKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcGF0Y2hET01Qcm9wKGVsLCBrZXksIHZhbHVlLCBwcmV2Q2hpbGRyZW4sIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHVubW91bnRDaGlsZHJlbikge1xuICBpZiAoa2V5ID09PSBcImlubmVySFRNTFwiIHx8IGtleSA9PT0gXCJ0ZXh0Q29udGVudFwiKSB7XG4gICAgaWYgKHByZXZDaGlsZHJlbikge1xuICAgICAgdW5tb3VudENoaWxkcmVuKHByZXZDaGlsZHJlbiwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSk7XG4gICAgfVxuICAgIGVsW2tleV0gPSB2YWx1ZSA9PSBudWxsID8gXCJcIiA6IHZhbHVlO1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCB0YWcgPSBlbC50YWdOYW1lO1xuICBpZiAoa2V5ID09PSBcInZhbHVlXCIgJiYgdGFnICE9PSBcIlBST0dSRVNTXCIgJiYgLy8gY3VzdG9tIGVsZW1lbnRzIG1heSB1c2UgX3ZhbHVlIGludGVybmFsbHlcbiAgIXRhZy5pbmNsdWRlcyhcIi1cIikpIHtcbiAgICBlbC5fdmFsdWUgPSB2YWx1ZTtcbiAgICBjb25zdCBvbGRWYWx1ZSA9IHRhZyA9PT0gXCJPUFRJT05cIiA/IGVsLmdldEF0dHJpYnV0ZShcInZhbHVlXCIpIDogZWwudmFsdWU7XG4gICAgY29uc3QgbmV3VmFsdWUgPSB2YWx1ZSA9PSBudWxsID8gXCJcIiA6IHZhbHVlO1xuICAgIGlmIChvbGRWYWx1ZSAhPT0gbmV3VmFsdWUpIHtcbiAgICAgIGVsLnZhbHVlID0gbmV3VmFsdWU7XG4gICAgfVxuICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG4gIGxldCBuZWVkUmVtb3ZlID0gZmFsc2U7XG4gIGlmICh2YWx1ZSA9PT0gXCJcIiB8fCB2YWx1ZSA9PSBudWxsKSB7XG4gICAgY29uc3QgdHlwZSA9IHR5cGVvZiBlbFtrZXldO1xuICAgIGlmICh0eXBlID09PSBcImJvb2xlYW5cIikge1xuICAgICAgdmFsdWUgPSBpbmNsdWRlQm9vbGVhbkF0dHIodmFsdWUpO1xuICAgIH0gZWxzZSBpZiAodmFsdWUgPT0gbnVsbCAmJiB0eXBlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICB2YWx1ZSA9IFwiXCI7XG4gICAgICBuZWVkUmVtb3ZlID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHZhbHVlID0gMDtcbiAgICAgIG5lZWRSZW1vdmUgPSB0cnVlO1xuICAgIH1cbiAgfVxuICB0cnkge1xuICAgIGVsW2tleV0gPSB2YWx1ZTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICFuZWVkUmVtb3ZlKSB7XG4gICAgICB3YXJuKFxuICAgICAgICBgRmFpbGVkIHNldHRpbmcgcHJvcCBcIiR7a2V5fVwiIG9uIDwke3RhZy50b0xvd2VyQ2FzZSgpfT46IHZhbHVlICR7dmFsdWV9IGlzIGludmFsaWQuYCxcbiAgICAgICAgZVxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgbmVlZFJlbW92ZSAmJiBlbC5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcbn1cblxuZnVuY3Rpb24gYWRkRXZlbnRMaXN0ZW5lcihlbCwgZXZlbnQsIGhhbmRsZXIsIG9wdGlvbnMpIHtcbiAgZWwuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlciwgb3B0aW9ucyk7XG59XG5mdW5jdGlvbiByZW1vdmVFdmVudExpc3RlbmVyKGVsLCBldmVudCwgaGFuZGxlciwgb3B0aW9ucykge1xuICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyLCBvcHRpb25zKTtcbn1cbmZ1bmN0aW9uIHBhdGNoRXZlbnQoZWwsIHJhd05hbWUsIHByZXZWYWx1ZSwgbmV4dFZhbHVlLCBpbnN0YW5jZSA9IG51bGwpIHtcbiAgY29uc3QgaW52b2tlcnMgPSBlbC5fdmVpIHx8IChlbC5fdmVpID0ge30pO1xuICBjb25zdCBleGlzdGluZ0ludm9rZXIgPSBpbnZva2Vyc1tyYXdOYW1lXTtcbiAgaWYgKG5leHRWYWx1ZSAmJiBleGlzdGluZ0ludm9rZXIpIHtcbiAgICBleGlzdGluZ0ludm9rZXIudmFsdWUgPSBuZXh0VmFsdWU7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgW25hbWUsIG9wdGlvbnNdID0gcGFyc2VOYW1lKHJhd05hbWUpO1xuICAgIGlmIChuZXh0VmFsdWUpIHtcbiAgICAgIGNvbnN0IGludm9rZXIgPSBpbnZva2Vyc1tyYXdOYW1lXSA9IGNyZWF0ZUludm9rZXIobmV4dFZhbHVlLCBpbnN0YW5jZSk7XG4gICAgICBhZGRFdmVudExpc3RlbmVyKGVsLCBuYW1lLCBpbnZva2VyLCBvcHRpb25zKTtcbiAgICB9IGVsc2UgaWYgKGV4aXN0aW5nSW52b2tlcikge1xuICAgICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcihlbCwgbmFtZSwgZXhpc3RpbmdJbnZva2VyLCBvcHRpb25zKTtcbiAgICAgIGludm9rZXJzW3Jhd05hbWVdID0gdm9pZCAwO1xuICAgIH1cbiAgfVxufVxuY29uc3Qgb3B0aW9uc01vZGlmaWVyUkUgPSAvKD86T25jZXxQYXNzaXZlfENhcHR1cmUpJC87XG5mdW5jdGlvbiBwYXJzZU5hbWUobmFtZSkge1xuICBsZXQgb3B0aW9ucztcbiAgaWYgKG9wdGlvbnNNb2RpZmllclJFLnRlc3QobmFtZSkpIHtcbiAgICBvcHRpb25zID0ge307XG4gICAgbGV0IG07XG4gICAgd2hpbGUgKG0gPSBuYW1lLm1hdGNoKG9wdGlvbnNNb2RpZmllclJFKSkge1xuICAgICAgbmFtZSA9IG5hbWUuc2xpY2UoMCwgbmFtZS5sZW5ndGggLSBtWzBdLmxlbmd0aCk7XG4gICAgICBvcHRpb25zW21bMF0udG9Mb3dlckNhc2UoKV0gPSB0cnVlO1xuICAgIH1cbiAgfVxuICBjb25zdCBldmVudCA9IG5hbWVbMl0gPT09IFwiOlwiID8gbmFtZS5zbGljZSgzKSA6IGh5cGhlbmF0ZShuYW1lLnNsaWNlKDIpKTtcbiAgcmV0dXJuIFtldmVudCwgb3B0aW9uc107XG59XG5sZXQgY2FjaGVkTm93ID0gMDtcbmNvbnN0IHAgPSAvKiBAX19QVVJFX18gKi8gUHJvbWlzZS5yZXNvbHZlKCk7XG5jb25zdCBnZXROb3cgPSAoKSA9PiBjYWNoZWROb3cgfHwgKHAudGhlbigoKSA9PiBjYWNoZWROb3cgPSAwKSwgY2FjaGVkTm93ID0gRGF0ZS5ub3coKSk7XG5mdW5jdGlvbiBjcmVhdGVJbnZva2VyKGluaXRpYWxWYWx1ZSwgaW5zdGFuY2UpIHtcbiAgY29uc3QgaW52b2tlciA9IChlKSA9PiB7XG4gICAgaWYgKCFlLl92dHMpIHtcbiAgICAgIGUuX3Z0cyA9IERhdGUubm93KCk7XG4gICAgfSBlbHNlIGlmIChlLl92dHMgPD0gaW52b2tlci5hdHRhY2hlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZyhcbiAgICAgIHBhdGNoU3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKGUsIGludm9rZXIudmFsdWUpLFxuICAgICAgaW5zdGFuY2UsXG4gICAgICA1LFxuICAgICAgW2VdXG4gICAgKTtcbiAgfTtcbiAgaW52b2tlci52YWx1ZSA9IGluaXRpYWxWYWx1ZTtcbiAgaW52b2tlci5hdHRhY2hlZCA9IGdldE5vdygpO1xuICByZXR1cm4gaW52b2tlcjtcbn1cbmZ1bmN0aW9uIHBhdGNoU3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKGUsIHZhbHVlKSB7XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIGNvbnN0IG9yaWdpbmFsU3RvcCA9IGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uO1xuICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uID0gKCkgPT4ge1xuICAgICAgb3JpZ2luYWxTdG9wLmNhbGwoZSk7XG4gICAgICBlLl9zdG9wcGVkID0gdHJ1ZTtcbiAgICB9O1xuICAgIHJldHVybiB2YWx1ZS5tYXAoKGZuKSA9PiAoZTIpID0+ICFlMi5fc3RvcHBlZCAmJiBmbiAmJiBmbihlMikpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxufVxuXG5jb25zdCBuYXRpdmVPblJFID0gL15vblthLXpdLztcbmNvbnN0IHBhdGNoUHJvcCA9IChlbCwga2V5LCBwcmV2VmFsdWUsIG5leHRWYWx1ZSwgaXNTVkcgPSBmYWxzZSwgcHJldkNoaWxkcmVuLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCB1bm1vdW50Q2hpbGRyZW4pID0+IHtcbiAgaWYgKGtleSA9PT0gXCJjbGFzc1wiKSB7XG4gICAgcGF0Y2hDbGFzcyhlbCwgbmV4dFZhbHVlLCBpc1NWRyk7XG4gIH0gZWxzZSBpZiAoa2V5ID09PSBcInN0eWxlXCIpIHtcbiAgICBwYXRjaFN0eWxlKGVsLCBwcmV2VmFsdWUsIG5leHRWYWx1ZSk7XG4gIH0gZWxzZSBpZiAoaXNPbihrZXkpKSB7XG4gICAgaWYgKCFpc01vZGVsTGlzdGVuZXIoa2V5KSkge1xuICAgICAgcGF0Y2hFdmVudChlbCwga2V5LCBwcmV2VmFsdWUsIG5leHRWYWx1ZSwgcGFyZW50Q29tcG9uZW50KTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoa2V5WzBdID09PSBcIi5cIiA/IChrZXkgPSBrZXkuc2xpY2UoMSksIHRydWUpIDoga2V5WzBdID09PSBcIl5cIiA/IChrZXkgPSBrZXkuc2xpY2UoMSksIGZhbHNlKSA6IHNob3VsZFNldEFzUHJvcChlbCwga2V5LCBuZXh0VmFsdWUsIGlzU1ZHKSkge1xuICAgIHBhdGNoRE9NUHJvcChcbiAgICAgIGVsLFxuICAgICAga2V5LFxuICAgICAgbmV4dFZhbHVlLFxuICAgICAgcHJldkNoaWxkcmVuLFxuICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICB1bm1vdW50Q2hpbGRyZW5cbiAgICApO1xuICB9IGVsc2Uge1xuICAgIGlmIChrZXkgPT09IFwidHJ1ZS12YWx1ZVwiKSB7XG4gICAgICBlbC5fdHJ1ZVZhbHVlID0gbmV4dFZhbHVlO1xuICAgIH0gZWxzZSBpZiAoa2V5ID09PSBcImZhbHNlLXZhbHVlXCIpIHtcbiAgICAgIGVsLl9mYWxzZVZhbHVlID0gbmV4dFZhbHVlO1xuICAgIH1cbiAgICBwYXRjaEF0dHIoZWwsIGtleSwgbmV4dFZhbHVlLCBpc1NWRyk7XG4gIH1cbn07XG5mdW5jdGlvbiBzaG91bGRTZXRBc1Byb3AoZWwsIGtleSwgdmFsdWUsIGlzU1ZHKSB7XG4gIGlmIChpc1NWRykge1xuICAgIGlmIChrZXkgPT09IFwiaW5uZXJIVE1MXCIgfHwga2V5ID09PSBcInRleHRDb250ZW50XCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoa2V5IGluIGVsICYmIG5hdGl2ZU9uUkUudGVzdChrZXkpICYmIGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChrZXkgPT09IFwic3BlbGxjaGVja1wiIHx8IGtleSA9PT0gXCJkcmFnZ2FibGVcIiB8fCBrZXkgPT09IFwidHJhbnNsYXRlXCIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGtleSA9PT0gXCJmb3JtXCIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGtleSA9PT0gXCJsaXN0XCIgJiYgZWwudGFnTmFtZSA9PT0gXCJJTlBVVFwiKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChrZXkgPT09IFwidHlwZVwiICYmIGVsLnRhZ05hbWUgPT09IFwiVEVYVEFSRUFcIikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAobmF0aXZlT25SRS50ZXN0KGtleSkgJiYgaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBrZXkgaW4gZWw7XG59XG5cbmZ1bmN0aW9uIGRlZmluZUN1c3RvbUVsZW1lbnQob3B0aW9ucywgaHlkcmF0ZTIpIHtcbiAgY29uc3QgQ29tcCA9IGRlZmluZUNvbXBvbmVudChvcHRpb25zKTtcbiAgY2xhc3MgVnVlQ3VzdG9tRWxlbWVudCBleHRlbmRzIFZ1ZUVsZW1lbnQge1xuICAgIGNvbnN0cnVjdG9yKGluaXRpYWxQcm9wcykge1xuICAgICAgc3VwZXIoQ29tcCwgaW5pdGlhbFByb3BzLCBoeWRyYXRlMik7XG4gICAgfVxuICB9XG4gIFZ1ZUN1c3RvbUVsZW1lbnQuZGVmID0gQ29tcDtcbiAgcmV0dXJuIFZ1ZUN1c3RvbUVsZW1lbnQ7XG59XG5jb25zdCBkZWZpbmVTU1JDdXN0b21FbGVtZW50ID0gKG9wdGlvbnMpID0+IHtcbiAgcmV0dXJuIGRlZmluZUN1c3RvbUVsZW1lbnQob3B0aW9ucywgaHlkcmF0ZSk7XG59O1xuY29uc3QgQmFzZUNsYXNzID0gdHlwZW9mIEhUTUxFbGVtZW50ICE9PSBcInVuZGVmaW5lZFwiID8gSFRNTEVsZW1lbnQgOiBjbGFzcyB7XG59O1xuY2xhc3MgVnVlRWxlbWVudCBleHRlbmRzIEJhc2VDbGFzcyB7XG4gIGNvbnN0cnVjdG9yKF9kZWYsIF9wcm9wcyA9IHt9LCBoeWRyYXRlMikge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5fZGVmID0gX2RlZjtcbiAgICB0aGlzLl9wcm9wcyA9IF9wcm9wcztcbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICB0aGlzLl9pbnN0YW5jZSA9IG51bGw7XG4gICAgdGhpcy5fY29ubmVjdGVkID0gZmFsc2U7XG4gICAgdGhpcy5fcmVzb2x2ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9udW1iZXJQcm9wcyA9IG51bGw7XG4gICAgaWYgKHRoaXMuc2hhZG93Um9vdCAmJiBoeWRyYXRlMikge1xuICAgICAgaHlkcmF0ZTIodGhpcy5fY3JlYXRlVk5vZGUoKSwgdGhpcy5zaGFkb3dSb290KTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgdGhpcy5zaGFkb3dSb290KSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgYEN1c3RvbSBlbGVtZW50IGhhcyBwcmUtcmVuZGVyZWQgZGVjbGFyYXRpdmUgc2hhZG93IHJvb3QgYnV0IGlzIG5vdCBkZWZpbmVkIGFzIGh5ZHJhdGFibGUuIFVzZSBcXGBkZWZpbmVTU1JDdXN0b21FbGVtZW50XFxgLmBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuYXR0YWNoU2hhZG93KHsgbW9kZTogXCJvcGVuXCIgfSk7XG4gICAgICBpZiAoIXRoaXMuX2RlZi5fX2FzeW5jTG9hZGVyKSB7XG4gICAgICAgIHRoaXMuX3Jlc29sdmVQcm9wcyh0aGlzLl9kZWYpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICB0aGlzLl9jb25uZWN0ZWQgPSB0cnVlO1xuICAgIGlmICghdGhpcy5faW5zdGFuY2UpIHtcbiAgICAgIGlmICh0aGlzLl9yZXNvbHZlZCkge1xuICAgICAgICB0aGlzLl91cGRhdGUoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3Jlc29sdmVEZWYoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5fY29ubmVjdGVkID0gZmFsc2U7XG4gICAgbmV4dFRpY2soKCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLl9jb25uZWN0ZWQpIHtcbiAgICAgICAgcmVuZGVyKG51bGwsIHRoaXMuc2hhZG93Um9vdCk7XG4gICAgICAgIHRoaXMuX2luc3RhbmNlID0gbnVsbDtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogcmVzb2x2ZSBpbm5lciBjb21wb25lbnQgZGVmaW5pdGlvbiAoaGFuZGxlIHBvc3NpYmxlIGFzeW5jIGNvbXBvbmVudClcbiAgICovXG4gIF9yZXNvbHZlRGVmKCkge1xuICAgIHRoaXMuX3Jlc29sdmVkID0gdHJ1ZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuYXR0cmlidXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5fc2V0QXR0cih0aGlzLmF0dHJpYnV0ZXNbaV0ubmFtZSk7XG4gICAgfVxuICAgIG5ldyBNdXRhdGlvbk9ic2VydmVyKChtdXRhdGlvbnMpID0+IHtcbiAgICAgIGZvciAoY29uc3QgbSBvZiBtdXRhdGlvbnMpIHtcbiAgICAgICAgdGhpcy5fc2V0QXR0cihtLmF0dHJpYnV0ZU5hbWUpO1xuICAgICAgfVxuICAgIH0pLm9ic2VydmUodGhpcywgeyBhdHRyaWJ1dGVzOiB0cnVlIH0pO1xuICAgIGNvbnN0IHJlc29sdmUgPSAoZGVmLCBpc0FzeW5jID0gZmFsc2UpID0+IHtcbiAgICAgIGNvbnN0IHsgcHJvcHMsIHN0eWxlcyB9ID0gZGVmO1xuICAgICAgbGV0IG51bWJlclByb3BzO1xuICAgICAgaWYgKHByb3BzICYmICFpc0FycmF5KHByb3BzKSkge1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwcm9wcykge1xuICAgICAgICAgIGNvbnN0IG9wdCA9IHByb3BzW2tleV07XG4gICAgICAgICAgaWYgKG9wdCA9PT0gTnVtYmVyIHx8IG9wdCAmJiBvcHQudHlwZSA9PT0gTnVtYmVyKSB7XG4gICAgICAgICAgICBpZiAoa2V5IGluIHRoaXMuX3Byb3BzKSB7XG4gICAgICAgICAgICAgIHRoaXMuX3Byb3BzW2tleV0gPSB0b051bWJlcih0aGlzLl9wcm9wc1trZXldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIChudW1iZXJQcm9wcyB8fCAobnVtYmVyUHJvcHMgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKSkpW2NhbWVsaXplJDEoa2V5KV0gPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5fbnVtYmVyUHJvcHMgPSBudW1iZXJQcm9wcztcbiAgICAgIGlmIChpc0FzeW5jKSB7XG4gICAgICAgIHRoaXMuX3Jlc29sdmVQcm9wcyhkZWYpO1xuICAgICAgfVxuICAgICAgdGhpcy5fYXBwbHlTdHlsZXMoc3R5bGVzKTtcbiAgICAgIHRoaXMuX3VwZGF0ZSgpO1xuICAgIH07XG4gICAgY29uc3QgYXN5bmNEZWYgPSB0aGlzLl9kZWYuX19hc3luY0xvYWRlcjtcbiAgICBpZiAoYXN5bmNEZWYpIHtcbiAgICAgIGFzeW5jRGVmKCkudGhlbigoZGVmKSA9PiByZXNvbHZlKGRlZiwgdHJ1ZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXNvbHZlKHRoaXMuX2RlZik7XG4gICAgfVxuICB9XG4gIF9yZXNvbHZlUHJvcHMoZGVmKSB7XG4gICAgY29uc3QgeyBwcm9wcyB9ID0gZGVmO1xuICAgIGNvbnN0IGRlY2xhcmVkUHJvcEtleXMgPSBpc0FycmF5KHByb3BzKSA/IHByb3BzIDogT2JqZWN0LmtleXMocHJvcHMgfHwge30pO1xuICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHRoaXMpKSB7XG4gICAgICBpZiAoa2V5WzBdICE9PSBcIl9cIiAmJiBkZWNsYXJlZFByb3BLZXlzLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgdGhpcy5fc2V0UHJvcChrZXksIHRoaXNba2V5XSwgdHJ1ZSwgZmFsc2UpO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGNvbnN0IGtleSBvZiBkZWNsYXJlZFByb3BLZXlzLm1hcChjYW1lbGl6ZSQxKSkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIGtleSwge1xuICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2dldFByb3Aoa2V5KTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0KHZhbCkge1xuICAgICAgICAgIHRoaXMuX3NldFByb3Aoa2V5LCB2YWwpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgX3NldEF0dHIoa2V5KSB7XG4gICAgbGV0IHZhbHVlID0gdGhpcy5nZXRBdHRyaWJ1dGUoa2V5KTtcbiAgICBjb25zdCBjYW1lbEtleSA9IGNhbWVsaXplJDEoa2V5KTtcbiAgICBpZiAodGhpcy5fbnVtYmVyUHJvcHMgJiYgdGhpcy5fbnVtYmVyUHJvcHNbY2FtZWxLZXldKSB7XG4gICAgICB2YWx1ZSA9IHRvTnVtYmVyKHZhbHVlKTtcbiAgICB9XG4gICAgdGhpcy5fc2V0UHJvcChjYW1lbEtleSwgdmFsdWUsIGZhbHNlKTtcbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBfZ2V0UHJvcChrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5fcHJvcHNba2V5XTtcbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBfc2V0UHJvcChrZXksIHZhbCwgc2hvdWxkUmVmbGVjdCA9IHRydWUsIHNob3VsZFVwZGF0ZSA9IHRydWUpIHtcbiAgICBpZiAodmFsICE9PSB0aGlzLl9wcm9wc1trZXldKSB7XG4gICAgICB0aGlzLl9wcm9wc1trZXldID0gdmFsO1xuICAgICAgaWYgKHNob3VsZFVwZGF0ZSAmJiB0aGlzLl9pbnN0YW5jZSkge1xuICAgICAgICB0aGlzLl91cGRhdGUoKTtcbiAgICAgIH1cbiAgICAgIGlmIChzaG91bGRSZWZsZWN0KSB7XG4gICAgICAgIGlmICh2YWwgPT09IHRydWUpIHtcbiAgICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZShoeXBoZW5hdGUoa2V5KSwgXCJcIik7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgdmFsID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoaHlwaGVuYXRlKGtleSksIHZhbCArIFwiXCIpO1xuICAgICAgICB9IGVsc2UgaWYgKCF2YWwpIHtcbiAgICAgICAgICB0aGlzLnJlbW92ZUF0dHJpYnV0ZShoeXBoZW5hdGUoa2V5KSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgX3VwZGF0ZSgpIHtcbiAgICByZW5kZXIodGhpcy5fY3JlYXRlVk5vZGUoKSwgdGhpcy5zaGFkb3dSb290KTtcbiAgfVxuICBfY3JlYXRlVk5vZGUoKSB7XG4gICAgY29uc3Qgdm5vZGUgPSBjcmVhdGVWTm9kZSh0aGlzLl9kZWYsIGV4dGVuZCh7fSwgdGhpcy5fcHJvcHMpKTtcbiAgICBpZiAoIXRoaXMuX2luc3RhbmNlKSB7XG4gICAgICB2bm9kZS5jZSA9IChpbnN0YW5jZSkgPT4ge1xuICAgICAgICB0aGlzLl9pbnN0YW5jZSA9IGluc3RhbmNlO1xuICAgICAgICBpbnN0YW5jZS5pc0NFID0gdHJ1ZTtcbiAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICBpbnN0YW5jZS5jZVJlbG9hZCA9IChuZXdTdHlsZXMpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9zdHlsZXMpIHtcbiAgICAgICAgICAgICAgdGhpcy5fc3R5bGVzLmZvckVhY2goKHMpID0+IHRoaXMuc2hhZG93Um9vdC5yZW1vdmVDaGlsZChzKSk7XG4gICAgICAgICAgICAgIHRoaXMuX3N0eWxlcy5sZW5ndGggPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fYXBwbHlTdHlsZXMobmV3U3R5bGVzKTtcbiAgICAgICAgICAgIHRoaXMuX2luc3RhbmNlID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZSgpO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGlzcGF0Y2ggPSAoZXZlbnQsIGFyZ3MpID0+IHtcbiAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoXG4gICAgICAgICAgICBuZXcgQ3VzdG9tRXZlbnQoZXZlbnQsIHtcbiAgICAgICAgICAgICAgZGV0YWlsOiBhcmdzXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICk7XG4gICAgICAgIH07XG4gICAgICAgIGluc3RhbmNlLmVtaXQgPSAoZXZlbnQsIC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICBkaXNwYXRjaChldmVudCwgYXJncyk7XG4gICAgICAgICAgaWYgKGh5cGhlbmF0ZShldmVudCkgIT09IGV2ZW50KSB7XG4gICAgICAgICAgICBkaXNwYXRjaChoeXBoZW5hdGUoZXZlbnQpLCBhcmdzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGxldCBwYXJlbnQgPSB0aGlzO1xuICAgICAgICB3aGlsZSAocGFyZW50ID0gcGFyZW50ICYmIChwYXJlbnQucGFyZW50Tm9kZSB8fCBwYXJlbnQuaG9zdCkpIHtcbiAgICAgICAgICBpZiAocGFyZW50IGluc3RhbmNlb2YgVnVlRWxlbWVudCkge1xuICAgICAgICAgICAgaW5zdGFuY2UucGFyZW50ID0gcGFyZW50Ll9pbnN0YW5jZTtcbiAgICAgICAgICAgIGluc3RhbmNlLnByb3ZpZGVzID0gcGFyZW50Ll9pbnN0YW5jZS5wcm92aWRlcztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHZub2RlO1xuICB9XG4gIF9hcHBseVN0eWxlcyhzdHlsZXMpIHtcbiAgICBpZiAoc3R5bGVzKSB7XG4gICAgICBzdHlsZXMuZm9yRWFjaCgoY3NzKSA9PiB7XG4gICAgICAgIGNvbnN0IHMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XG4gICAgICAgIHMudGV4dENvbnRlbnQgPSBjc3M7XG4gICAgICAgIHRoaXMuc2hhZG93Um9vdC5hcHBlbmRDaGlsZChzKTtcbiAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICAodGhpcy5fc3R5bGVzIHx8ICh0aGlzLl9zdHlsZXMgPSBbXSkpLnB1c2gocyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB1c2VDc3NNb2R1bGUobmFtZSA9IFwiJHN0eWxlXCIpIHtcbiAge1xuICAgIGNvbnN0IGluc3RhbmNlID0gZ2V0Q3VycmVudEluc3RhbmNlKCk7XG4gICAgaWYgKCFpbnN0YW5jZSkge1xuICAgICAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiB3YXJuKGB1c2VDc3NNb2R1bGUgbXVzdCBiZSBjYWxsZWQgaW5zaWRlIHNldHVwKClgKTtcbiAgICAgIHJldHVybiBFTVBUWV9PQko7XG4gICAgfVxuICAgIGNvbnN0IG1vZHVsZXMgPSBpbnN0YW5jZS50eXBlLl9fY3NzTW9kdWxlcztcbiAgICBpZiAoIW1vZHVsZXMpIHtcbiAgICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgd2FybihgQ3VycmVudCBpbnN0YW5jZSBkb2VzIG5vdCBoYXZlIENTUyBtb2R1bGVzIGluamVjdGVkLmApO1xuICAgICAgcmV0dXJuIEVNUFRZX09CSjtcbiAgICB9XG4gICAgY29uc3QgbW9kID0gbW9kdWxlc1tuYW1lXTtcbiAgICBpZiAoIW1vZCkge1xuICAgICAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiB3YXJuKGBDdXJyZW50IGluc3RhbmNlIGRvZXMgbm90IGhhdmUgQ1NTIG1vZHVsZSBuYW1lZCBcIiR7bmFtZX1cIi5gKTtcbiAgICAgIHJldHVybiBFTVBUWV9PQko7XG4gICAgfVxuICAgIHJldHVybiBtb2Q7XG4gIH1cbn1cblxuZnVuY3Rpb24gdXNlQ3NzVmFycyhnZXR0ZXIpIHtcbiAgY29uc3QgaW5zdGFuY2UgPSBnZXRDdXJyZW50SW5zdGFuY2UoKTtcbiAgaWYgKCFpbnN0YW5jZSkge1xuICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgd2FybihgdXNlQ3NzVmFycyBpcyBjYWxsZWQgd2l0aG91dCBjdXJyZW50IGFjdGl2ZSBjb21wb25lbnQgaW5zdGFuY2UuYCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHVwZGF0ZVRlbGVwb3J0cyA9IGluc3RhbmNlLnV0ID0gKHZhcnMgPSBnZXR0ZXIoaW5zdGFuY2UucHJveHkpKSA9PiB7XG4gICAgQXJyYXkuZnJvbShcbiAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoYFtkYXRhLXYtb3duZXI9XCIke2luc3RhbmNlLnVpZH1cIl1gKVxuICAgICkuZm9yRWFjaCgobm9kZSkgPT4gc2V0VmFyc09uTm9kZShub2RlLCB2YXJzKSk7XG4gIH07XG4gIGNvbnN0IHNldFZhcnMgPSAoKSA9PiB7XG4gICAgY29uc3QgdmFycyA9IGdldHRlcihpbnN0YW5jZS5wcm94eSk7XG4gICAgc2V0VmFyc09uVk5vZGUoaW5zdGFuY2Uuc3ViVHJlZSwgdmFycyk7XG4gICAgdXBkYXRlVGVsZXBvcnRzKHZhcnMpO1xuICB9O1xuICB3YXRjaFBvc3RFZmZlY3Qoc2V0VmFycyk7XG4gIG9uTW91bnRlZCgoKSA9PiB7XG4gICAgY29uc3Qgb2IgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihzZXRWYXJzKTtcbiAgICBvYi5vYnNlcnZlKGluc3RhbmNlLnN1YlRyZWUuZWwucGFyZW50Tm9kZSwgeyBjaGlsZExpc3Q6IHRydWUgfSk7XG4gICAgb25Vbm1vdW50ZWQoKCkgPT4gb2IuZGlzY29ubmVjdCgpKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBzZXRWYXJzT25WTm9kZSh2bm9kZSwgdmFycykge1xuICBpZiAodm5vZGUuc2hhcGVGbGFnICYgMTI4KSB7XG4gICAgY29uc3Qgc3VzcGVuc2UgPSB2bm9kZS5zdXNwZW5zZTtcbiAgICB2bm9kZSA9IHN1c3BlbnNlLmFjdGl2ZUJyYW5jaDtcbiAgICBpZiAoc3VzcGVuc2UucGVuZGluZ0JyYW5jaCAmJiAhc3VzcGVuc2UuaXNIeWRyYXRpbmcpIHtcbiAgICAgIHN1c3BlbnNlLmVmZmVjdHMucHVzaCgoKSA9PiB7XG4gICAgICAgIHNldFZhcnNPblZOb2RlKHN1c3BlbnNlLmFjdGl2ZUJyYW5jaCwgdmFycyk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgd2hpbGUgKHZub2RlLmNvbXBvbmVudCkge1xuICAgIHZub2RlID0gdm5vZGUuY29tcG9uZW50LnN1YlRyZWU7XG4gIH1cbiAgaWYgKHZub2RlLnNoYXBlRmxhZyAmIDEgJiYgdm5vZGUuZWwpIHtcbiAgICBzZXRWYXJzT25Ob2RlKHZub2RlLmVsLCB2YXJzKTtcbiAgfSBlbHNlIGlmICh2bm9kZS50eXBlID09PSBGcmFnbWVudCkge1xuICAgIHZub2RlLmNoaWxkcmVuLmZvckVhY2goKGMpID0+IHNldFZhcnNPblZOb2RlKGMsIHZhcnMpKTtcbiAgfSBlbHNlIGlmICh2bm9kZS50eXBlID09PSBTdGF0aWMpIHtcbiAgICBsZXQgeyBlbCwgYW5jaG9yIH0gPSB2bm9kZTtcbiAgICB3aGlsZSAoZWwpIHtcbiAgICAgIHNldFZhcnNPbk5vZGUoZWwsIHZhcnMpO1xuICAgICAgaWYgKGVsID09PSBhbmNob3IpXG4gICAgICAgIGJyZWFrO1xuICAgICAgZWwgPSBlbC5uZXh0U2libGluZztcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHNldFZhcnNPbk5vZGUoZWwsIHZhcnMpIHtcbiAgaWYgKGVsLm5vZGVUeXBlID09PSAxKSB7XG4gICAgY29uc3Qgc3R5bGUgPSBlbC5zdHlsZTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiB2YXJzKSB7XG4gICAgICBzdHlsZS5zZXRQcm9wZXJ0eShgLS0ke2tleX1gLCB2YXJzW2tleV0pO1xuICAgIH1cbiAgfVxufVxuXG5jb25zdCBUUkFOU0lUSU9OID0gXCJ0cmFuc2l0aW9uXCI7XG5jb25zdCBBTklNQVRJT04gPSBcImFuaW1hdGlvblwiO1xuY29uc3QgVHJhbnNpdGlvbiA9IChwcm9wcywgeyBzbG90cyB9KSA9PiBoKEJhc2VUcmFuc2l0aW9uLCByZXNvbHZlVHJhbnNpdGlvblByb3BzKHByb3BzKSwgc2xvdHMpO1xuVHJhbnNpdGlvbi5kaXNwbGF5TmFtZSA9IFwiVHJhbnNpdGlvblwiO1xuY29uc3QgRE9NVHJhbnNpdGlvblByb3BzVmFsaWRhdG9ycyA9IHtcbiAgbmFtZTogU3RyaW5nLFxuICB0eXBlOiBTdHJpbmcsXG4gIGNzczoge1xuICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgZGVmYXVsdDogdHJ1ZVxuICB9LFxuICBkdXJhdGlvbjogW1N0cmluZywgTnVtYmVyLCBPYmplY3RdLFxuICBlbnRlckZyb21DbGFzczogU3RyaW5nLFxuICBlbnRlckFjdGl2ZUNsYXNzOiBTdHJpbmcsXG4gIGVudGVyVG9DbGFzczogU3RyaW5nLFxuICBhcHBlYXJGcm9tQ2xhc3M6IFN0cmluZyxcbiAgYXBwZWFyQWN0aXZlQ2xhc3M6IFN0cmluZyxcbiAgYXBwZWFyVG9DbGFzczogU3RyaW5nLFxuICBsZWF2ZUZyb21DbGFzczogU3RyaW5nLFxuICBsZWF2ZUFjdGl2ZUNsYXNzOiBTdHJpbmcsXG4gIGxlYXZlVG9DbGFzczogU3RyaW5nXG59O1xuY29uc3QgVHJhbnNpdGlvblByb3BzVmFsaWRhdG9ycyA9IFRyYW5zaXRpb24ucHJvcHMgPSAvKiBAX19QVVJFX18gKi8gZXh0ZW5kKFxuICB7fSxcbiAgQmFzZVRyYW5zaXRpb25Qcm9wc1ZhbGlkYXRvcnMsXG4gIERPTVRyYW5zaXRpb25Qcm9wc1ZhbGlkYXRvcnNcbik7XG5jb25zdCBjYWxsSG9vayA9IChob29rLCBhcmdzID0gW10pID0+IHtcbiAgaWYgKGlzQXJyYXkoaG9vaykpIHtcbiAgICBob29rLmZvckVhY2goKGgyKSA9PiBoMiguLi5hcmdzKSk7XG4gIH0gZWxzZSBpZiAoaG9vaykge1xuICAgIGhvb2soLi4uYXJncyk7XG4gIH1cbn07XG5jb25zdCBoYXNFeHBsaWNpdENhbGxiYWNrID0gKGhvb2spID0+IHtcbiAgcmV0dXJuIGhvb2sgPyBpc0FycmF5KGhvb2spID8gaG9vay5zb21lKChoMikgPT4gaDIubGVuZ3RoID4gMSkgOiBob29rLmxlbmd0aCA+IDEgOiBmYWxzZTtcbn07XG5mdW5jdGlvbiByZXNvbHZlVHJhbnNpdGlvblByb3BzKHJhd1Byb3BzKSB7XG4gIGNvbnN0IGJhc2VQcm9wcyA9IHt9O1xuICBmb3IgKGNvbnN0IGtleSBpbiByYXdQcm9wcykge1xuICAgIGlmICghKGtleSBpbiBET01UcmFuc2l0aW9uUHJvcHNWYWxpZGF0b3JzKSkge1xuICAgICAgYmFzZVByb3BzW2tleV0gPSByYXdQcm9wc1trZXldO1xuICAgIH1cbiAgfVxuICBpZiAocmF3UHJvcHMuY3NzID09PSBmYWxzZSkge1xuICAgIHJldHVybiBiYXNlUHJvcHM7XG4gIH1cbiAgY29uc3Qge1xuICAgIG5hbWUgPSBcInZcIixcbiAgICB0eXBlLFxuICAgIGR1cmF0aW9uLFxuICAgIGVudGVyRnJvbUNsYXNzID0gYCR7bmFtZX0tZW50ZXItZnJvbWAsXG4gICAgZW50ZXJBY3RpdmVDbGFzcyA9IGAke25hbWV9LWVudGVyLWFjdGl2ZWAsXG4gICAgZW50ZXJUb0NsYXNzID0gYCR7bmFtZX0tZW50ZXItdG9gLFxuICAgIGFwcGVhckZyb21DbGFzcyA9IGVudGVyRnJvbUNsYXNzLFxuICAgIGFwcGVhckFjdGl2ZUNsYXNzID0gZW50ZXJBY3RpdmVDbGFzcyxcbiAgICBhcHBlYXJUb0NsYXNzID0gZW50ZXJUb0NsYXNzLFxuICAgIGxlYXZlRnJvbUNsYXNzID0gYCR7bmFtZX0tbGVhdmUtZnJvbWAsXG4gICAgbGVhdmVBY3RpdmVDbGFzcyA9IGAke25hbWV9LWxlYXZlLWFjdGl2ZWAsXG4gICAgbGVhdmVUb0NsYXNzID0gYCR7bmFtZX0tbGVhdmUtdG9gXG4gIH0gPSByYXdQcm9wcztcbiAgY29uc3QgZHVyYXRpb25zID0gbm9ybWFsaXplRHVyYXRpb24oZHVyYXRpb24pO1xuICBjb25zdCBlbnRlckR1cmF0aW9uID0gZHVyYXRpb25zICYmIGR1cmF0aW9uc1swXTtcbiAgY29uc3QgbGVhdmVEdXJhdGlvbiA9IGR1cmF0aW9ucyAmJiBkdXJhdGlvbnNbMV07XG4gIGNvbnN0IHtcbiAgICBvbkJlZm9yZUVudGVyLFxuICAgIG9uRW50ZXIsXG4gICAgb25FbnRlckNhbmNlbGxlZCxcbiAgICBvbkxlYXZlLFxuICAgIG9uTGVhdmVDYW5jZWxsZWQsXG4gICAgb25CZWZvcmVBcHBlYXIgPSBvbkJlZm9yZUVudGVyLFxuICAgIG9uQXBwZWFyID0gb25FbnRlcixcbiAgICBvbkFwcGVhckNhbmNlbGxlZCA9IG9uRW50ZXJDYW5jZWxsZWRcbiAgfSA9IGJhc2VQcm9wcztcbiAgY29uc3QgZmluaXNoRW50ZXIgPSAoZWwsIGlzQXBwZWFyLCBkb25lKSA9PiB7XG4gICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBpc0FwcGVhciA/IGFwcGVhclRvQ2xhc3MgOiBlbnRlclRvQ2xhc3MpO1xuICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgaXNBcHBlYXIgPyBhcHBlYXJBY3RpdmVDbGFzcyA6IGVudGVyQWN0aXZlQ2xhc3MpO1xuICAgIGRvbmUgJiYgZG9uZSgpO1xuICB9O1xuICBjb25zdCBmaW5pc2hMZWF2ZSA9IChlbCwgZG9uZSkgPT4ge1xuICAgIGVsLl9pc0xlYXZpbmcgPSBmYWxzZTtcbiAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlRnJvbUNsYXNzKTtcbiAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlVG9DbGFzcyk7XG4gICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUFjdGl2ZUNsYXNzKTtcbiAgICBkb25lICYmIGRvbmUoKTtcbiAgfTtcbiAgY29uc3QgbWFrZUVudGVySG9vayA9IChpc0FwcGVhcikgPT4ge1xuICAgIHJldHVybiAoZWwsIGRvbmUpID0+IHtcbiAgICAgIGNvbnN0IGhvb2sgPSBpc0FwcGVhciA/IG9uQXBwZWFyIDogb25FbnRlcjtcbiAgICAgIGNvbnN0IHJlc29sdmUgPSAoKSA9PiBmaW5pc2hFbnRlcihlbCwgaXNBcHBlYXIsIGRvbmUpO1xuICAgICAgY2FsbEhvb2soaG9vaywgW2VsLCByZXNvbHZlXSk7XG4gICAgICBuZXh0RnJhbWUoKCkgPT4ge1xuICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGlzQXBwZWFyID8gYXBwZWFyRnJvbUNsYXNzIDogZW50ZXJGcm9tQ2xhc3MpO1xuICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGlzQXBwZWFyID8gYXBwZWFyVG9DbGFzcyA6IGVudGVyVG9DbGFzcyk7XG4gICAgICAgIGlmICghaGFzRXhwbGljaXRDYWxsYmFjayhob29rKSkge1xuICAgICAgICAgIHdoZW5UcmFuc2l0aW9uRW5kcyhlbCwgdHlwZSwgZW50ZXJEdXJhdGlvbiwgcmVzb2x2ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG4gIH07XG4gIHJldHVybiBleHRlbmQoYmFzZVByb3BzLCB7XG4gICAgb25CZWZvcmVFbnRlcihlbCkge1xuICAgICAgY2FsbEhvb2sob25CZWZvcmVFbnRlciwgW2VsXSk7XG4gICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGVudGVyRnJvbUNsYXNzKTtcbiAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgZW50ZXJBY3RpdmVDbGFzcyk7XG4gICAgfSxcbiAgICBvbkJlZm9yZUFwcGVhcihlbCkge1xuICAgICAgY2FsbEhvb2sob25CZWZvcmVBcHBlYXIsIFtlbF0pO1xuICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBhcHBlYXJGcm9tQ2xhc3MpO1xuICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBhcHBlYXJBY3RpdmVDbGFzcyk7XG4gICAgfSxcbiAgICBvbkVudGVyOiBtYWtlRW50ZXJIb29rKGZhbHNlKSxcbiAgICBvbkFwcGVhcjogbWFrZUVudGVySG9vayh0cnVlKSxcbiAgICBvbkxlYXZlKGVsLCBkb25lKSB7XG4gICAgICBlbC5faXNMZWF2aW5nID0gdHJ1ZTtcbiAgICAgIGNvbnN0IHJlc29sdmUgPSAoKSA9PiBmaW5pc2hMZWF2ZShlbCwgZG9uZSk7XG4gICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlRnJvbUNsYXNzKTtcbiAgICAgIGZvcmNlUmVmbG93KCk7XG4gICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQWN0aXZlQ2xhc3MpO1xuICAgICAgbmV4dEZyYW1lKCgpID0+IHtcbiAgICAgICAgaWYgKCFlbC5faXNMZWF2aW5nKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVGcm9tQ2xhc3MpO1xuICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlVG9DbGFzcyk7XG4gICAgICAgIGlmICghaGFzRXhwbGljaXRDYWxsYmFjayhvbkxlYXZlKSkge1xuICAgICAgICAgIHdoZW5UcmFuc2l0aW9uRW5kcyhlbCwgdHlwZSwgbGVhdmVEdXJhdGlvbiwgcmVzb2x2ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgY2FsbEhvb2sob25MZWF2ZSwgW2VsLCByZXNvbHZlXSk7XG4gICAgfSxcbiAgICBvbkVudGVyQ2FuY2VsbGVkKGVsKSB7XG4gICAgICBmaW5pc2hFbnRlcihlbCwgZmFsc2UpO1xuICAgICAgY2FsbEhvb2sob25FbnRlckNhbmNlbGxlZCwgW2VsXSk7XG4gICAgfSxcbiAgICBvbkFwcGVhckNhbmNlbGxlZChlbCkge1xuICAgICAgZmluaXNoRW50ZXIoZWwsIHRydWUpO1xuICAgICAgY2FsbEhvb2sob25BcHBlYXJDYW5jZWxsZWQsIFtlbF0pO1xuICAgIH0sXG4gICAgb25MZWF2ZUNhbmNlbGxlZChlbCkge1xuICAgICAgZmluaXNoTGVhdmUoZWwpO1xuICAgICAgY2FsbEhvb2sob25MZWF2ZUNhbmNlbGxlZCwgW2VsXSk7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZUR1cmF0aW9uKGR1cmF0aW9uKSB7XG4gIGlmIChkdXJhdGlvbiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QoZHVyYXRpb24pKSB7XG4gICAgcmV0dXJuIFtOdW1iZXJPZihkdXJhdGlvbi5lbnRlciksIE51bWJlck9mKGR1cmF0aW9uLmxlYXZlKV07XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgbiA9IE51bWJlck9mKGR1cmF0aW9uKTtcbiAgICByZXR1cm4gW24sIG5dO1xuICB9XG59XG5mdW5jdGlvbiBOdW1iZXJPZih2YWwpIHtcbiAgY29uc3QgcmVzID0gdG9OdW1iZXIodmFsKTtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICBhc3NlcnROdW1iZXIocmVzLCBcIjx0cmFuc2l0aW9uPiBleHBsaWNpdCBkdXJhdGlvblwiKTtcbiAgfVxuICByZXR1cm4gcmVzO1xufVxuZnVuY3Rpb24gYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBjbHMpIHtcbiAgY2xzLnNwbGl0KC9cXHMrLykuZm9yRWFjaCgoYykgPT4gYyAmJiBlbC5jbGFzc0xpc3QuYWRkKGMpKTtcbiAgKGVsLl92dGMgfHwgKGVsLl92dGMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpKSkuYWRkKGNscyk7XG59XG5mdW5jdGlvbiByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGNscykge1xuICBjbHMuc3BsaXQoL1xccysvKS5mb3JFYWNoKChjKSA9PiBjICYmIGVsLmNsYXNzTGlzdC5yZW1vdmUoYykpO1xuICBjb25zdCB7IF92dGMgfSA9IGVsO1xuICBpZiAoX3Z0Yykge1xuICAgIF92dGMuZGVsZXRlKGNscyk7XG4gICAgaWYgKCFfdnRjLnNpemUpIHtcbiAgICAgIGVsLl92dGMgPSB2b2lkIDA7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBuZXh0RnJhbWUoY2IpIHtcbiAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoY2IpO1xuICB9KTtcbn1cbmxldCBlbmRJZCA9IDA7XG5mdW5jdGlvbiB3aGVuVHJhbnNpdGlvbkVuZHMoZWwsIGV4cGVjdGVkVHlwZSwgZXhwbGljaXRUaW1lb3V0LCByZXNvbHZlKSB7XG4gIGNvbnN0IGlkID0gZWwuX2VuZElkID0gKytlbmRJZDtcbiAgY29uc3QgcmVzb2x2ZUlmTm90U3RhbGUgPSAoKSA9PiB7XG4gICAgaWYgKGlkID09PSBlbC5fZW5kSWQpIHtcbiAgICAgIHJlc29sdmUoKTtcbiAgICB9XG4gIH07XG4gIGlmIChleHBsaWNpdFRpbWVvdXQpIHtcbiAgICByZXR1cm4gc2V0VGltZW91dChyZXNvbHZlSWZOb3RTdGFsZSwgZXhwbGljaXRUaW1lb3V0KTtcbiAgfVxuICBjb25zdCB7IHR5cGUsIHRpbWVvdXQsIHByb3BDb3VudCB9ID0gZ2V0VHJhbnNpdGlvbkluZm8oZWwsIGV4cGVjdGVkVHlwZSk7XG4gIGlmICghdHlwZSkge1xuICAgIHJldHVybiByZXNvbHZlKCk7XG4gIH1cbiAgY29uc3QgZW5kRXZlbnQgPSB0eXBlICsgXCJlbmRcIjtcbiAgbGV0IGVuZGVkID0gMDtcbiAgY29uc3QgZW5kID0gKCkgPT4ge1xuICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoZW5kRXZlbnQsIG9uRW5kKTtcbiAgICByZXNvbHZlSWZOb3RTdGFsZSgpO1xuICB9O1xuICBjb25zdCBvbkVuZCA9IChlKSA9PiB7XG4gICAgaWYgKGUudGFyZ2V0ID09PSBlbCAmJiArK2VuZGVkID49IHByb3BDb3VudCkge1xuICAgICAgZW5kKCk7XG4gICAgfVxuICB9O1xuICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICBpZiAoZW5kZWQgPCBwcm9wQ291bnQpIHtcbiAgICAgIGVuZCgpO1xuICAgIH1cbiAgfSwgdGltZW91dCArIDEpO1xuICBlbC5hZGRFdmVudExpc3RlbmVyKGVuZEV2ZW50LCBvbkVuZCk7XG59XG5mdW5jdGlvbiBnZXRUcmFuc2l0aW9uSW5mbyhlbCwgZXhwZWN0ZWRUeXBlKSB7XG4gIGNvbnN0IHN0eWxlcyA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsKTtcbiAgY29uc3QgZ2V0U3R5bGVQcm9wZXJ0aWVzID0gKGtleSkgPT4gKHN0eWxlc1trZXldIHx8IFwiXCIpLnNwbGl0KFwiLCBcIik7XG4gIGNvbnN0IHRyYW5zaXRpb25EZWxheXMgPSBnZXRTdHlsZVByb3BlcnRpZXMoYCR7VFJBTlNJVElPTn1EZWxheWApO1xuICBjb25zdCB0cmFuc2l0aW9uRHVyYXRpb25zID0gZ2V0U3R5bGVQcm9wZXJ0aWVzKGAke1RSQU5TSVRJT059RHVyYXRpb25gKTtcbiAgY29uc3QgdHJhbnNpdGlvblRpbWVvdXQgPSBnZXRUaW1lb3V0KHRyYW5zaXRpb25EZWxheXMsIHRyYW5zaXRpb25EdXJhdGlvbnMpO1xuICBjb25zdCBhbmltYXRpb25EZWxheXMgPSBnZXRTdHlsZVByb3BlcnRpZXMoYCR7QU5JTUFUSU9OfURlbGF5YCk7XG4gIGNvbnN0IGFuaW1hdGlvbkR1cmF0aW9ucyA9IGdldFN0eWxlUHJvcGVydGllcyhgJHtBTklNQVRJT059RHVyYXRpb25gKTtcbiAgY29uc3QgYW5pbWF0aW9uVGltZW91dCA9IGdldFRpbWVvdXQoYW5pbWF0aW9uRGVsYXlzLCBhbmltYXRpb25EdXJhdGlvbnMpO1xuICBsZXQgdHlwZSA9IG51bGw7XG4gIGxldCB0aW1lb3V0ID0gMDtcbiAgbGV0IHByb3BDb3VudCA9IDA7XG4gIGlmIChleHBlY3RlZFR5cGUgPT09IFRSQU5TSVRJT04pIHtcbiAgICBpZiAodHJhbnNpdGlvblRpbWVvdXQgPiAwKSB7XG4gICAgICB0eXBlID0gVFJBTlNJVElPTjtcbiAgICAgIHRpbWVvdXQgPSB0cmFuc2l0aW9uVGltZW91dDtcbiAgICAgIHByb3BDb3VudCA9IHRyYW5zaXRpb25EdXJhdGlvbnMubGVuZ3RoO1xuICAgIH1cbiAgfSBlbHNlIGlmIChleHBlY3RlZFR5cGUgPT09IEFOSU1BVElPTikge1xuICAgIGlmIChhbmltYXRpb25UaW1lb3V0ID4gMCkge1xuICAgICAgdHlwZSA9IEFOSU1BVElPTjtcbiAgICAgIHRpbWVvdXQgPSBhbmltYXRpb25UaW1lb3V0O1xuICAgICAgcHJvcENvdW50ID0gYW5pbWF0aW9uRHVyYXRpb25zLmxlbmd0aDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGltZW91dCA9IE1hdGgubWF4KHRyYW5zaXRpb25UaW1lb3V0LCBhbmltYXRpb25UaW1lb3V0KTtcbiAgICB0eXBlID0gdGltZW91dCA+IDAgPyB0cmFuc2l0aW9uVGltZW91dCA+IGFuaW1hdGlvblRpbWVvdXQgPyBUUkFOU0lUSU9OIDogQU5JTUFUSU9OIDogbnVsbDtcbiAgICBwcm9wQ291bnQgPSB0eXBlID8gdHlwZSA9PT0gVFJBTlNJVElPTiA/IHRyYW5zaXRpb25EdXJhdGlvbnMubGVuZ3RoIDogYW5pbWF0aW9uRHVyYXRpb25zLmxlbmd0aCA6IDA7XG4gIH1cbiAgY29uc3QgaGFzVHJhbnNmb3JtID0gdHlwZSA9PT0gVFJBTlNJVElPTiAmJiAvXFxiKHRyYW5zZm9ybXxhbGwpKCx8JCkvLnRlc3QoXG4gICAgZ2V0U3R5bGVQcm9wZXJ0aWVzKGAke1RSQU5TSVRJT059UHJvcGVydHlgKS50b1N0cmluZygpXG4gICk7XG4gIHJldHVybiB7XG4gICAgdHlwZSxcbiAgICB0aW1lb3V0LFxuICAgIHByb3BDb3VudCxcbiAgICBoYXNUcmFuc2Zvcm1cbiAgfTtcbn1cbmZ1bmN0aW9uIGdldFRpbWVvdXQoZGVsYXlzLCBkdXJhdGlvbnMpIHtcbiAgd2hpbGUgKGRlbGF5cy5sZW5ndGggPCBkdXJhdGlvbnMubGVuZ3RoKSB7XG4gICAgZGVsYXlzID0gZGVsYXlzLmNvbmNhdChkZWxheXMpO1xuICB9XG4gIHJldHVybiBNYXRoLm1heCguLi5kdXJhdGlvbnMubWFwKChkLCBpKSA9PiB0b01zKGQpICsgdG9NcyhkZWxheXNbaV0pKSk7XG59XG5mdW5jdGlvbiB0b01zKHMpIHtcbiAgcmV0dXJuIE51bWJlcihzLnNsaWNlKDAsIC0xKS5yZXBsYWNlKFwiLFwiLCBcIi5cIikpICogMWUzO1xufVxuZnVuY3Rpb24gZm9yY2VSZWZsb3coKSB7XG4gIHJldHVybiBkb2N1bWVudC5ib2R5Lm9mZnNldEhlaWdodDtcbn1cblxuY29uc3QgcG9zaXRpb25NYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbmNvbnN0IG5ld1Bvc2l0aW9uTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG5jb25zdCBUcmFuc2l0aW9uR3JvdXBJbXBsID0ge1xuICBuYW1lOiBcIlRyYW5zaXRpb25Hcm91cFwiLFxuICBwcm9wczogLyogQF9fUFVSRV9fICovIGV4dGVuZCh7fSwgVHJhbnNpdGlvblByb3BzVmFsaWRhdG9ycywge1xuICAgIHRhZzogU3RyaW5nLFxuICAgIG1vdmVDbGFzczogU3RyaW5nXG4gIH0pLFxuICBzZXR1cChwcm9wcywgeyBzbG90cyB9KSB7XG4gICAgY29uc3QgaW5zdGFuY2UgPSBnZXRDdXJyZW50SW5zdGFuY2UoKTtcbiAgICBjb25zdCBzdGF0ZSA9IHVzZVRyYW5zaXRpb25TdGF0ZSgpO1xuICAgIGxldCBwcmV2Q2hpbGRyZW47XG4gICAgbGV0IGNoaWxkcmVuO1xuICAgIG9uVXBkYXRlZCgoKSA9PiB7XG4gICAgICBpZiAoIXByZXZDaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgbW92ZUNsYXNzID0gcHJvcHMubW92ZUNsYXNzIHx8IGAke3Byb3BzLm5hbWUgfHwgXCJ2XCJ9LW1vdmVgO1xuICAgICAgaWYgKCFoYXNDU1NUcmFuc2Zvcm0oXG4gICAgICAgIHByZXZDaGlsZHJlblswXS5lbCxcbiAgICAgICAgaW5zdGFuY2Uudm5vZGUuZWwsXG4gICAgICAgIG1vdmVDbGFzc1xuICAgICAgKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBwcmV2Q2hpbGRyZW4uZm9yRWFjaChjYWxsUGVuZGluZ0Nicyk7XG4gICAgICBwcmV2Q2hpbGRyZW4uZm9yRWFjaChyZWNvcmRQb3NpdGlvbik7XG4gICAgICBjb25zdCBtb3ZlZENoaWxkcmVuID0gcHJldkNoaWxkcmVuLmZpbHRlcihhcHBseVRyYW5zbGF0aW9uKTtcbiAgICAgIGZvcmNlUmVmbG93KCk7XG4gICAgICBtb3ZlZENoaWxkcmVuLmZvckVhY2goKGMpID0+IHtcbiAgICAgICAgY29uc3QgZWwgPSBjLmVsO1xuICAgICAgICBjb25zdCBzdHlsZSA9IGVsLnN0eWxlO1xuICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIG1vdmVDbGFzcyk7XG4gICAgICAgIHN0eWxlLnRyYW5zZm9ybSA9IHN0eWxlLndlYmtpdFRyYW5zZm9ybSA9IHN0eWxlLnRyYW5zaXRpb25EdXJhdGlvbiA9IFwiXCI7XG4gICAgICAgIGNvbnN0IGNiID0gZWwuX21vdmVDYiA9IChlKSA9PiB7XG4gICAgICAgICAgaWYgKGUgJiYgZS50YXJnZXQgIT09IGVsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghZSB8fCAvdHJhbnNmb3JtJC8udGVzdChlLnByb3BlcnR5TmFtZSkpIHtcbiAgICAgICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0cmFuc2l0aW9uZW5kXCIsIGNiKTtcbiAgICAgICAgICAgIGVsLl9tb3ZlQ2IgPSBudWxsO1xuICAgICAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBtb3ZlQ2xhc3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcihcInRyYW5zaXRpb25lbmRcIiwgY2IpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGNvbnN0IHJhd1Byb3BzID0gdG9SYXcocHJvcHMpO1xuICAgICAgY29uc3QgY3NzVHJhbnNpdGlvblByb3BzID0gcmVzb2x2ZVRyYW5zaXRpb25Qcm9wcyhyYXdQcm9wcyk7XG4gICAgICBsZXQgdGFnID0gcmF3UHJvcHMudGFnIHx8IEZyYWdtZW50O1xuICAgICAgcHJldkNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgICBjaGlsZHJlbiA9IHNsb3RzLmRlZmF1bHQgPyBnZXRUcmFuc2l0aW9uUmF3Q2hpbGRyZW4oc2xvdHMuZGVmYXVsdCgpKSA6IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgICBpZiAoY2hpbGQua2V5ICE9IG51bGwpIHtcbiAgICAgICAgICBzZXRUcmFuc2l0aW9uSG9va3MoXG4gICAgICAgICAgICBjaGlsZCxcbiAgICAgICAgICAgIHJlc29sdmVUcmFuc2l0aW9uSG9va3MoY2hpbGQsIGNzc1RyYW5zaXRpb25Qcm9wcywgc3RhdGUsIGluc3RhbmNlKVxuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgIHdhcm4oYDxUcmFuc2l0aW9uR3JvdXA+IGNoaWxkcmVuIG11c3QgYmUga2V5ZWQuYCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChwcmV2Q2hpbGRyZW4pIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcmV2Q2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBjaGlsZCA9IHByZXZDaGlsZHJlbltpXTtcbiAgICAgICAgICBzZXRUcmFuc2l0aW9uSG9va3MoXG4gICAgICAgICAgICBjaGlsZCxcbiAgICAgICAgICAgIHJlc29sdmVUcmFuc2l0aW9uSG9va3MoY2hpbGQsIGNzc1RyYW5zaXRpb25Qcm9wcywgc3RhdGUsIGluc3RhbmNlKVxuICAgICAgICAgICk7XG4gICAgICAgICAgcG9zaXRpb25NYXAuc2V0KGNoaWxkLCBjaGlsZC5lbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBjcmVhdGVWTm9kZSh0YWcsIG51bGwsIGNoaWxkcmVuKTtcbiAgICB9O1xuICB9XG59O1xuY29uc3QgcmVtb3ZlTW9kZSA9IChwcm9wcykgPT4gZGVsZXRlIHByb3BzLm1vZGU7XG4vKiBAX19QVVJFX18gKi8gcmVtb3ZlTW9kZShUcmFuc2l0aW9uR3JvdXBJbXBsLnByb3BzKTtcbmNvbnN0IFRyYW5zaXRpb25Hcm91cCA9IFRyYW5zaXRpb25Hcm91cEltcGw7XG5mdW5jdGlvbiBjYWxsUGVuZGluZ0NicyhjKSB7XG4gIGNvbnN0IGVsID0gYy5lbDtcbiAgaWYgKGVsLl9tb3ZlQ2IpIHtcbiAgICBlbC5fbW92ZUNiKCk7XG4gIH1cbiAgaWYgKGVsLl9lbnRlckNiKSB7XG4gICAgZWwuX2VudGVyQ2IoKTtcbiAgfVxufVxuZnVuY3Rpb24gcmVjb3JkUG9zaXRpb24oYykge1xuICBuZXdQb3NpdGlvbk1hcC5zZXQoYywgYy5lbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSk7XG59XG5mdW5jdGlvbiBhcHBseVRyYW5zbGF0aW9uKGMpIHtcbiAgY29uc3Qgb2xkUG9zID0gcG9zaXRpb25NYXAuZ2V0KGMpO1xuICBjb25zdCBuZXdQb3MgPSBuZXdQb3NpdGlvbk1hcC5nZXQoYyk7XG4gIGNvbnN0IGR4ID0gb2xkUG9zLmxlZnQgLSBuZXdQb3MubGVmdDtcbiAgY29uc3QgZHkgPSBvbGRQb3MudG9wIC0gbmV3UG9zLnRvcDtcbiAgaWYgKGR4IHx8IGR5KSB7XG4gICAgY29uc3QgcyA9IGMuZWwuc3R5bGU7XG4gICAgcy50cmFuc2Zvcm0gPSBzLndlYmtpdFRyYW5zZm9ybSA9IGB0cmFuc2xhdGUoJHtkeH1weCwke2R5fXB4KWA7XG4gICAgcy50cmFuc2l0aW9uRHVyYXRpb24gPSBcIjBzXCI7XG4gICAgcmV0dXJuIGM7XG4gIH1cbn1cbmZ1bmN0aW9uIGhhc0NTU1RyYW5zZm9ybShlbCwgcm9vdCwgbW92ZUNsYXNzKSB7XG4gIGNvbnN0IGNsb25lID0gZWwuY2xvbmVOb2RlKCk7XG4gIGlmIChlbC5fdnRjKSB7XG4gICAgZWwuX3Z0Yy5mb3JFYWNoKChjbHMpID0+IHtcbiAgICAgIGNscy5zcGxpdCgvXFxzKy8pLmZvckVhY2goKGMpID0+IGMgJiYgY2xvbmUuY2xhc3NMaXN0LnJlbW92ZShjKSk7XG4gICAgfSk7XG4gIH1cbiAgbW92ZUNsYXNzLnNwbGl0KC9cXHMrLykuZm9yRWFjaCgoYykgPT4gYyAmJiBjbG9uZS5jbGFzc0xpc3QuYWRkKGMpKTtcbiAgY2xvbmUuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICBjb25zdCBjb250YWluZXIgPSByb290Lm5vZGVUeXBlID09PSAxID8gcm9vdCA6IHJvb3QucGFyZW50Tm9kZTtcbiAgY29udGFpbmVyLmFwcGVuZENoaWxkKGNsb25lKTtcbiAgY29uc3QgeyBoYXNUcmFuc2Zvcm0gfSA9IGdldFRyYW5zaXRpb25JbmZvKGNsb25lKTtcbiAgY29udGFpbmVyLnJlbW92ZUNoaWxkKGNsb25lKTtcbiAgcmV0dXJuIGhhc1RyYW5zZm9ybTtcbn1cblxuY29uc3QgZ2V0TW9kZWxBc3NpZ25lciA9ICh2bm9kZSkgPT4ge1xuICBjb25zdCBmbiA9IHZub2RlLnByb3BzW1wib25VcGRhdGU6bW9kZWxWYWx1ZVwiXSB8fCBmYWxzZTtcbiAgcmV0dXJuIGlzQXJyYXkoZm4pID8gKHZhbHVlKSA9PiBpbnZva2VBcnJheUZucyhmbiwgdmFsdWUpIDogZm47XG59O1xuZnVuY3Rpb24gb25Db21wb3NpdGlvblN0YXJ0KGUpIHtcbiAgZS50YXJnZXQuY29tcG9zaW5nID0gdHJ1ZTtcbn1cbmZ1bmN0aW9uIG9uQ29tcG9zaXRpb25FbmQoZSkge1xuICBjb25zdCB0YXJnZXQgPSBlLnRhcmdldDtcbiAgaWYgKHRhcmdldC5jb21wb3NpbmcpIHtcbiAgICB0YXJnZXQuY29tcG9zaW5nID0gZmFsc2U7XG4gICAgdGFyZ2V0LmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KFwiaW5wdXRcIikpO1xuICB9XG59XG5jb25zdCB2TW9kZWxUZXh0ID0ge1xuICBjcmVhdGVkKGVsLCB7IG1vZGlmaWVyczogeyBsYXp5LCB0cmltLCBudW1iZXIgfSB9LCB2bm9kZSkge1xuICAgIGVsLl9hc3NpZ24gPSBnZXRNb2RlbEFzc2lnbmVyKHZub2RlKTtcbiAgICBjb25zdCBjYXN0VG9OdW1iZXIgPSBudW1iZXIgfHwgdm5vZGUucHJvcHMgJiYgdm5vZGUucHJvcHMudHlwZSA9PT0gXCJudW1iZXJcIjtcbiAgICBhZGRFdmVudExpc3RlbmVyKGVsLCBsYXp5ID8gXCJjaGFuZ2VcIiA6IFwiaW5wdXRcIiwgKGUpID0+IHtcbiAgICAgIGlmIChlLnRhcmdldC5jb21wb3NpbmcpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGxldCBkb21WYWx1ZSA9IGVsLnZhbHVlO1xuICAgICAgaWYgKHRyaW0pIHtcbiAgICAgICAgZG9tVmFsdWUgPSBkb21WYWx1ZS50cmltKCk7XG4gICAgICB9XG4gICAgICBpZiAoY2FzdFRvTnVtYmVyKSB7XG4gICAgICAgIGRvbVZhbHVlID0gbG9vc2VUb051bWJlcihkb21WYWx1ZSk7XG4gICAgICB9XG4gICAgICBlbC5fYXNzaWduKGRvbVZhbHVlKTtcbiAgICB9KTtcbiAgICBpZiAodHJpbSkge1xuICAgICAgYWRkRXZlbnRMaXN0ZW5lcihlbCwgXCJjaGFuZ2VcIiwgKCkgPT4ge1xuICAgICAgICBlbC52YWx1ZSA9IGVsLnZhbHVlLnRyaW0oKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoIWxhenkpIHtcbiAgICAgIGFkZEV2ZW50TGlzdGVuZXIoZWwsIFwiY29tcG9zaXRpb25zdGFydFwiLCBvbkNvbXBvc2l0aW9uU3RhcnQpO1xuICAgICAgYWRkRXZlbnRMaXN0ZW5lcihlbCwgXCJjb21wb3NpdGlvbmVuZFwiLCBvbkNvbXBvc2l0aW9uRW5kKTtcbiAgICAgIGFkZEV2ZW50TGlzdGVuZXIoZWwsIFwiY2hhbmdlXCIsIG9uQ29tcG9zaXRpb25FbmQpO1xuICAgIH1cbiAgfSxcbiAgLy8gc2V0IHZhbHVlIG9uIG1vdW50ZWQgc28gaXQncyBhZnRlciBtaW4vbWF4IGZvciB0eXBlPVwicmFuZ2VcIlxuICBtb3VudGVkKGVsLCB7IHZhbHVlIH0pIHtcbiAgICBlbC52YWx1ZSA9IHZhbHVlID09IG51bGwgPyBcIlwiIDogdmFsdWU7XG4gIH0sXG4gIGJlZm9yZVVwZGF0ZShlbCwgeyB2YWx1ZSwgbW9kaWZpZXJzOiB7IGxhenksIHRyaW0sIG51bWJlciB9IH0sIHZub2RlKSB7XG4gICAgZWwuX2Fzc2lnbiA9IGdldE1vZGVsQXNzaWduZXIodm5vZGUpO1xuICAgIGlmIChlbC5jb21wb3NpbmcpXG4gICAgICByZXR1cm47XG4gICAgaWYgKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPT09IGVsICYmIGVsLnR5cGUgIT09IFwicmFuZ2VcIikge1xuICAgICAgaWYgKGxhenkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHRyaW0gJiYgZWwudmFsdWUudHJpbSgpID09PSB2YWx1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoKG51bWJlciB8fCBlbC50eXBlID09PSBcIm51bWJlclwiKSAmJiBsb29zZVRvTnVtYmVyKGVsLnZhbHVlKSA9PT0gdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBuZXdWYWx1ZSA9IHZhbHVlID09IG51bGwgPyBcIlwiIDogdmFsdWU7XG4gICAgaWYgKGVsLnZhbHVlICE9PSBuZXdWYWx1ZSkge1xuICAgICAgZWwudmFsdWUgPSBuZXdWYWx1ZTtcbiAgICB9XG4gIH1cbn07XG5jb25zdCB2TW9kZWxDaGVja2JveCA9IHtcbiAgLy8gIzQwOTYgYXJyYXkgY2hlY2tib3hlcyBuZWVkIHRvIGJlIGRlZXAgdHJhdmVyc2VkXG4gIGRlZXA6IHRydWUsXG4gIGNyZWF0ZWQoZWwsIF8sIHZub2RlKSB7XG4gICAgZWwuX2Fzc2lnbiA9IGdldE1vZGVsQXNzaWduZXIodm5vZGUpO1xuICAgIGFkZEV2ZW50TGlzdGVuZXIoZWwsIFwiY2hhbmdlXCIsICgpID0+IHtcbiAgICAgIGNvbnN0IG1vZGVsVmFsdWUgPSBlbC5fbW9kZWxWYWx1ZTtcbiAgICAgIGNvbnN0IGVsZW1lbnRWYWx1ZSA9IGdldFZhbHVlKGVsKTtcbiAgICAgIGNvbnN0IGNoZWNrZWQgPSBlbC5jaGVja2VkO1xuICAgICAgY29uc3QgYXNzaWduID0gZWwuX2Fzc2lnbjtcbiAgICAgIGlmIChpc0FycmF5KG1vZGVsVmFsdWUpKSB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gbG9vc2VJbmRleE9mKG1vZGVsVmFsdWUsIGVsZW1lbnRWYWx1ZSk7XG4gICAgICAgIGNvbnN0IGZvdW5kID0gaW5kZXggIT09IC0xO1xuICAgICAgICBpZiAoY2hlY2tlZCAmJiAhZm91bmQpIHtcbiAgICAgICAgICBhc3NpZ24obW9kZWxWYWx1ZS5jb25jYXQoZWxlbWVudFZhbHVlKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoIWNoZWNrZWQgJiYgZm91bmQpIHtcbiAgICAgICAgICBjb25zdCBmaWx0ZXJlZCA9IFsuLi5tb2RlbFZhbHVlXTtcbiAgICAgICAgICBmaWx0ZXJlZC5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgIGFzc2lnbihmaWx0ZXJlZCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaXNTZXQobW9kZWxWYWx1ZSkpIHtcbiAgICAgICAgY29uc3QgY2xvbmVkID0gbmV3IFNldChtb2RlbFZhbHVlKTtcbiAgICAgICAgaWYgKGNoZWNrZWQpIHtcbiAgICAgICAgICBjbG9uZWQuYWRkKGVsZW1lbnRWYWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2xvbmVkLmRlbGV0ZShlbGVtZW50VmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGFzc2lnbihjbG9uZWQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXNzaWduKGdldENoZWNrYm94VmFsdWUoZWwsIGNoZWNrZWQpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcbiAgLy8gc2V0IGluaXRpYWwgY2hlY2tlZCBvbiBtb3VudCB0byB3YWl0IGZvciB0cnVlLXZhbHVlL2ZhbHNlLXZhbHVlXG4gIG1vdW50ZWQ6IHNldENoZWNrZWQsXG4gIGJlZm9yZVVwZGF0ZShlbCwgYmluZGluZywgdm5vZGUpIHtcbiAgICBlbC5fYXNzaWduID0gZ2V0TW9kZWxBc3NpZ25lcih2bm9kZSk7XG4gICAgc2V0Q2hlY2tlZChlbCwgYmluZGluZywgdm5vZGUpO1xuICB9XG59O1xuZnVuY3Rpb24gc2V0Q2hlY2tlZChlbCwgeyB2YWx1ZSwgb2xkVmFsdWUgfSwgdm5vZGUpIHtcbiAgZWwuX21vZGVsVmFsdWUgPSB2YWx1ZTtcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgZWwuY2hlY2tlZCA9IGxvb3NlSW5kZXhPZih2YWx1ZSwgdm5vZGUucHJvcHMudmFsdWUpID4gLTE7XG4gIH0gZWxzZSBpZiAoaXNTZXQodmFsdWUpKSB7XG4gICAgZWwuY2hlY2tlZCA9IHZhbHVlLmhhcyh2bm9kZS5wcm9wcy52YWx1ZSk7XG4gIH0gZWxzZSBpZiAodmFsdWUgIT09IG9sZFZhbHVlKSB7XG4gICAgZWwuY2hlY2tlZCA9IGxvb3NlRXF1YWwodmFsdWUsIGdldENoZWNrYm94VmFsdWUoZWwsIHRydWUpKTtcbiAgfVxufVxuY29uc3Qgdk1vZGVsUmFkaW8gPSB7XG4gIGNyZWF0ZWQoZWwsIHsgdmFsdWUgfSwgdm5vZGUpIHtcbiAgICBlbC5jaGVja2VkID0gbG9vc2VFcXVhbCh2YWx1ZSwgdm5vZGUucHJvcHMudmFsdWUpO1xuICAgIGVsLl9hc3NpZ24gPSBnZXRNb2RlbEFzc2lnbmVyKHZub2RlKTtcbiAgICBhZGRFdmVudExpc3RlbmVyKGVsLCBcImNoYW5nZVwiLCAoKSA9PiB7XG4gICAgICBlbC5fYXNzaWduKGdldFZhbHVlKGVsKSk7XG4gICAgfSk7XG4gIH0sXG4gIGJlZm9yZVVwZGF0ZShlbCwgeyB2YWx1ZSwgb2xkVmFsdWUgfSwgdm5vZGUpIHtcbiAgICBlbC5fYXNzaWduID0gZ2V0TW9kZWxBc3NpZ25lcih2bm9kZSk7XG4gICAgaWYgKHZhbHVlICE9PSBvbGRWYWx1ZSkge1xuICAgICAgZWwuY2hlY2tlZCA9IGxvb3NlRXF1YWwodmFsdWUsIHZub2RlLnByb3BzLnZhbHVlKTtcbiAgICB9XG4gIH1cbn07XG5jb25zdCB2TW9kZWxTZWxlY3QgPSB7XG4gIC8vIDxzZWxlY3QgbXVsdGlwbGU+IHZhbHVlIG5lZWQgdG8gYmUgZGVlcCB0cmF2ZXJzZWRcbiAgZGVlcDogdHJ1ZSxcbiAgY3JlYXRlZChlbCwgeyB2YWx1ZSwgbW9kaWZpZXJzOiB7IG51bWJlciB9IH0sIHZub2RlKSB7XG4gICAgY29uc3QgaXNTZXRNb2RlbCA9IGlzU2V0KHZhbHVlKTtcbiAgICBhZGRFdmVudExpc3RlbmVyKGVsLCBcImNoYW5nZVwiLCAoKSA9PiB7XG4gICAgICBjb25zdCBzZWxlY3RlZFZhbCA9IEFycmF5LnByb3RvdHlwZS5maWx0ZXIuY2FsbChlbC5vcHRpb25zLCAobykgPT4gby5zZWxlY3RlZCkubWFwKFxuICAgICAgICAobykgPT4gbnVtYmVyID8gbG9vc2VUb051bWJlcihnZXRWYWx1ZShvKSkgOiBnZXRWYWx1ZShvKVxuICAgICAgKTtcbiAgICAgIGVsLl9hc3NpZ24oXG4gICAgICAgIGVsLm11bHRpcGxlID8gaXNTZXRNb2RlbCA/IG5ldyBTZXQoc2VsZWN0ZWRWYWwpIDogc2VsZWN0ZWRWYWwgOiBzZWxlY3RlZFZhbFswXVxuICAgICAgKTtcbiAgICB9KTtcbiAgICBlbC5fYXNzaWduID0gZ2V0TW9kZWxBc3NpZ25lcih2bm9kZSk7XG4gIH0sXG4gIC8vIHNldCB2YWx1ZSBpbiBtb3VudGVkICYgdXBkYXRlZCBiZWNhdXNlIDxzZWxlY3Q+IHJlbGllcyBvbiBpdHMgY2hpbGRyZW5cbiAgLy8gPG9wdGlvbj5zLlxuICBtb3VudGVkKGVsLCB7IHZhbHVlIH0pIHtcbiAgICBzZXRTZWxlY3RlZChlbCwgdmFsdWUpO1xuICB9LFxuICBiZWZvcmVVcGRhdGUoZWwsIF9iaW5kaW5nLCB2bm9kZSkge1xuICAgIGVsLl9hc3NpZ24gPSBnZXRNb2RlbEFzc2lnbmVyKHZub2RlKTtcbiAgfSxcbiAgdXBkYXRlZChlbCwgeyB2YWx1ZSB9KSB7XG4gICAgc2V0U2VsZWN0ZWQoZWwsIHZhbHVlKTtcbiAgfVxufTtcbmZ1bmN0aW9uIHNldFNlbGVjdGVkKGVsLCB2YWx1ZSkge1xuICBjb25zdCBpc011bHRpcGxlID0gZWwubXVsdGlwbGU7XG4gIGlmIChpc011bHRpcGxlICYmICFpc0FycmF5KHZhbHVlKSAmJiAhaXNTZXQodmFsdWUpKSB7XG4gICAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiB3YXJuKFxuICAgICAgYDxzZWxlY3QgbXVsdGlwbGUgdi1tb2RlbD4gZXhwZWN0cyBhbiBBcnJheSBvciBTZXQgdmFsdWUgZm9yIGl0cyBiaW5kaW5nLCBidXQgZ290ICR7T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKS5zbGljZSg4LCAtMSl9LmBcbiAgICApO1xuICAgIHJldHVybjtcbiAgfVxuICBmb3IgKGxldCBpID0gMCwgbCA9IGVsLm9wdGlvbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgY29uc3Qgb3B0aW9uID0gZWwub3B0aW9uc1tpXTtcbiAgICBjb25zdCBvcHRpb25WYWx1ZSA9IGdldFZhbHVlKG9wdGlvbik7XG4gICAgaWYgKGlzTXVsdGlwbGUpIHtcbiAgICAgIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgICAgICBvcHRpb24uc2VsZWN0ZWQgPSBsb29zZUluZGV4T2YodmFsdWUsIG9wdGlvblZhbHVlKSA+IC0xO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3B0aW9uLnNlbGVjdGVkID0gdmFsdWUuaGFzKG9wdGlvblZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGxvb3NlRXF1YWwoZ2V0VmFsdWUob3B0aW9uKSwgdmFsdWUpKSB7XG4gICAgICAgIGlmIChlbC5zZWxlY3RlZEluZGV4ICE9PSBpKVxuICAgICAgICAgIGVsLnNlbGVjdGVkSW5kZXggPSBpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmICghaXNNdWx0aXBsZSAmJiBlbC5zZWxlY3RlZEluZGV4ICE9PSAtMSkge1xuICAgIGVsLnNlbGVjdGVkSW5kZXggPSAtMTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0VmFsdWUoZWwpIHtcbiAgcmV0dXJuIFwiX3ZhbHVlXCIgaW4gZWwgPyBlbC5fdmFsdWUgOiBlbC52YWx1ZTtcbn1cbmZ1bmN0aW9uIGdldENoZWNrYm94VmFsdWUoZWwsIGNoZWNrZWQpIHtcbiAgY29uc3Qga2V5ID0gY2hlY2tlZCA/IFwiX3RydWVWYWx1ZVwiIDogXCJfZmFsc2VWYWx1ZVwiO1xuICByZXR1cm4ga2V5IGluIGVsID8gZWxba2V5XSA6IGNoZWNrZWQ7XG59XG5jb25zdCB2TW9kZWxEeW5hbWljID0ge1xuICBjcmVhdGVkKGVsLCBiaW5kaW5nLCB2bm9kZSkge1xuICAgIGNhbGxNb2RlbEhvb2soZWwsIGJpbmRpbmcsIHZub2RlLCBudWxsLCBcImNyZWF0ZWRcIik7XG4gIH0sXG4gIG1vdW50ZWQoZWwsIGJpbmRpbmcsIHZub2RlKSB7XG4gICAgY2FsbE1vZGVsSG9vayhlbCwgYmluZGluZywgdm5vZGUsIG51bGwsIFwibW91bnRlZFwiKTtcbiAgfSxcbiAgYmVmb3JlVXBkYXRlKGVsLCBiaW5kaW5nLCB2bm9kZSwgcHJldlZOb2RlKSB7XG4gICAgY2FsbE1vZGVsSG9vayhlbCwgYmluZGluZywgdm5vZGUsIHByZXZWTm9kZSwgXCJiZWZvcmVVcGRhdGVcIik7XG4gIH0sXG4gIHVwZGF0ZWQoZWwsIGJpbmRpbmcsIHZub2RlLCBwcmV2Vk5vZGUpIHtcbiAgICBjYWxsTW9kZWxIb29rKGVsLCBiaW5kaW5nLCB2bm9kZSwgcHJldlZOb2RlLCBcInVwZGF0ZWRcIik7XG4gIH1cbn07XG5mdW5jdGlvbiByZXNvbHZlRHluYW1pY01vZGVsKHRhZ05hbWUsIHR5cGUpIHtcbiAgc3dpdGNoICh0YWdOYW1lKSB7XG4gICAgY2FzZSBcIlNFTEVDVFwiOlxuICAgICAgcmV0dXJuIHZNb2RlbFNlbGVjdDtcbiAgICBjYXNlIFwiVEVYVEFSRUFcIjpcbiAgICAgIHJldHVybiB2TW9kZWxUZXh0O1xuICAgIGRlZmF1bHQ6XG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBcImNoZWNrYm94XCI6XG4gICAgICAgICAgcmV0dXJuIHZNb2RlbENoZWNrYm94O1xuICAgICAgICBjYXNlIFwicmFkaW9cIjpcbiAgICAgICAgICByZXR1cm4gdk1vZGVsUmFkaW87XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIHZNb2RlbFRleHQ7XG4gICAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGNhbGxNb2RlbEhvb2soZWwsIGJpbmRpbmcsIHZub2RlLCBwcmV2Vk5vZGUsIGhvb2spIHtcbiAgY29uc3QgbW9kZWxUb1VzZSA9IHJlc29sdmVEeW5hbWljTW9kZWwoXG4gICAgZWwudGFnTmFtZSxcbiAgICB2bm9kZS5wcm9wcyAmJiB2bm9kZS5wcm9wcy50eXBlXG4gICk7XG4gIGNvbnN0IGZuID0gbW9kZWxUb1VzZVtob29rXTtcbiAgZm4gJiYgZm4oZWwsIGJpbmRpbmcsIHZub2RlLCBwcmV2Vk5vZGUpO1xufVxuZnVuY3Rpb24gaW5pdFZNb2RlbEZvclNTUigpIHtcbiAgdk1vZGVsVGV4dC5nZXRTU1JQcm9wcyA9ICh7IHZhbHVlIH0pID0+ICh7IHZhbHVlIH0pO1xuICB2TW9kZWxSYWRpby5nZXRTU1JQcm9wcyA9ICh7IHZhbHVlIH0sIHZub2RlKSA9PiB7XG4gICAgaWYgKHZub2RlLnByb3BzICYmIGxvb3NlRXF1YWwodm5vZGUucHJvcHMudmFsdWUsIHZhbHVlKSkge1xuICAgICAgcmV0dXJuIHsgY2hlY2tlZDogdHJ1ZSB9O1xuICAgIH1cbiAgfTtcbiAgdk1vZGVsQ2hlY2tib3guZ2V0U1NSUHJvcHMgPSAoeyB2YWx1ZSB9LCB2bm9kZSkgPT4ge1xuICAgIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgICAgaWYgKHZub2RlLnByb3BzICYmIGxvb3NlSW5kZXhPZih2YWx1ZSwgdm5vZGUucHJvcHMudmFsdWUpID4gLTEpIHtcbiAgICAgICAgcmV0dXJuIHsgY2hlY2tlZDogdHJ1ZSB9O1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNTZXQodmFsdWUpKSB7XG4gICAgICBpZiAodm5vZGUucHJvcHMgJiYgdmFsdWUuaGFzKHZub2RlLnByb3BzLnZhbHVlKSkge1xuICAgICAgICByZXR1cm4geyBjaGVja2VkOiB0cnVlIH07XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHsgY2hlY2tlZDogdHJ1ZSB9O1xuICAgIH1cbiAgfTtcbiAgdk1vZGVsRHluYW1pYy5nZXRTU1JQcm9wcyA9IChiaW5kaW5nLCB2bm9kZSkgPT4ge1xuICAgIGlmICh0eXBlb2Ygdm5vZGUudHlwZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBtb2RlbFRvVXNlID0gcmVzb2x2ZUR5bmFtaWNNb2RlbChcbiAgICAgIC8vIHJlc29sdmVEeW5hbWljTW9kZWwgZXhwZWN0cyBhbiB1cHBlcmNhc2UgdGFnIG5hbWUsIGJ1dCB2bm9kZS50eXBlIGlzIGxvd2VyY2FzZVxuICAgICAgdm5vZGUudHlwZS50b1VwcGVyQ2FzZSgpLFxuICAgICAgdm5vZGUucHJvcHMgJiYgdm5vZGUucHJvcHMudHlwZVxuICAgICk7XG4gICAgaWYgKG1vZGVsVG9Vc2UuZ2V0U1NSUHJvcHMpIHtcbiAgICAgIHJldHVybiBtb2RlbFRvVXNlLmdldFNTUlByb3BzKGJpbmRpbmcsIHZub2RlKTtcbiAgICB9XG4gIH07XG59XG5cbmNvbnN0IHN5c3RlbU1vZGlmaWVycyA9IFtcImN0cmxcIiwgXCJzaGlmdFwiLCBcImFsdFwiLCBcIm1ldGFcIl07XG5jb25zdCBtb2RpZmllckd1YXJkcyA9IHtcbiAgc3RvcDogKGUpID0+IGUuc3RvcFByb3BhZ2F0aW9uKCksXG4gIHByZXZlbnQ6IChlKSA9PiBlLnByZXZlbnREZWZhdWx0KCksXG4gIHNlbGY6IChlKSA9PiBlLnRhcmdldCAhPT0gZS5jdXJyZW50VGFyZ2V0LFxuICBjdHJsOiAoZSkgPT4gIWUuY3RybEtleSxcbiAgc2hpZnQ6IChlKSA9PiAhZS5zaGlmdEtleSxcbiAgYWx0OiAoZSkgPT4gIWUuYWx0S2V5LFxuICBtZXRhOiAoZSkgPT4gIWUubWV0YUtleSxcbiAgbGVmdDogKGUpID0+IFwiYnV0dG9uXCIgaW4gZSAmJiBlLmJ1dHRvbiAhPT0gMCxcbiAgbWlkZGxlOiAoZSkgPT4gXCJidXR0b25cIiBpbiBlICYmIGUuYnV0dG9uICE9PSAxLFxuICByaWdodDogKGUpID0+IFwiYnV0dG9uXCIgaW4gZSAmJiBlLmJ1dHRvbiAhPT0gMixcbiAgZXhhY3Q6IChlLCBtb2RpZmllcnMpID0+IHN5c3RlbU1vZGlmaWVycy5zb21lKChtKSA9PiBlW2Ake219S2V5YF0gJiYgIW1vZGlmaWVycy5pbmNsdWRlcyhtKSlcbn07XG5jb25zdCB3aXRoTW9kaWZpZXJzID0gKGZuLCBtb2RpZmllcnMpID0+IHtcbiAgcmV0dXJuIChldmVudCwgLi4uYXJncykgPT4ge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbW9kaWZpZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBndWFyZCA9IG1vZGlmaWVyR3VhcmRzW21vZGlmaWVyc1tpXV07XG4gICAgICBpZiAoZ3VhcmQgJiYgZ3VhcmQoZXZlbnQsIG1vZGlmaWVycykpXG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmV0dXJuIGZuKGV2ZW50LCAuLi5hcmdzKTtcbiAgfTtcbn07XG5jb25zdCBrZXlOYW1lcyA9IHtcbiAgZXNjOiBcImVzY2FwZVwiLFxuICBzcGFjZTogXCIgXCIsXG4gIHVwOiBcImFycm93LXVwXCIsXG4gIGxlZnQ6IFwiYXJyb3ctbGVmdFwiLFxuICByaWdodDogXCJhcnJvdy1yaWdodFwiLFxuICBkb3duOiBcImFycm93LWRvd25cIixcbiAgZGVsZXRlOiBcImJhY2tzcGFjZVwiXG59O1xuY29uc3Qgd2l0aEtleXMgPSAoZm4sIG1vZGlmaWVycykgPT4ge1xuICByZXR1cm4gKGV2ZW50KSA9PiB7XG4gICAgaWYgKCEoXCJrZXlcIiBpbiBldmVudCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZXZlbnRLZXkgPSBoeXBoZW5hdGUoZXZlbnQua2V5KTtcbiAgICBpZiAobW9kaWZpZXJzLnNvbWUoKGspID0+IGsgPT09IGV2ZW50S2V5IHx8IGtleU5hbWVzW2tdID09PSBldmVudEtleSkpIHtcbiAgICAgIHJldHVybiBmbihldmVudCk7XG4gICAgfVxuICB9O1xufTtcblxuY29uc3QgdlNob3cgPSB7XG4gIGJlZm9yZU1vdW50KGVsLCB7IHZhbHVlIH0sIHsgdHJhbnNpdGlvbiB9KSB7XG4gICAgZWwuX3ZvZCA9IGVsLnN0eWxlLmRpc3BsYXkgPT09IFwibm9uZVwiID8gXCJcIiA6IGVsLnN0eWxlLmRpc3BsYXk7XG4gICAgaWYgKHRyYW5zaXRpb24gJiYgdmFsdWUpIHtcbiAgICAgIHRyYW5zaXRpb24uYmVmb3JlRW50ZXIoZWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZXREaXNwbGF5KGVsLCB2YWx1ZSk7XG4gICAgfVxuICB9LFxuICBtb3VudGVkKGVsLCB7IHZhbHVlIH0sIHsgdHJhbnNpdGlvbiB9KSB7XG4gICAgaWYgKHRyYW5zaXRpb24gJiYgdmFsdWUpIHtcbiAgICAgIHRyYW5zaXRpb24uZW50ZXIoZWwpO1xuICAgIH1cbiAgfSxcbiAgdXBkYXRlZChlbCwgeyB2YWx1ZSwgb2xkVmFsdWUgfSwgeyB0cmFuc2l0aW9uIH0pIHtcbiAgICBpZiAoIXZhbHVlID09PSAhb2xkVmFsdWUpXG4gICAgICByZXR1cm47XG4gICAgaWYgKHRyYW5zaXRpb24pIHtcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICB0cmFuc2l0aW9uLmJlZm9yZUVudGVyKGVsKTtcbiAgICAgICAgc2V0RGlzcGxheShlbCwgdHJ1ZSk7XG4gICAgICAgIHRyYW5zaXRpb24uZW50ZXIoZWwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHJhbnNpdGlvbi5sZWF2ZShlbCwgKCkgPT4ge1xuICAgICAgICAgIHNldERpc3BsYXkoZWwsIGZhbHNlKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHNldERpc3BsYXkoZWwsIHZhbHVlKTtcbiAgICB9XG4gIH0sXG4gIGJlZm9yZVVubW91bnQoZWwsIHsgdmFsdWUgfSkge1xuICAgIHNldERpc3BsYXkoZWwsIHZhbHVlKTtcbiAgfVxufTtcbmZ1bmN0aW9uIHNldERpc3BsYXkoZWwsIHZhbHVlKSB7XG4gIGVsLnN0eWxlLmRpc3BsYXkgPSB2YWx1ZSA/IGVsLl92b2QgOiBcIm5vbmVcIjtcbn1cbmZ1bmN0aW9uIGluaXRWU2hvd0ZvclNTUigpIHtcbiAgdlNob3cuZ2V0U1NSUHJvcHMgPSAoeyB2YWx1ZSB9KSA9PiB7XG4gICAgaWYgKCF2YWx1ZSkge1xuICAgICAgcmV0dXJuIHsgc3R5bGU6IHsgZGlzcGxheTogXCJub25lXCIgfSB9O1xuICAgIH1cbiAgfTtcbn1cblxuY29uc3QgcmVuZGVyZXJPcHRpb25zID0gLyogQF9fUFVSRV9fICovIGV4dGVuZCh7IHBhdGNoUHJvcCB9LCBub2RlT3BzKTtcbmxldCByZW5kZXJlcjtcbmxldCBlbmFibGVkSHlkcmF0aW9uID0gZmFsc2U7XG5mdW5jdGlvbiBlbnN1cmVSZW5kZXJlcigpIHtcbiAgcmV0dXJuIHJlbmRlcmVyIHx8IChyZW5kZXJlciA9IGNyZWF0ZVJlbmRlcmVyKHJlbmRlcmVyT3B0aW9ucykpO1xufVxuZnVuY3Rpb24gZW5zdXJlSHlkcmF0aW9uUmVuZGVyZXIoKSB7XG4gIHJlbmRlcmVyID0gZW5hYmxlZEh5ZHJhdGlvbiA/IHJlbmRlcmVyIDogY3JlYXRlSHlkcmF0aW9uUmVuZGVyZXIocmVuZGVyZXJPcHRpb25zKTtcbiAgZW5hYmxlZEh5ZHJhdGlvbiA9IHRydWU7XG4gIHJldHVybiByZW5kZXJlcjtcbn1cbmNvbnN0IHJlbmRlciA9ICguLi5hcmdzKSA9PiB7XG4gIGVuc3VyZVJlbmRlcmVyKCkucmVuZGVyKC4uLmFyZ3MpO1xufTtcbmNvbnN0IGh5ZHJhdGUgPSAoLi4uYXJncykgPT4ge1xuICBlbnN1cmVIeWRyYXRpb25SZW5kZXJlcigpLmh5ZHJhdGUoLi4uYXJncyk7XG59O1xuY29uc3QgY3JlYXRlQXBwID0gKC4uLmFyZ3MpID0+IHtcbiAgY29uc3QgYXBwID0gZW5zdXJlUmVuZGVyZXIoKS5jcmVhdGVBcHAoLi4uYXJncyk7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgaW5qZWN0TmF0aXZlVGFnQ2hlY2soYXBwKTtcbiAgICBpbmplY3RDb21waWxlck9wdGlvbnNDaGVjayhhcHApO1xuICB9XG4gIGNvbnN0IHsgbW91bnQgfSA9IGFwcDtcbiAgYXBwLm1vdW50ID0gKGNvbnRhaW5lck9yU2VsZWN0b3IpID0+IHtcbiAgICBjb25zdCBjb250YWluZXIgPSBub3JtYWxpemVDb250YWluZXIoY29udGFpbmVyT3JTZWxlY3Rvcik7XG4gICAgaWYgKCFjb250YWluZXIpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgY29tcG9uZW50ID0gYXBwLl9jb21wb25lbnQ7XG4gICAgaWYgKCFpc0Z1bmN0aW9uKGNvbXBvbmVudCkgJiYgIWNvbXBvbmVudC5yZW5kZXIgJiYgIWNvbXBvbmVudC50ZW1wbGF0ZSkge1xuICAgICAgY29tcG9uZW50LnRlbXBsYXRlID0gY29udGFpbmVyLmlubmVySFRNTDtcbiAgICB9XG4gICAgY29udGFpbmVyLmlubmVySFRNTCA9IFwiXCI7XG4gICAgY29uc3QgcHJveHkgPSBtb3VudChjb250YWluZXIsIGZhbHNlLCBjb250YWluZXIgaW5zdGFuY2VvZiBTVkdFbGVtZW50KTtcbiAgICBpZiAoY29udGFpbmVyIGluc3RhbmNlb2YgRWxlbWVudCkge1xuICAgICAgY29udGFpbmVyLnJlbW92ZUF0dHJpYnV0ZShcInYtY2xvYWtcIik7XG4gICAgICBjb250YWluZXIuc2V0QXR0cmlidXRlKFwiZGF0YS12LWFwcFwiLCBcIlwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHByb3h5O1xuICB9O1xuICByZXR1cm4gYXBwO1xufTtcbmNvbnN0IGNyZWF0ZVNTUkFwcCA9ICguLi5hcmdzKSA9PiB7XG4gIGNvbnN0IGFwcCA9IGVuc3VyZUh5ZHJhdGlvblJlbmRlcmVyKCkuY3JlYXRlQXBwKC4uLmFyZ3MpO1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIGluamVjdE5hdGl2ZVRhZ0NoZWNrKGFwcCk7XG4gICAgaW5qZWN0Q29tcGlsZXJPcHRpb25zQ2hlY2soYXBwKTtcbiAgfVxuICBjb25zdCB7IG1vdW50IH0gPSBhcHA7XG4gIGFwcC5tb3VudCA9IChjb250YWluZXJPclNlbGVjdG9yKSA9PiB7XG4gICAgY29uc3QgY29udGFpbmVyID0gbm9ybWFsaXplQ29udGFpbmVyKGNvbnRhaW5lck9yU2VsZWN0b3IpO1xuICAgIGlmIChjb250YWluZXIpIHtcbiAgICAgIHJldHVybiBtb3VudChjb250YWluZXIsIHRydWUsIGNvbnRhaW5lciBpbnN0YW5jZW9mIFNWR0VsZW1lbnQpO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIGFwcDtcbn07XG5mdW5jdGlvbiBpbmplY3ROYXRpdmVUYWdDaGVjayhhcHApIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGFwcC5jb25maWcsIFwiaXNOYXRpdmVUYWdcIiwge1xuICAgIHZhbHVlOiAodGFnKSA9PiBpc0hUTUxUYWcodGFnKSB8fCBpc1NWR1RhZyh0YWcpLFxuICAgIHdyaXRhYmxlOiBmYWxzZVxuICB9KTtcbn1cbmZ1bmN0aW9uIGluamVjdENvbXBpbGVyT3B0aW9uc0NoZWNrKGFwcCkge1xuICBpZiAoaXNSdW50aW1lT25seSgpKSB7XG4gICAgY29uc3QgaXNDdXN0b21FbGVtZW50ID0gYXBwLmNvbmZpZy5pc0N1c3RvbUVsZW1lbnQ7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGFwcC5jb25maWcsIFwiaXNDdXN0b21FbGVtZW50XCIsIHtcbiAgICAgIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIGlzQ3VzdG9tRWxlbWVudDtcbiAgICAgIH0sXG4gICAgICBzZXQoKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgYFRoZSBcXGBpc0N1c3RvbUVsZW1lbnRcXGAgY29uZmlnIG9wdGlvbiBpcyBkZXByZWNhdGVkLiBVc2UgXFxgY29tcGlsZXJPcHRpb25zLmlzQ3VzdG9tRWxlbWVudFxcYCBpbnN0ZWFkLmBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBjb25zdCBjb21waWxlck9wdGlvbnMgPSBhcHAuY29uZmlnLmNvbXBpbGVyT3B0aW9ucztcbiAgICBjb25zdCBtc2cgPSBgVGhlIFxcYGNvbXBpbGVyT3B0aW9uc1xcYCBjb25maWcgb3B0aW9uIGlzIG9ubHkgcmVzcGVjdGVkIHdoZW4gdXNpbmcgYSBidWlsZCBvZiBWdWUuanMgdGhhdCBpbmNsdWRlcyB0aGUgcnVudGltZSBjb21waWxlciAoYWthIFwiZnVsbCBidWlsZFwiKS4gU2luY2UgeW91IGFyZSB1c2luZyB0aGUgcnVudGltZS1vbmx5IGJ1aWxkLCBcXGBjb21waWxlck9wdGlvbnNcXGAgbXVzdCBiZSBwYXNzZWQgdG8gXFxgQHZ1ZS9jb21waWxlci1kb21cXGAgaW4gdGhlIGJ1aWxkIHNldHVwIGluc3RlYWQuXG4tIEZvciB2dWUtbG9hZGVyOiBwYXNzIGl0IHZpYSB2dWUtbG9hZGVyJ3MgXFxgY29tcGlsZXJPcHRpb25zXFxgIGxvYWRlciBvcHRpb24uXG4tIEZvciB2dWUtY2xpOiBzZWUgaHR0cHM6Ly9jbGkudnVlanMub3JnL2d1aWRlL3dlYnBhY2suaHRtbCNtb2RpZnlpbmctb3B0aW9ucy1vZi1hLWxvYWRlclxuLSBGb3Igdml0ZTogcGFzcyBpdCB2aWEgQHZpdGVqcy9wbHVnaW4tdnVlIG9wdGlvbnMuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vdml0ZWpzL3ZpdGUtcGx1Z2luLXZ1ZS90cmVlL21haW4vcGFja2FnZXMvcGx1Z2luLXZ1ZSNleGFtcGxlLWZvci1wYXNzaW5nLW9wdGlvbnMtdG8tdnVlY29tcGlsZXItc2ZjYDtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYXBwLmNvbmZpZywgXCJjb21waWxlck9wdGlvbnNcIiwge1xuICAgICAgZ2V0KCkge1xuICAgICAgICB3YXJuKG1zZyk7XG4gICAgICAgIHJldHVybiBjb21waWxlck9wdGlvbnM7XG4gICAgICB9LFxuICAgICAgc2V0KCkge1xuICAgICAgICB3YXJuKG1zZyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZUNvbnRhaW5lcihjb250YWluZXIpIHtcbiAgaWYgKGlzU3RyaW5nKGNvbnRhaW5lcikpIHtcbiAgICBjb25zdCByZXMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGNvbnRhaW5lcik7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgIXJlcykge1xuICAgICAgd2FybihcbiAgICAgICAgYEZhaWxlZCB0byBtb3VudCBhcHA6IG1vdW50IHRhcmdldCBzZWxlY3RvciBcIiR7Y29udGFpbmVyfVwiIHJldHVybmVkIG51bGwuYFxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbiAgfVxuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiB3aW5kb3cuU2hhZG93Um9vdCAmJiBjb250YWluZXIgaW5zdGFuY2VvZiB3aW5kb3cuU2hhZG93Um9vdCAmJiBjb250YWluZXIubW9kZSA9PT0gXCJjbG9zZWRcIikge1xuICAgIHdhcm4oXG4gICAgICBgbW91bnRpbmcgb24gYSBTaGFkb3dSb290IHdpdGggXFxge21vZGU6IFwiY2xvc2VkXCJ9XFxgIG1heSBsZWFkIHRvIHVucHJlZGljdGFibGUgYnVnc2BcbiAgICApO1xuICB9XG4gIHJldHVybiBjb250YWluZXI7XG59XG5sZXQgc3NyRGlyZWN0aXZlSW5pdGlhbGl6ZWQgPSBmYWxzZTtcbmNvbnN0IGluaXREaXJlY3RpdmVzRm9yU1NSID0gKCkgPT4ge1xuICBpZiAoIXNzckRpcmVjdGl2ZUluaXRpYWxpemVkKSB7XG4gICAgc3NyRGlyZWN0aXZlSW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgIGluaXRWTW9kZWxGb3JTU1IoKTtcbiAgICBpbml0VlNob3dGb3JTU1IoKTtcbiAgfVxufSA7XG5cbmV4cG9ydCB7IFRyYW5zaXRpb24sIFRyYW5zaXRpb25Hcm91cCwgVnVlRWxlbWVudCwgY3JlYXRlQXBwLCBjcmVhdGVTU1JBcHAsIGRlZmluZUN1c3RvbUVsZW1lbnQsIGRlZmluZVNTUkN1c3RvbUVsZW1lbnQsIGh5ZHJhdGUsIGluaXREaXJlY3RpdmVzRm9yU1NSLCByZW5kZXIsIHVzZUNzc01vZHVsZSwgdXNlQ3NzVmFycywgdk1vZGVsQ2hlY2tib3gsIHZNb2RlbER5bmFtaWMsIHZNb2RlbFJhZGlvLCB2TW9kZWxTZWxlY3QsIHZNb2RlbFRleHQsIHZTaG93LCB3aXRoS2V5cywgd2l0aE1vZGlmaWVycyB9O1xuIiwiaW1wb3J0IHsgcGF1c2VUcmFja2luZywgcmVzZXRUcmFja2luZywgaXNSZWYsIHRvUmF3LCBnZXRDdXJyZW50U2NvcGUsIGlzU2hhbGxvdyBhcyBpc1NoYWxsb3ckMSwgaXNSZWFjdGl2ZSwgUmVhY3RpdmVFZmZlY3QsIHJlZiwgc2hhbGxvd1JlYWRvbmx5LCB0cmFjaywgcmVhY3RpdmUsIHNoYWxsb3dSZWFjdGl2ZSwgdHJpZ2dlciwgaXNQcm94eSwgcHJveHlSZWZzLCBtYXJrUmF3LCBFZmZlY3RTY29wZSwgY29tcHV0ZWQgYXMgY29tcHV0ZWQkMSwgaXNSZWFkb25seSB9IGZyb20gJ0B2dWUvcmVhY3Rpdml0eSc7XG5leHBvcnQgeyBFZmZlY3RTY29wZSwgUmVhY3RpdmVFZmZlY3QsIGN1c3RvbVJlZiwgZWZmZWN0LCBlZmZlY3RTY29wZSwgZ2V0Q3VycmVudFNjb3BlLCBpc1Byb3h5LCBpc1JlYWN0aXZlLCBpc1JlYWRvbmx5LCBpc1JlZiwgaXNTaGFsbG93LCBtYXJrUmF3LCBvblNjb3BlRGlzcG9zZSwgcHJveHlSZWZzLCByZWFjdGl2ZSwgcmVhZG9ubHksIHJlZiwgc2hhbGxvd1JlYWN0aXZlLCBzaGFsbG93UmVhZG9ubHksIHNoYWxsb3dSZWYsIHN0b3AsIHRvUmF3LCB0b1JlZiwgdG9SZWZzLCB0b1ZhbHVlLCB0cmlnZ2VyUmVmLCB1bnJlZiB9IGZyb20gJ0B2dWUvcmVhY3Rpdml0eSc7XG5pbXBvcnQgeyBpc1N0cmluZywgaXNGdW5jdGlvbiwgaXNQcm9taXNlLCBpc0FycmF5LCBOT09QLCBnZXRHbG9iYWxUaGlzLCBleHRlbmQsIEVNUFRZX09CSiwgdG9IYW5kbGVyS2V5LCBsb29zZVRvTnVtYmVyLCBoeXBoZW5hdGUsIGNhbWVsaXplLCBpc09iamVjdCwgaXNPbiwgaGFzT3duLCBpc01vZGVsTGlzdGVuZXIsIHRvTnVtYmVyLCBoYXNDaGFuZ2VkLCByZW1vdmUsIGlzU2V0LCBpc01hcCwgaXNQbGFpbk9iamVjdCwgaXNCdWlsdEluRGlyZWN0aXZlLCBpbnZva2VBcnJheUZucywgaXNSZWdFeHAsIGNhcGl0YWxpemUsIGlzR2xvYmFsbHlXaGl0ZWxpc3RlZCwgTk8sIGRlZiwgaXNSZXNlcnZlZFByb3AsIEVNUFRZX0FSUiwgdG9SYXdUeXBlLCBtYWtlTWFwLCBub3JtYWxpemVDbGFzcywgbm9ybWFsaXplU3R5bGUgfSBmcm9tICdAdnVlL3NoYXJlZCc7XG5leHBvcnQgeyBjYW1lbGl6ZSwgY2FwaXRhbGl6ZSwgbm9ybWFsaXplQ2xhc3MsIG5vcm1hbGl6ZVByb3BzLCBub3JtYWxpemVTdHlsZSwgdG9EaXNwbGF5U3RyaW5nLCB0b0hhbmRsZXJLZXkgfSBmcm9tICdAdnVlL3NoYXJlZCc7XG5cbmNvbnN0IHN0YWNrID0gW107XG5mdW5jdGlvbiBwdXNoV2FybmluZ0NvbnRleHQodm5vZGUpIHtcbiAgc3RhY2sucHVzaCh2bm9kZSk7XG59XG5mdW5jdGlvbiBwb3BXYXJuaW5nQ29udGV4dCgpIHtcbiAgc3RhY2sucG9wKCk7XG59XG5mdW5jdGlvbiB3YXJuKG1zZywgLi4uYXJncykge1xuICBpZiAoISEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpXG4gICAgcmV0dXJuO1xuICBwYXVzZVRyYWNraW5nKCk7XG4gIGNvbnN0IGluc3RhbmNlID0gc3RhY2subGVuZ3RoID8gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV0uY29tcG9uZW50IDogbnVsbDtcbiAgY29uc3QgYXBwV2FybkhhbmRsZXIgPSBpbnN0YW5jZSAmJiBpbnN0YW5jZS5hcHBDb250ZXh0LmNvbmZpZy53YXJuSGFuZGxlcjtcbiAgY29uc3QgdHJhY2UgPSBnZXRDb21wb25lbnRUcmFjZSgpO1xuICBpZiAoYXBwV2FybkhhbmRsZXIpIHtcbiAgICBjYWxsV2l0aEVycm9ySGFuZGxpbmcoXG4gICAgICBhcHBXYXJuSGFuZGxlcixcbiAgICAgIGluc3RhbmNlLFxuICAgICAgMTEsXG4gICAgICBbXG4gICAgICAgIG1zZyArIGFyZ3Muam9pbihcIlwiKSxcbiAgICAgICAgaW5zdGFuY2UgJiYgaW5zdGFuY2UucHJveHksXG4gICAgICAgIHRyYWNlLm1hcChcbiAgICAgICAgICAoeyB2bm9kZSB9KSA9PiBgYXQgPCR7Zm9ybWF0Q29tcG9uZW50TmFtZShpbnN0YW5jZSwgdm5vZGUudHlwZSl9PmBcbiAgICAgICAgKS5qb2luKFwiXFxuXCIpLFxuICAgICAgICB0cmFjZVxuICAgICAgXVxuICAgICk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3Qgd2FybkFyZ3MgPSBbYFtWdWUgd2Fybl06ICR7bXNnfWAsIC4uLmFyZ3NdO1xuICAgIGlmICh0cmFjZS5sZW5ndGggJiYgLy8gYXZvaWQgc3BhbW1pbmcgY29uc29sZSBkdXJpbmcgdGVzdHNcbiAgICB0cnVlKSB7XG4gICAgICB3YXJuQXJncy5wdXNoKGBcbmAsIC4uLmZvcm1hdFRyYWNlKHRyYWNlKSk7XG4gICAgfVxuICAgIGNvbnNvbGUud2FybiguLi53YXJuQXJncyk7XG4gIH1cbiAgcmVzZXRUcmFja2luZygpO1xufVxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50VHJhY2UoKSB7XG4gIGxldCBjdXJyZW50Vk5vZGUgPSBzdGFja1tzdGFjay5sZW5ndGggLSAxXTtcbiAgaWYgKCFjdXJyZW50Vk5vZGUpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgY29uc3Qgbm9ybWFsaXplZFN0YWNrID0gW107XG4gIHdoaWxlIChjdXJyZW50Vk5vZGUpIHtcbiAgICBjb25zdCBsYXN0ID0gbm9ybWFsaXplZFN0YWNrWzBdO1xuICAgIGlmIChsYXN0ICYmIGxhc3Qudm5vZGUgPT09IGN1cnJlbnRWTm9kZSkge1xuICAgICAgbGFzdC5yZWN1cnNlQ291bnQrKztcbiAgICB9IGVsc2Uge1xuICAgICAgbm9ybWFsaXplZFN0YWNrLnB1c2goe1xuICAgICAgICB2bm9kZTogY3VycmVudFZOb2RlLFxuICAgICAgICByZWN1cnNlQ291bnQ6IDBcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBwYXJlbnRJbnN0YW5jZSA9IGN1cnJlbnRWTm9kZS5jb21wb25lbnQgJiYgY3VycmVudFZOb2RlLmNvbXBvbmVudC5wYXJlbnQ7XG4gICAgY3VycmVudFZOb2RlID0gcGFyZW50SW5zdGFuY2UgJiYgcGFyZW50SW5zdGFuY2Uudm5vZGU7XG4gIH1cbiAgcmV0dXJuIG5vcm1hbGl6ZWRTdGFjaztcbn1cbmZ1bmN0aW9uIGZvcm1hdFRyYWNlKHRyYWNlKSB7XG4gIGNvbnN0IGxvZ3MgPSBbXTtcbiAgdHJhY2UuZm9yRWFjaCgoZW50cnksIGkpID0+IHtcbiAgICBsb2dzLnB1c2goLi4uaSA9PT0gMCA/IFtdIDogW2BcbmBdLCAuLi5mb3JtYXRUcmFjZUVudHJ5KGVudHJ5KSk7XG4gIH0pO1xuICByZXR1cm4gbG9ncztcbn1cbmZ1bmN0aW9uIGZvcm1hdFRyYWNlRW50cnkoeyB2bm9kZSwgcmVjdXJzZUNvdW50IH0pIHtcbiAgY29uc3QgcG9zdGZpeCA9IHJlY3Vyc2VDb3VudCA+IDAgPyBgLi4uICgke3JlY3Vyc2VDb3VudH0gcmVjdXJzaXZlIGNhbGxzKWAgOiBgYDtcbiAgY29uc3QgaXNSb290ID0gdm5vZGUuY29tcG9uZW50ID8gdm5vZGUuY29tcG9uZW50LnBhcmVudCA9PSBudWxsIDogZmFsc2U7XG4gIGNvbnN0IG9wZW4gPSBgIGF0IDwke2Zvcm1hdENvbXBvbmVudE5hbWUoXG4gICAgdm5vZGUuY29tcG9uZW50LFxuICAgIHZub2RlLnR5cGUsXG4gICAgaXNSb290XG4gICl9YDtcbiAgY29uc3QgY2xvc2UgPSBgPmAgKyBwb3N0Zml4O1xuICByZXR1cm4gdm5vZGUucHJvcHMgPyBbb3BlbiwgLi4uZm9ybWF0UHJvcHModm5vZGUucHJvcHMpLCBjbG9zZV0gOiBbb3BlbiArIGNsb3NlXTtcbn1cbmZ1bmN0aW9uIGZvcm1hdFByb3BzKHByb3BzKSB7XG4gIGNvbnN0IHJlcyA9IFtdO1xuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMocHJvcHMpO1xuICBrZXlzLnNsaWNlKDAsIDMpLmZvckVhY2goKGtleSkgPT4ge1xuICAgIHJlcy5wdXNoKC4uLmZvcm1hdFByb3Aoa2V5LCBwcm9wc1trZXldKSk7XG4gIH0pO1xuICBpZiAoa2V5cy5sZW5ndGggPiAzKSB7XG4gICAgcmVzLnB1c2goYCAuLi5gKTtcbiAgfVxuICByZXR1cm4gcmVzO1xufVxuZnVuY3Rpb24gZm9ybWF0UHJvcChrZXksIHZhbHVlLCByYXcpIHtcbiAgaWYgKGlzU3RyaW5nKHZhbHVlKSkge1xuICAgIHZhbHVlID0gSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xuICAgIHJldHVybiByYXcgPyB2YWx1ZSA6IFtgJHtrZXl9PSR7dmFsdWV9YF07XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiIHx8IHR5cGVvZiB2YWx1ZSA9PT0gXCJib29sZWFuXCIgfHwgdmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiByYXcgPyB2YWx1ZSA6IFtgJHtrZXl9PSR7dmFsdWV9YF07XG4gIH0gZWxzZSBpZiAoaXNSZWYodmFsdWUpKSB7XG4gICAgdmFsdWUgPSBmb3JtYXRQcm9wKGtleSwgdG9SYXcodmFsdWUudmFsdWUpLCB0cnVlKTtcbiAgICByZXR1cm4gcmF3ID8gdmFsdWUgOiBbYCR7a2V5fT1SZWY8YCwgdmFsdWUsIGA+YF07XG4gIH0gZWxzZSBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICByZXR1cm4gW2Ake2tleX09Zm4ke3ZhbHVlLm5hbWUgPyBgPCR7dmFsdWUubmFtZX0+YCA6IGBgfWBdO1xuICB9IGVsc2Uge1xuICAgIHZhbHVlID0gdG9SYXcodmFsdWUpO1xuICAgIHJldHVybiByYXcgPyB2YWx1ZSA6IFtgJHtrZXl9PWAsIHZhbHVlXTtcbiAgfVxufVxuZnVuY3Rpb24gYXNzZXJ0TnVtYmVyKHZhbCwgdHlwZSkge1xuICBpZiAoISEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpXG4gICAgcmV0dXJuO1xuICBpZiAodmFsID09PSB2b2lkIDApIHtcbiAgICByZXR1cm47XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCAhPT0gXCJudW1iZXJcIikge1xuICAgIHdhcm4oYCR7dHlwZX0gaXMgbm90IGEgdmFsaWQgbnVtYmVyIC0gZ290ICR7SlNPTi5zdHJpbmdpZnkodmFsKX0uYCk7XG4gIH0gZWxzZSBpZiAoaXNOYU4odmFsKSkge1xuICAgIHdhcm4oYCR7dHlwZX0gaXMgTmFOIC0gdGhlIGR1cmF0aW9uIGV4cHJlc3Npb24gbWlnaHQgYmUgaW5jb3JyZWN0LmApO1xuICB9XG59XG5cbmNvbnN0IEVycm9yVHlwZVN0cmluZ3MgPSB7XG4gIFtcInNwXCJdOiBcInNlcnZlclByZWZldGNoIGhvb2tcIixcbiAgW1wiYmNcIl06IFwiYmVmb3JlQ3JlYXRlIGhvb2tcIixcbiAgW1wiY1wiXTogXCJjcmVhdGVkIGhvb2tcIixcbiAgW1wiYm1cIl06IFwiYmVmb3JlTW91bnQgaG9va1wiLFxuICBbXCJtXCJdOiBcIm1vdW50ZWQgaG9va1wiLFxuICBbXCJidVwiXTogXCJiZWZvcmVVcGRhdGUgaG9va1wiLFxuICBbXCJ1XCJdOiBcInVwZGF0ZWRcIixcbiAgW1wiYnVtXCJdOiBcImJlZm9yZVVubW91bnQgaG9va1wiLFxuICBbXCJ1bVwiXTogXCJ1bm1vdW50ZWQgaG9va1wiLFxuICBbXCJhXCJdOiBcImFjdGl2YXRlZCBob29rXCIsXG4gIFtcImRhXCJdOiBcImRlYWN0aXZhdGVkIGhvb2tcIixcbiAgW1wiZWNcIl06IFwiZXJyb3JDYXB0dXJlZCBob29rXCIsXG4gIFtcInJ0Y1wiXTogXCJyZW5kZXJUcmFja2VkIGhvb2tcIixcbiAgW1wicnRnXCJdOiBcInJlbmRlclRyaWdnZXJlZCBob29rXCIsXG4gIFswXTogXCJzZXR1cCBmdW5jdGlvblwiLFxuICBbMV06IFwicmVuZGVyIGZ1bmN0aW9uXCIsXG4gIFsyXTogXCJ3YXRjaGVyIGdldHRlclwiLFxuICBbM106IFwid2F0Y2hlciBjYWxsYmFja1wiLFxuICBbNF06IFwid2F0Y2hlciBjbGVhbnVwIGZ1bmN0aW9uXCIsXG4gIFs1XTogXCJuYXRpdmUgZXZlbnQgaGFuZGxlclwiLFxuICBbNl06IFwiY29tcG9uZW50IGV2ZW50IGhhbmRsZXJcIixcbiAgWzddOiBcInZub2RlIGhvb2tcIixcbiAgWzhdOiBcImRpcmVjdGl2ZSBob29rXCIsXG4gIFs5XTogXCJ0cmFuc2l0aW9uIGhvb2tcIixcbiAgWzEwXTogXCJhcHAgZXJyb3JIYW5kbGVyXCIsXG4gIFsxMV06IFwiYXBwIHdhcm5IYW5kbGVyXCIsXG4gIFsxMl06IFwicmVmIGZ1bmN0aW9uXCIsXG4gIFsxM106IFwiYXN5bmMgY29tcG9uZW50IGxvYWRlclwiLFxuICBbMTRdOiBcInNjaGVkdWxlciBmbHVzaC4gVGhpcyBpcyBsaWtlbHkgYSBWdWUgaW50ZXJuYWxzIGJ1Zy4gUGxlYXNlIG9wZW4gYW4gaXNzdWUgYXQgaHR0cHM6Ly9uZXctaXNzdWUudnVlanMub3JnLz9yZXBvPXZ1ZWpzL2NvcmVcIlxufTtcbmZ1bmN0aW9uIGNhbGxXaXRoRXJyb3JIYW5kbGluZyhmbiwgaW5zdGFuY2UsIHR5cGUsIGFyZ3MpIHtcbiAgbGV0IHJlcztcbiAgdHJ5IHtcbiAgICByZXMgPSBhcmdzID8gZm4oLi4uYXJncykgOiBmbigpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBoYW5kbGVFcnJvcihlcnIsIGluc3RhbmNlLCB0eXBlKTtcbiAgfVxuICByZXR1cm4gcmVzO1xufVxuZnVuY3Rpb24gY2FsbFdpdGhBc3luY0Vycm9ySGFuZGxpbmcoZm4sIGluc3RhbmNlLCB0eXBlLCBhcmdzKSB7XG4gIGlmIChpc0Z1bmN0aW9uKGZuKSkge1xuICAgIGNvbnN0IHJlcyA9IGNhbGxXaXRoRXJyb3JIYW5kbGluZyhmbiwgaW5zdGFuY2UsIHR5cGUsIGFyZ3MpO1xuICAgIGlmIChyZXMgJiYgaXNQcm9taXNlKHJlcykpIHtcbiAgICAgIHJlcy5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgIGhhbmRsZUVycm9yKGVyciwgaW5zdGFuY2UsIHR5cGUpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG4gIH1cbiAgY29uc3QgdmFsdWVzID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZm4ubGVuZ3RoOyBpKyspIHtcbiAgICB2YWx1ZXMucHVzaChjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZyhmbltpXSwgaW5zdGFuY2UsIHR5cGUsIGFyZ3MpKTtcbiAgfVxuICByZXR1cm4gdmFsdWVzO1xufVxuZnVuY3Rpb24gaGFuZGxlRXJyb3IoZXJyLCBpbnN0YW5jZSwgdHlwZSwgdGhyb3dJbkRldiA9IHRydWUpIHtcbiAgY29uc3QgY29udGV4dFZOb2RlID0gaW5zdGFuY2UgPyBpbnN0YW5jZS52bm9kZSA6IG51bGw7XG4gIGlmIChpbnN0YW5jZSkge1xuICAgIGxldCBjdXIgPSBpbnN0YW5jZS5wYXJlbnQ7XG4gICAgY29uc3QgZXhwb3NlZEluc3RhbmNlID0gaW5zdGFuY2UucHJveHk7XG4gICAgY29uc3QgZXJyb3JJbmZvID0gISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IEVycm9yVHlwZVN0cmluZ3NbdHlwZV0gOiB0eXBlO1xuICAgIHdoaWxlIChjdXIpIHtcbiAgICAgIGNvbnN0IGVycm9yQ2FwdHVyZWRIb29rcyA9IGN1ci5lYztcbiAgICAgIGlmIChlcnJvckNhcHR1cmVkSG9va3MpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlcnJvckNhcHR1cmVkSG9va3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAoZXJyb3JDYXB0dXJlZEhvb2tzW2ldKGVyciwgZXhwb3NlZEluc3RhbmNlLCBlcnJvckluZm8pID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY3VyID0gY3VyLnBhcmVudDtcbiAgICB9XG4gICAgY29uc3QgYXBwRXJyb3JIYW5kbGVyID0gaW5zdGFuY2UuYXBwQ29udGV4dC5jb25maWcuZXJyb3JIYW5kbGVyO1xuICAgIGlmIChhcHBFcnJvckhhbmRsZXIpIHtcbiAgICAgIGNhbGxXaXRoRXJyb3JIYW5kbGluZyhcbiAgICAgICAgYXBwRXJyb3JIYW5kbGVyLFxuICAgICAgICBudWxsLFxuICAgICAgICAxMCxcbiAgICAgICAgW2VyciwgZXhwb3NlZEluc3RhbmNlLCBlcnJvckluZm9dXG4gICAgICApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuICBsb2dFcnJvcihlcnIsIHR5cGUsIGNvbnRleHRWTm9kZSwgdGhyb3dJbkRldik7XG59XG5mdW5jdGlvbiBsb2dFcnJvcihlcnIsIHR5cGUsIGNvbnRleHRWTm9kZSwgdGhyb3dJbkRldiA9IHRydWUpIHtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICBjb25zdCBpbmZvID0gRXJyb3JUeXBlU3RyaW5nc1t0eXBlXTtcbiAgICBpZiAoY29udGV4dFZOb2RlKSB7XG4gICAgICBwdXNoV2FybmluZ0NvbnRleHQoY29udGV4dFZOb2RlKTtcbiAgICB9XG4gICAgd2FybihgVW5oYW5kbGVkIGVycm9yJHtpbmZvID8gYCBkdXJpbmcgZXhlY3V0aW9uIG9mICR7aW5mb31gIDogYGB9YCk7XG4gICAgaWYgKGNvbnRleHRWTm9kZSkge1xuICAgICAgcG9wV2FybmluZ0NvbnRleHQoKTtcbiAgICB9XG4gICAgaWYgKHRocm93SW5EZXYpIHtcbiAgICAgIHRocm93IGVycjtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBjb25zb2xlLmVycm9yKGVycik7XG4gIH1cbn1cblxubGV0IGlzRmx1c2hpbmcgPSBmYWxzZTtcbmxldCBpc0ZsdXNoUGVuZGluZyA9IGZhbHNlO1xuY29uc3QgcXVldWUgPSBbXTtcbmxldCBmbHVzaEluZGV4ID0gMDtcbmNvbnN0IHBlbmRpbmdQb3N0Rmx1c2hDYnMgPSBbXTtcbmxldCBhY3RpdmVQb3N0Rmx1c2hDYnMgPSBudWxsO1xubGV0IHBvc3RGbHVzaEluZGV4ID0gMDtcbmNvbnN0IHJlc29sdmVkUHJvbWlzZSA9IC8qIEBfX1BVUkVfXyAqLyBQcm9taXNlLnJlc29sdmUoKTtcbmxldCBjdXJyZW50Rmx1c2hQcm9taXNlID0gbnVsbDtcbmNvbnN0IFJFQ1VSU0lPTl9MSU1JVCA9IDEwMDtcbmZ1bmN0aW9uIG5leHRUaWNrKGZuKSB7XG4gIGNvbnN0IHAgPSBjdXJyZW50Rmx1c2hQcm9taXNlIHx8IHJlc29sdmVkUHJvbWlzZTtcbiAgcmV0dXJuIGZuID8gcC50aGVuKHRoaXMgPyBmbi5iaW5kKHRoaXMpIDogZm4pIDogcDtcbn1cbmZ1bmN0aW9uIGZpbmRJbnNlcnRpb25JbmRleChpZCkge1xuICBsZXQgc3RhcnQgPSBmbHVzaEluZGV4ICsgMTtcbiAgbGV0IGVuZCA9IHF1ZXVlLmxlbmd0aDtcbiAgd2hpbGUgKHN0YXJ0IDwgZW5kKSB7XG4gICAgY29uc3QgbWlkZGxlID0gc3RhcnQgKyBlbmQgPj4+IDE7XG4gICAgY29uc3QgbWlkZGxlSm9iSWQgPSBnZXRJZChxdWV1ZVttaWRkbGVdKTtcbiAgICBtaWRkbGVKb2JJZCA8IGlkID8gc3RhcnQgPSBtaWRkbGUgKyAxIDogZW5kID0gbWlkZGxlO1xuICB9XG4gIHJldHVybiBzdGFydDtcbn1cbmZ1bmN0aW9uIHF1ZXVlSm9iKGpvYikge1xuICBpZiAoIXF1ZXVlLmxlbmd0aCB8fCAhcXVldWUuaW5jbHVkZXMoXG4gICAgam9iLFxuICAgIGlzRmx1c2hpbmcgJiYgam9iLmFsbG93UmVjdXJzZSA/IGZsdXNoSW5kZXggKyAxIDogZmx1c2hJbmRleFxuICApKSB7XG4gICAgaWYgKGpvYi5pZCA9PSBudWxsKSB7XG4gICAgICBxdWV1ZS5wdXNoKGpvYik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHF1ZXVlLnNwbGljZShmaW5kSW5zZXJ0aW9uSW5kZXgoam9iLmlkKSwgMCwgam9iKTtcbiAgICB9XG4gICAgcXVldWVGbHVzaCgpO1xuICB9XG59XG5mdW5jdGlvbiBxdWV1ZUZsdXNoKCkge1xuICBpZiAoIWlzRmx1c2hpbmcgJiYgIWlzRmx1c2hQZW5kaW5nKSB7XG4gICAgaXNGbHVzaFBlbmRpbmcgPSB0cnVlO1xuICAgIGN1cnJlbnRGbHVzaFByb21pc2UgPSByZXNvbHZlZFByb21pc2UudGhlbihmbHVzaEpvYnMpO1xuICB9XG59XG5mdW5jdGlvbiBpbnZhbGlkYXRlSm9iKGpvYikge1xuICBjb25zdCBpID0gcXVldWUuaW5kZXhPZihqb2IpO1xuICBpZiAoaSA+IGZsdXNoSW5kZXgpIHtcbiAgICBxdWV1ZS5zcGxpY2UoaSwgMSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHF1ZXVlUG9zdEZsdXNoQ2IoY2IpIHtcbiAgaWYgKCFpc0FycmF5KGNiKSkge1xuICAgIGlmICghYWN0aXZlUG9zdEZsdXNoQ2JzIHx8ICFhY3RpdmVQb3N0Rmx1c2hDYnMuaW5jbHVkZXMoXG4gICAgICBjYixcbiAgICAgIGNiLmFsbG93UmVjdXJzZSA/IHBvc3RGbHVzaEluZGV4ICsgMSA6IHBvc3RGbHVzaEluZGV4XG4gICAgKSkge1xuICAgICAgcGVuZGluZ1Bvc3RGbHVzaENicy5wdXNoKGNiKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcGVuZGluZ1Bvc3RGbHVzaENicy5wdXNoKC4uLmNiKTtcbiAgfVxuICBxdWV1ZUZsdXNoKCk7XG59XG5mdW5jdGlvbiBmbHVzaFByZUZsdXNoQ2JzKHNlZW4sIGkgPSBpc0ZsdXNoaW5nID8gZmx1c2hJbmRleCArIDEgOiAwKSB7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgc2VlbiA9IHNlZW4gfHwgLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgfVxuICBmb3IgKDsgaSA8IHF1ZXVlLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgY2IgPSBxdWV1ZVtpXTtcbiAgICBpZiAoY2IgJiYgY2IucHJlKSB7XG4gICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBjaGVja1JlY3Vyc2l2ZVVwZGF0ZXMoc2VlbiwgY2IpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgcXVldWUuc3BsaWNlKGksIDEpO1xuICAgICAgaS0tO1xuICAgICAgY2IoKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGZsdXNoUG9zdEZsdXNoQ2JzKHNlZW4pIHtcbiAgaWYgKHBlbmRpbmdQb3N0Rmx1c2hDYnMubGVuZ3RoKSB7XG4gICAgY29uc3QgZGVkdXBlZCA9IFsuLi5uZXcgU2V0KHBlbmRpbmdQb3N0Rmx1c2hDYnMpXTtcbiAgICBwZW5kaW5nUG9zdEZsdXNoQ2JzLmxlbmd0aCA9IDA7XG4gICAgaWYgKGFjdGl2ZVBvc3RGbHVzaENicykge1xuICAgICAgYWN0aXZlUG9zdEZsdXNoQ2JzLnB1c2goLi4uZGVkdXBlZCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGFjdGl2ZVBvc3RGbHVzaENicyA9IGRlZHVwZWQ7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgIHNlZW4gPSBzZWVuIHx8IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgfVxuICAgIGFjdGl2ZVBvc3RGbHVzaENicy5zb3J0KChhLCBiKSA9PiBnZXRJZChhKSAtIGdldElkKGIpKTtcbiAgICBmb3IgKHBvc3RGbHVzaEluZGV4ID0gMDsgcG9zdEZsdXNoSW5kZXggPCBhY3RpdmVQb3N0Rmx1c2hDYnMubGVuZ3RoOyBwb3N0Rmx1c2hJbmRleCsrKSB7XG4gICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBjaGVja1JlY3Vyc2l2ZVVwZGF0ZXMoc2VlbiwgYWN0aXZlUG9zdEZsdXNoQ2JzW3Bvc3RGbHVzaEluZGV4XSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBhY3RpdmVQb3N0Rmx1c2hDYnNbcG9zdEZsdXNoSW5kZXhdKCk7XG4gICAgfVxuICAgIGFjdGl2ZVBvc3RGbHVzaENicyA9IG51bGw7XG4gICAgcG9zdEZsdXNoSW5kZXggPSAwO1xuICB9XG59XG5jb25zdCBnZXRJZCA9IChqb2IpID0+IGpvYi5pZCA9PSBudWxsID8gSW5maW5pdHkgOiBqb2IuaWQ7XG5jb25zdCBjb21wYXJhdG9yID0gKGEsIGIpID0+IHtcbiAgY29uc3QgZGlmZiA9IGdldElkKGEpIC0gZ2V0SWQoYik7XG4gIGlmIChkaWZmID09PSAwKSB7XG4gICAgaWYgKGEucHJlICYmICFiLnByZSlcbiAgICAgIHJldHVybiAtMTtcbiAgICBpZiAoYi5wcmUgJiYgIWEucHJlKVxuICAgICAgcmV0dXJuIDE7XG4gIH1cbiAgcmV0dXJuIGRpZmY7XG59O1xuZnVuY3Rpb24gZmx1c2hKb2JzKHNlZW4pIHtcbiAgaXNGbHVzaFBlbmRpbmcgPSBmYWxzZTtcbiAgaXNGbHVzaGluZyA9IHRydWU7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgc2VlbiA9IHNlZW4gfHwgLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgfVxuICBxdWV1ZS5zb3J0KGNvbXBhcmF0b3IpO1xuICBjb25zdCBjaGVjayA9ICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyAoam9iKSA9PiBjaGVja1JlY3Vyc2l2ZVVwZGF0ZXMoc2Vlbiwgam9iKSA6IE5PT1A7XG4gIHRyeSB7XG4gICAgZm9yIChmbHVzaEluZGV4ID0gMDsgZmx1c2hJbmRleCA8IHF1ZXVlLmxlbmd0aDsgZmx1c2hJbmRleCsrKSB7XG4gICAgICBjb25zdCBqb2IgPSBxdWV1ZVtmbHVzaEluZGV4XTtcbiAgICAgIGlmIChqb2IgJiYgam9iLmFjdGl2ZSAhPT0gZmFsc2UpIHtcbiAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgY2hlY2soam9iKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNhbGxXaXRoRXJyb3JIYW5kbGluZyhqb2IsIG51bGwsIDE0KTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZmluYWxseSB7XG4gICAgZmx1c2hJbmRleCA9IDA7XG4gICAgcXVldWUubGVuZ3RoID0gMDtcbiAgICBmbHVzaFBvc3RGbHVzaENicyhzZWVuKTtcbiAgICBpc0ZsdXNoaW5nID0gZmFsc2U7XG4gICAgY3VycmVudEZsdXNoUHJvbWlzZSA9IG51bGw7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCB8fCBwZW5kaW5nUG9zdEZsdXNoQ2JzLmxlbmd0aCkge1xuICAgICAgZmx1c2hKb2JzKHNlZW4pO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gY2hlY2tSZWN1cnNpdmVVcGRhdGVzKHNlZW4sIGZuKSB7XG4gIGlmICghc2Vlbi5oYXMoZm4pKSB7XG4gICAgc2Vlbi5zZXQoZm4sIDEpO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IGNvdW50ID0gc2Vlbi5nZXQoZm4pO1xuICAgIGlmIChjb3VudCA+IFJFQ1VSU0lPTl9MSU1JVCkge1xuICAgICAgY29uc3QgaW5zdGFuY2UgPSBmbi5vd25lckluc3RhbmNlO1xuICAgICAgY29uc3QgY29tcG9uZW50TmFtZSA9IGluc3RhbmNlICYmIGdldENvbXBvbmVudE5hbWUoaW5zdGFuY2UudHlwZSk7XG4gICAgICB3YXJuKFxuICAgICAgICBgTWF4aW11bSByZWN1cnNpdmUgdXBkYXRlcyBleGNlZWRlZCR7Y29tcG9uZW50TmFtZSA/IGAgaW4gY29tcG9uZW50IDwke2NvbXBvbmVudE5hbWV9PmAgOiBgYH0uIFRoaXMgbWVhbnMgeW91IGhhdmUgYSByZWFjdGl2ZSBlZmZlY3QgdGhhdCBpcyBtdXRhdGluZyBpdHMgb3duIGRlcGVuZGVuY2llcyBhbmQgdGh1cyByZWN1cnNpdmVseSB0cmlnZ2VyaW5nIGl0c2VsZi4gUG9zc2libGUgc291cmNlcyBpbmNsdWRlIGNvbXBvbmVudCB0ZW1wbGF0ZSwgcmVuZGVyIGZ1bmN0aW9uLCB1cGRhdGVkIGhvb2sgb3Igd2F0Y2hlciBzb3VyY2UgZnVuY3Rpb24uYFxuICAgICAgKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZWVuLnNldChmbiwgY291bnQgKyAxKTtcbiAgICB9XG4gIH1cbn1cblxubGV0IGlzSG1yVXBkYXRpbmcgPSBmYWxzZTtcbmNvbnN0IGhtckRpcnR5Q29tcG9uZW50cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG5pZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICBnZXRHbG9iYWxUaGlzKCkuX19WVUVfSE1SX1JVTlRJTUVfXyA9IHtcbiAgICBjcmVhdGVSZWNvcmQ6IHRyeVdyYXAoY3JlYXRlUmVjb3JkKSxcbiAgICByZXJlbmRlcjogdHJ5V3JhcChyZXJlbmRlciksXG4gICAgcmVsb2FkOiB0cnlXcmFwKHJlbG9hZClcbiAgfTtcbn1cbmNvbnN0IG1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG5mdW5jdGlvbiByZWdpc3RlckhNUihpbnN0YW5jZSkge1xuICBjb25zdCBpZCA9IGluc3RhbmNlLnR5cGUuX19obXJJZDtcbiAgbGV0IHJlY29yZCA9IG1hcC5nZXQoaWQpO1xuICBpZiAoIXJlY29yZCkge1xuICAgIGNyZWF0ZVJlY29yZChpZCwgaW5zdGFuY2UudHlwZSk7XG4gICAgcmVjb3JkID0gbWFwLmdldChpZCk7XG4gIH1cbiAgcmVjb3JkLmluc3RhbmNlcy5hZGQoaW5zdGFuY2UpO1xufVxuZnVuY3Rpb24gdW5yZWdpc3RlckhNUihpbnN0YW5jZSkge1xuICBtYXAuZ2V0KGluc3RhbmNlLnR5cGUuX19obXJJZCkuaW5zdGFuY2VzLmRlbGV0ZShpbnN0YW5jZSk7XG59XG5mdW5jdGlvbiBjcmVhdGVSZWNvcmQoaWQsIGluaXRpYWxEZWYpIHtcbiAgaWYgKG1hcC5oYXMoaWQpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIG1hcC5zZXQoaWQsIHtcbiAgICBpbml0aWFsRGVmOiBub3JtYWxpemVDbGFzc0NvbXBvbmVudChpbml0aWFsRGVmKSxcbiAgICBpbnN0YW5jZXM6IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KClcbiAgfSk7XG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplQ2xhc3NDb21wb25lbnQoY29tcG9uZW50KSB7XG4gIHJldHVybiBpc0NsYXNzQ29tcG9uZW50KGNvbXBvbmVudCkgPyBjb21wb25lbnQuX192Y2NPcHRzIDogY29tcG9uZW50O1xufVxuZnVuY3Rpb24gcmVyZW5kZXIoaWQsIG5ld1JlbmRlcikge1xuICBjb25zdCByZWNvcmQgPSBtYXAuZ2V0KGlkKTtcbiAgaWYgKCFyZWNvcmQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgcmVjb3JkLmluaXRpYWxEZWYucmVuZGVyID0gbmV3UmVuZGVyO1xuICBbLi4ucmVjb3JkLmluc3RhbmNlc10uZm9yRWFjaCgoaW5zdGFuY2UpID0+IHtcbiAgICBpZiAobmV3UmVuZGVyKSB7XG4gICAgICBpbnN0YW5jZS5yZW5kZXIgPSBuZXdSZW5kZXI7XG4gICAgICBub3JtYWxpemVDbGFzc0NvbXBvbmVudChpbnN0YW5jZS50eXBlKS5yZW5kZXIgPSBuZXdSZW5kZXI7XG4gICAgfVxuICAgIGluc3RhbmNlLnJlbmRlckNhY2hlID0gW107XG4gICAgaXNIbXJVcGRhdGluZyA9IHRydWU7XG4gICAgaW5zdGFuY2UudXBkYXRlKCk7XG4gICAgaXNIbXJVcGRhdGluZyA9IGZhbHNlO1xuICB9KTtcbn1cbmZ1bmN0aW9uIHJlbG9hZChpZCwgbmV3Q29tcCkge1xuICBjb25zdCByZWNvcmQgPSBtYXAuZ2V0KGlkKTtcbiAgaWYgKCFyZWNvcmQpXG4gICAgcmV0dXJuO1xuICBuZXdDb21wID0gbm9ybWFsaXplQ2xhc3NDb21wb25lbnQobmV3Q29tcCk7XG4gIHVwZGF0ZUNvbXBvbmVudERlZihyZWNvcmQuaW5pdGlhbERlZiwgbmV3Q29tcCk7XG4gIGNvbnN0IGluc3RhbmNlcyA9IFsuLi5yZWNvcmQuaW5zdGFuY2VzXTtcbiAgZm9yIChjb25zdCBpbnN0YW5jZSBvZiBpbnN0YW5jZXMpIHtcbiAgICBjb25zdCBvbGRDb21wID0gbm9ybWFsaXplQ2xhc3NDb21wb25lbnQoaW5zdGFuY2UudHlwZSk7XG4gICAgaWYgKCFobXJEaXJ0eUNvbXBvbmVudHMuaGFzKG9sZENvbXApKSB7XG4gICAgICBpZiAob2xkQ29tcCAhPT0gcmVjb3JkLmluaXRpYWxEZWYpIHtcbiAgICAgICAgdXBkYXRlQ29tcG9uZW50RGVmKG9sZENvbXAsIG5ld0NvbXApO1xuICAgICAgfVxuICAgICAgaG1yRGlydHlDb21wb25lbnRzLmFkZChvbGRDb21wKTtcbiAgICB9XG4gICAgaW5zdGFuY2UuYXBwQ29udGV4dC5wcm9wc0NhY2hlLmRlbGV0ZShpbnN0YW5jZS50eXBlKTtcbiAgICBpbnN0YW5jZS5hcHBDb250ZXh0LmVtaXRzQ2FjaGUuZGVsZXRlKGluc3RhbmNlLnR5cGUpO1xuICAgIGluc3RhbmNlLmFwcENvbnRleHQub3B0aW9uc0NhY2hlLmRlbGV0ZShpbnN0YW5jZS50eXBlKTtcbiAgICBpZiAoaW5zdGFuY2UuY2VSZWxvYWQpIHtcbiAgICAgIGhtckRpcnR5Q29tcG9uZW50cy5hZGQob2xkQ29tcCk7XG4gICAgICBpbnN0YW5jZS5jZVJlbG9hZChuZXdDb21wLnN0eWxlcyk7XG4gICAgICBobXJEaXJ0eUNvbXBvbmVudHMuZGVsZXRlKG9sZENvbXApO1xuICAgIH0gZWxzZSBpZiAoaW5zdGFuY2UucGFyZW50KSB7XG4gICAgICBxdWV1ZUpvYihpbnN0YW5jZS5wYXJlbnQudXBkYXRlKTtcbiAgICB9IGVsc2UgaWYgKGluc3RhbmNlLmFwcENvbnRleHQucmVsb2FkKSB7XG4gICAgICBpbnN0YW5jZS5hcHBDb250ZXh0LnJlbG9hZCgpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgd2luZG93LmxvY2F0aW9uLnJlbG9hZCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgIFwiW0hNUl0gUm9vdCBvciBtYW51YWxseSBtb3VudGVkIGluc3RhbmNlIG1vZGlmaWVkLiBGdWxsIHJlbG9hZCByZXF1aXJlZC5cIlxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgcXVldWVQb3N0Rmx1c2hDYigoKSA9PiB7XG4gICAgZm9yIChjb25zdCBpbnN0YW5jZSBvZiBpbnN0YW5jZXMpIHtcbiAgICAgIGhtckRpcnR5Q29tcG9uZW50cy5kZWxldGUoXG4gICAgICAgIG5vcm1hbGl6ZUNsYXNzQ29tcG9uZW50KGluc3RhbmNlLnR5cGUpXG4gICAgICApO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiB1cGRhdGVDb21wb25lbnREZWYob2xkQ29tcCwgbmV3Q29tcCkge1xuICBleHRlbmQob2xkQ29tcCwgbmV3Q29tcCk7XG4gIGZvciAoY29uc3Qga2V5IGluIG9sZENvbXApIHtcbiAgICBpZiAoa2V5ICE9PSBcIl9fZmlsZVwiICYmICEoa2V5IGluIG5ld0NvbXApKSB7XG4gICAgICBkZWxldGUgb2xkQ29tcFtrZXldO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gdHJ5V3JhcChmbikge1xuICByZXR1cm4gKGlkLCBhcmcpID0+IHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGZuKGlkLCBhcmcpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgIGBbSE1SXSBTb21ldGhpbmcgd2VudCB3cm9uZyBkdXJpbmcgVnVlIGNvbXBvbmVudCBob3QtcmVsb2FkLiBGdWxsIHJlbG9hZCByZXF1aXJlZC5gXG4gICAgICApO1xuICAgIH1cbiAgfTtcbn1cblxubGV0IGRldnRvb2xzO1xubGV0IGJ1ZmZlciA9IFtdO1xubGV0IGRldnRvb2xzTm90SW5zdGFsbGVkID0gZmFsc2U7XG5mdW5jdGlvbiBlbWl0JDEoZXZlbnQsIC4uLmFyZ3MpIHtcbiAgaWYgKGRldnRvb2xzKSB7XG4gICAgZGV2dG9vbHMuZW1pdChldmVudCwgLi4uYXJncyk7XG4gIH0gZWxzZSBpZiAoIWRldnRvb2xzTm90SW5zdGFsbGVkKSB7XG4gICAgYnVmZmVyLnB1c2goeyBldmVudCwgYXJncyB9KTtcbiAgfVxufVxuZnVuY3Rpb24gc2V0RGV2dG9vbHNIb29rKGhvb2ssIHRhcmdldCkge1xuICB2YXIgX2EsIF9iO1xuICBkZXZ0b29scyA9IGhvb2s7XG4gIGlmIChkZXZ0b29scykge1xuICAgIGRldnRvb2xzLmVuYWJsZWQgPSB0cnVlO1xuICAgIGJ1ZmZlci5mb3JFYWNoKCh7IGV2ZW50LCBhcmdzIH0pID0+IGRldnRvb2xzLmVtaXQoZXZlbnQsIC4uLmFyZ3MpKTtcbiAgICBidWZmZXIgPSBbXTtcbiAgfSBlbHNlIGlmIChcbiAgICAvLyBoYW5kbGUgbGF0ZSBkZXZ0b29scyBpbmplY3Rpb24gLSBvbmx5IGRvIHRoaXMgaWYgd2UgYXJlIGluIGFuIGFjdHVhbFxuICAgIC8vIGJyb3dzZXIgZW52aXJvbm1lbnQgdG8gYXZvaWQgdGhlIHRpbWVyIGhhbmRsZSBzdGFsbGluZyB0ZXN0IHJ1bm5lciBleGl0XG4gICAgLy8gKCM0ODE1KVxuICAgIHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgLy8gc29tZSBlbnZzIG1vY2sgd2luZG93IGJ1dCBub3QgZnVsbHlcbiAgICB3aW5kb3cuSFRNTEVsZW1lbnQgJiYgLy8gYWxzbyBleGNsdWRlIGpzZG9tXG4gICAgISgoX2IgPSAoX2EgPSB3aW5kb3cubmF2aWdhdG9yKSA9PSBudWxsID8gdm9pZCAwIDogX2EudXNlckFnZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2IuaW5jbHVkZXMoXCJqc2RvbVwiKSlcbiAgKSB7XG4gICAgY29uc3QgcmVwbGF5ID0gdGFyZ2V0Ll9fVlVFX0RFVlRPT0xTX0hPT0tfUkVQTEFZX18gPSB0YXJnZXQuX19WVUVfREVWVE9PTFNfSE9PS19SRVBMQVlfXyB8fCBbXTtcbiAgICByZXBsYXkucHVzaCgobmV3SG9vaykgPT4ge1xuICAgICAgc2V0RGV2dG9vbHNIb29rKG5ld0hvb2ssIHRhcmdldCk7XG4gICAgfSk7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBpZiAoIWRldnRvb2xzKSB7XG4gICAgICAgIHRhcmdldC5fX1ZVRV9ERVZUT09MU19IT09LX1JFUExBWV9fID0gbnVsbDtcbiAgICAgICAgZGV2dG9vbHNOb3RJbnN0YWxsZWQgPSB0cnVlO1xuICAgICAgICBidWZmZXIgPSBbXTtcbiAgICAgIH1cbiAgICB9LCAzZTMpO1xuICB9IGVsc2Uge1xuICAgIGRldnRvb2xzTm90SW5zdGFsbGVkID0gdHJ1ZTtcbiAgICBidWZmZXIgPSBbXTtcbiAgfVxufVxuZnVuY3Rpb24gZGV2dG9vbHNJbml0QXBwKGFwcCwgdmVyc2lvbikge1xuICBlbWl0JDEoXCJhcHA6aW5pdFwiIC8qIEFQUF9JTklUICovLCBhcHAsIHZlcnNpb24sIHtcbiAgICBGcmFnbWVudCxcbiAgICBUZXh0LFxuICAgIENvbW1lbnQsXG4gICAgU3RhdGljXG4gIH0pO1xufVxuZnVuY3Rpb24gZGV2dG9vbHNVbm1vdW50QXBwKGFwcCkge1xuICBlbWl0JDEoXCJhcHA6dW5tb3VudFwiIC8qIEFQUF9VTk1PVU5UICovLCBhcHApO1xufVxuY29uc3QgZGV2dG9vbHNDb21wb25lbnRBZGRlZCA9IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVEZXZ0b29sc0NvbXBvbmVudEhvb2soXG4gIFwiY29tcG9uZW50OmFkZGVkXCIgLyogQ09NUE9ORU5UX0FEREVEICovXG4pO1xuY29uc3QgZGV2dG9vbHNDb21wb25lbnRVcGRhdGVkID0gLyogQF9fUFVSRV9fICovIGNyZWF0ZURldnRvb2xzQ29tcG9uZW50SG9vayhcImNvbXBvbmVudDp1cGRhdGVkXCIgLyogQ09NUE9ORU5UX1VQREFURUQgKi8pO1xuY29uc3QgX2RldnRvb2xzQ29tcG9uZW50UmVtb3ZlZCA9IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVEZXZ0b29sc0NvbXBvbmVudEhvb2soXG4gIFwiY29tcG9uZW50OnJlbW92ZWRcIiAvKiBDT01QT05FTlRfUkVNT1ZFRCAqL1xuKTtcbmNvbnN0IGRldnRvb2xzQ29tcG9uZW50UmVtb3ZlZCA9IChjb21wb25lbnQpID0+IHtcbiAgaWYgKGRldnRvb2xzICYmIHR5cGVvZiBkZXZ0b29scy5jbGVhbnVwQnVmZmVyID09PSBcImZ1bmN0aW9uXCIgJiYgLy8gcmVtb3ZlIHRoZSBjb21wb25lbnQgaWYgaXQgd2Fzbid0IGJ1ZmZlcmVkXG4gICFkZXZ0b29scy5jbGVhbnVwQnVmZmVyKGNvbXBvbmVudCkpIHtcbiAgICBfZGV2dG9vbHNDb21wb25lbnRSZW1vdmVkKGNvbXBvbmVudCk7XG4gIH1cbn07XG5mdW5jdGlvbiBjcmVhdGVEZXZ0b29sc0NvbXBvbmVudEhvb2soaG9vaykge1xuICByZXR1cm4gKGNvbXBvbmVudCkgPT4ge1xuICAgIGVtaXQkMShcbiAgICAgIGhvb2ssXG4gICAgICBjb21wb25lbnQuYXBwQ29udGV4dC5hcHAsXG4gICAgICBjb21wb25lbnQudWlkLFxuICAgICAgY29tcG9uZW50LnBhcmVudCA/IGNvbXBvbmVudC5wYXJlbnQudWlkIDogdm9pZCAwLFxuICAgICAgY29tcG9uZW50XG4gICAgKTtcbiAgfTtcbn1cbmNvbnN0IGRldnRvb2xzUGVyZlN0YXJ0ID0gLyogQF9fUFVSRV9fICovIGNyZWF0ZURldnRvb2xzUGVyZm9ybWFuY2VIb29rKFxuICBcInBlcmY6c3RhcnRcIiAvKiBQRVJGT1JNQU5DRV9TVEFSVCAqL1xuKTtcbmNvbnN0IGRldnRvb2xzUGVyZkVuZCA9IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVEZXZ0b29sc1BlcmZvcm1hbmNlSG9vayhcbiAgXCJwZXJmOmVuZFwiIC8qIFBFUkZPUk1BTkNFX0VORCAqL1xuKTtcbmZ1bmN0aW9uIGNyZWF0ZURldnRvb2xzUGVyZm9ybWFuY2VIb29rKGhvb2spIHtcbiAgcmV0dXJuIChjb21wb25lbnQsIHR5cGUsIHRpbWUpID0+IHtcbiAgICBlbWl0JDEoaG9vaywgY29tcG9uZW50LmFwcENvbnRleHQuYXBwLCBjb21wb25lbnQudWlkLCBjb21wb25lbnQsIHR5cGUsIHRpbWUpO1xuICB9O1xufVxuZnVuY3Rpb24gZGV2dG9vbHNDb21wb25lbnRFbWl0KGNvbXBvbmVudCwgZXZlbnQsIHBhcmFtcykge1xuICBlbWl0JDEoXG4gICAgXCJjb21wb25lbnQ6ZW1pdFwiIC8qIENPTVBPTkVOVF9FTUlUICovLFxuICAgIGNvbXBvbmVudC5hcHBDb250ZXh0LmFwcCxcbiAgICBjb21wb25lbnQsXG4gICAgZXZlbnQsXG4gICAgcGFyYW1zXG4gICk7XG59XG5cbmZ1bmN0aW9uIGVtaXQoaW5zdGFuY2UsIGV2ZW50LCAuLi5yYXdBcmdzKSB7XG4gIGlmIChpbnN0YW5jZS5pc1VubW91bnRlZClcbiAgICByZXR1cm47XG4gIGNvbnN0IHByb3BzID0gaW5zdGFuY2Uudm5vZGUucHJvcHMgfHwgRU1QVFlfT0JKO1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGVtaXRzT3B0aW9ucyxcbiAgICAgIHByb3BzT3B0aW9uczogW3Byb3BzT3B0aW9uc11cbiAgICB9ID0gaW5zdGFuY2U7XG4gICAgaWYgKGVtaXRzT3B0aW9ucykge1xuICAgICAgaWYgKCEoZXZlbnQgaW4gZW1pdHNPcHRpb25zKSAmJiB0cnVlKSB7XG4gICAgICAgIGlmICghcHJvcHNPcHRpb25zIHx8ICEodG9IYW5kbGVyS2V5KGV2ZW50KSBpbiBwcm9wc09wdGlvbnMpKSB7XG4gICAgICAgICAgd2FybihcbiAgICAgICAgICAgIGBDb21wb25lbnQgZW1pdHRlZCBldmVudCBcIiR7ZXZlbnR9XCIgYnV0IGl0IGlzIG5laXRoZXIgZGVjbGFyZWQgaW4gdGhlIGVtaXRzIG9wdGlvbiBub3IgYXMgYW4gXCIke3RvSGFuZGxlcktleShldmVudCl9XCIgcHJvcC5gXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgdmFsaWRhdG9yID0gZW1pdHNPcHRpb25zW2V2ZW50XTtcbiAgICAgICAgaWYgKGlzRnVuY3Rpb24odmFsaWRhdG9yKSkge1xuICAgICAgICAgIGNvbnN0IGlzVmFsaWQgPSB2YWxpZGF0b3IoLi4ucmF3QXJncyk7XG4gICAgICAgICAgaWYgKCFpc1ZhbGlkKSB7XG4gICAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgICBgSW52YWxpZCBldmVudCBhcmd1bWVudHM6IGV2ZW50IHZhbGlkYXRpb24gZmFpbGVkIGZvciBldmVudCBcIiR7ZXZlbnR9XCIuYFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgbGV0IGFyZ3MgPSByYXdBcmdzO1xuICBjb25zdCBpc01vZGVsTGlzdGVuZXIgPSBldmVudC5zdGFydHNXaXRoKFwidXBkYXRlOlwiKTtcbiAgY29uc3QgbW9kZWxBcmcgPSBpc01vZGVsTGlzdGVuZXIgJiYgZXZlbnQuc2xpY2UoNyk7XG4gIGlmIChtb2RlbEFyZyAmJiBtb2RlbEFyZyBpbiBwcm9wcykge1xuICAgIGNvbnN0IG1vZGlmaWVyc0tleSA9IGAke21vZGVsQXJnID09PSBcIm1vZGVsVmFsdWVcIiA/IFwibW9kZWxcIiA6IG1vZGVsQXJnfU1vZGlmaWVyc2A7XG4gICAgY29uc3QgeyBudW1iZXIsIHRyaW0gfSA9IHByb3BzW21vZGlmaWVyc0tleV0gfHwgRU1QVFlfT0JKO1xuICAgIGlmICh0cmltKSB7XG4gICAgICBhcmdzID0gcmF3QXJncy5tYXAoKGEpID0+IGlzU3RyaW5nKGEpID8gYS50cmltKCkgOiBhKTtcbiAgICB9XG4gICAgaWYgKG51bWJlcikge1xuICAgICAgYXJncyA9IHJhd0FyZ3MubWFwKGxvb3NlVG9OdW1iZXIpO1xuICAgIH1cbiAgfVxuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcbiAgICBkZXZ0b29sc0NvbXBvbmVudEVtaXQoaW5zdGFuY2UsIGV2ZW50LCBhcmdzKTtcbiAgfVxuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIGNvbnN0IGxvd2VyQ2FzZUV2ZW50ID0gZXZlbnQudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAobG93ZXJDYXNlRXZlbnQgIT09IGV2ZW50ICYmIHByb3BzW3RvSGFuZGxlcktleShsb3dlckNhc2VFdmVudCldKSB7XG4gICAgICB3YXJuKFxuICAgICAgICBgRXZlbnQgXCIke2xvd2VyQ2FzZUV2ZW50fVwiIGlzIGVtaXR0ZWQgaW4gY29tcG9uZW50ICR7Zm9ybWF0Q29tcG9uZW50TmFtZShcbiAgICAgICAgICBpbnN0YW5jZSxcbiAgICAgICAgICBpbnN0YW5jZS50eXBlXG4gICAgICAgICl9IGJ1dCB0aGUgaGFuZGxlciBpcyByZWdpc3RlcmVkIGZvciBcIiR7ZXZlbnR9XCIuIE5vdGUgdGhhdCBIVE1MIGF0dHJpYnV0ZXMgYXJlIGNhc2UtaW5zZW5zaXRpdmUgYW5kIHlvdSBjYW5ub3QgdXNlIHYtb24gdG8gbGlzdGVuIHRvIGNhbWVsQ2FzZSBldmVudHMgd2hlbiB1c2luZyBpbi1ET00gdGVtcGxhdGVzLiBZb3Ugc2hvdWxkIHByb2JhYmx5IHVzZSBcIiR7aHlwaGVuYXRlKGV2ZW50KX1cIiBpbnN0ZWFkIG9mIFwiJHtldmVudH1cIi5gXG4gICAgICApO1xuICAgIH1cbiAgfVxuICBsZXQgaGFuZGxlck5hbWU7XG4gIGxldCBoYW5kbGVyID0gcHJvcHNbaGFuZGxlck5hbWUgPSB0b0hhbmRsZXJLZXkoZXZlbnQpXSB8fCAvLyBhbHNvIHRyeSBjYW1lbENhc2UgZXZlbnQgaGFuZGxlciAoIzIyNDkpXG4gIHByb3BzW2hhbmRsZXJOYW1lID0gdG9IYW5kbGVyS2V5KGNhbWVsaXplKGV2ZW50KSldO1xuICBpZiAoIWhhbmRsZXIgJiYgaXNNb2RlbExpc3RlbmVyKSB7XG4gICAgaGFuZGxlciA9IHByb3BzW2hhbmRsZXJOYW1lID0gdG9IYW5kbGVyS2V5KGh5cGhlbmF0ZShldmVudCkpXTtcbiAgfVxuICBpZiAoaGFuZGxlcikge1xuICAgIGNhbGxXaXRoQXN5bmNFcnJvckhhbmRsaW5nKFxuICAgICAgaGFuZGxlcixcbiAgICAgIGluc3RhbmNlLFxuICAgICAgNixcbiAgICAgIGFyZ3NcbiAgICApO1xuICB9XG4gIGNvbnN0IG9uY2VIYW5kbGVyID0gcHJvcHNbaGFuZGxlck5hbWUgKyBgT25jZWBdO1xuICBpZiAob25jZUhhbmRsZXIpIHtcbiAgICBpZiAoIWluc3RhbmNlLmVtaXR0ZWQpIHtcbiAgICAgIGluc3RhbmNlLmVtaXR0ZWQgPSB7fTtcbiAgICB9IGVsc2UgaWYgKGluc3RhbmNlLmVtaXR0ZWRbaGFuZGxlck5hbWVdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGluc3RhbmNlLmVtaXR0ZWRbaGFuZGxlck5hbWVdID0gdHJ1ZTtcbiAgICBjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZyhcbiAgICAgIG9uY2VIYW5kbGVyLFxuICAgICAgaW5zdGFuY2UsXG4gICAgICA2LFxuICAgICAgYXJnc1xuICAgICk7XG4gIH1cbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZUVtaXRzT3B0aW9ucyhjb21wLCBhcHBDb250ZXh0LCBhc01peGluID0gZmFsc2UpIHtcbiAgY29uc3QgY2FjaGUgPSBhcHBDb250ZXh0LmVtaXRzQ2FjaGU7XG4gIGNvbnN0IGNhY2hlZCA9IGNhY2hlLmdldChjb21wKTtcbiAgaWYgKGNhY2hlZCAhPT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuIGNhY2hlZDtcbiAgfVxuICBjb25zdCByYXcgPSBjb21wLmVtaXRzO1xuICBsZXQgbm9ybWFsaXplZCA9IHt9O1xuICBsZXQgaGFzRXh0ZW5kcyA9IGZhbHNlO1xuICBpZiAoX19WVUVfT1BUSU9OU19BUElfXyAmJiAhaXNGdW5jdGlvbihjb21wKSkge1xuICAgIGNvbnN0IGV4dGVuZEVtaXRzID0gKHJhdzIpID0+IHtcbiAgICAgIGNvbnN0IG5vcm1hbGl6ZWRGcm9tRXh0ZW5kID0gbm9ybWFsaXplRW1pdHNPcHRpb25zKHJhdzIsIGFwcENvbnRleHQsIHRydWUpO1xuICAgICAgaWYgKG5vcm1hbGl6ZWRGcm9tRXh0ZW5kKSB7XG4gICAgICAgIGhhc0V4dGVuZHMgPSB0cnVlO1xuICAgICAgICBleHRlbmQobm9ybWFsaXplZCwgbm9ybWFsaXplZEZyb21FeHRlbmQpO1xuICAgICAgfVxuICAgIH07XG4gICAgaWYgKCFhc01peGluICYmIGFwcENvbnRleHQubWl4aW5zLmxlbmd0aCkge1xuICAgICAgYXBwQ29udGV4dC5taXhpbnMuZm9yRWFjaChleHRlbmRFbWl0cyk7XG4gICAgfVxuICAgIGlmIChjb21wLmV4dGVuZHMpIHtcbiAgICAgIGV4dGVuZEVtaXRzKGNvbXAuZXh0ZW5kcyk7XG4gICAgfVxuICAgIGlmIChjb21wLm1peGlucykge1xuICAgICAgY29tcC5taXhpbnMuZm9yRWFjaChleHRlbmRFbWl0cyk7XG4gICAgfVxuICB9XG4gIGlmICghcmF3ICYmICFoYXNFeHRlbmRzKSB7XG4gICAgaWYgKGlzT2JqZWN0KGNvbXApKSB7XG4gICAgICBjYWNoZS5zZXQoY29tcCwgbnVsbCk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmIChpc0FycmF5KHJhdykpIHtcbiAgICByYXcuZm9yRWFjaCgoa2V5KSA9PiBub3JtYWxpemVkW2tleV0gPSBudWxsKTtcbiAgfSBlbHNlIHtcbiAgICBleHRlbmQobm9ybWFsaXplZCwgcmF3KTtcbiAgfVxuICBpZiAoaXNPYmplY3QoY29tcCkpIHtcbiAgICBjYWNoZS5zZXQoY29tcCwgbm9ybWFsaXplZCk7XG4gIH1cbiAgcmV0dXJuIG5vcm1hbGl6ZWQ7XG59XG5mdW5jdGlvbiBpc0VtaXRMaXN0ZW5lcihvcHRpb25zLCBrZXkpIHtcbiAgaWYgKCFvcHRpb25zIHx8ICFpc09uKGtleSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAga2V5ID0ga2V5LnNsaWNlKDIpLnJlcGxhY2UoL09uY2UkLywgXCJcIik7XG4gIHJldHVybiBoYXNPd24ob3B0aW9ucywga2V5WzBdLnRvTG93ZXJDYXNlKCkgKyBrZXkuc2xpY2UoMSkpIHx8IGhhc093bihvcHRpb25zLCBoeXBoZW5hdGUoa2V5KSkgfHwgaGFzT3duKG9wdGlvbnMsIGtleSk7XG59XG5cbmxldCBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UgPSBudWxsO1xubGV0IGN1cnJlbnRTY29wZUlkID0gbnVsbDtcbmZ1bmN0aW9uIHNldEN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZShpbnN0YW5jZSkge1xuICBjb25zdCBwcmV2ID0gY3VycmVudFJlbmRlcmluZ0luc3RhbmNlO1xuICBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UgPSBpbnN0YW5jZTtcbiAgY3VycmVudFNjb3BlSWQgPSBpbnN0YW5jZSAmJiBpbnN0YW5jZS50eXBlLl9fc2NvcGVJZCB8fCBudWxsO1xuICByZXR1cm4gcHJldjtcbn1cbmZ1bmN0aW9uIHB1c2hTY29wZUlkKGlkKSB7XG4gIGN1cnJlbnRTY29wZUlkID0gaWQ7XG59XG5mdW5jdGlvbiBwb3BTY29wZUlkKCkge1xuICBjdXJyZW50U2NvcGVJZCA9IG51bGw7XG59XG5jb25zdCB3aXRoU2NvcGVJZCA9IChfaWQpID0+IHdpdGhDdHg7XG5mdW5jdGlvbiB3aXRoQ3R4KGZuLCBjdHggPSBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UsIGlzTm9uU2NvcGVkU2xvdCkge1xuICBpZiAoIWN0eClcbiAgICByZXR1cm4gZm47XG4gIGlmIChmbi5fbikge1xuICAgIHJldHVybiBmbjtcbiAgfVxuICBjb25zdCByZW5kZXJGbldpdGhDb250ZXh0ID0gKC4uLmFyZ3MpID0+IHtcbiAgICBpZiAocmVuZGVyRm5XaXRoQ29udGV4dC5fZCkge1xuICAgICAgc2V0QmxvY2tUcmFja2luZygtMSk7XG4gICAgfVxuICAgIGNvbnN0IHByZXZJbnN0YW5jZSA9IHNldEN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZShjdHgpO1xuICAgIGxldCByZXM7XG4gICAgdHJ5IHtcbiAgICAgIHJlcyA9IGZuKC4uLmFyZ3MpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBzZXRDdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UocHJldkluc3RhbmNlKTtcbiAgICAgIGlmIChyZW5kZXJGbldpdGhDb250ZXh0Ll9kKSB7XG4gICAgICAgIHNldEJsb2NrVHJhY2tpbmcoMSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykge1xuICAgICAgZGV2dG9vbHNDb21wb25lbnRVcGRhdGVkKGN0eCk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG4gIH07XG4gIHJlbmRlckZuV2l0aENvbnRleHQuX24gPSB0cnVlO1xuICByZW5kZXJGbldpdGhDb250ZXh0Ll9jID0gdHJ1ZTtcbiAgcmVuZGVyRm5XaXRoQ29udGV4dC5fZCA9IHRydWU7XG4gIHJldHVybiByZW5kZXJGbldpdGhDb250ZXh0O1xufVxuXG5sZXQgYWNjZXNzZWRBdHRycyA9IGZhbHNlO1xuZnVuY3Rpb24gbWFya0F0dHJzQWNjZXNzZWQoKSB7XG4gIGFjY2Vzc2VkQXR0cnMgPSB0cnVlO1xufVxuZnVuY3Rpb24gcmVuZGVyQ29tcG9uZW50Um9vdChpbnN0YW5jZSkge1xuICBjb25zdCB7XG4gICAgdHlwZTogQ29tcG9uZW50LFxuICAgIHZub2RlLFxuICAgIHByb3h5LFxuICAgIHdpdGhQcm94eSxcbiAgICBwcm9wcyxcbiAgICBwcm9wc09wdGlvbnM6IFtwcm9wc09wdGlvbnNdLFxuICAgIHNsb3RzLFxuICAgIGF0dHJzLFxuICAgIGVtaXQsXG4gICAgcmVuZGVyLFxuICAgIHJlbmRlckNhY2hlLFxuICAgIGRhdGEsXG4gICAgc2V0dXBTdGF0ZSxcbiAgICBjdHgsXG4gICAgaW5oZXJpdEF0dHJzXG4gIH0gPSBpbnN0YW5jZTtcbiAgbGV0IHJlc3VsdDtcbiAgbGV0IGZhbGx0aHJvdWdoQXR0cnM7XG4gIGNvbnN0IHByZXYgPSBzZXRDdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UoaW5zdGFuY2UpO1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIGFjY2Vzc2VkQXR0cnMgPSBmYWxzZTtcbiAgfVxuICB0cnkge1xuICAgIGlmICh2bm9kZS5zaGFwZUZsYWcgJiA0KSB7XG4gICAgICBjb25zdCBwcm94eVRvVXNlID0gd2l0aFByb3h5IHx8IHByb3h5O1xuICAgICAgcmVzdWx0ID0gbm9ybWFsaXplVk5vZGUoXG4gICAgICAgIHJlbmRlci5jYWxsKFxuICAgICAgICAgIHByb3h5VG9Vc2UsXG4gICAgICAgICAgcHJveHlUb1VzZSxcbiAgICAgICAgICByZW5kZXJDYWNoZSxcbiAgICAgICAgICBwcm9wcyxcbiAgICAgICAgICBzZXR1cFN0YXRlLFxuICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgY3R4XG4gICAgICAgIClcbiAgICAgICk7XG4gICAgICBmYWxsdGhyb3VnaEF0dHJzID0gYXR0cnM7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHJlbmRlcjIgPSBDb21wb25lbnQ7XG4gICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBhdHRycyA9PT0gcHJvcHMpIHtcbiAgICAgICAgbWFya0F0dHJzQWNjZXNzZWQoKTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdCA9IG5vcm1hbGl6ZVZOb2RlKFxuICAgICAgICByZW5kZXIyLmxlbmd0aCA+IDEgPyByZW5kZXIyKFxuICAgICAgICAgIHByb3BzLFxuICAgICAgICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyB7XG4gICAgICAgICAgICBnZXQgYXR0cnMoKSB7XG4gICAgICAgICAgICAgIG1hcmtBdHRyc0FjY2Vzc2VkKCk7XG4gICAgICAgICAgICAgIHJldHVybiBhdHRycztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzbG90cyxcbiAgICAgICAgICAgIGVtaXRcbiAgICAgICAgICB9IDogeyBhdHRycywgc2xvdHMsIGVtaXQgfVxuICAgICAgICApIDogcmVuZGVyMihcbiAgICAgICAgICBwcm9wcyxcbiAgICAgICAgICBudWxsXG4gICAgICAgICAgLyogd2Uga25vdyBpdCBkb2Vzbid0IG5lZWQgaXQgKi9cbiAgICAgICAgKVxuICAgICAgKTtcbiAgICAgIGZhbGx0aHJvdWdoQXR0cnMgPSBDb21wb25lbnQucHJvcHMgPyBhdHRycyA6IGdldEZ1bmN0aW9uYWxGYWxsdGhyb3VnaChhdHRycyk7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBibG9ja1N0YWNrLmxlbmd0aCA9IDA7XG4gICAgaGFuZGxlRXJyb3IoZXJyLCBpbnN0YW5jZSwgMSk7XG4gICAgcmVzdWx0ID0gY3JlYXRlVk5vZGUoQ29tbWVudCk7XG4gIH1cbiAgbGV0IHJvb3QgPSByZXN1bHQ7XG4gIGxldCBzZXRSb290ID0gdm9pZCAwO1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiByZXN1bHQucGF0Y2hGbGFnID4gMCAmJiByZXN1bHQucGF0Y2hGbGFnICYgMjA0OCkge1xuICAgIFtyb290LCBzZXRSb290XSA9IGdldENoaWxkUm9vdChyZXN1bHQpO1xuICB9XG4gIGlmIChmYWxsdGhyb3VnaEF0dHJzICYmIGluaGVyaXRBdHRycyAhPT0gZmFsc2UpIHtcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoZmFsbHRocm91Z2hBdHRycyk7XG4gICAgY29uc3QgeyBzaGFwZUZsYWcgfSA9IHJvb3Q7XG4gICAgaWYgKGtleXMubGVuZ3RoKSB7XG4gICAgICBpZiAoc2hhcGVGbGFnICYgKDEgfCA2KSkge1xuICAgICAgICBpZiAocHJvcHNPcHRpb25zICYmIGtleXMuc29tZShpc01vZGVsTGlzdGVuZXIpKSB7XG4gICAgICAgICAgZmFsbHRocm91Z2hBdHRycyA9IGZpbHRlck1vZGVsTGlzdGVuZXJzKFxuICAgICAgICAgICAgZmFsbHRocm91Z2hBdHRycyxcbiAgICAgICAgICAgIHByb3BzT3B0aW9uc1xuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgcm9vdCA9IGNsb25lVk5vZGUocm9vdCwgZmFsbHRocm91Z2hBdHRycyk7XG4gICAgICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgIWFjY2Vzc2VkQXR0cnMgJiYgcm9vdC50eXBlICE9PSBDb21tZW50KSB7XG4gICAgICAgIGNvbnN0IGFsbEF0dHJzID0gT2JqZWN0LmtleXMoYXR0cnMpO1xuICAgICAgICBjb25zdCBldmVudEF0dHJzID0gW107XG4gICAgICAgIGNvbnN0IGV4dHJhQXR0cnMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSBhbGxBdHRycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBrZXkgPSBhbGxBdHRyc1tpXTtcbiAgICAgICAgICBpZiAoaXNPbihrZXkpKSB7XG4gICAgICAgICAgICBpZiAoIWlzTW9kZWxMaXN0ZW5lcihrZXkpKSB7XG4gICAgICAgICAgICAgIGV2ZW50QXR0cnMucHVzaChrZXlbMl0udG9Mb3dlckNhc2UoKSArIGtleS5zbGljZSgzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGV4dHJhQXR0cnMucHVzaChrZXkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZXh0cmFBdHRycy5sZW5ndGgpIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgYEV4dHJhbmVvdXMgbm9uLXByb3BzIGF0dHJpYnV0ZXMgKCR7ZXh0cmFBdHRycy5qb2luKFwiLCBcIil9KSB3ZXJlIHBhc3NlZCB0byBjb21wb25lbnQgYnV0IGNvdWxkIG5vdCBiZSBhdXRvbWF0aWNhbGx5IGluaGVyaXRlZCBiZWNhdXNlIGNvbXBvbmVudCByZW5kZXJzIGZyYWdtZW50IG9yIHRleHQgcm9vdCBub2Rlcy5gXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXZlbnRBdHRycy5sZW5ndGgpIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgYEV4dHJhbmVvdXMgbm9uLWVtaXRzIGV2ZW50IGxpc3RlbmVycyAoJHtldmVudEF0dHJzLmpvaW4oXCIsIFwiKX0pIHdlcmUgcGFzc2VkIHRvIGNvbXBvbmVudCBidXQgY291bGQgbm90IGJlIGF1dG9tYXRpY2FsbHkgaW5oZXJpdGVkIGJlY2F1c2UgY29tcG9uZW50IHJlbmRlcnMgZnJhZ21lbnQgb3IgdGV4dCByb290IG5vZGVzLiBJZiB0aGUgbGlzdGVuZXIgaXMgaW50ZW5kZWQgdG8gYmUgYSBjb21wb25lbnQgY3VzdG9tIGV2ZW50IGxpc3RlbmVyIG9ubHksIGRlY2xhcmUgaXQgdXNpbmcgdGhlIFwiZW1pdHNcIiBvcHRpb24uYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKHZub2RlLmRpcnMpIHtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhaXNFbGVtZW50Um9vdChyb290KSkge1xuICAgICAgd2FybihcbiAgICAgICAgYFJ1bnRpbWUgZGlyZWN0aXZlIHVzZWQgb24gY29tcG9uZW50IHdpdGggbm9uLWVsZW1lbnQgcm9vdCBub2RlLiBUaGUgZGlyZWN0aXZlcyB3aWxsIG5vdCBmdW5jdGlvbiBhcyBpbnRlbmRlZC5gXG4gICAgICApO1xuICAgIH1cbiAgICByb290ID0gY2xvbmVWTm9kZShyb290KTtcbiAgICByb290LmRpcnMgPSByb290LmRpcnMgPyByb290LmRpcnMuY29uY2F0KHZub2RlLmRpcnMpIDogdm5vZGUuZGlycztcbiAgfVxuICBpZiAodm5vZGUudHJhbnNpdGlvbikge1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICFpc0VsZW1lbnRSb290KHJvb3QpKSB7XG4gICAgICB3YXJuKFxuICAgICAgICBgQ29tcG9uZW50IGluc2lkZSA8VHJhbnNpdGlvbj4gcmVuZGVycyBub24tZWxlbWVudCByb290IG5vZGUgdGhhdCBjYW5ub3QgYmUgYW5pbWF0ZWQuYFxuICAgICAgKTtcbiAgICB9XG4gICAgcm9vdC50cmFuc2l0aW9uID0gdm5vZGUudHJhbnNpdGlvbjtcbiAgfVxuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBzZXRSb290KSB7XG4gICAgc2V0Um9vdChyb290KTtcbiAgfSBlbHNlIHtcbiAgICByZXN1bHQgPSByb290O1xuICB9XG4gIHNldEN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZShwcmV2KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmNvbnN0IGdldENoaWxkUm9vdCA9ICh2bm9kZSkgPT4ge1xuICBjb25zdCByYXdDaGlsZHJlbiA9IHZub2RlLmNoaWxkcmVuO1xuICBjb25zdCBkeW5hbWljQ2hpbGRyZW4gPSB2bm9kZS5keW5hbWljQ2hpbGRyZW47XG4gIGNvbnN0IGNoaWxkUm9vdCA9IGZpbHRlclNpbmdsZVJvb3QocmF3Q2hpbGRyZW4pO1xuICBpZiAoIWNoaWxkUm9vdCkge1xuICAgIHJldHVybiBbdm5vZGUsIHZvaWQgMF07XG4gIH1cbiAgY29uc3QgaW5kZXggPSByYXdDaGlsZHJlbi5pbmRleE9mKGNoaWxkUm9vdCk7XG4gIGNvbnN0IGR5bmFtaWNJbmRleCA9IGR5bmFtaWNDaGlsZHJlbiA/IGR5bmFtaWNDaGlsZHJlbi5pbmRleE9mKGNoaWxkUm9vdCkgOiAtMTtcbiAgY29uc3Qgc2V0Um9vdCA9ICh1cGRhdGVkUm9vdCkgPT4ge1xuICAgIHJhd0NoaWxkcmVuW2luZGV4XSA9IHVwZGF0ZWRSb290O1xuICAgIGlmIChkeW5hbWljQ2hpbGRyZW4pIHtcbiAgICAgIGlmIChkeW5hbWljSW5kZXggPiAtMSkge1xuICAgICAgICBkeW5hbWljQ2hpbGRyZW5bZHluYW1pY0luZGV4XSA9IHVwZGF0ZWRSb290O1xuICAgICAgfSBlbHNlIGlmICh1cGRhdGVkUm9vdC5wYXRjaEZsYWcgPiAwKSB7XG4gICAgICAgIHZub2RlLmR5bmFtaWNDaGlsZHJlbiA9IFsuLi5keW5hbWljQ2hpbGRyZW4sIHVwZGF0ZWRSb290XTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIHJldHVybiBbbm9ybWFsaXplVk5vZGUoY2hpbGRSb290KSwgc2V0Um9vdF07XG59O1xuZnVuY3Rpb24gZmlsdGVyU2luZ2xlUm9vdChjaGlsZHJlbikge1xuICBsZXQgc2luZ2xlUm9vdDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgaWYgKGlzVk5vZGUoY2hpbGQpKSB7XG4gICAgICBpZiAoY2hpbGQudHlwZSAhPT0gQ29tbWVudCB8fCBjaGlsZC5jaGlsZHJlbiA9PT0gXCJ2LWlmXCIpIHtcbiAgICAgICAgaWYgKHNpbmdsZVJvb3QpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2luZ2xlUm9vdCA9IGNoaWxkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHNpbmdsZVJvb3Q7XG59XG5jb25zdCBnZXRGdW5jdGlvbmFsRmFsbHRocm91Z2ggPSAoYXR0cnMpID0+IHtcbiAgbGV0IHJlcztcbiAgZm9yIChjb25zdCBrZXkgaW4gYXR0cnMpIHtcbiAgICBpZiAoa2V5ID09PSBcImNsYXNzXCIgfHwga2V5ID09PSBcInN0eWxlXCIgfHwgaXNPbihrZXkpKSB7XG4gICAgICAocmVzIHx8IChyZXMgPSB7fSkpW2tleV0gPSBhdHRyc1trZXldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzO1xufTtcbmNvbnN0IGZpbHRlck1vZGVsTGlzdGVuZXJzID0gKGF0dHJzLCBwcm9wcykgPT4ge1xuICBjb25zdCByZXMgPSB7fTtcbiAgZm9yIChjb25zdCBrZXkgaW4gYXR0cnMpIHtcbiAgICBpZiAoIWlzTW9kZWxMaXN0ZW5lcihrZXkpIHx8ICEoa2V5LnNsaWNlKDkpIGluIHByb3BzKSkge1xuICAgICAgcmVzW2tleV0gPSBhdHRyc1trZXldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzO1xufTtcbmNvbnN0IGlzRWxlbWVudFJvb3QgPSAodm5vZGUpID0+IHtcbiAgcmV0dXJuIHZub2RlLnNoYXBlRmxhZyAmICg2IHwgMSkgfHwgdm5vZGUudHlwZSA9PT0gQ29tbWVudDtcbn07XG5mdW5jdGlvbiBzaG91bGRVcGRhdGVDb21wb25lbnQocHJldlZOb2RlLCBuZXh0Vk5vZGUsIG9wdGltaXplZCkge1xuICBjb25zdCB7IHByb3BzOiBwcmV2UHJvcHMsIGNoaWxkcmVuOiBwcmV2Q2hpbGRyZW4sIGNvbXBvbmVudCB9ID0gcHJldlZOb2RlO1xuICBjb25zdCB7IHByb3BzOiBuZXh0UHJvcHMsIGNoaWxkcmVuOiBuZXh0Q2hpbGRyZW4sIHBhdGNoRmxhZyB9ID0gbmV4dFZOb2RlO1xuICBjb25zdCBlbWl0cyA9IGNvbXBvbmVudC5lbWl0c09wdGlvbnM7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIChwcmV2Q2hpbGRyZW4gfHwgbmV4dENoaWxkcmVuKSAmJiBpc0htclVwZGF0aW5nKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKG5leHRWTm9kZS5kaXJzIHx8IG5leHRWTm9kZS50cmFuc2l0aW9uKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKG9wdGltaXplZCAmJiBwYXRjaEZsYWcgPj0gMCkge1xuICAgIGlmIChwYXRjaEZsYWcgJiAxMDI0KSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHBhdGNoRmxhZyAmIDE2KSB7XG4gICAgICBpZiAoIXByZXZQcm9wcykge1xuICAgICAgICByZXR1cm4gISFuZXh0UHJvcHM7XG4gICAgICB9XG4gICAgICByZXR1cm4gaGFzUHJvcHNDaGFuZ2VkKHByZXZQcm9wcywgbmV4dFByb3BzLCBlbWl0cyk7XG4gICAgfSBlbHNlIGlmIChwYXRjaEZsYWcgJiA4KSB7XG4gICAgICBjb25zdCBkeW5hbWljUHJvcHMgPSBuZXh0Vk5vZGUuZHluYW1pY1Byb3BzO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkeW5hbWljUHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3Qga2V5ID0gZHluYW1pY1Byb3BzW2ldO1xuICAgICAgICBpZiAobmV4dFByb3BzW2tleV0gIT09IHByZXZQcm9wc1trZXldICYmICFpc0VtaXRMaXN0ZW5lcihlbWl0cywga2V5KSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChwcmV2Q2hpbGRyZW4gfHwgbmV4dENoaWxkcmVuKSB7XG4gICAgICBpZiAoIW5leHRDaGlsZHJlbiB8fCAhbmV4dENoaWxkcmVuLiRzdGFibGUpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChwcmV2UHJvcHMgPT09IG5leHRQcm9wcykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoIXByZXZQcm9wcykge1xuICAgICAgcmV0dXJuICEhbmV4dFByb3BzO1xuICAgIH1cbiAgICBpZiAoIW5leHRQcm9wcykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBoYXNQcm9wc0NoYW5nZWQocHJldlByb3BzLCBuZXh0UHJvcHMsIGVtaXRzKTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBoYXNQcm9wc0NoYW5nZWQocHJldlByb3BzLCBuZXh0UHJvcHMsIGVtaXRzT3B0aW9ucykge1xuICBjb25zdCBuZXh0S2V5cyA9IE9iamVjdC5rZXlzKG5leHRQcm9wcyk7XG4gIGlmIChuZXh0S2V5cy5sZW5ndGggIT09IE9iamVjdC5rZXlzKHByZXZQcm9wcykubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBuZXh0S2V5cy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGtleSA9IG5leHRLZXlzW2ldO1xuICAgIGlmIChuZXh0UHJvcHNba2V5XSAhPT0gcHJldlByb3BzW2tleV0gJiYgIWlzRW1pdExpc3RlbmVyKGVtaXRzT3B0aW9ucywga2V5KSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZUhPQ0hvc3RFbCh7IHZub2RlLCBwYXJlbnQgfSwgZWwpIHtcbiAgd2hpbGUgKHBhcmVudCAmJiBwYXJlbnQuc3ViVHJlZSA9PT0gdm5vZGUpIHtcbiAgICAodm5vZGUgPSBwYXJlbnQudm5vZGUpLmVsID0gZWw7XG4gICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgfVxufVxuXG5jb25zdCBpc1N1c3BlbnNlID0gKHR5cGUpID0+IHR5cGUuX19pc1N1c3BlbnNlO1xuY29uc3QgU3VzcGVuc2VJbXBsID0ge1xuICBuYW1lOiBcIlN1c3BlbnNlXCIsXG4gIC8vIEluIG9yZGVyIHRvIG1ha2UgU3VzcGVuc2UgdHJlZS1zaGFrYWJsZSwgd2UgbmVlZCB0byBhdm9pZCBpbXBvcnRpbmcgaXRcbiAgLy8gZGlyZWN0bHkgaW4gdGhlIHJlbmRlcmVyLiBUaGUgcmVuZGVyZXIgY2hlY2tzIGZvciB0aGUgX19pc1N1c3BlbnNlIGZsYWdcbiAgLy8gb24gYSB2bm9kZSdzIHR5cGUgYW5kIGNhbGxzIHRoZSBgcHJvY2Vzc2AgbWV0aG9kLCBwYXNzaW5nIGluIHJlbmRlcmVyXG4gIC8vIGludGVybmFscy5cbiAgX19pc1N1c3BlbnNlOiB0cnVlLFxuICBwcm9jZXNzKG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCwgcmVuZGVyZXJJbnRlcm5hbHMpIHtcbiAgICBpZiAobjEgPT0gbnVsbCkge1xuICAgICAgbW91bnRTdXNwZW5zZShcbiAgICAgICAgbjIsXG4gICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgYW5jaG9yLFxuICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICBpc1NWRyxcbiAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICBvcHRpbWl6ZWQsXG4gICAgICAgIHJlbmRlcmVySW50ZXJuYWxzXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXRjaFN1c3BlbnNlKFxuICAgICAgICBuMSxcbiAgICAgICAgbjIsXG4gICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgYW5jaG9yLFxuICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgIGlzU1ZHLFxuICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgIG9wdGltaXplZCxcbiAgICAgICAgcmVuZGVyZXJJbnRlcm5hbHNcbiAgICAgICk7XG4gICAgfVxuICB9LFxuICBoeWRyYXRlOiBoeWRyYXRlU3VzcGVuc2UsXG4gIGNyZWF0ZTogY3JlYXRlU3VzcGVuc2VCb3VuZGFyeSxcbiAgbm9ybWFsaXplOiBub3JtYWxpemVTdXNwZW5zZUNoaWxkcmVuXG59O1xuY29uc3QgU3VzcGVuc2UgPSBTdXNwZW5zZUltcGwgO1xuZnVuY3Rpb24gdHJpZ2dlckV2ZW50KHZub2RlLCBuYW1lKSB7XG4gIGNvbnN0IGV2ZW50TGlzdGVuZXIgPSB2bm9kZS5wcm9wcyAmJiB2bm9kZS5wcm9wc1tuYW1lXTtcbiAgaWYgKGlzRnVuY3Rpb24oZXZlbnRMaXN0ZW5lcikpIHtcbiAgICBldmVudExpc3RlbmVyKCk7XG4gIH1cbn1cbmZ1bmN0aW9uIG1vdW50U3VzcGVuc2Uodm5vZGUsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQsIHJlbmRlcmVySW50ZXJuYWxzKSB7XG4gIGNvbnN0IHtcbiAgICBwOiBwYXRjaCxcbiAgICBvOiB7IGNyZWF0ZUVsZW1lbnQgfVxuICB9ID0gcmVuZGVyZXJJbnRlcm5hbHM7XG4gIGNvbnN0IGhpZGRlbkNvbnRhaW5lciA9IGNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gIGNvbnN0IHN1c3BlbnNlID0gdm5vZGUuc3VzcGVuc2UgPSBjcmVhdGVTdXNwZW5zZUJvdW5kYXJ5KFxuICAgIHZub2RlLFxuICAgIHBhcmVudFN1c3BlbnNlLFxuICAgIHBhcmVudENvbXBvbmVudCxcbiAgICBjb250YWluZXIsXG4gICAgaGlkZGVuQ29udGFpbmVyLFxuICAgIGFuY2hvcixcbiAgICBpc1NWRyxcbiAgICBzbG90U2NvcGVJZHMsXG4gICAgb3B0aW1pemVkLFxuICAgIHJlbmRlcmVySW50ZXJuYWxzXG4gICk7XG4gIHBhdGNoKFxuICAgIG51bGwsXG4gICAgc3VzcGVuc2UucGVuZGluZ0JyYW5jaCA9IHZub2RlLnNzQ29udGVudCxcbiAgICBoaWRkZW5Db250YWluZXIsXG4gICAgbnVsbCxcbiAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgc3VzcGVuc2UsXG4gICAgaXNTVkcsXG4gICAgc2xvdFNjb3BlSWRzXG4gICk7XG4gIGlmIChzdXNwZW5zZS5kZXBzID4gMCkge1xuICAgIHRyaWdnZXJFdmVudCh2bm9kZSwgXCJvblBlbmRpbmdcIik7XG4gICAgdHJpZ2dlckV2ZW50KHZub2RlLCBcIm9uRmFsbGJhY2tcIik7XG4gICAgcGF0Y2goXG4gICAgICBudWxsLFxuICAgICAgdm5vZGUuc3NGYWxsYmFjayxcbiAgICAgIGNvbnRhaW5lcixcbiAgICAgIGFuY2hvcixcbiAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgIG51bGwsXG4gICAgICAvLyBmYWxsYmFjayB0cmVlIHdpbGwgbm90IGhhdmUgc3VzcGVuc2UgY29udGV4dFxuICAgICAgaXNTVkcsXG4gICAgICBzbG90U2NvcGVJZHNcbiAgICApO1xuICAgIHNldEFjdGl2ZUJyYW5jaChzdXNwZW5zZSwgdm5vZGUuc3NGYWxsYmFjayk7XG4gIH0gZWxzZSB7XG4gICAgc3VzcGVuc2UucmVzb2x2ZShmYWxzZSwgdHJ1ZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHBhdGNoU3VzcGVuc2UobjEsIG4yLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQsIHsgcDogcGF0Y2gsIHVtOiB1bm1vdW50LCBvOiB7IGNyZWF0ZUVsZW1lbnQgfSB9KSB7XG4gIGNvbnN0IHN1c3BlbnNlID0gbjIuc3VzcGVuc2UgPSBuMS5zdXNwZW5zZTtcbiAgc3VzcGVuc2Uudm5vZGUgPSBuMjtcbiAgbjIuZWwgPSBuMS5lbDtcbiAgY29uc3QgbmV3QnJhbmNoID0gbjIuc3NDb250ZW50O1xuICBjb25zdCBuZXdGYWxsYmFjayA9IG4yLnNzRmFsbGJhY2s7XG4gIGNvbnN0IHsgYWN0aXZlQnJhbmNoLCBwZW5kaW5nQnJhbmNoLCBpc0luRmFsbGJhY2ssIGlzSHlkcmF0aW5nIH0gPSBzdXNwZW5zZTtcbiAgaWYgKHBlbmRpbmdCcmFuY2gpIHtcbiAgICBzdXNwZW5zZS5wZW5kaW5nQnJhbmNoID0gbmV3QnJhbmNoO1xuICAgIGlmIChpc1NhbWVWTm9kZVR5cGUobmV3QnJhbmNoLCBwZW5kaW5nQnJhbmNoKSkge1xuICAgICAgcGF0Y2goXG4gICAgICAgIHBlbmRpbmdCcmFuY2gsXG4gICAgICAgIG5ld0JyYW5jaCxcbiAgICAgICAgc3VzcGVuc2UuaGlkZGVuQ29udGFpbmVyLFxuICAgICAgICBudWxsLFxuICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgIHN1c3BlbnNlLFxuICAgICAgICBpc1NWRyxcbiAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICk7XG4gICAgICBpZiAoc3VzcGVuc2UuZGVwcyA8PSAwKSB7XG4gICAgICAgIHN1c3BlbnNlLnJlc29sdmUoKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNJbkZhbGxiYWNrKSB7XG4gICAgICAgIHBhdGNoKFxuICAgICAgICAgIGFjdGl2ZUJyYW5jaCxcbiAgICAgICAgICBuZXdGYWxsYmFjayxcbiAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgYW5jaG9yLFxuICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICBudWxsLFxuICAgICAgICAgIC8vIGZhbGxiYWNrIHRyZWUgd2lsbCBub3QgaGF2ZSBzdXNwZW5zZSBjb250ZXh0XG4gICAgICAgICAgaXNTVkcsXG4gICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgIG9wdGltaXplZFxuICAgICAgICApO1xuICAgICAgICBzZXRBY3RpdmVCcmFuY2goc3VzcGVuc2UsIG5ld0ZhbGxiYWNrKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3VzcGVuc2UucGVuZGluZ0lkKys7XG4gICAgICBpZiAoaXNIeWRyYXRpbmcpIHtcbiAgICAgICAgc3VzcGVuc2UuaXNIeWRyYXRpbmcgPSBmYWxzZTtcbiAgICAgICAgc3VzcGVuc2UuYWN0aXZlQnJhbmNoID0gcGVuZGluZ0JyYW5jaDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHVubW91bnQocGVuZGluZ0JyYW5jaCwgcGFyZW50Q29tcG9uZW50LCBzdXNwZW5zZSk7XG4gICAgICB9XG4gICAgICBzdXNwZW5zZS5kZXBzID0gMDtcbiAgICAgIHN1c3BlbnNlLmVmZmVjdHMubGVuZ3RoID0gMDtcbiAgICAgIHN1c3BlbnNlLmhpZGRlbkNvbnRhaW5lciA9IGNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICBpZiAoaXNJbkZhbGxiYWNrKSB7XG4gICAgICAgIHBhdGNoKFxuICAgICAgICAgIG51bGwsXG4gICAgICAgICAgbmV3QnJhbmNoLFxuICAgICAgICAgIHN1c3BlbnNlLmhpZGRlbkNvbnRhaW5lcixcbiAgICAgICAgICBudWxsLFxuICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICBzdXNwZW5zZSxcbiAgICAgICAgICBpc1NWRyxcbiAgICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgICAgb3B0aW1pemVkXG4gICAgICAgICk7XG4gICAgICAgIGlmIChzdXNwZW5zZS5kZXBzIDw9IDApIHtcbiAgICAgICAgICBzdXNwZW5zZS5yZXNvbHZlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGF0Y2goXG4gICAgICAgICAgICBhY3RpdmVCcmFuY2gsXG4gICAgICAgICAgICBuZXdGYWxsYmFjayxcbiAgICAgICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgICAgIGFuY2hvcixcbiAgICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAvLyBmYWxsYmFjayB0cmVlIHdpbGwgbm90IGhhdmUgc3VzcGVuc2UgY29udGV4dFxuICAgICAgICAgICAgaXNTVkcsXG4gICAgICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICAgICApO1xuICAgICAgICAgIHNldEFjdGl2ZUJyYW5jaChzdXNwZW5zZSwgbmV3RmFsbGJhY2spO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGFjdGl2ZUJyYW5jaCAmJiBpc1NhbWVWTm9kZVR5cGUobmV3QnJhbmNoLCBhY3RpdmVCcmFuY2gpKSB7XG4gICAgICAgIHBhdGNoKFxuICAgICAgICAgIGFjdGl2ZUJyYW5jaCxcbiAgICAgICAgICBuZXdCcmFuY2gsXG4gICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgIGFuY2hvcixcbiAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgc3VzcGVuc2UsXG4gICAgICAgICAgaXNTVkcsXG4gICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgIG9wdGltaXplZFxuICAgICAgICApO1xuICAgICAgICBzdXNwZW5zZS5yZXNvbHZlKHRydWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGF0Y2goXG4gICAgICAgICAgbnVsbCxcbiAgICAgICAgICBuZXdCcmFuY2gsXG4gICAgICAgICAgc3VzcGVuc2UuaGlkZGVuQ29udGFpbmVyLFxuICAgICAgICAgIG51bGwsXG4gICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgIHN1c3BlbnNlLFxuICAgICAgICAgIGlzU1ZHLFxuICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKHN1c3BlbnNlLmRlcHMgPD0gMCkge1xuICAgICAgICAgIHN1c3BlbnNlLnJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoYWN0aXZlQnJhbmNoICYmIGlzU2FtZVZOb2RlVHlwZShuZXdCcmFuY2gsIGFjdGl2ZUJyYW5jaCkpIHtcbiAgICAgIHBhdGNoKFxuICAgICAgICBhY3RpdmVCcmFuY2gsXG4gICAgICAgIG5ld0JyYW5jaCxcbiAgICAgICAgY29udGFpbmVyLFxuICAgICAgICBhbmNob3IsXG4gICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgc3VzcGVuc2UsXG4gICAgICAgIGlzU1ZHLFxuICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgIG9wdGltaXplZFxuICAgICAgKTtcbiAgICAgIHNldEFjdGl2ZUJyYW5jaChzdXNwZW5zZSwgbmV3QnJhbmNoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdHJpZ2dlckV2ZW50KG4yLCBcIm9uUGVuZGluZ1wiKTtcbiAgICAgIHN1c3BlbnNlLnBlbmRpbmdCcmFuY2ggPSBuZXdCcmFuY2g7XG4gICAgICBzdXNwZW5zZS5wZW5kaW5nSWQrKztcbiAgICAgIHBhdGNoKFxuICAgICAgICBudWxsLFxuICAgICAgICBuZXdCcmFuY2gsXG4gICAgICAgIHN1c3BlbnNlLmhpZGRlbkNvbnRhaW5lcixcbiAgICAgICAgbnVsbCxcbiAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICBzdXNwZW5zZSxcbiAgICAgICAgaXNTVkcsXG4gICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgb3B0aW1pemVkXG4gICAgICApO1xuICAgICAgaWYgKHN1c3BlbnNlLmRlcHMgPD0gMCkge1xuICAgICAgICBzdXNwZW5zZS5yZXNvbHZlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCB7IHRpbWVvdXQsIHBlbmRpbmdJZCB9ID0gc3VzcGVuc2U7XG4gICAgICAgIGlmICh0aW1lb3V0ID4gMCkge1xuICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHN1c3BlbnNlLnBlbmRpbmdJZCA9PT0gcGVuZGluZ0lkKSB7XG4gICAgICAgICAgICAgIHN1c3BlbnNlLmZhbGxiYWNrKG5ld0ZhbGxiYWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCB0aW1lb3V0KTtcbiAgICAgICAgfSBlbHNlIGlmICh0aW1lb3V0ID09PSAwKSB7XG4gICAgICAgICAgc3VzcGVuc2UuZmFsbGJhY2sobmV3RmFsbGJhY2spO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5sZXQgaGFzV2FybmVkID0gZmFsc2U7XG5mdW5jdGlvbiBjcmVhdGVTdXNwZW5zZUJvdW5kYXJ5KHZub2RlLCBwYXJlbnRTdXNwZW5zZSwgcGFyZW50Q29tcG9uZW50LCBjb250YWluZXIsIGhpZGRlbkNvbnRhaW5lciwgYW5jaG9yLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQsIHJlbmRlcmVySW50ZXJuYWxzLCBpc0h5ZHJhdGluZyA9IGZhbHNlKSB7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHRydWUgJiYgIWhhc1dhcm5lZCkge1xuICAgIGhhc1dhcm5lZCA9IHRydWU7XG4gICAgY29uc29sZVtjb25zb2xlLmluZm8gPyBcImluZm9cIiA6IFwibG9nXCJdKFxuICAgICAgYDxTdXNwZW5zZT4gaXMgYW4gZXhwZXJpbWVudGFsIGZlYXR1cmUgYW5kIGl0cyBBUEkgd2lsbCBsaWtlbHkgY2hhbmdlLmBcbiAgICApO1xuICB9XG4gIGNvbnN0IHtcbiAgICBwOiBwYXRjaCxcbiAgICBtOiBtb3ZlLFxuICAgIHVtOiB1bm1vdW50LFxuICAgIG46IG5leHQsXG4gICAgbzogeyBwYXJlbnROb2RlLCByZW1vdmUgfVxuICB9ID0gcmVuZGVyZXJJbnRlcm5hbHM7XG4gIGxldCBwYXJlbnRTdXNwZW5zZUlkO1xuICBjb25zdCBpc1N1c3BlbnNpYmxlID0gaXNWTm9kZVN1c3BlbnNpYmxlKHZub2RlKTtcbiAgaWYgKGlzU3VzcGVuc2libGUpIHtcbiAgICBpZiAocGFyZW50U3VzcGVuc2UgPT0gbnVsbCA/IHZvaWQgMCA6IHBhcmVudFN1c3BlbnNlLnBlbmRpbmdCcmFuY2gpIHtcbiAgICAgIHBhcmVudFN1c3BlbnNlSWQgPSBwYXJlbnRTdXNwZW5zZS5wZW5kaW5nSWQ7XG4gICAgICBwYXJlbnRTdXNwZW5zZS5kZXBzKys7XG4gICAgfVxuICB9XG4gIGNvbnN0IHRpbWVvdXQgPSB2bm9kZS5wcm9wcyA/IHRvTnVtYmVyKHZub2RlLnByb3BzLnRpbWVvdXQpIDogdm9pZCAwO1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIGFzc2VydE51bWJlcih0aW1lb3V0LCBgU3VzcGVuc2UgdGltZW91dGApO1xuICB9XG4gIGNvbnN0IHN1c3BlbnNlID0ge1xuICAgIHZub2RlLFxuICAgIHBhcmVudDogcGFyZW50U3VzcGVuc2UsXG4gICAgcGFyZW50Q29tcG9uZW50LFxuICAgIGlzU1ZHLFxuICAgIGNvbnRhaW5lcixcbiAgICBoaWRkZW5Db250YWluZXIsXG4gICAgYW5jaG9yLFxuICAgIGRlcHM6IDAsXG4gICAgcGVuZGluZ0lkOiAwLFxuICAgIHRpbWVvdXQ6IHR5cGVvZiB0aW1lb3V0ID09PSBcIm51bWJlclwiID8gdGltZW91dCA6IC0xLFxuICAgIGFjdGl2ZUJyYW5jaDogbnVsbCxcbiAgICBwZW5kaW5nQnJhbmNoOiBudWxsLFxuICAgIGlzSW5GYWxsYmFjazogdHJ1ZSxcbiAgICBpc0h5ZHJhdGluZyxcbiAgICBpc1VubW91bnRlZDogZmFsc2UsXG4gICAgZWZmZWN0czogW10sXG4gICAgcmVzb2x2ZShyZXN1bWUgPSBmYWxzZSwgc3luYyA9IGZhbHNlKSB7XG4gICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICBpZiAoIXJlc3VtZSAmJiAhc3VzcGVuc2UucGVuZGluZ0JyYW5jaCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBzdXNwZW5zZS5yZXNvbHZlKCkgaXMgY2FsbGVkIHdpdGhvdXQgYSBwZW5kaW5nIGJyYW5jaC5gXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3VzcGVuc2UuaXNVbm1vdW50ZWQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgc3VzcGVuc2UucmVzb2x2ZSgpIGlzIGNhbGxlZCBvbiBhbiBhbHJlYWR5IHVubW91bnRlZCBzdXNwZW5zZSBib3VuZGFyeS5gXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3Qge1xuICAgICAgICB2bm9kZTogdm5vZGUyLFxuICAgICAgICBhY3RpdmVCcmFuY2gsXG4gICAgICAgIHBlbmRpbmdCcmFuY2gsXG4gICAgICAgIHBlbmRpbmdJZCxcbiAgICAgICAgZWZmZWN0cyxcbiAgICAgICAgcGFyZW50Q29tcG9uZW50OiBwYXJlbnRDb21wb25lbnQyLFxuICAgICAgICBjb250YWluZXI6IGNvbnRhaW5lcjJcbiAgICAgIH0gPSBzdXNwZW5zZTtcbiAgICAgIGlmIChzdXNwZW5zZS5pc0h5ZHJhdGluZykge1xuICAgICAgICBzdXNwZW5zZS5pc0h5ZHJhdGluZyA9IGZhbHNlO1xuICAgICAgfSBlbHNlIGlmICghcmVzdW1lKSB7XG4gICAgICAgIGNvbnN0IGRlbGF5RW50ZXIgPSBhY3RpdmVCcmFuY2ggJiYgcGVuZGluZ0JyYW5jaC50cmFuc2l0aW9uICYmIHBlbmRpbmdCcmFuY2gudHJhbnNpdGlvbi5tb2RlID09PSBcIm91dC1pblwiO1xuICAgICAgICBpZiAoZGVsYXlFbnRlcikge1xuICAgICAgICAgIGFjdGl2ZUJyYW5jaC50cmFuc2l0aW9uLmFmdGVyTGVhdmUgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAocGVuZGluZ0lkID09PSBzdXNwZW5zZS5wZW5kaW5nSWQpIHtcbiAgICAgICAgICAgICAgbW92ZShwZW5kaW5nQnJhbmNoLCBjb250YWluZXIyLCBhbmNob3IyLCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGxldCB7IGFuY2hvcjogYW5jaG9yMiB9ID0gc3VzcGVuc2U7XG4gICAgICAgIGlmIChhY3RpdmVCcmFuY2gpIHtcbiAgICAgICAgICBhbmNob3IyID0gbmV4dChhY3RpdmVCcmFuY2gpO1xuICAgICAgICAgIHVubW91bnQoYWN0aXZlQnJhbmNoLCBwYXJlbnRDb21wb25lbnQyLCBzdXNwZW5zZSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkZWxheUVudGVyKSB7XG4gICAgICAgICAgbW92ZShwZW5kaW5nQnJhbmNoLCBjb250YWluZXIyLCBhbmNob3IyLCAwKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc2V0QWN0aXZlQnJhbmNoKHN1c3BlbnNlLCBwZW5kaW5nQnJhbmNoKTtcbiAgICAgIHN1c3BlbnNlLnBlbmRpbmdCcmFuY2ggPSBudWxsO1xuICAgICAgc3VzcGVuc2UuaXNJbkZhbGxiYWNrID0gZmFsc2U7XG4gICAgICBsZXQgcGFyZW50ID0gc3VzcGVuc2UucGFyZW50O1xuICAgICAgbGV0IGhhc1VucmVzb2x2ZWRBbmNlc3RvciA9IGZhbHNlO1xuICAgICAgd2hpbGUgKHBhcmVudCkge1xuICAgICAgICBpZiAocGFyZW50LnBlbmRpbmdCcmFuY2gpIHtcbiAgICAgICAgICBwYXJlbnQuZWZmZWN0cy5wdXNoKC4uLmVmZmVjdHMpO1xuICAgICAgICAgIGhhc1VucmVzb2x2ZWRBbmNlc3RvciA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgICAgIH1cbiAgICAgIGlmICghaGFzVW5yZXNvbHZlZEFuY2VzdG9yKSB7XG4gICAgICAgIHF1ZXVlUG9zdEZsdXNoQ2IoZWZmZWN0cyk7XG4gICAgICB9XG4gICAgICBzdXNwZW5zZS5lZmZlY3RzID0gW107XG4gICAgICBpZiAoaXNTdXNwZW5zaWJsZSkge1xuICAgICAgICBpZiAocGFyZW50U3VzcGVuc2UgJiYgcGFyZW50U3VzcGVuc2UucGVuZGluZ0JyYW5jaCAmJiBwYXJlbnRTdXNwZW5zZUlkID09PSBwYXJlbnRTdXNwZW5zZS5wZW5kaW5nSWQpIHtcbiAgICAgICAgICBwYXJlbnRTdXNwZW5zZS5kZXBzLS07XG4gICAgICAgICAgaWYgKHBhcmVudFN1c3BlbnNlLmRlcHMgPT09IDAgJiYgIXN5bmMpIHtcbiAgICAgICAgICAgIHBhcmVudFN1c3BlbnNlLnJlc29sdmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRyaWdnZXJFdmVudCh2bm9kZTIsIFwib25SZXNvbHZlXCIpO1xuICAgIH0sXG4gICAgZmFsbGJhY2soZmFsbGJhY2tWTm9kZSkge1xuICAgICAgaWYgKCFzdXNwZW5zZS5wZW5kaW5nQnJhbmNoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHsgdm5vZGU6IHZub2RlMiwgYWN0aXZlQnJhbmNoLCBwYXJlbnRDb21wb25lbnQ6IHBhcmVudENvbXBvbmVudDIsIGNvbnRhaW5lcjogY29udGFpbmVyMiwgaXNTVkc6IGlzU1ZHMiB9ID0gc3VzcGVuc2U7XG4gICAgICB0cmlnZ2VyRXZlbnQodm5vZGUyLCBcIm9uRmFsbGJhY2tcIik7XG4gICAgICBjb25zdCBhbmNob3IyID0gbmV4dChhY3RpdmVCcmFuY2gpO1xuICAgICAgY29uc3QgbW91bnRGYWxsYmFjayA9ICgpID0+IHtcbiAgICAgICAgaWYgKCFzdXNwZW5zZS5pc0luRmFsbGJhY2spIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcGF0Y2goXG4gICAgICAgICAgbnVsbCxcbiAgICAgICAgICBmYWxsYmFja1ZOb2RlLFxuICAgICAgICAgIGNvbnRhaW5lcjIsXG4gICAgICAgICAgYW5jaG9yMixcbiAgICAgICAgICBwYXJlbnRDb21wb25lbnQyLFxuICAgICAgICAgIG51bGwsXG4gICAgICAgICAgLy8gZmFsbGJhY2sgdHJlZSB3aWxsIG5vdCBoYXZlIHN1c3BlbnNlIGNvbnRleHRcbiAgICAgICAgICBpc1NWRzIsXG4gICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgIG9wdGltaXplZFxuICAgICAgICApO1xuICAgICAgICBzZXRBY3RpdmVCcmFuY2goc3VzcGVuc2UsIGZhbGxiYWNrVk5vZGUpO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGRlbGF5RW50ZXIgPSBmYWxsYmFja1ZOb2RlLnRyYW5zaXRpb24gJiYgZmFsbGJhY2tWTm9kZS50cmFuc2l0aW9uLm1vZGUgPT09IFwib3V0LWluXCI7XG4gICAgICBpZiAoZGVsYXlFbnRlcikge1xuICAgICAgICBhY3RpdmVCcmFuY2gudHJhbnNpdGlvbi5hZnRlckxlYXZlID0gbW91bnRGYWxsYmFjaztcbiAgICAgIH1cbiAgICAgIHN1c3BlbnNlLmlzSW5GYWxsYmFjayA9IHRydWU7XG4gICAgICB1bm1vdW50KFxuICAgICAgICBhY3RpdmVCcmFuY2gsXG4gICAgICAgIHBhcmVudENvbXBvbmVudDIsXG4gICAgICAgIG51bGwsXG4gICAgICAgIC8vIG5vIHN1c3BlbnNlIHNvIHVubW91bnQgaG9va3MgZmlyZSBub3dcbiAgICAgICAgdHJ1ZVxuICAgICAgICAvLyBzaG91bGRSZW1vdmVcbiAgICAgICk7XG4gICAgICBpZiAoIWRlbGF5RW50ZXIpIHtcbiAgICAgICAgbW91bnRGYWxsYmFjaygpO1xuICAgICAgfVxuICAgIH0sXG4gICAgbW92ZShjb250YWluZXIyLCBhbmNob3IyLCB0eXBlKSB7XG4gICAgICBzdXNwZW5zZS5hY3RpdmVCcmFuY2ggJiYgbW92ZShzdXNwZW5zZS5hY3RpdmVCcmFuY2gsIGNvbnRhaW5lcjIsIGFuY2hvcjIsIHR5cGUpO1xuICAgICAgc3VzcGVuc2UuY29udGFpbmVyID0gY29udGFpbmVyMjtcbiAgICB9LFxuICAgIG5leHQoKSB7XG4gICAgICByZXR1cm4gc3VzcGVuc2UuYWN0aXZlQnJhbmNoICYmIG5leHQoc3VzcGVuc2UuYWN0aXZlQnJhbmNoKTtcbiAgICB9LFxuICAgIHJlZ2lzdGVyRGVwKGluc3RhbmNlLCBzZXR1cFJlbmRlckVmZmVjdCkge1xuICAgICAgY29uc3QgaXNJblBlbmRpbmdTdXNwZW5zZSA9ICEhc3VzcGVuc2UucGVuZGluZ0JyYW5jaDtcbiAgICAgIGlmIChpc0luUGVuZGluZ1N1c3BlbnNlKSB7XG4gICAgICAgIHN1c3BlbnNlLmRlcHMrKztcbiAgICAgIH1cbiAgICAgIGNvbnN0IGh5ZHJhdGVkRWwgPSBpbnN0YW5jZS52bm9kZS5lbDtcbiAgICAgIGluc3RhbmNlLmFzeW5jRGVwLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgaGFuZGxlRXJyb3IoZXJyLCBpbnN0YW5jZSwgMCk7XG4gICAgICB9KS50aGVuKChhc3luY1NldHVwUmVzdWx0KSA9PiB7XG4gICAgICAgIGlmIChpbnN0YW5jZS5pc1VubW91bnRlZCB8fCBzdXNwZW5zZS5pc1VubW91bnRlZCB8fCBzdXNwZW5zZS5wZW5kaW5nSWQgIT09IGluc3RhbmNlLnN1c3BlbnNlSWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaW5zdGFuY2UuYXN5bmNSZXNvbHZlZCA9IHRydWU7XG4gICAgICAgIGNvbnN0IHsgdm5vZGU6IHZub2RlMiB9ID0gaW5zdGFuY2U7XG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgcHVzaFdhcm5pbmdDb250ZXh0KHZub2RlMik7XG4gICAgICAgIH1cbiAgICAgICAgaGFuZGxlU2V0dXBSZXN1bHQoaW5zdGFuY2UsIGFzeW5jU2V0dXBSZXN1bHQsIGZhbHNlKTtcbiAgICAgICAgaWYgKGh5ZHJhdGVkRWwpIHtcbiAgICAgICAgICB2bm9kZTIuZWwgPSBoeWRyYXRlZEVsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBsYWNlaG9sZGVyID0gIWh5ZHJhdGVkRWwgJiYgaW5zdGFuY2Uuc3ViVHJlZS5lbDtcbiAgICAgICAgc2V0dXBSZW5kZXJFZmZlY3QoXG4gICAgICAgICAgaW5zdGFuY2UsXG4gICAgICAgICAgdm5vZGUyLFxuICAgICAgICAgIC8vIGNvbXBvbmVudCBtYXkgaGF2ZSBiZWVuIG1vdmVkIGJlZm9yZSByZXNvbHZlLlxuICAgICAgICAgIC8vIGlmIHRoaXMgaXMgbm90IGEgaHlkcmF0aW9uLCBpbnN0YW5jZS5zdWJUcmVlIHdpbGwgYmUgdGhlIGNvbW1lbnRcbiAgICAgICAgICAvLyBwbGFjZWhvbGRlci5cbiAgICAgICAgICBwYXJlbnROb2RlKGh5ZHJhdGVkRWwgfHwgaW5zdGFuY2Uuc3ViVHJlZS5lbCksXG4gICAgICAgICAgLy8gYW5jaG9yIHdpbGwgbm90IGJlIHVzZWQgaWYgdGhpcyBpcyBoeWRyYXRpb24sIHNvIG9ubHkgbmVlZCB0b1xuICAgICAgICAgIC8vIGNvbnNpZGVyIHRoZSBjb21tZW50IHBsYWNlaG9sZGVyIGNhc2UuXG4gICAgICAgICAgaHlkcmF0ZWRFbCA/IG51bGwgOiBuZXh0KGluc3RhbmNlLnN1YlRyZWUpLFxuICAgICAgICAgIHN1c3BlbnNlLFxuICAgICAgICAgIGlzU1ZHLFxuICAgICAgICAgIG9wdGltaXplZFxuICAgICAgICApO1xuICAgICAgICBpZiAocGxhY2Vob2xkZXIpIHtcbiAgICAgICAgICByZW1vdmUocGxhY2Vob2xkZXIpO1xuICAgICAgICB9XG4gICAgICAgIHVwZGF0ZUhPQ0hvc3RFbChpbnN0YW5jZSwgdm5vZGUyLmVsKTtcbiAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICBwb3BXYXJuaW5nQ29udGV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0luUGVuZGluZ1N1c3BlbnNlICYmIC0tc3VzcGVuc2UuZGVwcyA9PT0gMCkge1xuICAgICAgICAgIHN1c3BlbnNlLnJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSxcbiAgICB1bm1vdW50KHBhcmVudFN1c3BlbnNlMiwgZG9SZW1vdmUpIHtcbiAgICAgIHN1c3BlbnNlLmlzVW5tb3VudGVkID0gdHJ1ZTtcbiAgICAgIGlmIChzdXNwZW5zZS5hY3RpdmVCcmFuY2gpIHtcbiAgICAgICAgdW5tb3VudChcbiAgICAgICAgICBzdXNwZW5zZS5hY3RpdmVCcmFuY2gsXG4gICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgIHBhcmVudFN1c3BlbnNlMixcbiAgICAgICAgICBkb1JlbW92ZVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKHN1c3BlbnNlLnBlbmRpbmdCcmFuY2gpIHtcbiAgICAgICAgdW5tb3VudChcbiAgICAgICAgICBzdXNwZW5zZS5wZW5kaW5nQnJhbmNoLFxuICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICBwYXJlbnRTdXNwZW5zZTIsXG4gICAgICAgICAgZG9SZW1vdmVcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIHJldHVybiBzdXNwZW5zZTtcbn1cbmZ1bmN0aW9uIGh5ZHJhdGVTdXNwZW5zZShub2RlLCB2bm9kZSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkLCByZW5kZXJlckludGVybmFscywgaHlkcmF0ZU5vZGUpIHtcbiAgY29uc3Qgc3VzcGVuc2UgPSB2bm9kZS5zdXNwZW5zZSA9IGNyZWF0ZVN1c3BlbnNlQm91bmRhcnkoXG4gICAgdm5vZGUsXG4gICAgcGFyZW50U3VzcGVuc2UsXG4gICAgcGFyZW50Q29tcG9uZW50LFxuICAgIG5vZGUucGFyZW50Tm9kZSxcbiAgICBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLFxuICAgIG51bGwsXG4gICAgaXNTVkcsXG4gICAgc2xvdFNjb3BlSWRzLFxuICAgIG9wdGltaXplZCxcbiAgICByZW5kZXJlckludGVybmFscyxcbiAgICB0cnVlXG4gICAgLyogaHlkcmF0aW5nICovXG4gICk7XG4gIGNvbnN0IHJlc3VsdCA9IGh5ZHJhdGVOb2RlKFxuICAgIG5vZGUsXG4gICAgc3VzcGVuc2UucGVuZGluZ0JyYW5jaCA9IHZub2RlLnNzQ29udGVudCxcbiAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgc3VzcGVuc2UsXG4gICAgc2xvdFNjb3BlSWRzLFxuICAgIG9wdGltaXplZFxuICApO1xuICBpZiAoc3VzcGVuc2UuZGVwcyA9PT0gMCkge1xuICAgIHN1c3BlbnNlLnJlc29sdmUoZmFsc2UsIHRydWUpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBub3JtYWxpemVTdXNwZW5zZUNoaWxkcmVuKHZub2RlKSB7XG4gIGNvbnN0IHsgc2hhcGVGbGFnLCBjaGlsZHJlbiB9ID0gdm5vZGU7XG4gIGNvbnN0IGlzU2xvdENoaWxkcmVuID0gc2hhcGVGbGFnICYgMzI7XG4gIHZub2RlLnNzQ29udGVudCA9IG5vcm1hbGl6ZVN1c3BlbnNlU2xvdChcbiAgICBpc1Nsb3RDaGlsZHJlbiA/IGNoaWxkcmVuLmRlZmF1bHQgOiBjaGlsZHJlblxuICApO1xuICB2bm9kZS5zc0ZhbGxiYWNrID0gaXNTbG90Q2hpbGRyZW4gPyBub3JtYWxpemVTdXNwZW5zZVNsb3QoY2hpbGRyZW4uZmFsbGJhY2spIDogY3JlYXRlVk5vZGUoQ29tbWVudCk7XG59XG5mdW5jdGlvbiBub3JtYWxpemVTdXNwZW5zZVNsb3Qocykge1xuICBsZXQgYmxvY2s7XG4gIGlmIChpc0Z1bmN0aW9uKHMpKSB7XG4gICAgY29uc3QgdHJhY2tCbG9jayA9IGlzQmxvY2tUcmVlRW5hYmxlZCAmJiBzLl9jO1xuICAgIGlmICh0cmFja0Jsb2NrKSB7XG4gICAgICBzLl9kID0gZmFsc2U7XG4gICAgICBvcGVuQmxvY2soKTtcbiAgICB9XG4gICAgcyA9IHMoKTtcbiAgICBpZiAodHJhY2tCbG9jaykge1xuICAgICAgcy5fZCA9IHRydWU7XG4gICAgICBibG9jayA9IGN1cnJlbnRCbG9jaztcbiAgICAgIGNsb3NlQmxvY2soKTtcbiAgICB9XG4gIH1cbiAgaWYgKGlzQXJyYXkocykpIHtcbiAgICBjb25zdCBzaW5nbGVDaGlsZCA9IGZpbHRlclNpbmdsZVJvb3Qocyk7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgIXNpbmdsZUNoaWxkKSB7XG4gICAgICB3YXJuKGA8U3VzcGVuc2U+IHNsb3RzIGV4cGVjdCBhIHNpbmdsZSByb290IG5vZGUuYCk7XG4gICAgfVxuICAgIHMgPSBzaW5nbGVDaGlsZDtcbiAgfVxuICBzID0gbm9ybWFsaXplVk5vZGUocyk7XG4gIGlmIChibG9jayAmJiAhcy5keW5hbWljQ2hpbGRyZW4pIHtcbiAgICBzLmR5bmFtaWNDaGlsZHJlbiA9IGJsb2NrLmZpbHRlcigoYykgPT4gYyAhPT0gcyk7XG4gIH1cbiAgcmV0dXJuIHM7XG59XG5mdW5jdGlvbiBxdWV1ZUVmZmVjdFdpdGhTdXNwZW5zZShmbiwgc3VzcGVuc2UpIHtcbiAgaWYgKHN1c3BlbnNlICYmIHN1c3BlbnNlLnBlbmRpbmdCcmFuY2gpIHtcbiAgICBpZiAoaXNBcnJheShmbikpIHtcbiAgICAgIHN1c3BlbnNlLmVmZmVjdHMucHVzaCguLi5mbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN1c3BlbnNlLmVmZmVjdHMucHVzaChmbik7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHF1ZXVlUG9zdEZsdXNoQ2IoZm4pO1xuICB9XG59XG5mdW5jdGlvbiBzZXRBY3RpdmVCcmFuY2goc3VzcGVuc2UsIGJyYW5jaCkge1xuICBzdXNwZW5zZS5hY3RpdmVCcmFuY2ggPSBicmFuY2g7XG4gIGNvbnN0IHsgdm5vZGUsIHBhcmVudENvbXBvbmVudCB9ID0gc3VzcGVuc2U7XG4gIGNvbnN0IGVsID0gdm5vZGUuZWwgPSBicmFuY2guZWw7XG4gIGlmIChwYXJlbnRDb21wb25lbnQgJiYgcGFyZW50Q29tcG9uZW50LnN1YlRyZWUgPT09IHZub2RlKSB7XG4gICAgcGFyZW50Q29tcG9uZW50LnZub2RlLmVsID0gZWw7XG4gICAgdXBkYXRlSE9DSG9zdEVsKHBhcmVudENvbXBvbmVudCwgZWwpO1xuICB9XG59XG5mdW5jdGlvbiBpc1ZOb2RlU3VzcGVuc2libGUodm5vZGUpIHtcbiAgdmFyIF9hO1xuICByZXR1cm4gKChfYSA9IHZub2RlLnByb3BzKSA9PSBudWxsID8gdm9pZCAwIDogX2Euc3VzcGVuc2libGUpICE9IG51bGwgJiYgdm5vZGUucHJvcHMuc3VzcGVuc2libGUgIT09IGZhbHNlO1xufVxuXG5mdW5jdGlvbiB3YXRjaEVmZmVjdChlZmZlY3QsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIGRvV2F0Y2goZWZmZWN0LCBudWxsLCBvcHRpb25zKTtcbn1cbmZ1bmN0aW9uIHdhdGNoUG9zdEVmZmVjdChlZmZlY3QsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIGRvV2F0Y2goXG4gICAgZWZmZWN0LFxuICAgIG51bGwsXG4gICAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IGV4dGVuZCh7fSwgb3B0aW9ucywgeyBmbHVzaDogXCJwb3N0XCIgfSkgOiB7IGZsdXNoOiBcInBvc3RcIiB9XG4gICk7XG59XG5mdW5jdGlvbiB3YXRjaFN5bmNFZmZlY3QoZWZmZWN0LCBvcHRpb25zKSB7XG4gIHJldHVybiBkb1dhdGNoKFxuICAgIGVmZmVjdCxcbiAgICBudWxsLFxuICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyBleHRlbmQoe30sIG9wdGlvbnMsIHsgZmx1c2g6IFwic3luY1wiIH0pIDogeyBmbHVzaDogXCJzeW5jXCIgfVxuICApO1xufVxuY29uc3QgSU5JVElBTF9XQVRDSEVSX1ZBTFVFID0ge307XG5mdW5jdGlvbiB3YXRjaChzb3VyY2UsIGNiLCBvcHRpb25zKSB7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICFpc0Z1bmN0aW9uKGNiKSkge1xuICAgIHdhcm4oXG4gICAgICBgXFxgd2F0Y2goZm4sIG9wdGlvbnM/KVxcYCBzaWduYXR1cmUgaGFzIGJlZW4gbW92ZWQgdG8gYSBzZXBhcmF0ZSBBUEkuIFVzZSBcXGB3YXRjaEVmZmVjdChmbiwgb3B0aW9ucz8pXFxgIGluc3RlYWQuIFxcYHdhdGNoXFxgIG5vdyBvbmx5IHN1cHBvcnRzIFxcYHdhdGNoKHNvdXJjZSwgY2IsIG9wdGlvbnM/KSBzaWduYXR1cmUuYFxuICAgICk7XG4gIH1cbiAgcmV0dXJuIGRvV2F0Y2goc291cmNlLCBjYiwgb3B0aW9ucyk7XG59XG5mdW5jdGlvbiBkb1dhdGNoKHNvdXJjZSwgY2IsIHsgaW1tZWRpYXRlLCBkZWVwLCBmbHVzaCwgb25UcmFjaywgb25UcmlnZ2VyIH0gPSBFTVBUWV9PQkopIHtcbiAgdmFyIF9hO1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhY2IpIHtcbiAgICBpZiAoaW1tZWRpYXRlICE9PSB2b2lkIDApIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIGB3YXRjaCgpIFwiaW1tZWRpYXRlXCIgb3B0aW9uIGlzIG9ubHkgcmVzcGVjdGVkIHdoZW4gdXNpbmcgdGhlIHdhdGNoKHNvdXJjZSwgY2FsbGJhY2ssIG9wdGlvbnM/KSBzaWduYXR1cmUuYFxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKGRlZXAgIT09IHZvaWQgMCkge1xuICAgICAgd2FybihcbiAgICAgICAgYHdhdGNoKCkgXCJkZWVwXCIgb3B0aW9uIGlzIG9ubHkgcmVzcGVjdGVkIHdoZW4gdXNpbmcgdGhlIHdhdGNoKHNvdXJjZSwgY2FsbGJhY2ssIG9wdGlvbnM/KSBzaWduYXR1cmUuYFxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgY29uc3Qgd2FybkludmFsaWRTb3VyY2UgPSAocykgPT4ge1xuICAgIHdhcm4oXG4gICAgICBgSW52YWxpZCB3YXRjaCBzb3VyY2U6IGAsXG4gICAgICBzLFxuICAgICAgYEEgd2F0Y2ggc291cmNlIGNhbiBvbmx5IGJlIGEgZ2V0dGVyL2VmZmVjdCBmdW5jdGlvbiwgYSByZWYsIGEgcmVhY3RpdmUgb2JqZWN0LCBvciBhbiBhcnJheSBvZiB0aGVzZSB0eXBlcy5gXG4gICAgKTtcbiAgfTtcbiAgY29uc3QgaW5zdGFuY2UgPSBnZXRDdXJyZW50U2NvcGUoKSA9PT0gKChfYSA9IGN1cnJlbnRJbnN0YW5jZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnNjb3BlKSA/IGN1cnJlbnRJbnN0YW5jZSA6IG51bGw7XG4gIGxldCBnZXR0ZXI7XG4gIGxldCBmb3JjZVRyaWdnZXIgPSBmYWxzZTtcbiAgbGV0IGlzTXVsdGlTb3VyY2UgPSBmYWxzZTtcbiAgaWYgKGlzUmVmKHNvdXJjZSkpIHtcbiAgICBnZXR0ZXIgPSAoKSA9PiBzb3VyY2UudmFsdWU7XG4gICAgZm9yY2VUcmlnZ2VyID0gaXNTaGFsbG93JDEoc291cmNlKTtcbiAgfSBlbHNlIGlmIChpc1JlYWN0aXZlKHNvdXJjZSkpIHtcbiAgICBnZXR0ZXIgPSAoKSA9PiBzb3VyY2U7XG4gICAgZGVlcCA9IHRydWU7XG4gIH0gZWxzZSBpZiAoaXNBcnJheShzb3VyY2UpKSB7XG4gICAgaXNNdWx0aVNvdXJjZSA9IHRydWU7XG4gICAgZm9yY2VUcmlnZ2VyID0gc291cmNlLnNvbWUoKHMpID0+IGlzUmVhY3RpdmUocykgfHwgaXNTaGFsbG93JDEocykpO1xuICAgIGdldHRlciA9ICgpID0+IHNvdXJjZS5tYXAoKHMpID0+IHtcbiAgICAgIGlmIChpc1JlZihzKSkge1xuICAgICAgICByZXR1cm4gcy52YWx1ZTtcbiAgICAgIH0gZWxzZSBpZiAoaXNSZWFjdGl2ZShzKSkge1xuICAgICAgICByZXR1cm4gdHJhdmVyc2Uocyk7XG4gICAgICB9IGVsc2UgaWYgKGlzRnVuY3Rpb24ocykpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxXaXRoRXJyb3JIYW5kbGluZyhzLCBpbnN0YW5jZSwgMik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHdhcm5JbnZhbGlkU291cmNlKHMpO1xuICAgICAgfVxuICAgIH0pO1xuICB9IGVsc2UgaWYgKGlzRnVuY3Rpb24oc291cmNlKSkge1xuICAgIGlmIChjYikge1xuICAgICAgZ2V0dGVyID0gKCkgPT4gY2FsbFdpdGhFcnJvckhhbmRsaW5nKHNvdXJjZSwgaW5zdGFuY2UsIDIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBnZXR0ZXIgPSAoKSA9PiB7XG4gICAgICAgIGlmIChpbnN0YW5jZSAmJiBpbnN0YW5jZS5pc1VubW91bnRlZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2xlYW51cCkge1xuICAgICAgICAgIGNsZWFudXAoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2FsbFdpdGhBc3luY0Vycm9ySGFuZGxpbmcoXG4gICAgICAgICAgc291cmNlLFxuICAgICAgICAgIGluc3RhbmNlLFxuICAgICAgICAgIDMsXG4gICAgICAgICAgW29uQ2xlYW51cF1cbiAgICAgICAgKTtcbiAgICAgIH07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGdldHRlciA9IE5PT1A7XG4gICAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiB3YXJuSW52YWxpZFNvdXJjZShzb3VyY2UpO1xuICB9XG4gIGlmIChjYiAmJiBkZWVwKSB7XG4gICAgY29uc3QgYmFzZUdldHRlciA9IGdldHRlcjtcbiAgICBnZXR0ZXIgPSAoKSA9PiB0cmF2ZXJzZShiYXNlR2V0dGVyKCkpO1xuICB9XG4gIGxldCBjbGVhbnVwO1xuICBsZXQgb25DbGVhbnVwID0gKGZuKSA9PiB7XG4gICAgY2xlYW51cCA9IGVmZmVjdC5vblN0b3AgPSAoKSA9PiB7XG4gICAgICBjYWxsV2l0aEVycm9ySGFuZGxpbmcoZm4sIGluc3RhbmNlLCA0KTtcbiAgICB9O1xuICB9O1xuICBsZXQgc3NyQ2xlYW51cDtcbiAgaWYgKGlzSW5TU1JDb21wb25lbnRTZXR1cCkge1xuICAgIG9uQ2xlYW51cCA9IE5PT1A7XG4gICAgaWYgKCFjYikge1xuICAgICAgZ2V0dGVyKCk7XG4gICAgfSBlbHNlIGlmIChpbW1lZGlhdGUpIHtcbiAgICAgIGNhbGxXaXRoQXN5bmNFcnJvckhhbmRsaW5nKGNiLCBpbnN0YW5jZSwgMywgW1xuICAgICAgICBnZXR0ZXIoKSxcbiAgICAgICAgaXNNdWx0aVNvdXJjZSA/IFtdIDogdm9pZCAwLFxuICAgICAgICBvbkNsZWFudXBcbiAgICAgIF0pO1xuICAgIH1cbiAgICBpZiAoZmx1c2ggPT09IFwic3luY1wiKSB7XG4gICAgICBjb25zdCBjdHggPSB1c2VTU1JDb250ZXh0KCk7XG4gICAgICBzc3JDbGVhbnVwID0gY3R4Ll9fd2F0Y2hlckhhbmRsZXMgfHwgKGN0eC5fX3dhdGNoZXJIYW5kbGVzID0gW10pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gTk9PUDtcbiAgICB9XG4gIH1cbiAgbGV0IG9sZFZhbHVlID0gaXNNdWx0aVNvdXJjZSA/IG5ldyBBcnJheShzb3VyY2UubGVuZ3RoKS5maWxsKElOSVRJQUxfV0FUQ0hFUl9WQUxVRSkgOiBJTklUSUFMX1dBVENIRVJfVkFMVUU7XG4gIGNvbnN0IGpvYiA9ICgpID0+IHtcbiAgICBpZiAoIWVmZmVjdC5hY3RpdmUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGNiKSB7XG4gICAgICBjb25zdCBuZXdWYWx1ZSA9IGVmZmVjdC5ydW4oKTtcbiAgICAgIGlmIChkZWVwIHx8IGZvcmNlVHJpZ2dlciB8fCAoaXNNdWx0aVNvdXJjZSA/IG5ld1ZhbHVlLnNvbWUoXG4gICAgICAgICh2LCBpKSA9PiBoYXNDaGFuZ2VkKHYsIG9sZFZhbHVlW2ldKVxuICAgICAgKSA6IGhhc0NoYW5nZWQobmV3VmFsdWUsIG9sZFZhbHVlKSkgfHwgZmFsc2UpIHtcbiAgICAgICAgaWYgKGNsZWFudXApIHtcbiAgICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgIH1cbiAgICAgICAgY2FsbFdpdGhBc3luY0Vycm9ySGFuZGxpbmcoY2IsIGluc3RhbmNlLCAzLCBbXG4gICAgICAgICAgbmV3VmFsdWUsXG4gICAgICAgICAgLy8gcGFzcyB1bmRlZmluZWQgYXMgdGhlIG9sZCB2YWx1ZSB3aGVuIGl0J3MgY2hhbmdlZCBmb3IgdGhlIGZpcnN0IHRpbWVcbiAgICAgICAgICBvbGRWYWx1ZSA9PT0gSU5JVElBTF9XQVRDSEVSX1ZBTFVFID8gdm9pZCAwIDogaXNNdWx0aVNvdXJjZSAmJiBvbGRWYWx1ZVswXSA9PT0gSU5JVElBTF9XQVRDSEVSX1ZBTFVFID8gW10gOiBvbGRWYWx1ZSxcbiAgICAgICAgICBvbkNsZWFudXBcbiAgICAgICAgXSk7XG4gICAgICAgIG9sZFZhbHVlID0gbmV3VmFsdWU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGVmZmVjdC5ydW4oKTtcbiAgICB9XG4gIH07XG4gIGpvYi5hbGxvd1JlY3Vyc2UgPSAhIWNiO1xuICBsZXQgc2NoZWR1bGVyO1xuICBpZiAoZmx1c2ggPT09IFwic3luY1wiKSB7XG4gICAgc2NoZWR1bGVyID0gam9iO1xuICB9IGVsc2UgaWYgKGZsdXNoID09PSBcInBvc3RcIikge1xuICAgIHNjaGVkdWxlciA9ICgpID0+IHF1ZXVlUG9zdFJlbmRlckVmZmVjdChqb2IsIGluc3RhbmNlICYmIGluc3RhbmNlLnN1c3BlbnNlKTtcbiAgfSBlbHNlIHtcbiAgICBqb2IucHJlID0gdHJ1ZTtcbiAgICBpZiAoaW5zdGFuY2UpXG4gICAgICBqb2IuaWQgPSBpbnN0YW5jZS51aWQ7XG4gICAgc2NoZWR1bGVyID0gKCkgPT4gcXVldWVKb2Ioam9iKTtcbiAgfVxuICBjb25zdCBlZmZlY3QgPSBuZXcgUmVhY3RpdmVFZmZlY3QoZ2V0dGVyLCBzY2hlZHVsZXIpO1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIGVmZmVjdC5vblRyYWNrID0gb25UcmFjaztcbiAgICBlZmZlY3Qub25UcmlnZ2VyID0gb25UcmlnZ2VyO1xuICB9XG4gIGlmIChjYikge1xuICAgIGlmIChpbW1lZGlhdGUpIHtcbiAgICAgIGpvYigpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvbGRWYWx1ZSA9IGVmZmVjdC5ydW4oKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZmx1c2ggPT09IFwicG9zdFwiKSB7XG4gICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KFxuICAgICAgZWZmZWN0LnJ1bi5iaW5kKGVmZmVjdCksXG4gICAgICBpbnN0YW5jZSAmJiBpbnN0YW5jZS5zdXNwZW5zZVxuICAgICk7XG4gIH0gZWxzZSB7XG4gICAgZWZmZWN0LnJ1bigpO1xuICB9XG4gIGNvbnN0IHVud2F0Y2ggPSAoKSA9PiB7XG4gICAgZWZmZWN0LnN0b3AoKTtcbiAgICBpZiAoaW5zdGFuY2UgJiYgaW5zdGFuY2Uuc2NvcGUpIHtcbiAgICAgIHJlbW92ZShpbnN0YW5jZS5zY29wZS5lZmZlY3RzLCBlZmZlY3QpO1xuICAgIH1cbiAgfTtcbiAgaWYgKHNzckNsZWFudXApXG4gICAgc3NyQ2xlYW51cC5wdXNoKHVud2F0Y2gpO1xuICByZXR1cm4gdW53YXRjaDtcbn1cbmZ1bmN0aW9uIGluc3RhbmNlV2F0Y2goc291cmNlLCB2YWx1ZSwgb3B0aW9ucykge1xuICBjb25zdCBwdWJsaWNUaGlzID0gdGhpcy5wcm94eTtcbiAgY29uc3QgZ2V0dGVyID0gaXNTdHJpbmcoc291cmNlKSA/IHNvdXJjZS5pbmNsdWRlcyhcIi5cIikgPyBjcmVhdGVQYXRoR2V0dGVyKHB1YmxpY1RoaXMsIHNvdXJjZSkgOiAoKSA9PiBwdWJsaWNUaGlzW3NvdXJjZV0gOiBzb3VyY2UuYmluZChwdWJsaWNUaGlzLCBwdWJsaWNUaGlzKTtcbiAgbGV0IGNiO1xuICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICBjYiA9IHZhbHVlO1xuICB9IGVsc2Uge1xuICAgIGNiID0gdmFsdWUuaGFuZGxlcjtcbiAgICBvcHRpb25zID0gdmFsdWU7XG4gIH1cbiAgY29uc3QgY3VyID0gY3VycmVudEluc3RhbmNlO1xuICBzZXRDdXJyZW50SW5zdGFuY2UodGhpcyk7XG4gIGNvbnN0IHJlcyA9IGRvV2F0Y2goZ2V0dGVyLCBjYi5iaW5kKHB1YmxpY1RoaXMpLCBvcHRpb25zKTtcbiAgaWYgKGN1cikge1xuICAgIHNldEN1cnJlbnRJbnN0YW5jZShjdXIpO1xuICB9IGVsc2Uge1xuICAgIHVuc2V0Q3VycmVudEluc3RhbmNlKCk7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cbmZ1bmN0aW9uIGNyZWF0ZVBhdGhHZXR0ZXIoY3R4LCBwYXRoKSB7XG4gIGNvbnN0IHNlZ21lbnRzID0gcGF0aC5zcGxpdChcIi5cIik7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgbGV0IGN1ciA9IGN0eDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNlZ21lbnRzLmxlbmd0aCAmJiBjdXI7IGkrKykge1xuICAgICAgY3VyID0gY3VyW3NlZ21lbnRzW2ldXTtcbiAgICB9XG4gICAgcmV0dXJuIGN1cjtcbiAgfTtcbn1cbmZ1bmN0aW9uIHRyYXZlcnNlKHZhbHVlLCBzZWVuKSB7XG4gIGlmICghaXNPYmplY3QodmFsdWUpIHx8IHZhbHVlW1wiX192X3NraXBcIl0pIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgc2VlbiA9IHNlZW4gfHwgLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgaWYgKHNlZW4uaGFzKHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBzZWVuLmFkZCh2YWx1ZSk7XG4gIGlmIChpc1JlZih2YWx1ZSkpIHtcbiAgICB0cmF2ZXJzZSh2YWx1ZS52YWx1ZSwgc2Vlbik7XG4gIH0gZWxzZSBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0cmF2ZXJzZSh2YWx1ZVtpXSwgc2Vlbik7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzU2V0KHZhbHVlKSB8fCBpc01hcCh2YWx1ZSkpIHtcbiAgICB2YWx1ZS5mb3JFYWNoKCh2KSA9PiB7XG4gICAgICB0cmF2ZXJzZSh2LCBzZWVuKTtcbiAgICB9KTtcbiAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHZhbHVlKSkge1xuICAgIGZvciAoY29uc3Qga2V5IGluIHZhbHVlKSB7XG4gICAgICB0cmF2ZXJzZSh2YWx1ZVtrZXldLCBzZWVuKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZURpcmVjdGl2ZU5hbWUobmFtZSkge1xuICBpZiAoaXNCdWlsdEluRGlyZWN0aXZlKG5hbWUpKSB7XG4gICAgd2FybihcIkRvIG5vdCB1c2UgYnVpbHQtaW4gZGlyZWN0aXZlIGlkcyBhcyBjdXN0b20gZGlyZWN0aXZlIGlkOiBcIiArIG5hbWUpO1xuICB9XG59XG5mdW5jdGlvbiB3aXRoRGlyZWN0aXZlcyh2bm9kZSwgZGlyZWN0aXZlcykge1xuICBjb25zdCBpbnRlcm5hbEluc3RhbmNlID0gY3VycmVudFJlbmRlcmluZ0luc3RhbmNlO1xuICBpZiAoaW50ZXJuYWxJbnN0YW5jZSA9PT0gbnVsbCkge1xuICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgd2Fybihgd2l0aERpcmVjdGl2ZXMgY2FuIG9ubHkgYmUgdXNlZCBpbnNpZGUgcmVuZGVyIGZ1bmN0aW9ucy5gKTtcbiAgICByZXR1cm4gdm5vZGU7XG4gIH1cbiAgY29uc3QgaW5zdGFuY2UgPSBnZXRFeHBvc2VQcm94eShpbnRlcm5hbEluc3RhbmNlKSB8fCBpbnRlcm5hbEluc3RhbmNlLnByb3h5O1xuICBjb25zdCBiaW5kaW5ncyA9IHZub2RlLmRpcnMgfHwgKHZub2RlLmRpcnMgPSBbXSk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZGlyZWN0aXZlcy5sZW5ndGg7IGkrKykge1xuICAgIGxldCBbZGlyLCB2YWx1ZSwgYXJnLCBtb2RpZmllcnMgPSBFTVBUWV9PQkpdID0gZGlyZWN0aXZlc1tpXTtcbiAgICBpZiAoZGlyKSB7XG4gICAgICBpZiAoaXNGdW5jdGlvbihkaXIpKSB7XG4gICAgICAgIGRpciA9IHtcbiAgICAgICAgICBtb3VudGVkOiBkaXIsXG4gICAgICAgICAgdXBkYXRlZDogZGlyXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBpZiAoZGlyLmRlZXApIHtcbiAgICAgICAgdHJhdmVyc2UodmFsdWUpO1xuICAgICAgfVxuICAgICAgYmluZGluZ3MucHVzaCh7XG4gICAgICAgIGRpcixcbiAgICAgICAgaW5zdGFuY2UsXG4gICAgICAgIHZhbHVlLFxuICAgICAgICBvbGRWYWx1ZTogdm9pZCAwLFxuICAgICAgICBhcmcsXG4gICAgICAgIG1vZGlmaWVyc1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHJldHVybiB2bm9kZTtcbn1cbmZ1bmN0aW9uIGludm9rZURpcmVjdGl2ZUhvb2sodm5vZGUsIHByZXZWTm9kZSwgaW5zdGFuY2UsIG5hbWUpIHtcbiAgY29uc3QgYmluZGluZ3MgPSB2bm9kZS5kaXJzO1xuICBjb25zdCBvbGRCaW5kaW5ncyA9IHByZXZWTm9kZSAmJiBwcmV2Vk5vZGUuZGlycztcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBiaW5kaW5ncy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGJpbmRpbmcgPSBiaW5kaW5nc1tpXTtcbiAgICBpZiAob2xkQmluZGluZ3MpIHtcbiAgICAgIGJpbmRpbmcub2xkVmFsdWUgPSBvbGRCaW5kaW5nc1tpXS52YWx1ZTtcbiAgICB9XG4gICAgbGV0IGhvb2sgPSBiaW5kaW5nLmRpcltuYW1lXTtcbiAgICBpZiAoaG9vaykge1xuICAgICAgcGF1c2VUcmFja2luZygpO1xuICAgICAgY2FsbFdpdGhBc3luY0Vycm9ySGFuZGxpbmcoaG9vaywgaW5zdGFuY2UsIDgsIFtcbiAgICAgICAgdm5vZGUuZWwsXG4gICAgICAgIGJpbmRpbmcsXG4gICAgICAgIHZub2RlLFxuICAgICAgICBwcmV2Vk5vZGVcbiAgICAgIF0pO1xuICAgICAgcmVzZXRUcmFja2luZygpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB1c2VUcmFuc2l0aW9uU3RhdGUoKSB7XG4gIGNvbnN0IHN0YXRlID0ge1xuICAgIGlzTW91bnRlZDogZmFsc2UsXG4gICAgaXNMZWF2aW5nOiBmYWxzZSxcbiAgICBpc1VubW91bnRpbmc6IGZhbHNlLFxuICAgIGxlYXZpbmdWTm9kZXM6IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKClcbiAgfTtcbiAgb25Nb3VudGVkKCgpID0+IHtcbiAgICBzdGF0ZS5pc01vdW50ZWQgPSB0cnVlO1xuICB9KTtcbiAgb25CZWZvcmVVbm1vdW50KCgpID0+IHtcbiAgICBzdGF0ZS5pc1VubW91bnRpbmcgPSB0cnVlO1xuICB9KTtcbiAgcmV0dXJuIHN0YXRlO1xufVxuY29uc3QgVHJhbnNpdGlvbkhvb2tWYWxpZGF0b3IgPSBbRnVuY3Rpb24sIEFycmF5XTtcbmNvbnN0IEJhc2VUcmFuc2l0aW9uUHJvcHNWYWxpZGF0b3JzID0ge1xuICBtb2RlOiBTdHJpbmcsXG4gIGFwcGVhcjogQm9vbGVhbixcbiAgcGVyc2lzdGVkOiBCb29sZWFuLFxuICAvLyBlbnRlclxuICBvbkJlZm9yZUVudGVyOiBUcmFuc2l0aW9uSG9va1ZhbGlkYXRvcixcbiAgb25FbnRlcjogVHJhbnNpdGlvbkhvb2tWYWxpZGF0b3IsXG4gIG9uQWZ0ZXJFbnRlcjogVHJhbnNpdGlvbkhvb2tWYWxpZGF0b3IsXG4gIG9uRW50ZXJDYW5jZWxsZWQ6IFRyYW5zaXRpb25Ib29rVmFsaWRhdG9yLFxuICAvLyBsZWF2ZVxuICBvbkJlZm9yZUxlYXZlOiBUcmFuc2l0aW9uSG9va1ZhbGlkYXRvcixcbiAgb25MZWF2ZTogVHJhbnNpdGlvbkhvb2tWYWxpZGF0b3IsXG4gIG9uQWZ0ZXJMZWF2ZTogVHJhbnNpdGlvbkhvb2tWYWxpZGF0b3IsXG4gIG9uTGVhdmVDYW5jZWxsZWQ6IFRyYW5zaXRpb25Ib29rVmFsaWRhdG9yLFxuICAvLyBhcHBlYXJcbiAgb25CZWZvcmVBcHBlYXI6IFRyYW5zaXRpb25Ib29rVmFsaWRhdG9yLFxuICBvbkFwcGVhcjogVHJhbnNpdGlvbkhvb2tWYWxpZGF0b3IsXG4gIG9uQWZ0ZXJBcHBlYXI6IFRyYW5zaXRpb25Ib29rVmFsaWRhdG9yLFxuICBvbkFwcGVhckNhbmNlbGxlZDogVHJhbnNpdGlvbkhvb2tWYWxpZGF0b3Jcbn07XG5jb25zdCBCYXNlVHJhbnNpdGlvbkltcGwgPSB7XG4gIG5hbWU6IGBCYXNlVHJhbnNpdGlvbmAsXG4gIHByb3BzOiBCYXNlVHJhbnNpdGlvblByb3BzVmFsaWRhdG9ycyxcbiAgc2V0dXAocHJvcHMsIHsgc2xvdHMgfSkge1xuICAgIGNvbnN0IGluc3RhbmNlID0gZ2V0Q3VycmVudEluc3RhbmNlKCk7XG4gICAgY29uc3Qgc3RhdGUgPSB1c2VUcmFuc2l0aW9uU3RhdGUoKTtcbiAgICBsZXQgcHJldlRyYW5zaXRpb25LZXk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGNvbnN0IGNoaWxkcmVuID0gc2xvdHMuZGVmYXVsdCAmJiBnZXRUcmFuc2l0aW9uUmF3Q2hpbGRyZW4oc2xvdHMuZGVmYXVsdCgpLCB0cnVlKTtcbiAgICAgIGlmICghY2hpbGRyZW4gfHwgIWNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBsZXQgY2hpbGQgPSBjaGlsZHJlblswXTtcbiAgICAgIGlmIChjaGlsZHJlbi5sZW5ndGggPiAxKSB7XG4gICAgICAgIGxldCBoYXNGb3VuZCA9IGZhbHNlO1xuICAgICAgICBmb3IgKGNvbnN0IGMgb2YgY2hpbGRyZW4pIHtcbiAgICAgICAgICBpZiAoYy50eXBlICE9PSBDb21tZW50KSB7XG4gICAgICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBoYXNGb3VuZCkge1xuICAgICAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgICAgIFwiPHRyYW5zaXRpb24+IGNhbiBvbmx5IGJlIHVzZWQgb24gYSBzaW5nbGUgZWxlbWVudCBvciBjb21wb25lbnQuIFVzZSA8dHJhbnNpdGlvbi1ncm91cD4gZm9yIGxpc3RzLlwiXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2hpbGQgPSBjO1xuICAgICAgICAgICAgaGFzRm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKCEhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IHJhd1Byb3BzID0gdG9SYXcocHJvcHMpO1xuICAgICAgY29uc3QgeyBtb2RlIH0gPSByYXdQcm9wcztcbiAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIG1vZGUgJiYgbW9kZSAhPT0gXCJpbi1vdXRcIiAmJiBtb2RlICE9PSBcIm91dC1pblwiICYmIG1vZGUgIT09IFwiZGVmYXVsdFwiKSB7XG4gICAgICAgIHdhcm4oYGludmFsaWQgPHRyYW5zaXRpb24+IG1vZGU6ICR7bW9kZX1gKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdGF0ZS5pc0xlYXZpbmcpIHtcbiAgICAgICAgcmV0dXJuIGVtcHR5UGxhY2Vob2xkZXIoY2hpbGQpO1xuICAgICAgfVxuICAgICAgY29uc3QgaW5uZXJDaGlsZCA9IGdldEtlZXBBbGl2ZUNoaWxkKGNoaWxkKTtcbiAgICAgIGlmICghaW5uZXJDaGlsZCkge1xuICAgICAgICByZXR1cm4gZW1wdHlQbGFjZWhvbGRlcihjaGlsZCk7XG4gICAgICB9XG4gICAgICBjb25zdCBlbnRlckhvb2tzID0gcmVzb2x2ZVRyYW5zaXRpb25Ib29rcyhcbiAgICAgICAgaW5uZXJDaGlsZCxcbiAgICAgICAgcmF3UHJvcHMsXG4gICAgICAgIHN0YXRlLFxuICAgICAgICBpbnN0YW5jZVxuICAgICAgKTtcbiAgICAgIHNldFRyYW5zaXRpb25Ib29rcyhpbm5lckNoaWxkLCBlbnRlckhvb2tzKTtcbiAgICAgIGNvbnN0IG9sZENoaWxkID0gaW5zdGFuY2Uuc3ViVHJlZTtcbiAgICAgIGNvbnN0IG9sZElubmVyQ2hpbGQgPSBvbGRDaGlsZCAmJiBnZXRLZWVwQWxpdmVDaGlsZChvbGRDaGlsZCk7XG4gICAgICBsZXQgdHJhbnNpdGlvbktleUNoYW5nZWQgPSBmYWxzZTtcbiAgICAgIGNvbnN0IHsgZ2V0VHJhbnNpdGlvbktleSB9ID0gaW5uZXJDaGlsZC50eXBlO1xuICAgICAgaWYgKGdldFRyYW5zaXRpb25LZXkpIHtcbiAgICAgICAgY29uc3Qga2V5ID0gZ2V0VHJhbnNpdGlvbktleSgpO1xuICAgICAgICBpZiAocHJldlRyYW5zaXRpb25LZXkgPT09IHZvaWQgMCkge1xuICAgICAgICAgIHByZXZUcmFuc2l0aW9uS2V5ID0ga2V5O1xuICAgICAgICB9IGVsc2UgaWYgKGtleSAhPT0gcHJldlRyYW5zaXRpb25LZXkpIHtcbiAgICAgICAgICBwcmV2VHJhbnNpdGlvbktleSA9IGtleTtcbiAgICAgICAgICB0cmFuc2l0aW9uS2V5Q2hhbmdlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChvbGRJbm5lckNoaWxkICYmIG9sZElubmVyQ2hpbGQudHlwZSAhPT0gQ29tbWVudCAmJiAoIWlzU2FtZVZOb2RlVHlwZShpbm5lckNoaWxkLCBvbGRJbm5lckNoaWxkKSB8fCB0cmFuc2l0aW9uS2V5Q2hhbmdlZCkpIHtcbiAgICAgICAgY29uc3QgbGVhdmluZ0hvb2tzID0gcmVzb2x2ZVRyYW5zaXRpb25Ib29rcyhcbiAgICAgICAgICBvbGRJbm5lckNoaWxkLFxuICAgICAgICAgIHJhd1Byb3BzLFxuICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgIGluc3RhbmNlXG4gICAgICAgICk7XG4gICAgICAgIHNldFRyYW5zaXRpb25Ib29rcyhvbGRJbm5lckNoaWxkLCBsZWF2aW5nSG9va3MpO1xuICAgICAgICBpZiAobW9kZSA9PT0gXCJvdXQtaW5cIikge1xuICAgICAgICAgIHN0YXRlLmlzTGVhdmluZyA9IHRydWU7XG4gICAgICAgICAgbGVhdmluZ0hvb2tzLmFmdGVyTGVhdmUgPSAoKSA9PiB7XG4gICAgICAgICAgICBzdGF0ZS5pc0xlYXZpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChpbnN0YW5jZS51cGRhdGUuYWN0aXZlICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICBpbnN0YW5jZS51cGRhdGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICAgIHJldHVybiBlbXB0eVBsYWNlaG9sZGVyKGNoaWxkKTtcbiAgICAgICAgfSBlbHNlIGlmIChtb2RlID09PSBcImluLW91dFwiICYmIGlubmVyQ2hpbGQudHlwZSAhPT0gQ29tbWVudCkge1xuICAgICAgICAgIGxlYXZpbmdIb29rcy5kZWxheUxlYXZlID0gKGVsLCBlYXJseVJlbW92ZSwgZGVsYXllZExlYXZlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBsZWF2aW5nVk5vZGVzQ2FjaGUgPSBnZXRMZWF2aW5nTm9kZXNGb3JUeXBlKFxuICAgICAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICAgICAgb2xkSW5uZXJDaGlsZFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGxlYXZpbmdWTm9kZXNDYWNoZVtTdHJpbmcob2xkSW5uZXJDaGlsZC5rZXkpXSA9IG9sZElubmVyQ2hpbGQ7XG4gICAgICAgICAgICBlbC5fbGVhdmVDYiA9ICgpID0+IHtcbiAgICAgICAgICAgICAgZWFybHlSZW1vdmUoKTtcbiAgICAgICAgICAgICAgZWwuX2xlYXZlQ2IgPSB2b2lkIDA7XG4gICAgICAgICAgICAgIGRlbGV0ZSBlbnRlckhvb2tzLmRlbGF5ZWRMZWF2ZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBlbnRlckhvb2tzLmRlbGF5ZWRMZWF2ZSA9IGRlbGF5ZWRMZWF2ZTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gY2hpbGQ7XG4gICAgfTtcbiAgfVxufTtcbmNvbnN0IEJhc2VUcmFuc2l0aW9uID0gQmFzZVRyYW5zaXRpb25JbXBsO1xuZnVuY3Rpb24gZ2V0TGVhdmluZ05vZGVzRm9yVHlwZShzdGF0ZSwgdm5vZGUpIHtcbiAgY29uc3QgeyBsZWF2aW5nVk5vZGVzIH0gPSBzdGF0ZTtcbiAgbGV0IGxlYXZpbmdWTm9kZXNDYWNoZSA9IGxlYXZpbmdWTm9kZXMuZ2V0KHZub2RlLnR5cGUpO1xuICBpZiAoIWxlYXZpbmdWTm9kZXNDYWNoZSkge1xuICAgIGxlYXZpbmdWTm9kZXNDYWNoZSA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGxlYXZpbmdWTm9kZXMuc2V0KHZub2RlLnR5cGUsIGxlYXZpbmdWTm9kZXNDYWNoZSk7XG4gIH1cbiAgcmV0dXJuIGxlYXZpbmdWTm9kZXNDYWNoZTtcbn1cbmZ1bmN0aW9uIHJlc29sdmVUcmFuc2l0aW9uSG9va3Modm5vZGUsIHByb3BzLCBzdGF0ZSwgaW5zdGFuY2UpIHtcbiAgY29uc3Qge1xuICAgIGFwcGVhcixcbiAgICBtb2RlLFxuICAgIHBlcnNpc3RlZCA9IGZhbHNlLFxuICAgIG9uQmVmb3JlRW50ZXIsXG4gICAgb25FbnRlcixcbiAgICBvbkFmdGVyRW50ZXIsXG4gICAgb25FbnRlckNhbmNlbGxlZCxcbiAgICBvbkJlZm9yZUxlYXZlLFxuICAgIG9uTGVhdmUsXG4gICAgb25BZnRlckxlYXZlLFxuICAgIG9uTGVhdmVDYW5jZWxsZWQsXG4gICAgb25CZWZvcmVBcHBlYXIsXG4gICAgb25BcHBlYXIsXG4gICAgb25BZnRlckFwcGVhcixcbiAgICBvbkFwcGVhckNhbmNlbGxlZFxuICB9ID0gcHJvcHM7XG4gIGNvbnN0IGtleSA9IFN0cmluZyh2bm9kZS5rZXkpO1xuICBjb25zdCBsZWF2aW5nVk5vZGVzQ2FjaGUgPSBnZXRMZWF2aW5nTm9kZXNGb3JUeXBlKHN0YXRlLCB2bm9kZSk7XG4gIGNvbnN0IGNhbGxIb29rID0gKGhvb2ssIGFyZ3MpID0+IHtcbiAgICBob29rICYmIGNhbGxXaXRoQXN5bmNFcnJvckhhbmRsaW5nKFxuICAgICAgaG9vayxcbiAgICAgIGluc3RhbmNlLFxuICAgICAgOSxcbiAgICAgIGFyZ3NcbiAgICApO1xuICB9O1xuICBjb25zdCBjYWxsQXN5bmNIb29rID0gKGhvb2ssIGFyZ3MpID0+IHtcbiAgICBjb25zdCBkb25lID0gYXJnc1sxXTtcbiAgICBjYWxsSG9vayhob29rLCBhcmdzKTtcbiAgICBpZiAoaXNBcnJheShob29rKSkge1xuICAgICAgaWYgKGhvb2suZXZlcnkoKGhvb2syKSA9PiBob29rMi5sZW5ndGggPD0gMSkpXG4gICAgICAgIGRvbmUoKTtcbiAgICB9IGVsc2UgaWYgKGhvb2subGVuZ3RoIDw9IDEpIHtcbiAgICAgIGRvbmUoKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IGhvb2tzID0ge1xuICAgIG1vZGUsXG4gICAgcGVyc2lzdGVkLFxuICAgIGJlZm9yZUVudGVyKGVsKSB7XG4gICAgICBsZXQgaG9vayA9IG9uQmVmb3JlRW50ZXI7XG4gICAgICBpZiAoIXN0YXRlLmlzTW91bnRlZCkge1xuICAgICAgICBpZiAoYXBwZWFyKSB7XG4gICAgICAgICAgaG9vayA9IG9uQmVmb3JlQXBwZWFyIHx8IG9uQmVmb3JlRW50ZXI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZWwuX2xlYXZlQ2IpIHtcbiAgICAgICAgZWwuX2xlYXZlQ2IoXG4gICAgICAgICAgdHJ1ZVxuICAgICAgICAgIC8qIGNhbmNlbGxlZCAqL1xuICAgICAgICApO1xuICAgICAgfVxuICAgICAgY29uc3QgbGVhdmluZ1ZOb2RlID0gbGVhdmluZ1ZOb2Rlc0NhY2hlW2tleV07XG4gICAgICBpZiAobGVhdmluZ1ZOb2RlICYmIGlzU2FtZVZOb2RlVHlwZSh2bm9kZSwgbGVhdmluZ1ZOb2RlKSAmJiBsZWF2aW5nVk5vZGUuZWwuX2xlYXZlQ2IpIHtcbiAgICAgICAgbGVhdmluZ1ZOb2RlLmVsLl9sZWF2ZUNiKCk7XG4gICAgICB9XG4gICAgICBjYWxsSG9vayhob29rLCBbZWxdKTtcbiAgICB9LFxuICAgIGVudGVyKGVsKSB7XG4gICAgICBsZXQgaG9vayA9IG9uRW50ZXI7XG4gICAgICBsZXQgYWZ0ZXJIb29rID0gb25BZnRlckVudGVyO1xuICAgICAgbGV0IGNhbmNlbEhvb2sgPSBvbkVudGVyQ2FuY2VsbGVkO1xuICAgICAgaWYgKCFzdGF0ZS5pc01vdW50ZWQpIHtcbiAgICAgICAgaWYgKGFwcGVhcikge1xuICAgICAgICAgIGhvb2sgPSBvbkFwcGVhciB8fCBvbkVudGVyO1xuICAgICAgICAgIGFmdGVySG9vayA9IG9uQWZ0ZXJBcHBlYXIgfHwgb25BZnRlckVudGVyO1xuICAgICAgICAgIGNhbmNlbEhvb2sgPSBvbkFwcGVhckNhbmNlbGxlZCB8fCBvbkVudGVyQ2FuY2VsbGVkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbGV0IGNhbGxlZCA9IGZhbHNlO1xuICAgICAgY29uc3QgZG9uZSA9IGVsLl9lbnRlckNiID0gKGNhbmNlbGxlZCkgPT4ge1xuICAgICAgICBpZiAoY2FsbGVkKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKGNhbmNlbGxlZCkge1xuICAgICAgICAgIGNhbGxIb29rKGNhbmNlbEhvb2ssIFtlbF0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNhbGxIb29rKGFmdGVySG9vaywgW2VsXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhvb2tzLmRlbGF5ZWRMZWF2ZSkge1xuICAgICAgICAgIGhvb2tzLmRlbGF5ZWRMZWF2ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsLl9lbnRlckNiID0gdm9pZCAwO1xuICAgICAgfTtcbiAgICAgIGlmIChob29rKSB7XG4gICAgICAgIGNhbGxBc3luY0hvb2soaG9vaywgW2VsLCBkb25lXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkb25lKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBsZWF2ZShlbCwgcmVtb3ZlKSB7XG4gICAgICBjb25zdCBrZXkyID0gU3RyaW5nKHZub2RlLmtleSk7XG4gICAgICBpZiAoZWwuX2VudGVyQ2IpIHtcbiAgICAgICAgZWwuX2VudGVyQ2IoXG4gICAgICAgICAgdHJ1ZVxuICAgICAgICAgIC8qIGNhbmNlbGxlZCAqL1xuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKHN0YXRlLmlzVW5tb3VudGluZykge1xuICAgICAgICByZXR1cm4gcmVtb3ZlKCk7XG4gICAgICB9XG4gICAgICBjYWxsSG9vayhvbkJlZm9yZUxlYXZlLCBbZWxdKTtcbiAgICAgIGxldCBjYWxsZWQgPSBmYWxzZTtcbiAgICAgIGNvbnN0IGRvbmUgPSBlbC5fbGVhdmVDYiA9IChjYW5jZWxsZWQpID0+IHtcbiAgICAgICAgaWYgKGNhbGxlZClcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNhbGxlZCA9IHRydWU7XG4gICAgICAgIHJlbW92ZSgpO1xuICAgICAgICBpZiAoY2FuY2VsbGVkKSB7XG4gICAgICAgICAgY2FsbEhvb2sob25MZWF2ZUNhbmNlbGxlZCwgW2VsXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2FsbEhvb2sob25BZnRlckxlYXZlLCBbZWxdKTtcbiAgICAgICAgfVxuICAgICAgICBlbC5fbGVhdmVDYiA9IHZvaWQgMDtcbiAgICAgICAgaWYgKGxlYXZpbmdWTm9kZXNDYWNoZVtrZXkyXSA9PT0gdm5vZGUpIHtcbiAgICAgICAgICBkZWxldGUgbGVhdmluZ1ZOb2Rlc0NhY2hlW2tleTJdO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgbGVhdmluZ1ZOb2Rlc0NhY2hlW2tleTJdID0gdm5vZGU7XG4gICAgICBpZiAob25MZWF2ZSkge1xuICAgICAgICBjYWxsQXN5bmNIb29rKG9uTGVhdmUsIFtlbCwgZG9uZV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZG9uZSgpO1xuICAgICAgfVxuICAgIH0sXG4gICAgY2xvbmUodm5vZGUyKSB7XG4gICAgICByZXR1cm4gcmVzb2x2ZVRyYW5zaXRpb25Ib29rcyh2bm9kZTIsIHByb3BzLCBzdGF0ZSwgaW5zdGFuY2UpO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIGhvb2tzO1xufVxuZnVuY3Rpb24gZW1wdHlQbGFjZWhvbGRlcih2bm9kZSkge1xuICBpZiAoaXNLZWVwQWxpdmUodm5vZGUpKSB7XG4gICAgdm5vZGUgPSBjbG9uZVZOb2RlKHZub2RlKTtcbiAgICB2bm9kZS5jaGlsZHJlbiA9IG51bGw7XG4gICAgcmV0dXJuIHZub2RlO1xuICB9XG59XG5mdW5jdGlvbiBnZXRLZWVwQWxpdmVDaGlsZCh2bm9kZSkge1xuICByZXR1cm4gaXNLZWVwQWxpdmUodm5vZGUpID8gdm5vZGUuY2hpbGRyZW4gPyB2bm9kZS5jaGlsZHJlblswXSA6IHZvaWQgMCA6IHZub2RlO1xufVxuZnVuY3Rpb24gc2V0VHJhbnNpdGlvbkhvb2tzKHZub2RlLCBob29rcykge1xuICBpZiAodm5vZGUuc2hhcGVGbGFnICYgNiAmJiB2bm9kZS5jb21wb25lbnQpIHtcbiAgICBzZXRUcmFuc2l0aW9uSG9va3Modm5vZGUuY29tcG9uZW50LnN1YlRyZWUsIGhvb2tzKTtcbiAgfSBlbHNlIGlmICh2bm9kZS5zaGFwZUZsYWcgJiAxMjgpIHtcbiAgICB2bm9kZS5zc0NvbnRlbnQudHJhbnNpdGlvbiA9IGhvb2tzLmNsb25lKHZub2RlLnNzQ29udGVudCk7XG4gICAgdm5vZGUuc3NGYWxsYmFjay50cmFuc2l0aW9uID0gaG9va3MuY2xvbmUodm5vZGUuc3NGYWxsYmFjayk7XG4gIH0gZWxzZSB7XG4gICAgdm5vZGUudHJhbnNpdGlvbiA9IGhvb2tzO1xuICB9XG59XG5mdW5jdGlvbiBnZXRUcmFuc2l0aW9uUmF3Q2hpbGRyZW4oY2hpbGRyZW4sIGtlZXBDb21tZW50ID0gZmFsc2UsIHBhcmVudEtleSkge1xuICBsZXQgcmV0ID0gW107XG4gIGxldCBrZXllZEZyYWdtZW50Q291bnQgPSAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgbGV0IGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgY29uc3Qga2V5ID0gcGFyZW50S2V5ID09IG51bGwgPyBjaGlsZC5rZXkgOiBTdHJpbmcocGFyZW50S2V5KSArIFN0cmluZyhjaGlsZC5rZXkgIT0gbnVsbCA/IGNoaWxkLmtleSA6IGkpO1xuICAgIGlmIChjaGlsZC50eXBlID09PSBGcmFnbWVudCkge1xuICAgICAgaWYgKGNoaWxkLnBhdGNoRmxhZyAmIDEyOClcbiAgICAgICAga2V5ZWRGcmFnbWVudENvdW50Kys7XG4gICAgICByZXQgPSByZXQuY29uY2F0KFxuICAgICAgICBnZXRUcmFuc2l0aW9uUmF3Q2hpbGRyZW4oY2hpbGQuY2hpbGRyZW4sIGtlZXBDb21tZW50LCBrZXkpXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoa2VlcENvbW1lbnQgfHwgY2hpbGQudHlwZSAhPT0gQ29tbWVudCkge1xuICAgICAgcmV0LnB1c2goa2V5ICE9IG51bGwgPyBjbG9uZVZOb2RlKGNoaWxkLCB7IGtleSB9KSA6IGNoaWxkKTtcbiAgICB9XG4gIH1cbiAgaWYgKGtleWVkRnJhZ21lbnRDb3VudCA+IDEpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJldC5sZW5ndGg7IGkrKykge1xuICAgICAgcmV0W2ldLnBhdGNoRmxhZyA9IC0yO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBkZWZpbmVDb21wb25lbnQob3B0aW9ucywgZXh0cmFPcHRpb25zKSB7XG4gIHJldHVybiBpc0Z1bmN0aW9uKG9wdGlvbnMpID8gKFxuICAgIC8vICM4MzI2OiBleHRlbmQgY2FsbCBhbmQgb3B0aW9ucy5uYW1lIGFjY2VzcyBhcmUgY29uc2lkZXJlZCBzaWRlLWVmZmVjdHNcbiAgICAvLyBieSBSb2xsdXAsIHNvIHdlIGhhdmUgdG8gd3JhcCBpdCBpbiBhIHB1cmUtYW5ub3RhdGVkIElJRkUuXG4gICAgLyogQF9fUFVSRV9fICovICgoKSA9PiBleHRlbmQoeyBuYW1lOiBvcHRpb25zLm5hbWUgfSwgZXh0cmFPcHRpb25zLCB7IHNldHVwOiBvcHRpb25zIH0pKSgpXG4gICkgOiBvcHRpb25zO1xufVxuXG5jb25zdCBpc0FzeW5jV3JhcHBlciA9IChpKSA9PiAhIWkudHlwZS5fX2FzeW5jTG9hZGVyO1xuZnVuY3Rpb24gZGVmaW5lQXN5bmNDb21wb25lbnQoc291cmNlKSB7XG4gIGlmIChpc0Z1bmN0aW9uKHNvdXJjZSkpIHtcbiAgICBzb3VyY2UgPSB7IGxvYWRlcjogc291cmNlIH07XG4gIH1cbiAgY29uc3Qge1xuICAgIGxvYWRlcixcbiAgICBsb2FkaW5nQ29tcG9uZW50LFxuICAgIGVycm9yQ29tcG9uZW50LFxuICAgIGRlbGF5ID0gMjAwLFxuICAgIHRpbWVvdXQsXG4gICAgLy8gdW5kZWZpbmVkID0gbmV2ZXIgdGltZXMgb3V0XG4gICAgc3VzcGVuc2libGUgPSB0cnVlLFxuICAgIG9uRXJyb3I6IHVzZXJPbkVycm9yXG4gIH0gPSBzb3VyY2U7XG4gIGxldCBwZW5kaW5nUmVxdWVzdCA9IG51bGw7XG4gIGxldCByZXNvbHZlZENvbXA7XG4gIGxldCByZXRyaWVzID0gMDtcbiAgY29uc3QgcmV0cnkgPSAoKSA9PiB7XG4gICAgcmV0cmllcysrO1xuICAgIHBlbmRpbmdSZXF1ZXN0ID0gbnVsbDtcbiAgICByZXR1cm4gbG9hZCgpO1xuICB9O1xuICBjb25zdCBsb2FkID0gKCkgPT4ge1xuICAgIGxldCB0aGlzUmVxdWVzdDtcbiAgICByZXR1cm4gcGVuZGluZ1JlcXVlc3QgfHwgKHRoaXNSZXF1ZXN0ID0gcGVuZGluZ1JlcXVlc3QgPSBsb2FkZXIoKS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICBlcnIgPSBlcnIgaW5zdGFuY2VvZiBFcnJvciA/IGVyciA6IG5ldyBFcnJvcihTdHJpbmcoZXJyKSk7XG4gICAgICBpZiAodXNlck9uRXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICBjb25zdCB1c2VyUmV0cnkgPSAoKSA9PiByZXNvbHZlKHJldHJ5KCkpO1xuICAgICAgICAgIGNvbnN0IHVzZXJGYWlsID0gKCkgPT4gcmVqZWN0KGVycik7XG4gICAgICAgICAgdXNlck9uRXJyb3IoZXJyLCB1c2VyUmV0cnksIHVzZXJGYWlsLCByZXRyaWVzICsgMSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfVxuICAgIH0pLnRoZW4oKGNvbXApID0+IHtcbiAgICAgIGlmICh0aGlzUmVxdWVzdCAhPT0gcGVuZGluZ1JlcXVlc3QgJiYgcGVuZGluZ1JlcXVlc3QpIHtcbiAgICAgICAgcmV0dXJuIHBlbmRpbmdSZXF1ZXN0O1xuICAgICAgfVxuICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgIWNvbXApIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBgQXN5bmMgY29tcG9uZW50IGxvYWRlciByZXNvbHZlZCB0byB1bmRlZmluZWQuIElmIHlvdSBhcmUgdXNpbmcgcmV0cnkoKSwgbWFrZSBzdXJlIHRvIHJldHVybiBpdHMgcmV0dXJuIHZhbHVlLmBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChjb21wICYmIChjb21wLl9fZXNNb2R1bGUgfHwgY29tcFtTeW1ib2wudG9TdHJpbmdUYWddID09PSBcIk1vZHVsZVwiKSkge1xuICAgICAgICBjb21wID0gY29tcC5kZWZhdWx0O1xuICAgICAgfVxuICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgY29tcCAmJiAhaXNPYmplY3QoY29tcCkgJiYgIWlzRnVuY3Rpb24oY29tcCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGFzeW5jIGNvbXBvbmVudCBsb2FkIHJlc3VsdDogJHtjb21wfWApO1xuICAgICAgfVxuICAgICAgcmVzb2x2ZWRDb21wID0gY29tcDtcbiAgICAgIHJldHVybiBjb21wO1xuICAgIH0pKTtcbiAgfTtcbiAgcmV0dXJuIGRlZmluZUNvbXBvbmVudCh7XG4gICAgbmFtZTogXCJBc3luY0NvbXBvbmVudFdyYXBwZXJcIixcbiAgICBfX2FzeW5jTG9hZGVyOiBsb2FkLFxuICAgIGdldCBfX2FzeW5jUmVzb2x2ZWQoKSB7XG4gICAgICByZXR1cm4gcmVzb2x2ZWRDb21wO1xuICAgIH0sXG4gICAgc2V0dXAoKSB7XG4gICAgICBjb25zdCBpbnN0YW5jZSA9IGN1cnJlbnRJbnN0YW5jZTtcbiAgICAgIGlmIChyZXNvbHZlZENvbXApIHtcbiAgICAgICAgcmV0dXJuICgpID0+IGNyZWF0ZUlubmVyQ29tcChyZXNvbHZlZENvbXAsIGluc3RhbmNlKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG9uRXJyb3IgPSAoZXJyKSA9PiB7XG4gICAgICAgIHBlbmRpbmdSZXF1ZXN0ID0gbnVsbDtcbiAgICAgICAgaGFuZGxlRXJyb3IoXG4gICAgICAgICAgZXJyLFxuICAgICAgICAgIGluc3RhbmNlLFxuICAgICAgICAgIDEzLFxuICAgICAgICAgICFlcnJvckNvbXBvbmVudFxuICAgICAgICAgIC8qIGRvIG5vdCB0aHJvdyBpbiBkZXYgaWYgdXNlciBwcm92aWRlZCBlcnJvciBjb21wb25lbnQgKi9cbiAgICAgICAgKTtcbiAgICAgIH07XG4gICAgICBpZiAoc3VzcGVuc2libGUgJiYgaW5zdGFuY2Uuc3VzcGVuc2UgfHwgaXNJblNTUkNvbXBvbmVudFNldHVwKSB7XG4gICAgICAgIHJldHVybiBsb2FkKCkudGhlbigoY29tcCkgPT4ge1xuICAgICAgICAgIHJldHVybiAoKSA9PiBjcmVhdGVJbm5lckNvbXAoY29tcCwgaW5zdGFuY2UpO1xuICAgICAgICB9KS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgb25FcnJvcihlcnIpO1xuICAgICAgICAgIHJldHVybiAoKSA9PiBlcnJvckNvbXBvbmVudCA/IGNyZWF0ZVZOb2RlKGVycm9yQ29tcG9uZW50LCB7XG4gICAgICAgICAgICBlcnJvcjogZXJyXG4gICAgICAgICAgfSkgOiBudWxsO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGxvYWRlZCA9IHJlZihmYWxzZSk7XG4gICAgICBjb25zdCBlcnJvciA9IHJlZigpO1xuICAgICAgY29uc3QgZGVsYXllZCA9IHJlZighIWRlbGF5KTtcbiAgICAgIGlmIChkZWxheSkge1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICBkZWxheWVkLnZhbHVlID0gZmFsc2U7XG4gICAgICAgIH0sIGRlbGF5KTtcbiAgICAgIH1cbiAgICAgIGlmICh0aW1lb3V0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgaWYgKCFsb2FkZWQudmFsdWUgJiYgIWVycm9yLnZhbHVlKSB7XG4gICAgICAgICAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgIGBBc3luYyBjb21wb25lbnQgdGltZWQgb3V0IGFmdGVyICR7dGltZW91dH1tcy5gXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgb25FcnJvcihlcnIpO1xuICAgICAgICAgICAgZXJyb3IudmFsdWUgPSBlcnI7XG4gICAgICAgICAgfVxuICAgICAgICB9LCB0aW1lb3V0KTtcbiAgICAgIH1cbiAgICAgIGxvYWQoKS50aGVuKCgpID0+IHtcbiAgICAgICAgbG9hZGVkLnZhbHVlID0gdHJ1ZTtcbiAgICAgICAgaWYgKGluc3RhbmNlLnBhcmVudCAmJiBpc0tlZXBBbGl2ZShpbnN0YW5jZS5wYXJlbnQudm5vZGUpKSB7XG4gICAgICAgICAgcXVldWVKb2IoaW5zdGFuY2UucGFyZW50LnVwZGF0ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgb25FcnJvcihlcnIpO1xuICAgICAgICBlcnJvci52YWx1ZSA9IGVycjtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgaWYgKGxvYWRlZC52YWx1ZSAmJiByZXNvbHZlZENvbXApIHtcbiAgICAgICAgICByZXR1cm4gY3JlYXRlSW5uZXJDb21wKHJlc29sdmVkQ29tcCwgaW5zdGFuY2UpO1xuICAgICAgICB9IGVsc2UgaWYgKGVycm9yLnZhbHVlICYmIGVycm9yQ29tcG9uZW50KSB7XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZVZOb2RlKGVycm9yQ29tcG9uZW50LCB7XG4gICAgICAgICAgICBlcnJvcjogZXJyb3IudmFsdWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmIChsb2FkaW5nQ29tcG9uZW50ICYmICFkZWxheWVkLnZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZVZOb2RlKGxvYWRpbmdDb21wb25lbnQpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBjcmVhdGVJbm5lckNvbXAoY29tcCwgcGFyZW50KSB7XG4gIGNvbnN0IHsgcmVmOiByZWYyLCBwcm9wcywgY2hpbGRyZW4sIGNlIH0gPSBwYXJlbnQudm5vZGU7XG4gIGNvbnN0IHZub2RlID0gY3JlYXRlVk5vZGUoY29tcCwgcHJvcHMsIGNoaWxkcmVuKTtcbiAgdm5vZGUucmVmID0gcmVmMjtcbiAgdm5vZGUuY2UgPSBjZTtcbiAgZGVsZXRlIHBhcmVudC52bm9kZS5jZTtcbiAgcmV0dXJuIHZub2RlO1xufVxuXG5jb25zdCBpc0tlZXBBbGl2ZSA9ICh2bm9kZSkgPT4gdm5vZGUudHlwZS5fX2lzS2VlcEFsaXZlO1xuY29uc3QgS2VlcEFsaXZlSW1wbCA9IHtcbiAgbmFtZTogYEtlZXBBbGl2ZWAsXG4gIC8vIE1hcmtlciBmb3Igc3BlY2lhbCBoYW5kbGluZyBpbnNpZGUgdGhlIHJlbmRlcmVyLiBXZSBhcmUgbm90IHVzaW5nIGEgPT09XG4gIC8vIGNoZWNrIGRpcmVjdGx5IG9uIEtlZXBBbGl2ZSBpbiB0aGUgcmVuZGVyZXIsIGJlY2F1c2UgaW1wb3J0aW5nIGl0IGRpcmVjdGx5XG4gIC8vIHdvdWxkIHByZXZlbnQgaXQgZnJvbSBiZWluZyB0cmVlLXNoYWtlbi5cbiAgX19pc0tlZXBBbGl2ZTogdHJ1ZSxcbiAgcHJvcHM6IHtcbiAgICBpbmNsdWRlOiBbU3RyaW5nLCBSZWdFeHAsIEFycmF5XSxcbiAgICBleGNsdWRlOiBbU3RyaW5nLCBSZWdFeHAsIEFycmF5XSxcbiAgICBtYXg6IFtTdHJpbmcsIE51bWJlcl1cbiAgfSxcbiAgc2V0dXAocHJvcHMsIHsgc2xvdHMgfSkge1xuICAgIGNvbnN0IGluc3RhbmNlID0gZ2V0Q3VycmVudEluc3RhbmNlKCk7XG4gICAgY29uc3Qgc2hhcmVkQ29udGV4dCA9IGluc3RhbmNlLmN0eDtcbiAgICBpZiAoIXNoYXJlZENvbnRleHQucmVuZGVyZXIpIHtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGNoaWxkcmVuID0gc2xvdHMuZGVmYXVsdCAmJiBzbG90cy5kZWZhdWx0KCk7XG4gICAgICAgIHJldHVybiBjaGlsZHJlbiAmJiBjaGlsZHJlbi5sZW5ndGggPT09IDEgPyBjaGlsZHJlblswXSA6IGNoaWxkcmVuO1xuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgY2FjaGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIGNvbnN0IGtleXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIGxldCBjdXJyZW50ID0gbnVsbDtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcbiAgICAgIGluc3RhbmNlLl9fdl9jYWNoZSA9IGNhY2hlO1xuICAgIH1cbiAgICBjb25zdCBwYXJlbnRTdXNwZW5zZSA9IGluc3RhbmNlLnN1c3BlbnNlO1xuICAgIGNvbnN0IHtcbiAgICAgIHJlbmRlcmVyOiB7XG4gICAgICAgIHA6IHBhdGNoLFxuICAgICAgICBtOiBtb3ZlLFxuICAgICAgICB1bTogX3VubW91bnQsXG4gICAgICAgIG86IHsgY3JlYXRlRWxlbWVudCB9XG4gICAgICB9XG4gICAgfSA9IHNoYXJlZENvbnRleHQ7XG4gICAgY29uc3Qgc3RvcmFnZUNvbnRhaW5lciA9IGNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgc2hhcmVkQ29udGV4dC5hY3RpdmF0ZSA9ICh2bm9kZSwgY29udGFpbmVyLCBhbmNob3IsIGlzU1ZHLCBvcHRpbWl6ZWQpID0+IHtcbiAgICAgIGNvbnN0IGluc3RhbmNlMiA9IHZub2RlLmNvbXBvbmVudDtcbiAgICAgIG1vdmUodm5vZGUsIGNvbnRhaW5lciwgYW5jaG9yLCAwLCBwYXJlbnRTdXNwZW5zZSk7XG4gICAgICBwYXRjaChcbiAgICAgICAgaW5zdGFuY2UyLnZub2RlLFxuICAgICAgICB2bm9kZSxcbiAgICAgICAgY29udGFpbmVyLFxuICAgICAgICBhbmNob3IsXG4gICAgICAgIGluc3RhbmNlMixcbiAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgIGlzU1ZHLFxuICAgICAgICB2bm9kZS5zbG90U2NvcGVJZHMsXG4gICAgICAgIG9wdGltaXplZFxuICAgICAgKTtcbiAgICAgIHF1ZXVlUG9zdFJlbmRlckVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGluc3RhbmNlMi5pc0RlYWN0aXZhdGVkID0gZmFsc2U7XG4gICAgICAgIGlmIChpbnN0YW5jZTIuYSkge1xuICAgICAgICAgIGludm9rZUFycmF5Rm5zKGluc3RhbmNlMi5hKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2bm9kZUhvb2sgPSB2bm9kZS5wcm9wcyAmJiB2bm9kZS5wcm9wcy5vblZub2RlTW91bnRlZDtcbiAgICAgICAgaWYgKHZub2RlSG9vaykge1xuICAgICAgICAgIGludm9rZVZOb2RlSG9vayh2bm9kZUhvb2ssIGluc3RhbmNlMi5wYXJlbnQsIHZub2RlKTtcbiAgICAgICAgfVxuICAgICAgfSwgcGFyZW50U3VzcGVuc2UpO1xuICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XG4gICAgICAgIGRldnRvb2xzQ29tcG9uZW50QWRkZWQoaW5zdGFuY2UyKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHNoYXJlZENvbnRleHQuZGVhY3RpdmF0ZSA9ICh2bm9kZSkgPT4ge1xuICAgICAgY29uc3QgaW5zdGFuY2UyID0gdm5vZGUuY29tcG9uZW50O1xuICAgICAgbW92ZSh2bm9kZSwgc3RvcmFnZUNvbnRhaW5lciwgbnVsbCwgMSwgcGFyZW50U3VzcGVuc2UpO1xuICAgICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKGluc3RhbmNlMi5kYSkge1xuICAgICAgICAgIGludm9rZUFycmF5Rm5zKGluc3RhbmNlMi5kYSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgdm5vZGVIb29rID0gdm5vZGUucHJvcHMgJiYgdm5vZGUucHJvcHMub25Wbm9kZVVubW91bnRlZDtcbiAgICAgICAgaWYgKHZub2RlSG9vaykge1xuICAgICAgICAgIGludm9rZVZOb2RlSG9vayh2bm9kZUhvb2ssIGluc3RhbmNlMi5wYXJlbnQsIHZub2RlKTtcbiAgICAgICAgfVxuICAgICAgICBpbnN0YW5jZTIuaXNEZWFjdGl2YXRlZCA9IHRydWU7XG4gICAgICB9LCBwYXJlbnRTdXNwZW5zZSk7XG4gICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcbiAgICAgICAgZGV2dG9vbHNDb21wb25lbnRBZGRlZChpbnN0YW5jZTIpO1xuICAgICAgfVxuICAgIH07XG4gICAgZnVuY3Rpb24gdW5tb3VudCh2bm9kZSkge1xuICAgICAgcmVzZXRTaGFwZUZsYWcodm5vZGUpO1xuICAgICAgX3VubW91bnQodm5vZGUsIGluc3RhbmNlLCBwYXJlbnRTdXNwZW5zZSwgdHJ1ZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBydW5lQ2FjaGUoZmlsdGVyKSB7XG4gICAgICBjYWNoZS5mb3JFYWNoKCh2bm9kZSwga2V5KSA9PiB7XG4gICAgICAgIGNvbnN0IG5hbWUgPSBnZXRDb21wb25lbnROYW1lKHZub2RlLnR5cGUpO1xuICAgICAgICBpZiAobmFtZSAmJiAoIWZpbHRlciB8fCAhZmlsdGVyKG5hbWUpKSkge1xuICAgICAgICAgIHBydW5lQ2FjaGVFbnRyeShrZXkpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHJ1bmVDYWNoZUVudHJ5KGtleSkge1xuICAgICAgY29uc3QgY2FjaGVkID0gY2FjaGUuZ2V0KGtleSk7XG4gICAgICBpZiAoIWN1cnJlbnQgfHwgIWlzU2FtZVZOb2RlVHlwZShjYWNoZWQsIGN1cnJlbnQpKSB7XG4gICAgICAgIHVubW91bnQoY2FjaGVkKTtcbiAgICAgIH0gZWxzZSBpZiAoY3VycmVudCkge1xuICAgICAgICByZXNldFNoYXBlRmxhZyhjdXJyZW50KTtcbiAgICAgIH1cbiAgICAgIGNhY2hlLmRlbGV0ZShrZXkpO1xuICAgICAga2V5cy5kZWxldGUoa2V5KTtcbiAgICB9XG4gICAgd2F0Y2goXG4gICAgICAoKSA9PiBbcHJvcHMuaW5jbHVkZSwgcHJvcHMuZXhjbHVkZV0sXG4gICAgICAoW2luY2x1ZGUsIGV4Y2x1ZGVdKSA9PiB7XG4gICAgICAgIGluY2x1ZGUgJiYgcHJ1bmVDYWNoZSgobmFtZSkgPT4gbWF0Y2hlcyhpbmNsdWRlLCBuYW1lKSk7XG4gICAgICAgIGV4Y2x1ZGUgJiYgcHJ1bmVDYWNoZSgobmFtZSkgPT4gIW1hdGNoZXMoZXhjbHVkZSwgbmFtZSkpO1xuICAgICAgfSxcbiAgICAgIC8vIHBydW5lIHBvc3QtcmVuZGVyIGFmdGVyIGBjdXJyZW50YCBoYXMgYmVlbiB1cGRhdGVkXG4gICAgICB7IGZsdXNoOiBcInBvc3RcIiwgZGVlcDogdHJ1ZSB9XG4gICAgKTtcbiAgICBsZXQgcGVuZGluZ0NhY2hlS2V5ID0gbnVsbDtcbiAgICBjb25zdCBjYWNoZVN1YnRyZWUgPSAoKSA9PiB7XG4gICAgICBpZiAocGVuZGluZ0NhY2hlS2V5ICE9IG51bGwpIHtcbiAgICAgICAgY2FjaGUuc2V0KHBlbmRpbmdDYWNoZUtleSwgZ2V0SW5uZXJDaGlsZChpbnN0YW5jZS5zdWJUcmVlKSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBvbk1vdW50ZWQoY2FjaGVTdWJ0cmVlKTtcbiAgICBvblVwZGF0ZWQoY2FjaGVTdWJ0cmVlKTtcbiAgICBvbkJlZm9yZVVubW91bnQoKCkgPT4ge1xuICAgICAgY2FjaGUuZm9yRWFjaCgoY2FjaGVkKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgc3ViVHJlZSwgc3VzcGVuc2UgfSA9IGluc3RhbmNlO1xuICAgICAgICBjb25zdCB2bm9kZSA9IGdldElubmVyQ2hpbGQoc3ViVHJlZSk7XG4gICAgICAgIGlmIChjYWNoZWQudHlwZSA9PT0gdm5vZGUudHlwZSAmJiBjYWNoZWQua2V5ID09PSB2bm9kZS5rZXkpIHtcbiAgICAgICAgICByZXNldFNoYXBlRmxhZyh2bm9kZSk7XG4gICAgICAgICAgY29uc3QgZGEgPSB2bm9kZS5jb21wb25lbnQuZGE7XG4gICAgICAgICAgZGEgJiYgcXVldWVQb3N0UmVuZGVyRWZmZWN0KGRhLCBzdXNwZW5zZSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHVubW91bnQoY2FjaGVkKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBwZW5kaW5nQ2FjaGVLZXkgPSBudWxsO1xuICAgICAgaWYgKCFzbG90cy5kZWZhdWx0KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgY29uc3QgY2hpbGRyZW4gPSBzbG90cy5kZWZhdWx0KCk7XG4gICAgICBjb25zdCByYXdWTm9kZSA9IGNoaWxkcmVuWzBdO1xuICAgICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICB3YXJuKGBLZWVwQWxpdmUgc2hvdWxkIGNvbnRhaW4gZXhhY3RseSBvbmUgY29tcG9uZW50IGNoaWxkLmApO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnQgPSBudWxsO1xuICAgICAgICByZXR1cm4gY2hpbGRyZW47XG4gICAgICB9IGVsc2UgaWYgKCFpc1ZOb2RlKHJhd1ZOb2RlKSB8fCAhKHJhd1ZOb2RlLnNoYXBlRmxhZyAmIDQpICYmICEocmF3Vk5vZGUuc2hhcGVGbGFnICYgMTI4KSkge1xuICAgICAgICBjdXJyZW50ID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIHJhd1ZOb2RlO1xuICAgICAgfVxuICAgICAgbGV0IHZub2RlID0gZ2V0SW5uZXJDaGlsZChyYXdWTm9kZSk7XG4gICAgICBjb25zdCBjb21wID0gdm5vZGUudHlwZTtcbiAgICAgIGNvbnN0IG5hbWUgPSBnZXRDb21wb25lbnROYW1lKFxuICAgICAgICBpc0FzeW5jV3JhcHBlcih2bm9kZSkgPyB2bm9kZS50eXBlLl9fYXN5bmNSZXNvbHZlZCB8fCB7fSA6IGNvbXBcbiAgICAgICk7XG4gICAgICBjb25zdCB7IGluY2x1ZGUsIGV4Y2x1ZGUsIG1heCB9ID0gcHJvcHM7XG4gICAgICBpZiAoaW5jbHVkZSAmJiAoIW5hbWUgfHwgIW1hdGNoZXMoaW5jbHVkZSwgbmFtZSkpIHx8IGV4Y2x1ZGUgJiYgbmFtZSAmJiBtYXRjaGVzKGV4Y2x1ZGUsIG5hbWUpKSB7XG4gICAgICAgIGN1cnJlbnQgPSB2bm9kZTtcbiAgICAgICAgcmV0dXJuIHJhd1ZOb2RlO1xuICAgICAgfVxuICAgICAgY29uc3Qga2V5ID0gdm5vZGUua2V5ID09IG51bGwgPyBjb21wIDogdm5vZGUua2V5O1xuICAgICAgY29uc3QgY2FjaGVkVk5vZGUgPSBjYWNoZS5nZXQoa2V5KTtcbiAgICAgIGlmICh2bm9kZS5lbCkge1xuICAgICAgICB2bm9kZSA9IGNsb25lVk5vZGUodm5vZGUpO1xuICAgICAgICBpZiAocmF3Vk5vZGUuc2hhcGVGbGFnICYgMTI4KSB7XG4gICAgICAgICAgcmF3Vk5vZGUuc3NDb250ZW50ID0gdm5vZGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHBlbmRpbmdDYWNoZUtleSA9IGtleTtcbiAgICAgIGlmIChjYWNoZWRWTm9kZSkge1xuICAgICAgICB2bm9kZS5lbCA9IGNhY2hlZFZOb2RlLmVsO1xuICAgICAgICB2bm9kZS5jb21wb25lbnQgPSBjYWNoZWRWTm9kZS5jb21wb25lbnQ7XG4gICAgICAgIGlmICh2bm9kZS50cmFuc2l0aW9uKSB7XG4gICAgICAgICAgc2V0VHJhbnNpdGlvbkhvb2tzKHZub2RlLCB2bm9kZS50cmFuc2l0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICB2bm9kZS5zaGFwZUZsYWcgfD0gNTEyO1xuICAgICAgICBrZXlzLmRlbGV0ZShrZXkpO1xuICAgICAgICBrZXlzLmFkZChrZXkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAga2V5cy5hZGQoa2V5KTtcbiAgICAgICAgaWYgKG1heCAmJiBrZXlzLnNpemUgPiBwYXJzZUludChtYXgsIDEwKSkge1xuICAgICAgICAgIHBydW5lQ2FjaGVFbnRyeShrZXlzLnZhbHVlcygpLm5leHQoKS52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZub2RlLnNoYXBlRmxhZyB8PSAyNTY7XG4gICAgICBjdXJyZW50ID0gdm5vZGU7XG4gICAgICByZXR1cm4gaXNTdXNwZW5zZShyYXdWTm9kZS50eXBlKSA/IHJhd1ZOb2RlIDogdm5vZGU7XG4gICAgfTtcbiAgfVxufTtcbmNvbnN0IEtlZXBBbGl2ZSA9IEtlZXBBbGl2ZUltcGw7XG5mdW5jdGlvbiBtYXRjaGVzKHBhdHRlcm4sIG5hbWUpIHtcbiAgaWYgKGlzQXJyYXkocGF0dGVybikpIHtcbiAgICByZXR1cm4gcGF0dGVybi5zb21lKChwKSA9PiBtYXRjaGVzKHAsIG5hbWUpKTtcbiAgfSBlbHNlIGlmIChpc1N0cmluZyhwYXR0ZXJuKSkge1xuICAgIHJldHVybiBwYXR0ZXJuLnNwbGl0KFwiLFwiKS5pbmNsdWRlcyhuYW1lKTtcbiAgfSBlbHNlIGlmIChpc1JlZ0V4cChwYXR0ZXJuKSkge1xuICAgIHJldHVybiBwYXR0ZXJuLnRlc3QobmFtZSk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gb25BY3RpdmF0ZWQoaG9vaywgdGFyZ2V0KSB7XG4gIHJlZ2lzdGVyS2VlcEFsaXZlSG9vayhob29rLCBcImFcIiwgdGFyZ2V0KTtcbn1cbmZ1bmN0aW9uIG9uRGVhY3RpdmF0ZWQoaG9vaywgdGFyZ2V0KSB7XG4gIHJlZ2lzdGVyS2VlcEFsaXZlSG9vayhob29rLCBcImRhXCIsIHRhcmdldCk7XG59XG5mdW5jdGlvbiByZWdpc3RlcktlZXBBbGl2ZUhvb2soaG9vaywgdHlwZSwgdGFyZ2V0ID0gY3VycmVudEluc3RhbmNlKSB7XG4gIGNvbnN0IHdyYXBwZWRIb29rID0gaG9vay5fX3dkYyB8fCAoaG9vay5fX3dkYyA9ICgpID0+IHtcbiAgICBsZXQgY3VycmVudCA9IHRhcmdldDtcbiAgICB3aGlsZSAoY3VycmVudCkge1xuICAgICAgaWYgKGN1cnJlbnQuaXNEZWFjdGl2YXRlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjdXJyZW50ID0gY3VycmVudC5wYXJlbnQ7XG4gICAgfVxuICAgIHJldHVybiBob29rKCk7XG4gIH0pO1xuICBpbmplY3RIb29rKHR5cGUsIHdyYXBwZWRIb29rLCB0YXJnZXQpO1xuICBpZiAodGFyZ2V0KSB7XG4gICAgbGV0IGN1cnJlbnQgPSB0YXJnZXQucGFyZW50O1xuICAgIHdoaWxlIChjdXJyZW50ICYmIGN1cnJlbnQucGFyZW50KSB7XG4gICAgICBpZiAoaXNLZWVwQWxpdmUoY3VycmVudC5wYXJlbnQudm5vZGUpKSB7XG4gICAgICAgIGluamVjdFRvS2VlcEFsaXZlUm9vdCh3cmFwcGVkSG9vaywgdHlwZSwgdGFyZ2V0LCBjdXJyZW50KTtcbiAgICAgIH1cbiAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnBhcmVudDtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGluamVjdFRvS2VlcEFsaXZlUm9vdChob29rLCB0eXBlLCB0YXJnZXQsIGtlZXBBbGl2ZVJvb3QpIHtcbiAgY29uc3QgaW5qZWN0ZWQgPSBpbmplY3RIb29rKFxuICAgIHR5cGUsXG4gICAgaG9vayxcbiAgICBrZWVwQWxpdmVSb290LFxuICAgIHRydWVcbiAgICAvKiBwcmVwZW5kICovXG4gICk7XG4gIG9uVW5tb3VudGVkKCgpID0+IHtcbiAgICByZW1vdmUoa2VlcEFsaXZlUm9vdFt0eXBlXSwgaW5qZWN0ZWQpO1xuICB9LCB0YXJnZXQpO1xufVxuZnVuY3Rpb24gcmVzZXRTaGFwZUZsYWcodm5vZGUpIHtcbiAgdm5vZGUuc2hhcGVGbGFnICY9IH4yNTY7XG4gIHZub2RlLnNoYXBlRmxhZyAmPSB+NTEyO1xufVxuZnVuY3Rpb24gZ2V0SW5uZXJDaGlsZCh2bm9kZSkge1xuICByZXR1cm4gdm5vZGUuc2hhcGVGbGFnICYgMTI4ID8gdm5vZGUuc3NDb250ZW50IDogdm5vZGU7XG59XG5cbmZ1bmN0aW9uIGluamVjdEhvb2sodHlwZSwgaG9vaywgdGFyZ2V0ID0gY3VycmVudEluc3RhbmNlLCBwcmVwZW5kID0gZmFsc2UpIHtcbiAgaWYgKHRhcmdldCkge1xuICAgIGNvbnN0IGhvb2tzID0gdGFyZ2V0W3R5cGVdIHx8ICh0YXJnZXRbdHlwZV0gPSBbXSk7XG4gICAgY29uc3Qgd3JhcHBlZEhvb2sgPSBob29rLl9fd2VoIHx8IChob29rLl9fd2VoID0gKC4uLmFyZ3MpID0+IHtcbiAgICAgIGlmICh0YXJnZXQuaXNVbm1vdW50ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcGF1c2VUcmFja2luZygpO1xuICAgICAgc2V0Q3VycmVudEluc3RhbmNlKHRhcmdldCk7XG4gICAgICBjb25zdCByZXMgPSBjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZyhob29rLCB0YXJnZXQsIHR5cGUsIGFyZ3MpO1xuICAgICAgdW5zZXRDdXJyZW50SW5zdGFuY2UoKTtcbiAgICAgIHJlc2V0VHJhY2tpbmcoKTtcbiAgICAgIHJldHVybiByZXM7XG4gICAgfSk7XG4gICAgaWYgKHByZXBlbmQpIHtcbiAgICAgIGhvb2tzLnVuc2hpZnQod3JhcHBlZEhvb2spO1xuICAgIH0gZWxzZSB7XG4gICAgICBob29rcy5wdXNoKHdyYXBwZWRIb29rKTtcbiAgICB9XG4gICAgcmV0dXJuIHdyYXBwZWRIb29rO1xuICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICBjb25zdCBhcGlOYW1lID0gdG9IYW5kbGVyS2V5KEVycm9yVHlwZVN0cmluZ3NbdHlwZV0ucmVwbGFjZSgvIGhvb2skLywgXCJcIikpO1xuICAgIHdhcm4oXG4gICAgICBgJHthcGlOYW1lfSBpcyBjYWxsZWQgd2hlbiB0aGVyZSBpcyBubyBhY3RpdmUgY29tcG9uZW50IGluc3RhbmNlIHRvIGJlIGFzc29jaWF0ZWQgd2l0aC4gTGlmZWN5Y2xlIGluamVjdGlvbiBBUElzIGNhbiBvbmx5IGJlIHVzZWQgZHVyaW5nIGV4ZWN1dGlvbiBvZiBzZXR1cCgpLmAgKyAoYCBJZiB5b3UgYXJlIHVzaW5nIGFzeW5jIHNldHVwKCksIG1ha2Ugc3VyZSB0byByZWdpc3RlciBsaWZlY3ljbGUgaG9va3MgYmVmb3JlIHRoZSBmaXJzdCBhd2FpdCBzdGF0ZW1lbnQuYCApXG4gICAgKTtcbiAgfVxufVxuY29uc3QgY3JlYXRlSG9vayA9IChsaWZlY3ljbGUpID0+IChob29rLCB0YXJnZXQgPSBjdXJyZW50SW5zdGFuY2UpID0+IChcbiAgLy8gcG9zdC1jcmVhdGUgbGlmZWN5Y2xlIHJlZ2lzdHJhdGlvbnMgYXJlIG5vb3BzIGR1cmluZyBTU1IgKGV4Y2VwdCBmb3Igc2VydmVyUHJlZmV0Y2gpXG4gICghaXNJblNTUkNvbXBvbmVudFNldHVwIHx8IGxpZmVjeWNsZSA9PT0gXCJzcFwiKSAmJiBpbmplY3RIb29rKGxpZmVjeWNsZSwgKC4uLmFyZ3MpID0+IGhvb2soLi4uYXJncyksIHRhcmdldClcbik7XG5jb25zdCBvbkJlZm9yZU1vdW50ID0gY3JlYXRlSG9vayhcImJtXCIpO1xuY29uc3Qgb25Nb3VudGVkID0gY3JlYXRlSG9vayhcIm1cIik7XG5jb25zdCBvbkJlZm9yZVVwZGF0ZSA9IGNyZWF0ZUhvb2soXCJidVwiKTtcbmNvbnN0IG9uVXBkYXRlZCA9IGNyZWF0ZUhvb2soXCJ1XCIpO1xuY29uc3Qgb25CZWZvcmVVbm1vdW50ID0gY3JlYXRlSG9vayhcImJ1bVwiKTtcbmNvbnN0IG9uVW5tb3VudGVkID0gY3JlYXRlSG9vayhcInVtXCIpO1xuY29uc3Qgb25TZXJ2ZXJQcmVmZXRjaCA9IGNyZWF0ZUhvb2soXCJzcFwiKTtcbmNvbnN0IG9uUmVuZGVyVHJpZ2dlcmVkID0gY3JlYXRlSG9vayhcbiAgXCJydGdcIlxuKTtcbmNvbnN0IG9uUmVuZGVyVHJhY2tlZCA9IGNyZWF0ZUhvb2soXG4gIFwicnRjXCJcbik7XG5mdW5jdGlvbiBvbkVycm9yQ2FwdHVyZWQoaG9vaywgdGFyZ2V0ID0gY3VycmVudEluc3RhbmNlKSB7XG4gIGluamVjdEhvb2soXCJlY1wiLCBob29rLCB0YXJnZXQpO1xufVxuXG5jb25zdCBDT01QT05FTlRTID0gXCJjb21wb25lbnRzXCI7XG5jb25zdCBESVJFQ1RJVkVTID0gXCJkaXJlY3RpdmVzXCI7XG5mdW5jdGlvbiByZXNvbHZlQ29tcG9uZW50KG5hbWUsIG1heWJlU2VsZlJlZmVyZW5jZSkge1xuICByZXR1cm4gcmVzb2x2ZUFzc2V0KENPTVBPTkVOVFMsIG5hbWUsIHRydWUsIG1heWJlU2VsZlJlZmVyZW5jZSkgfHwgbmFtZTtcbn1cbmNvbnN0IE5VTExfRFlOQU1JQ19DT01QT05FTlQgPSBTeW1ib2wuZm9yKFwidi1uZGNcIik7XG5mdW5jdGlvbiByZXNvbHZlRHluYW1pY0NvbXBvbmVudChjb21wb25lbnQpIHtcbiAgaWYgKGlzU3RyaW5nKGNvbXBvbmVudCkpIHtcbiAgICByZXR1cm4gcmVzb2x2ZUFzc2V0KENPTVBPTkVOVFMsIGNvbXBvbmVudCwgZmFsc2UpIHx8IGNvbXBvbmVudDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gY29tcG9uZW50IHx8IE5VTExfRFlOQU1JQ19DT01QT05FTlQ7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlc29sdmVEaXJlY3RpdmUobmFtZSkge1xuICByZXR1cm4gcmVzb2x2ZUFzc2V0KERJUkVDVElWRVMsIG5hbWUpO1xufVxuZnVuY3Rpb24gcmVzb2x2ZUFzc2V0KHR5cGUsIG5hbWUsIHdhcm5NaXNzaW5nID0gdHJ1ZSwgbWF5YmVTZWxmUmVmZXJlbmNlID0gZmFsc2UpIHtcbiAgY29uc3QgaW5zdGFuY2UgPSBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UgfHwgY3VycmVudEluc3RhbmNlO1xuICBpZiAoaW5zdGFuY2UpIHtcbiAgICBjb25zdCBDb21wb25lbnQgPSBpbnN0YW5jZS50eXBlO1xuICAgIGlmICh0eXBlID09PSBDT01QT05FTlRTKSB7XG4gICAgICBjb25zdCBzZWxmTmFtZSA9IGdldENvbXBvbmVudE5hbWUoXG4gICAgICAgIENvbXBvbmVudCxcbiAgICAgICAgZmFsc2VcbiAgICAgICAgLyogZG8gbm90IGluY2x1ZGUgaW5mZXJyZWQgbmFtZSB0byBhdm9pZCBicmVha2luZyBleGlzdGluZyBjb2RlICovXG4gICAgICApO1xuICAgICAgaWYgKHNlbGZOYW1lICYmIChzZWxmTmFtZSA9PT0gbmFtZSB8fCBzZWxmTmFtZSA9PT0gY2FtZWxpemUobmFtZSkgfHwgc2VsZk5hbWUgPT09IGNhcGl0YWxpemUoY2FtZWxpemUobmFtZSkpKSkge1xuICAgICAgICByZXR1cm4gQ29tcG9uZW50O1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCByZXMgPSAoXG4gICAgICAvLyBsb2NhbCByZWdpc3RyYXRpb25cbiAgICAgIC8vIGNoZWNrIGluc3RhbmNlW3R5cGVdIGZpcnN0IHdoaWNoIGlzIHJlc29sdmVkIGZvciBvcHRpb25zIEFQSVxuICAgICAgcmVzb2x2ZShpbnN0YW5jZVt0eXBlXSB8fCBDb21wb25lbnRbdHlwZV0sIG5hbWUpIHx8IC8vIGdsb2JhbCByZWdpc3RyYXRpb25cbiAgICAgIHJlc29sdmUoaW5zdGFuY2UuYXBwQ29udGV4dFt0eXBlXSwgbmFtZSlcbiAgICApO1xuICAgIGlmICghcmVzICYmIG1heWJlU2VsZlJlZmVyZW5jZSkge1xuICAgICAgcmV0dXJuIENvbXBvbmVudDtcbiAgICB9XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgd2Fybk1pc3NpbmcgJiYgIXJlcykge1xuICAgICAgY29uc3QgZXh0cmEgPSB0eXBlID09PSBDT01QT05FTlRTID8gYFxuSWYgdGhpcyBpcyBhIG5hdGl2ZSBjdXN0b20gZWxlbWVudCwgbWFrZSBzdXJlIHRvIGV4Y2x1ZGUgaXQgZnJvbSBjb21wb25lbnQgcmVzb2x1dGlvbiB2aWEgY29tcGlsZXJPcHRpb25zLmlzQ3VzdG9tRWxlbWVudC5gIDogYGA7XG4gICAgICB3YXJuKGBGYWlsZWQgdG8gcmVzb2x2ZSAke3R5cGUuc2xpY2UoMCwgLTEpfTogJHtuYW1lfSR7ZXh0cmF9YCk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG4gIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIHdhcm4oXG4gICAgICBgcmVzb2x2ZSR7Y2FwaXRhbGl6ZSh0eXBlLnNsaWNlKDAsIC0xKSl9IGNhbiBvbmx5IGJlIHVzZWQgaW4gcmVuZGVyKCkgb3Igc2V0dXAoKS5gXG4gICAgKTtcbiAgfVxufVxuZnVuY3Rpb24gcmVzb2x2ZShyZWdpc3RyeSwgbmFtZSkge1xuICByZXR1cm4gcmVnaXN0cnkgJiYgKHJlZ2lzdHJ5W25hbWVdIHx8IHJlZ2lzdHJ5W2NhbWVsaXplKG5hbWUpXSB8fCByZWdpc3RyeVtjYXBpdGFsaXplKGNhbWVsaXplKG5hbWUpKV0pO1xufVxuXG5mdW5jdGlvbiByZW5kZXJMaXN0KHNvdXJjZSwgcmVuZGVySXRlbSwgY2FjaGUsIGluZGV4KSB7XG4gIGxldCByZXQ7XG4gIGNvbnN0IGNhY2hlZCA9IGNhY2hlICYmIGNhY2hlW2luZGV4XTtcbiAgaWYgKGlzQXJyYXkoc291cmNlKSB8fCBpc1N0cmluZyhzb3VyY2UpKSB7XG4gICAgcmV0ID0gbmV3IEFycmF5KHNvdXJjZS5sZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwLCBsID0gc291cmNlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgcmV0W2ldID0gcmVuZGVySXRlbShzb3VyY2VbaV0sIGksIHZvaWQgMCwgY2FjaGVkICYmIGNhY2hlZFtpXSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiBzb3VyY2UgPT09IFwibnVtYmVyXCIpIHtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhTnVtYmVyLmlzSW50ZWdlcihzb3VyY2UpKSB7XG4gICAgICB3YXJuKGBUaGUgdi1mb3IgcmFuZ2UgZXhwZWN0IGFuIGludGVnZXIgdmFsdWUgYnV0IGdvdCAke3NvdXJjZX0uYCk7XG4gICAgfVxuICAgIHJldCA9IG5ldyBBcnJheShzb3VyY2UpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc291cmNlOyBpKyspIHtcbiAgICAgIHJldFtpXSA9IHJlbmRlckl0ZW0oaSArIDEsIGksIHZvaWQgMCwgY2FjaGVkICYmIGNhY2hlZFtpXSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KHNvdXJjZSkpIHtcbiAgICBpZiAoc291cmNlW1N5bWJvbC5pdGVyYXRvcl0pIHtcbiAgICAgIHJldCA9IEFycmF5LmZyb20oXG4gICAgICAgIHNvdXJjZSxcbiAgICAgICAgKGl0ZW0sIGkpID0+IHJlbmRlckl0ZW0oaXRlbSwgaSwgdm9pZCAwLCBjYWNoZWQgJiYgY2FjaGVkW2ldKVxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG4gICAgICByZXQgPSBuZXcgQXJyYXkoa2V5cy5sZW5ndGgpO1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSBrZXlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBjb25zdCBrZXkgPSBrZXlzW2ldO1xuICAgICAgICByZXRbaV0gPSByZW5kZXJJdGVtKHNvdXJjZVtrZXldLCBrZXksIGksIGNhY2hlZCAmJiBjYWNoZWRbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXQgPSBbXTtcbiAgfVxuICBpZiAoY2FjaGUpIHtcbiAgICBjYWNoZVtpbmRleF0gPSByZXQ7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gY3JlYXRlU2xvdHMoc2xvdHMsIGR5bmFtaWNTbG90cykge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGR5bmFtaWNTbG90cy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHNsb3QgPSBkeW5hbWljU2xvdHNbaV07XG4gICAgaWYgKGlzQXJyYXkoc2xvdCkpIHtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgc2xvdC5sZW5ndGg7IGorKykge1xuICAgICAgICBzbG90c1tzbG90W2pdLm5hbWVdID0gc2xvdFtqXS5mbjtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHNsb3QpIHtcbiAgICAgIHNsb3RzW3Nsb3QubmFtZV0gPSBzbG90LmtleSA/ICguLi5hcmdzKSA9PiB7XG4gICAgICAgIGNvbnN0IHJlcyA9IHNsb3QuZm4oLi4uYXJncyk7XG4gICAgICAgIGlmIChyZXMpXG4gICAgICAgICAgcmVzLmtleSA9IHNsb3Qua2V5O1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgfSA6IHNsb3QuZm47XG4gICAgfVxuICB9XG4gIHJldHVybiBzbG90cztcbn1cblxuZnVuY3Rpb24gcmVuZGVyU2xvdChzbG90cywgbmFtZSwgcHJvcHMgPSB7fSwgZmFsbGJhY2ssIG5vU2xvdHRlZCkge1xuICBpZiAoY3VycmVudFJlbmRlcmluZ0luc3RhbmNlLmlzQ0UgfHwgY3VycmVudFJlbmRlcmluZ0luc3RhbmNlLnBhcmVudCAmJiBpc0FzeW5jV3JhcHBlcihjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UucGFyZW50KSAmJiBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UucGFyZW50LmlzQ0UpIHtcbiAgICBpZiAobmFtZSAhPT0gXCJkZWZhdWx0XCIpXG4gICAgICBwcm9wcy5uYW1lID0gbmFtZTtcbiAgICByZXR1cm4gY3JlYXRlVk5vZGUoXCJzbG90XCIsIHByb3BzLCBmYWxsYmFjayAmJiBmYWxsYmFjaygpKTtcbiAgfVxuICBsZXQgc2xvdCA9IHNsb3RzW25hbWVdO1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBzbG90ICYmIHNsb3QubGVuZ3RoID4gMSkge1xuICAgIHdhcm4oXG4gICAgICBgU1NSLW9wdGltaXplZCBzbG90IGZ1bmN0aW9uIGRldGVjdGVkIGluIGEgbm9uLVNTUi1vcHRpbWl6ZWQgcmVuZGVyIGZ1bmN0aW9uLiBZb3UgbmVlZCB0byBtYXJrIHRoaXMgY29tcG9uZW50IHdpdGggJGR5bmFtaWMtc2xvdHMgaW4gdGhlIHBhcmVudCB0ZW1wbGF0ZS5gXG4gICAgKTtcbiAgICBzbG90ID0gKCkgPT4gW107XG4gIH1cbiAgaWYgKHNsb3QgJiYgc2xvdC5fYykge1xuICAgIHNsb3QuX2QgPSBmYWxzZTtcbiAgfVxuICBvcGVuQmxvY2soKTtcbiAgY29uc3QgdmFsaWRTbG90Q29udGVudCA9IHNsb3QgJiYgZW5zdXJlVmFsaWRWTm9kZShzbG90KHByb3BzKSk7XG4gIGNvbnN0IHJlbmRlcmVkID0gY3JlYXRlQmxvY2soXG4gICAgRnJhZ21lbnQsXG4gICAge1xuICAgICAga2V5OiBwcm9wcy5rZXkgfHwgLy8gc2xvdCBjb250ZW50IGFycmF5IG9mIGEgZHluYW1pYyBjb25kaXRpb25hbCBzbG90IG1heSBoYXZlIGEgYnJhbmNoXG4gICAgICAvLyBrZXkgYXR0YWNoZWQgaW4gdGhlIGBjcmVhdGVTbG90c2AgaGVscGVyLCByZXNwZWN0IHRoYXRcbiAgICAgIHZhbGlkU2xvdENvbnRlbnQgJiYgdmFsaWRTbG90Q29udGVudC5rZXkgfHwgYF8ke25hbWV9YFxuICAgIH0sXG4gICAgdmFsaWRTbG90Q29udGVudCB8fCAoZmFsbGJhY2sgPyBmYWxsYmFjaygpIDogW10pLFxuICAgIHZhbGlkU2xvdENvbnRlbnQgJiYgc2xvdHMuXyA9PT0gMSA/IDY0IDogLTJcbiAgKTtcbiAgaWYgKCFub1Nsb3R0ZWQgJiYgcmVuZGVyZWQuc2NvcGVJZCkge1xuICAgIHJlbmRlcmVkLnNsb3RTY29wZUlkcyA9IFtyZW5kZXJlZC5zY29wZUlkICsgXCItc1wiXTtcbiAgfVxuICBpZiAoc2xvdCAmJiBzbG90Ll9jKSB7XG4gICAgc2xvdC5fZCA9IHRydWU7XG4gIH1cbiAgcmV0dXJuIHJlbmRlcmVkO1xufVxuZnVuY3Rpb24gZW5zdXJlVmFsaWRWTm9kZSh2bm9kZXMpIHtcbiAgcmV0dXJuIHZub2Rlcy5zb21lKChjaGlsZCkgPT4ge1xuICAgIGlmICghaXNWTm9kZShjaGlsZCkpXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoY2hpbGQudHlwZSA9PT0gQ29tbWVudClcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoY2hpbGQudHlwZSA9PT0gRnJhZ21lbnQgJiYgIWVuc3VyZVZhbGlkVk5vZGUoY2hpbGQuY2hpbGRyZW4pKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xuICB9KSA/IHZub2RlcyA6IG51bGw7XG59XG5cbmZ1bmN0aW9uIHRvSGFuZGxlcnMob2JqLCBwcmVzZXJ2ZUNhc2VJZk5lY2Vzc2FyeSkge1xuICBjb25zdCByZXQgPSB7fTtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgIWlzT2JqZWN0KG9iaikpIHtcbiAgICB3YXJuKGB2LW9uIHdpdGggbm8gYXJndW1lbnQgZXhwZWN0cyBhbiBvYmplY3QgdmFsdWUuYCk7XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuICBmb3IgKGNvbnN0IGtleSBpbiBvYmopIHtcbiAgICByZXRbcHJlc2VydmVDYXNlSWZOZWNlc3NhcnkgJiYgL1tBLVpdLy50ZXN0KGtleSkgPyBgb246JHtrZXl9YCA6IHRvSGFuZGxlcktleShrZXkpXSA9IG9ialtrZXldO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbmNvbnN0IGdldFB1YmxpY0luc3RhbmNlID0gKGkpID0+IHtcbiAgaWYgKCFpKVxuICAgIHJldHVybiBudWxsO1xuICBpZiAoaXNTdGF0ZWZ1bENvbXBvbmVudChpKSlcbiAgICByZXR1cm4gZ2V0RXhwb3NlUHJveHkoaSkgfHwgaS5wcm94eTtcbiAgcmV0dXJuIGdldFB1YmxpY0luc3RhbmNlKGkucGFyZW50KTtcbn07XG5jb25zdCBwdWJsaWNQcm9wZXJ0aWVzTWFwID0gKFxuICAvLyBNb3ZlIFBVUkUgbWFya2VyIHRvIG5ldyBsaW5lIHRvIHdvcmthcm91bmQgY29tcGlsZXIgZGlzY2FyZGluZyBpdFxuICAvLyBkdWUgdG8gdHlwZSBhbm5vdGF0aW9uXG4gIC8qIEBfX1BVUkVfXyAqLyBleHRlbmQoLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCksIHtcbiAgICAkOiAoaSkgPT4gaSxcbiAgICAkZWw6IChpKSA9PiBpLnZub2RlLmVsLFxuICAgICRkYXRhOiAoaSkgPT4gaS5kYXRhLFxuICAgICRwcm9wczogKGkpID0+ICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyBzaGFsbG93UmVhZG9ubHkoaS5wcm9wcykgOiBpLnByb3BzLFxuICAgICRhdHRyczogKGkpID0+ICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyBzaGFsbG93UmVhZG9ubHkoaS5hdHRycykgOiBpLmF0dHJzLFxuICAgICRzbG90czogKGkpID0+ICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyBzaGFsbG93UmVhZG9ubHkoaS5zbG90cykgOiBpLnNsb3RzLFxuICAgICRyZWZzOiAoaSkgPT4gISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IHNoYWxsb3dSZWFkb25seShpLnJlZnMpIDogaS5yZWZzLFxuICAgICRwYXJlbnQ6IChpKSA9PiBnZXRQdWJsaWNJbnN0YW5jZShpLnBhcmVudCksXG4gICAgJHJvb3Q6IChpKSA9PiBnZXRQdWJsaWNJbnN0YW5jZShpLnJvb3QpLFxuICAgICRlbWl0OiAoaSkgPT4gaS5lbWl0LFxuICAgICRvcHRpb25zOiAoaSkgPT4gX19WVUVfT1BUSU9OU19BUElfXyA/IHJlc29sdmVNZXJnZWRPcHRpb25zKGkpIDogaS50eXBlLFxuICAgICRmb3JjZVVwZGF0ZTogKGkpID0+IGkuZiB8fCAoaS5mID0gKCkgPT4gcXVldWVKb2IoaS51cGRhdGUpKSxcbiAgICAkbmV4dFRpY2s6IChpKSA9PiBpLm4gfHwgKGkubiA9IG5leHRUaWNrLmJpbmQoaS5wcm94eSkpLFxuICAgICR3YXRjaDogKGkpID0+IF9fVlVFX09QVElPTlNfQVBJX18gPyBpbnN0YW5jZVdhdGNoLmJpbmQoaSkgOiBOT09QXG4gIH0pXG4pO1xuY29uc3QgaXNSZXNlcnZlZFByZWZpeCA9IChrZXkpID0+IGtleSA9PT0gXCJfXCIgfHwga2V5ID09PSBcIiRcIjtcbmNvbnN0IGhhc1NldHVwQmluZGluZyA9IChzdGF0ZSwga2V5KSA9PiBzdGF0ZSAhPT0gRU1QVFlfT0JKICYmICFzdGF0ZS5fX2lzU2NyaXB0U2V0dXAgJiYgaGFzT3duKHN0YXRlLCBrZXkpO1xuY29uc3QgUHVibGljSW5zdGFuY2VQcm94eUhhbmRsZXJzID0ge1xuICBnZXQoeyBfOiBpbnN0YW5jZSB9LCBrZXkpIHtcbiAgICBjb25zdCB7IGN0eCwgc2V0dXBTdGF0ZSwgZGF0YSwgcHJvcHMsIGFjY2Vzc0NhY2hlLCB0eXBlLCBhcHBDb250ZXh0IH0gPSBpbnN0YW5jZTtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBrZXkgPT09IFwiX19pc1Z1ZVwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgbGV0IG5vcm1hbGl6ZWRQcm9wcztcbiAgICBpZiAoa2V5WzBdICE9PSBcIiRcIikge1xuICAgICAgY29uc3QgbiA9IGFjY2Vzc0NhY2hlW2tleV07XG4gICAgICBpZiAobiAhPT0gdm9pZCAwKSB7XG4gICAgICAgIHN3aXRjaCAobikge1xuICAgICAgICAgIGNhc2UgMSAvKiBTRVRVUCAqLzpcbiAgICAgICAgICAgIHJldHVybiBzZXR1cFN0YXRlW2tleV07XG4gICAgICAgICAgY2FzZSAyIC8qIERBVEEgKi86XG4gICAgICAgICAgICByZXR1cm4gZGF0YVtrZXldO1xuICAgICAgICAgIGNhc2UgNCAvKiBDT05URVhUICovOlxuICAgICAgICAgICAgcmV0dXJuIGN0eFtrZXldO1xuICAgICAgICAgIGNhc2UgMyAvKiBQUk9QUyAqLzpcbiAgICAgICAgICAgIHJldHVybiBwcm9wc1trZXldO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGhhc1NldHVwQmluZGluZyhzZXR1cFN0YXRlLCBrZXkpKSB7XG4gICAgICAgIGFjY2Vzc0NhY2hlW2tleV0gPSAxIC8qIFNFVFVQICovO1xuICAgICAgICByZXR1cm4gc2V0dXBTdGF0ZVtrZXldO1xuICAgICAgfSBlbHNlIGlmIChkYXRhICE9PSBFTVBUWV9PQkogJiYgaGFzT3duKGRhdGEsIGtleSkpIHtcbiAgICAgICAgYWNjZXNzQ2FjaGVba2V5XSA9IDIgLyogREFUQSAqLztcbiAgICAgICAgcmV0dXJuIGRhdGFba2V5XTtcbiAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgIC8vIG9ubHkgY2FjaGUgb3RoZXIgcHJvcGVydGllcyB3aGVuIGluc3RhbmNlIGhhcyBkZWNsYXJlZCAodGh1cyBzdGFibGUpXG4gICAgICAgIC8vIHByb3BzXG4gICAgICAgIChub3JtYWxpemVkUHJvcHMgPSBpbnN0YW5jZS5wcm9wc09wdGlvbnNbMF0pICYmIGhhc093bihub3JtYWxpemVkUHJvcHMsIGtleSlcbiAgICAgICkge1xuICAgICAgICBhY2Nlc3NDYWNoZVtrZXldID0gMyAvKiBQUk9QUyAqLztcbiAgICAgICAgcmV0dXJuIHByb3BzW2tleV07XG4gICAgICB9IGVsc2UgaWYgKGN0eCAhPT0gRU1QVFlfT0JKICYmIGhhc093bihjdHgsIGtleSkpIHtcbiAgICAgICAgYWNjZXNzQ2FjaGVba2V5XSA9IDQgLyogQ09OVEVYVCAqLztcbiAgICAgICAgcmV0dXJuIGN0eFtrZXldO1xuICAgICAgfSBlbHNlIGlmICghX19WVUVfT1BUSU9OU19BUElfXyB8fCBzaG91bGRDYWNoZUFjY2Vzcykge1xuICAgICAgICBhY2Nlc3NDYWNoZVtrZXldID0gMCAvKiBPVEhFUiAqLztcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgcHVibGljR2V0dGVyID0gcHVibGljUHJvcGVydGllc01hcFtrZXldO1xuICAgIGxldCBjc3NNb2R1bGUsIGdsb2JhbFByb3BlcnRpZXM7XG4gICAgaWYgKHB1YmxpY0dldHRlcikge1xuICAgICAgaWYgKGtleSA9PT0gXCIkYXR0cnNcIikge1xuICAgICAgICB0cmFjayhpbnN0YW5jZSwgXCJnZXRcIiwga2V5KTtcbiAgICAgICAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBtYXJrQXR0cnNBY2Nlc3NlZCgpO1xuICAgICAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGtleSA9PT0gXCIkc2xvdHNcIikge1xuICAgICAgICB0cmFjayhpbnN0YW5jZSwgXCJnZXRcIiwga2V5KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwdWJsaWNHZXR0ZXIoaW5zdGFuY2UpO1xuICAgIH0gZWxzZSBpZiAoXG4gICAgICAvLyBjc3MgbW9kdWxlIChpbmplY3RlZCBieSB2dWUtbG9hZGVyKVxuICAgICAgKGNzc01vZHVsZSA9IHR5cGUuX19jc3NNb2R1bGVzKSAmJiAoY3NzTW9kdWxlID0gY3NzTW9kdWxlW2tleV0pXG4gICAgKSB7XG4gICAgICByZXR1cm4gY3NzTW9kdWxlO1xuICAgIH0gZWxzZSBpZiAoY3R4ICE9PSBFTVBUWV9PQkogJiYgaGFzT3duKGN0eCwga2V5KSkge1xuICAgICAgYWNjZXNzQ2FjaGVba2V5XSA9IDQgLyogQ09OVEVYVCAqLztcbiAgICAgIHJldHVybiBjdHhba2V5XTtcbiAgICB9IGVsc2UgaWYgKFxuICAgICAgLy8gZ2xvYmFsIHByb3BlcnRpZXNcbiAgICAgIGdsb2JhbFByb3BlcnRpZXMgPSBhcHBDb250ZXh0LmNvbmZpZy5nbG9iYWxQcm9wZXJ0aWVzLCBoYXNPd24oZ2xvYmFsUHJvcGVydGllcywga2V5KVxuICAgICkge1xuICAgICAge1xuICAgICAgICByZXR1cm4gZ2xvYmFsUHJvcGVydGllc1trZXldO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UgJiYgKCFpc1N0cmluZyhrZXkpIHx8IC8vICMxMDkxIGF2b2lkIGludGVybmFsIGlzUmVmL2lzVk5vZGUgY2hlY2tzIG9uIGNvbXBvbmVudCBpbnN0YW5jZSBsZWFkaW5nXG4gICAgLy8gdG8gaW5maW5pdGUgd2FybmluZyBsb29wXG4gICAga2V5LmluZGV4T2YoXCJfX3ZcIikgIT09IDApKSB7XG4gICAgICBpZiAoZGF0YSAhPT0gRU1QVFlfT0JKICYmIGlzUmVzZXJ2ZWRQcmVmaXgoa2V5WzBdKSAmJiBoYXNPd24oZGF0YSwga2V5KSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIGBQcm9wZXJ0eSAke0pTT04uc3RyaW5naWZ5KFxuICAgICAgICAgICAga2V5XG4gICAgICAgICAgKX0gbXVzdCBiZSBhY2Nlc3NlZCB2aWEgJGRhdGEgYmVjYXVzZSBpdCBzdGFydHMgd2l0aCBhIHJlc2VydmVkIGNoYXJhY3RlciAoXCIkXCIgb3IgXCJfXCIpIGFuZCBpcyBub3QgcHJveGllZCBvbiB0aGUgcmVuZGVyIGNvbnRleHQuYFxuICAgICAgICApO1xuICAgICAgfSBlbHNlIGlmIChpbnN0YW5jZSA9PT0gY3VycmVudFJlbmRlcmluZ0luc3RhbmNlKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgYFByb3BlcnR5ICR7SlNPTi5zdHJpbmdpZnkoa2V5KX0gd2FzIGFjY2Vzc2VkIGR1cmluZyByZW5kZXIgYnV0IGlzIG5vdCBkZWZpbmVkIG9uIGluc3RhbmNlLmBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIHNldCh7IF86IGluc3RhbmNlIH0sIGtleSwgdmFsdWUpIHtcbiAgICBjb25zdCB7IGRhdGEsIHNldHVwU3RhdGUsIGN0eCB9ID0gaW5zdGFuY2U7XG4gICAgaWYgKGhhc1NldHVwQmluZGluZyhzZXR1cFN0YXRlLCBrZXkpKSB7XG4gICAgICBzZXR1cFN0YXRlW2tleV0gPSB2YWx1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBzZXR1cFN0YXRlLl9faXNTY3JpcHRTZXR1cCAmJiBoYXNPd24oc2V0dXBTdGF0ZSwga2V5KSkge1xuICAgICAgd2FybihgQ2Fubm90IG11dGF0ZSA8c2NyaXB0IHNldHVwPiBiaW5kaW5nIFwiJHtrZXl9XCIgZnJvbSBPcHRpb25zIEFQSS5gKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKGRhdGEgIT09IEVNUFRZX09CSiAmJiBoYXNPd24oZGF0YSwga2V5KSkge1xuICAgICAgZGF0YVtrZXldID0gdmFsdWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKGhhc093bihpbnN0YW5jZS5wcm9wcywga2V5KSkge1xuICAgICAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiB3YXJuKGBBdHRlbXB0aW5nIHRvIG11dGF0ZSBwcm9wIFwiJHtrZXl9XCIuIFByb3BzIGFyZSByZWFkb25seS5gKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGtleVswXSA9PT0gXCIkXCIgJiYga2V5LnNsaWNlKDEpIGluIGluc3RhbmNlKSB7XG4gICAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHdhcm4oXG4gICAgICAgIGBBdHRlbXB0aW5nIHRvIG11dGF0ZSBwdWJsaWMgcHJvcGVydHkgXCIke2tleX1cIi4gUHJvcGVydGllcyBzdGFydGluZyB3aXRoICQgYXJlIHJlc2VydmVkIGFuZCByZWFkb25seS5gXG4gICAgICApO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBrZXkgaW4gaW5zdGFuY2UuYXBwQ29udGV4dC5jb25maWcuZ2xvYmFsUHJvcGVydGllcykge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3R4LCBrZXksIHtcbiAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICB2YWx1ZVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN0eFtrZXldID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9LFxuICBoYXMoe1xuICAgIF86IHsgZGF0YSwgc2V0dXBTdGF0ZSwgYWNjZXNzQ2FjaGUsIGN0eCwgYXBwQ29udGV4dCwgcHJvcHNPcHRpb25zIH1cbiAgfSwga2V5KSB7XG4gICAgbGV0IG5vcm1hbGl6ZWRQcm9wcztcbiAgICByZXR1cm4gISFhY2Nlc3NDYWNoZVtrZXldIHx8IGRhdGEgIT09IEVNUFRZX09CSiAmJiBoYXNPd24oZGF0YSwga2V5KSB8fCBoYXNTZXR1cEJpbmRpbmcoc2V0dXBTdGF0ZSwga2V5KSB8fCAobm9ybWFsaXplZFByb3BzID0gcHJvcHNPcHRpb25zWzBdKSAmJiBoYXNPd24obm9ybWFsaXplZFByb3BzLCBrZXkpIHx8IGhhc093bihjdHgsIGtleSkgfHwgaGFzT3duKHB1YmxpY1Byb3BlcnRpZXNNYXAsIGtleSkgfHwgaGFzT3duKGFwcENvbnRleHQuY29uZmlnLmdsb2JhbFByb3BlcnRpZXMsIGtleSk7XG4gIH0sXG4gIGRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBkZXNjcmlwdG9yKSB7XG4gICAgaWYgKGRlc2NyaXB0b3IuZ2V0ICE9IG51bGwpIHtcbiAgICAgIHRhcmdldC5fLmFjY2Vzc0NhY2hlW2tleV0gPSAwO1xuICAgIH0gZWxzZSBpZiAoaGFzT3duKGRlc2NyaXB0b3IsIFwidmFsdWVcIikpIHtcbiAgICAgIHRoaXMuc2V0KHRhcmdldCwga2V5LCBkZXNjcmlwdG9yLnZhbHVlLCBudWxsKTtcbiAgICB9XG4gICAgcmV0dXJuIFJlZmxlY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIGRlc2NyaXB0b3IpO1xuICB9XG59O1xuaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgdHJ1ZSkge1xuICBQdWJsaWNJbnN0YW5jZVByb3h5SGFuZGxlcnMub3duS2V5cyA9ICh0YXJnZXQpID0+IHtcbiAgICB3YXJuKFxuICAgICAgYEF2b2lkIGFwcCBsb2dpYyB0aGF0IHJlbGllcyBvbiBlbnVtZXJhdGluZyBrZXlzIG9uIGEgY29tcG9uZW50IGluc3RhbmNlLiBUaGUga2V5cyB3aWxsIGJlIGVtcHR5IGluIHByb2R1Y3Rpb24gbW9kZSB0byBhdm9pZCBwZXJmb3JtYW5jZSBvdmVyaGVhZC5gXG4gICAgKTtcbiAgICByZXR1cm4gUmVmbGVjdC5vd25LZXlzKHRhcmdldCk7XG4gIH07XG59XG5jb25zdCBSdW50aW1lQ29tcGlsZWRQdWJsaWNJbnN0YW5jZVByb3h5SGFuZGxlcnMgPSAvKiBAX19QVVJFX18gKi8gZXh0ZW5kKFxuICB7fSxcbiAgUHVibGljSW5zdGFuY2VQcm94eUhhbmRsZXJzLFxuICB7XG4gICAgZ2V0KHRhcmdldCwga2V5KSB7XG4gICAgICBpZiAoa2V5ID09PSBTeW1ib2wudW5zY29wYWJsZXMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFB1YmxpY0luc3RhbmNlUHJveHlIYW5kbGVycy5nZXQodGFyZ2V0LCBrZXksIHRhcmdldCk7XG4gICAgfSxcbiAgICBoYXMoXywga2V5KSB7XG4gICAgICBjb25zdCBoYXMgPSBrZXlbMF0gIT09IFwiX1wiICYmICFpc0dsb2JhbGx5V2hpdGVsaXN0ZWQoa2V5KTtcbiAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICFoYXMgJiYgUHVibGljSW5zdGFuY2VQcm94eUhhbmRsZXJzLmhhcyhfLCBrZXkpKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgYFByb3BlcnR5ICR7SlNPTi5zdHJpbmdpZnkoXG4gICAgICAgICAgICBrZXlcbiAgICAgICAgICApfSBzaG91bGQgbm90IHN0YXJ0IHdpdGggXyB3aGljaCBpcyBhIHJlc2VydmVkIHByZWZpeCBmb3IgVnVlIGludGVybmFscy5gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gaGFzO1xuICAgIH1cbiAgfVxuKTtcbmZ1bmN0aW9uIGNyZWF0ZURldlJlbmRlckNvbnRleHQoaW5zdGFuY2UpIHtcbiAgY29uc3QgdGFyZ2V0ID0ge307XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGBfYCwge1xuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBnZXQ6ICgpID0+IGluc3RhbmNlXG4gIH0pO1xuICBPYmplY3Qua2V5cyhwdWJsaWNQcm9wZXJ0aWVzTWFwKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgZ2V0OiAoKSA9PiBwdWJsaWNQcm9wZXJ0aWVzTWFwW2tleV0oaW5zdGFuY2UpLFxuICAgICAgLy8gaW50ZXJjZXB0ZWQgYnkgdGhlIHByb3h5IHNvIG5vIG5lZWQgZm9yIGltcGxlbWVudGF0aW9uLFxuICAgICAgLy8gYnV0IG5lZWRlZCB0byBwcmV2ZW50IHNldCBlcnJvcnNcbiAgICAgIHNldDogTk9PUFxuICAgIH0pO1xuICB9KTtcbiAgcmV0dXJuIHRhcmdldDtcbn1cbmZ1bmN0aW9uIGV4cG9zZVByb3BzT25SZW5kZXJDb250ZXh0KGluc3RhbmNlKSB7XG4gIGNvbnN0IHtcbiAgICBjdHgsXG4gICAgcHJvcHNPcHRpb25zOiBbcHJvcHNPcHRpb25zXVxuICB9ID0gaW5zdGFuY2U7XG4gIGlmIChwcm9wc09wdGlvbnMpIHtcbiAgICBPYmplY3Qua2V5cyhwcm9wc09wdGlvbnMpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN0eCwga2V5LCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiAoKSA9PiBpbnN0YW5jZS5wcm9wc1trZXldLFxuICAgICAgICBzZXQ6IE5PT1BcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiBleHBvc2VTZXR1cFN0YXRlT25SZW5kZXJDb250ZXh0KGluc3RhbmNlKSB7XG4gIGNvbnN0IHsgY3R4LCBzZXR1cFN0YXRlIH0gPSBpbnN0YW5jZTtcbiAgT2JqZWN0LmtleXModG9SYXcoc2V0dXBTdGF0ZSkpLmZvckVhY2goKGtleSkgPT4ge1xuICAgIGlmICghc2V0dXBTdGF0ZS5fX2lzU2NyaXB0U2V0dXApIHtcbiAgICAgIGlmIChpc1Jlc2VydmVkUHJlZml4KGtleVswXSkpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBgc2V0dXAoKSByZXR1cm4gcHJvcGVydHkgJHtKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICAgIGtleVxuICAgICAgICAgICl9IHNob3VsZCBub3Qgc3RhcnQgd2l0aCBcIiRcIiBvciBcIl9cIiB3aGljaCBhcmUgcmVzZXJ2ZWQgcHJlZml4ZXMgZm9yIFZ1ZSBpbnRlcm5hbHMuYFxuICAgICAgICApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3R4LCBrZXksIHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6ICgpID0+IHNldHVwU3RhdGVba2V5XSxcbiAgICAgICAgc2V0OiBOT09QXG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xufVxuXG5jb25zdCB3YXJuUnVudGltZVVzYWdlID0gKG1ldGhvZCkgPT4gd2FybihcbiAgYCR7bWV0aG9kfSgpIGlzIGEgY29tcGlsZXItaGludCBoZWxwZXIgdGhhdCBpcyBvbmx5IHVzYWJsZSBpbnNpZGUgPHNjcmlwdCBzZXR1cD4gb2YgYSBzaW5nbGUgZmlsZSBjb21wb25lbnQuIEl0cyBhcmd1bWVudHMgc2hvdWxkIGJlIGNvbXBpbGVkIGF3YXkgYW5kIHBhc3NpbmcgaXQgYXQgcnVudGltZSBoYXMgbm8gZWZmZWN0LmBcbik7XG5mdW5jdGlvbiBkZWZpbmVQcm9wcygpIHtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICB3YXJuUnVudGltZVVzYWdlKGBkZWZpbmVQcm9wc2ApO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gZGVmaW5lRW1pdHMoKSB7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgd2FyblJ1bnRpbWVVc2FnZShgZGVmaW5lRW1pdHNgKTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGRlZmluZUV4cG9zZShleHBvc2VkKSB7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgd2FyblJ1bnRpbWVVc2FnZShgZGVmaW5lRXhwb3NlYCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGRlZmluZU9wdGlvbnMob3B0aW9ucykge1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIHdhcm5SdW50aW1lVXNhZ2UoYGRlZmluZU9wdGlvbnNgKTtcbiAgfVxufVxuZnVuY3Rpb24gZGVmaW5lU2xvdHMoKSB7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgd2FyblJ1bnRpbWVVc2FnZShgZGVmaW5lU2xvdHNgKTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGRlZmluZU1vZGVsKCkge1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIHdhcm5SdW50aW1lVXNhZ2UoXCJkZWZpbmVNb2RlbFwiKTtcbiAgfVxufVxuZnVuY3Rpb24gd2l0aERlZmF1bHRzKHByb3BzLCBkZWZhdWx0cykge1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIHdhcm5SdW50aW1lVXNhZ2UoYHdpdGhEZWZhdWx0c2ApO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gdXNlU2xvdHMoKSB7XG4gIHJldHVybiBnZXRDb250ZXh0KCkuc2xvdHM7XG59XG5mdW5jdGlvbiB1c2VBdHRycygpIHtcbiAgcmV0dXJuIGdldENvbnRleHQoKS5hdHRycztcbn1cbmZ1bmN0aW9uIHVzZU1vZGVsKHByb3BzLCBuYW1lLCBvcHRpb25zKSB7XG4gIGNvbnN0IGkgPSBnZXRDdXJyZW50SW5zdGFuY2UoKTtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgIWkpIHtcbiAgICB3YXJuKGB1c2VNb2RlbCgpIGNhbGxlZCB3aXRob3V0IGFjdGl2ZSBpbnN0YW5jZS5gKTtcbiAgICByZXR1cm4gcmVmKCk7XG4gIH1cbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgIWkucHJvcHNPcHRpb25zWzBdW25hbWVdKSB7XG4gICAgd2FybihgdXNlTW9kZWwoKSBjYWxsZWQgd2l0aCBwcm9wIFwiJHtuYW1lfVwiIHdoaWNoIGlzIG5vdCBkZWNsYXJlZC5gKTtcbiAgICByZXR1cm4gcmVmKCk7XG4gIH1cbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5sb2NhbCkge1xuICAgIGNvbnN0IHByb3h5ID0gcmVmKHByb3BzW25hbWVdKTtcbiAgICB3YXRjaChcbiAgICAgICgpID0+IHByb3BzW25hbWVdLFxuICAgICAgKHYpID0+IHByb3h5LnZhbHVlID0gdlxuICAgICk7XG4gICAgd2F0Y2gocHJveHksICh2YWx1ZSkgPT4ge1xuICAgICAgaWYgKHZhbHVlICE9PSBwcm9wc1tuYW1lXSkge1xuICAgICAgICBpLmVtaXQoYHVwZGF0ZToke25hbWV9YCwgdmFsdWUpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBwcm94eTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4ge1xuICAgICAgX192X2lzUmVmOiB0cnVlLFxuICAgICAgZ2V0IHZhbHVlKCkge1xuICAgICAgICByZXR1cm4gcHJvcHNbbmFtZV07XG4gICAgICB9LFxuICAgICAgc2V0IHZhbHVlKHZhbHVlKSB7XG4gICAgICAgIGkuZW1pdChgdXBkYXRlOiR7bmFtZX1gLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0Q29udGV4dCgpIHtcbiAgY29uc3QgaSA9IGdldEN1cnJlbnRJbnN0YW5jZSgpO1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhaSkge1xuICAgIHdhcm4oYHVzZUNvbnRleHQoKSBjYWxsZWQgd2l0aG91dCBhY3RpdmUgaW5zdGFuY2UuYCk7XG4gIH1cbiAgcmV0dXJuIGkuc2V0dXBDb250ZXh0IHx8IChpLnNldHVwQ29udGV4dCA9IGNyZWF0ZVNldHVwQ29udGV4dChpKSk7XG59XG5mdW5jdGlvbiBub3JtYWxpemVQcm9wc09yRW1pdHMocHJvcHMpIHtcbiAgcmV0dXJuIGlzQXJyYXkocHJvcHMpID8gcHJvcHMucmVkdWNlKFxuICAgIChub3JtYWxpemVkLCBwKSA9PiAobm9ybWFsaXplZFtwXSA9IG51bGwsIG5vcm1hbGl6ZWQpLFxuICAgIHt9XG4gICkgOiBwcm9wcztcbn1cbmZ1bmN0aW9uIG1lcmdlRGVmYXVsdHMocmF3LCBkZWZhdWx0cykge1xuICBjb25zdCBwcm9wcyA9IG5vcm1hbGl6ZVByb3BzT3JFbWl0cyhyYXcpO1xuICBmb3IgKGNvbnN0IGtleSBpbiBkZWZhdWx0cykge1xuICAgIGlmIChrZXkuc3RhcnRzV2l0aChcIl9fc2tpcFwiKSlcbiAgICAgIGNvbnRpbnVlO1xuICAgIGxldCBvcHQgPSBwcm9wc1trZXldO1xuICAgIGlmIChvcHQpIHtcbiAgICAgIGlmIChpc0FycmF5KG9wdCkgfHwgaXNGdW5jdGlvbihvcHQpKSB7XG4gICAgICAgIG9wdCA9IHByb3BzW2tleV0gPSB7IHR5cGU6IG9wdCwgZGVmYXVsdDogZGVmYXVsdHNba2V5XSB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3B0LmRlZmF1bHQgPSBkZWZhdWx0c1trZXldO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAob3B0ID09PSBudWxsKSB7XG4gICAgICBvcHQgPSBwcm9wc1trZXldID0geyBkZWZhdWx0OiBkZWZhdWx0c1trZXldIH07XG4gICAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICB3YXJuKGBwcm9wcyBkZWZhdWx0IGtleSBcIiR7a2V5fVwiIGhhcyBubyBjb3JyZXNwb25kaW5nIGRlY2xhcmF0aW9uLmApO1xuICAgIH1cbiAgICBpZiAob3B0ICYmIGRlZmF1bHRzW2BfX3NraXBfJHtrZXl9YF0pIHtcbiAgICAgIG9wdC5za2lwRmFjdG9yeSA9IHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBwcm9wcztcbn1cbmZ1bmN0aW9uIG1lcmdlTW9kZWxzKGEsIGIpIHtcbiAgaWYgKCFhIHx8ICFiKVxuICAgIHJldHVybiBhIHx8IGI7XG4gIGlmIChpc0FycmF5KGEpICYmIGlzQXJyYXkoYikpXG4gICAgcmV0dXJuIGEuY29uY2F0KGIpO1xuICByZXR1cm4gZXh0ZW5kKHt9LCBub3JtYWxpemVQcm9wc09yRW1pdHMoYSksIG5vcm1hbGl6ZVByb3BzT3JFbWl0cyhiKSk7XG59XG5mdW5jdGlvbiBjcmVhdGVQcm9wc1Jlc3RQcm94eShwcm9wcywgZXhjbHVkZWRLZXlzKSB7XG4gIGNvbnN0IHJldCA9IHt9O1xuICBmb3IgKGNvbnN0IGtleSBpbiBwcm9wcykge1xuICAgIGlmICghZXhjbHVkZWRLZXlzLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXQsIGtleSwge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6ICgpID0+IHByb3BzW2tleV1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmV0O1xufVxuZnVuY3Rpb24gd2l0aEFzeW5jQ29udGV4dChnZXRBd2FpdGFibGUpIHtcbiAgY29uc3QgY3R4ID0gZ2V0Q3VycmVudEluc3RhbmNlKCk7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICFjdHgpIHtcbiAgICB3YXJuKFxuICAgICAgYHdpdGhBc3luY0NvbnRleHQgY2FsbGVkIHdpdGhvdXQgYWN0aXZlIGN1cnJlbnQgaW5zdGFuY2UuIFRoaXMgaXMgbGlrZWx5IGEgYnVnLmBcbiAgICApO1xuICB9XG4gIGxldCBhd2FpdGFibGUgPSBnZXRBd2FpdGFibGUoKTtcbiAgdW5zZXRDdXJyZW50SW5zdGFuY2UoKTtcbiAgaWYgKGlzUHJvbWlzZShhd2FpdGFibGUpKSB7XG4gICAgYXdhaXRhYmxlID0gYXdhaXRhYmxlLmNhdGNoKChlKSA9PiB7XG4gICAgICBzZXRDdXJyZW50SW5zdGFuY2UoY3R4KTtcbiAgICAgIHRocm93IGU7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIFthd2FpdGFibGUsICgpID0+IHNldEN1cnJlbnRJbnN0YW5jZShjdHgpXTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRHVwbGljYXRlQ2hlY2tlcigpIHtcbiAgY29uc3QgY2FjaGUgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgcmV0dXJuICh0eXBlLCBrZXkpID0+IHtcbiAgICBpZiAoY2FjaGVba2V5XSkge1xuICAgICAgd2FybihgJHt0eXBlfSBwcm9wZXJ0eSBcIiR7a2V5fVwiIGlzIGFscmVhZHkgZGVmaW5lZCBpbiAke2NhY2hlW2tleV19LmApO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYWNoZVtrZXldID0gdHlwZTtcbiAgICB9XG4gIH07XG59XG5sZXQgc2hvdWxkQ2FjaGVBY2Nlc3MgPSB0cnVlO1xuZnVuY3Rpb24gYXBwbHlPcHRpb25zKGluc3RhbmNlKSB7XG4gIGNvbnN0IG9wdGlvbnMgPSByZXNvbHZlTWVyZ2VkT3B0aW9ucyhpbnN0YW5jZSk7XG4gIGNvbnN0IHB1YmxpY1RoaXMgPSBpbnN0YW5jZS5wcm94eTtcbiAgY29uc3QgY3R4ID0gaW5zdGFuY2UuY3R4O1xuICBzaG91bGRDYWNoZUFjY2VzcyA9IGZhbHNlO1xuICBpZiAob3B0aW9ucy5iZWZvcmVDcmVhdGUpIHtcbiAgICBjYWxsSG9vayhvcHRpb25zLmJlZm9yZUNyZWF0ZSwgaW5zdGFuY2UsIFwiYmNcIik7XG4gIH1cbiAgY29uc3Qge1xuICAgIC8vIHN0YXRlXG4gICAgZGF0YTogZGF0YU9wdGlvbnMsXG4gICAgY29tcHV0ZWQ6IGNvbXB1dGVkT3B0aW9ucyxcbiAgICBtZXRob2RzLFxuICAgIHdhdGNoOiB3YXRjaE9wdGlvbnMsXG4gICAgcHJvdmlkZTogcHJvdmlkZU9wdGlvbnMsXG4gICAgaW5qZWN0OiBpbmplY3RPcHRpb25zLFxuICAgIC8vIGxpZmVjeWNsZVxuICAgIGNyZWF0ZWQsXG4gICAgYmVmb3JlTW91bnQsXG4gICAgbW91bnRlZCxcbiAgICBiZWZvcmVVcGRhdGUsXG4gICAgdXBkYXRlZCxcbiAgICBhY3RpdmF0ZWQsXG4gICAgZGVhY3RpdmF0ZWQsXG4gICAgYmVmb3JlRGVzdHJveSxcbiAgICBiZWZvcmVVbm1vdW50LFxuICAgIGRlc3Ryb3llZCxcbiAgICB1bm1vdW50ZWQsXG4gICAgcmVuZGVyLFxuICAgIHJlbmRlclRyYWNrZWQsXG4gICAgcmVuZGVyVHJpZ2dlcmVkLFxuICAgIGVycm9yQ2FwdHVyZWQsXG4gICAgc2VydmVyUHJlZmV0Y2gsXG4gICAgLy8gcHVibGljIEFQSVxuICAgIGV4cG9zZSxcbiAgICBpbmhlcml0QXR0cnMsXG4gICAgLy8gYXNzZXRzXG4gICAgY29tcG9uZW50cyxcbiAgICBkaXJlY3RpdmVzLFxuICAgIGZpbHRlcnNcbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IGNoZWNrRHVwbGljYXRlUHJvcGVydGllcyA9ICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyBjcmVhdGVEdXBsaWNhdGVDaGVja2VyKCkgOiBudWxsO1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIGNvbnN0IFtwcm9wc09wdGlvbnNdID0gaW5zdGFuY2UucHJvcHNPcHRpb25zO1xuICAgIGlmIChwcm9wc09wdGlvbnMpIHtcbiAgICAgIGZvciAoY29uc3Qga2V5IGluIHByb3BzT3B0aW9ucykge1xuICAgICAgICBjaGVja0R1cGxpY2F0ZVByb3BlcnRpZXMoXCJQcm9wc1wiIC8qIFBST1BTICovLCBrZXkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoaW5qZWN0T3B0aW9ucykge1xuICAgIHJlc29sdmVJbmplY3Rpb25zKGluamVjdE9wdGlvbnMsIGN0eCwgY2hlY2tEdXBsaWNhdGVQcm9wZXJ0aWVzKTtcbiAgfVxuICBpZiAobWV0aG9kcykge1xuICAgIGZvciAoY29uc3Qga2V5IGluIG1ldGhvZHMpIHtcbiAgICAgIGNvbnN0IG1ldGhvZEhhbmRsZXIgPSBtZXRob2RzW2tleV07XG4gICAgICBpZiAoaXNGdW5jdGlvbihtZXRob2RIYW5kbGVyKSkge1xuICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdHgsIGtleSwge1xuICAgICAgICAgICAgdmFsdWU6IG1ldGhvZEhhbmRsZXIuYmluZChwdWJsaWNUaGlzKSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN0eFtrZXldID0gbWV0aG9kSGFuZGxlci5iaW5kKHB1YmxpY1RoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgY2hlY2tEdXBsaWNhdGVQcm9wZXJ0aWVzKFwiTWV0aG9kc1wiIC8qIE1FVEhPRFMgKi8sIGtleSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIGBNZXRob2QgXCIke2tleX1cIiBoYXMgdHlwZSBcIiR7dHlwZW9mIG1ldGhvZEhhbmRsZXJ9XCIgaW4gdGhlIGNvbXBvbmVudCBkZWZpbml0aW9uLiBEaWQgeW91IHJlZmVyZW5jZSB0aGUgZnVuY3Rpb24gY29ycmVjdGx5P2BcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKGRhdGFPcHRpb25zKSB7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgIWlzRnVuY3Rpb24oZGF0YU9wdGlvbnMpKSB7XG4gICAgICB3YXJuKFxuICAgICAgICBgVGhlIGRhdGEgb3B0aW9uIG11c3QgYmUgYSBmdW5jdGlvbi4gUGxhaW4gb2JqZWN0IHVzYWdlIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQuYFxuICAgICAgKTtcbiAgICB9XG4gICAgY29uc3QgZGF0YSA9IGRhdGFPcHRpb25zLmNhbGwocHVibGljVGhpcywgcHVibGljVGhpcyk7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgaXNQcm9taXNlKGRhdGEpKSB7XG4gICAgICB3YXJuKFxuICAgICAgICBgZGF0YSgpIHJldHVybmVkIGEgUHJvbWlzZSAtIG5vdGUgZGF0YSgpIGNhbm5vdCBiZSBhc3luYzsgSWYgeW91IGludGVuZCB0byBwZXJmb3JtIGRhdGEgZmV0Y2hpbmcgYmVmb3JlIGNvbXBvbmVudCByZW5kZXJzLCB1c2UgYXN5bmMgc2V0dXAoKSArIDxTdXNwZW5zZT4uYFxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKCFpc09iamVjdChkYXRhKSkge1xuICAgICAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiB3YXJuKGBkYXRhKCkgc2hvdWxkIHJldHVybiBhbiBvYmplY3QuYCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGluc3RhbmNlLmRhdGEgPSByZWFjdGl2ZShkYXRhKTtcbiAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIGRhdGEpIHtcbiAgICAgICAgICBjaGVja0R1cGxpY2F0ZVByb3BlcnRpZXMoXCJEYXRhXCIgLyogREFUQSAqLywga2V5KTtcbiAgICAgICAgICBpZiAoIWlzUmVzZXJ2ZWRQcmVmaXgoa2V5WzBdKSkge1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN0eCwga2V5LCB7XG4gICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgZ2V0OiAoKSA9PiBkYXRhW2tleV0sXG4gICAgICAgICAgICAgIHNldDogTk9PUFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHNob3VsZENhY2hlQWNjZXNzID0gdHJ1ZTtcbiAgaWYgKGNvbXB1dGVkT3B0aW9ucykge1xuICAgIGZvciAoY29uc3Qga2V5IGluIGNvbXB1dGVkT3B0aW9ucykge1xuICAgICAgY29uc3Qgb3B0ID0gY29tcHV0ZWRPcHRpb25zW2tleV07XG4gICAgICBjb25zdCBnZXQgPSBpc0Z1bmN0aW9uKG9wdCkgPyBvcHQuYmluZChwdWJsaWNUaGlzLCBwdWJsaWNUaGlzKSA6IGlzRnVuY3Rpb24ob3B0LmdldCkgPyBvcHQuZ2V0LmJpbmQocHVibGljVGhpcywgcHVibGljVGhpcykgOiBOT09QO1xuICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgZ2V0ID09PSBOT09QKSB7XG4gICAgICAgIHdhcm4oYENvbXB1dGVkIHByb3BlcnR5IFwiJHtrZXl9XCIgaGFzIG5vIGdldHRlci5gKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNldCA9ICFpc0Z1bmN0aW9uKG9wdCkgJiYgaXNGdW5jdGlvbihvcHQuc2V0KSA/IG9wdC5zZXQuYmluZChwdWJsaWNUaGlzKSA6ICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyAoKSA9PiB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgYFdyaXRlIG9wZXJhdGlvbiBmYWlsZWQ6IGNvbXB1dGVkIHByb3BlcnR5IFwiJHtrZXl9XCIgaXMgcmVhZG9ubHkuYFxuICAgICAgICApO1xuICAgICAgfSA6IE5PT1A7XG4gICAgICBjb25zdCBjID0gY29tcHV0ZWQoe1xuICAgICAgICBnZXQsXG4gICAgICAgIHNldFxuICAgICAgfSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3R4LCBrZXksIHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6ICgpID0+IGMudmFsdWUsXG4gICAgICAgIHNldDogKHYpID0+IGMudmFsdWUgPSB2XG4gICAgICB9KTtcbiAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgIGNoZWNrRHVwbGljYXRlUHJvcGVydGllcyhcIkNvbXB1dGVkXCIgLyogQ09NUFVURUQgKi8sIGtleSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmICh3YXRjaE9wdGlvbnMpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiB3YXRjaE9wdGlvbnMpIHtcbiAgICAgIGNyZWF0ZVdhdGNoZXIod2F0Y2hPcHRpb25zW2tleV0sIGN0eCwgcHVibGljVGhpcywga2V5KTtcbiAgICB9XG4gIH1cbiAgaWYgKHByb3ZpZGVPcHRpb25zKSB7XG4gICAgY29uc3QgcHJvdmlkZXMgPSBpc0Z1bmN0aW9uKHByb3ZpZGVPcHRpb25zKSA/IHByb3ZpZGVPcHRpb25zLmNhbGwocHVibGljVGhpcykgOiBwcm92aWRlT3B0aW9ucztcbiAgICBSZWZsZWN0Lm93bktleXMocHJvdmlkZXMpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgcHJvdmlkZShrZXksIHByb3ZpZGVzW2tleV0pO1xuICAgIH0pO1xuICB9XG4gIGlmIChjcmVhdGVkKSB7XG4gICAgY2FsbEhvb2soY3JlYXRlZCwgaW5zdGFuY2UsIFwiY1wiKTtcbiAgfVxuICBmdW5jdGlvbiByZWdpc3RlckxpZmVjeWNsZUhvb2socmVnaXN0ZXIsIGhvb2spIHtcbiAgICBpZiAoaXNBcnJheShob29rKSkge1xuICAgICAgaG9vay5mb3JFYWNoKChfaG9vaykgPT4gcmVnaXN0ZXIoX2hvb2suYmluZChwdWJsaWNUaGlzKSkpO1xuICAgIH0gZWxzZSBpZiAoaG9vaykge1xuICAgICAgcmVnaXN0ZXIoaG9vay5iaW5kKHB1YmxpY1RoaXMpKTtcbiAgICB9XG4gIH1cbiAgcmVnaXN0ZXJMaWZlY3ljbGVIb29rKG9uQmVmb3JlTW91bnQsIGJlZm9yZU1vdW50KTtcbiAgcmVnaXN0ZXJMaWZlY3ljbGVIb29rKG9uTW91bnRlZCwgbW91bnRlZCk7XG4gIHJlZ2lzdGVyTGlmZWN5Y2xlSG9vayhvbkJlZm9yZVVwZGF0ZSwgYmVmb3JlVXBkYXRlKTtcbiAgcmVnaXN0ZXJMaWZlY3ljbGVIb29rKG9uVXBkYXRlZCwgdXBkYXRlZCk7XG4gIHJlZ2lzdGVyTGlmZWN5Y2xlSG9vayhvbkFjdGl2YXRlZCwgYWN0aXZhdGVkKTtcbiAgcmVnaXN0ZXJMaWZlY3ljbGVIb29rKG9uRGVhY3RpdmF0ZWQsIGRlYWN0aXZhdGVkKTtcbiAgcmVnaXN0ZXJMaWZlY3ljbGVIb29rKG9uRXJyb3JDYXB0dXJlZCwgZXJyb3JDYXB0dXJlZCk7XG4gIHJlZ2lzdGVyTGlmZWN5Y2xlSG9vayhvblJlbmRlclRyYWNrZWQsIHJlbmRlclRyYWNrZWQpO1xuICByZWdpc3RlckxpZmVjeWNsZUhvb2sob25SZW5kZXJUcmlnZ2VyZWQsIHJlbmRlclRyaWdnZXJlZCk7XG4gIHJlZ2lzdGVyTGlmZWN5Y2xlSG9vayhvbkJlZm9yZVVubW91bnQsIGJlZm9yZVVubW91bnQpO1xuICByZWdpc3RlckxpZmVjeWNsZUhvb2sob25Vbm1vdW50ZWQsIHVubW91bnRlZCk7XG4gIHJlZ2lzdGVyTGlmZWN5Y2xlSG9vayhvblNlcnZlclByZWZldGNoLCBzZXJ2ZXJQcmVmZXRjaCk7XG4gIGlmIChpc0FycmF5KGV4cG9zZSkpIHtcbiAgICBpZiAoZXhwb3NlLmxlbmd0aCkge1xuICAgICAgY29uc3QgZXhwb3NlZCA9IGluc3RhbmNlLmV4cG9zZWQgfHwgKGluc3RhbmNlLmV4cG9zZWQgPSB7fSk7XG4gICAgICBleHBvc2UuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvc2VkLCBrZXksIHtcbiAgICAgICAgICBnZXQ6ICgpID0+IHB1YmxpY1RoaXNba2V5XSxcbiAgICAgICAgICBzZXQ6ICh2YWwpID0+IHB1YmxpY1RoaXNba2V5XSA9IHZhbFxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoIWluc3RhbmNlLmV4cG9zZWQpIHtcbiAgICAgIGluc3RhbmNlLmV4cG9zZWQgPSB7fTtcbiAgICB9XG4gIH1cbiAgaWYgKHJlbmRlciAmJiBpbnN0YW5jZS5yZW5kZXIgPT09IE5PT1ApIHtcbiAgICBpbnN0YW5jZS5yZW5kZXIgPSByZW5kZXI7XG4gIH1cbiAgaWYgKGluaGVyaXRBdHRycyAhPSBudWxsKSB7XG4gICAgaW5zdGFuY2UuaW5oZXJpdEF0dHJzID0gaW5oZXJpdEF0dHJzO1xuICB9XG4gIGlmIChjb21wb25lbnRzKVxuICAgIGluc3RhbmNlLmNvbXBvbmVudHMgPSBjb21wb25lbnRzO1xuICBpZiAoZGlyZWN0aXZlcylcbiAgICBpbnN0YW5jZS5kaXJlY3RpdmVzID0gZGlyZWN0aXZlcztcbn1cbmZ1bmN0aW9uIHJlc29sdmVJbmplY3Rpb25zKGluamVjdE9wdGlvbnMsIGN0eCwgY2hlY2tEdXBsaWNhdGVQcm9wZXJ0aWVzID0gTk9PUCkge1xuICBpZiAoaXNBcnJheShpbmplY3RPcHRpb25zKSkge1xuICAgIGluamVjdE9wdGlvbnMgPSBub3JtYWxpemVJbmplY3QoaW5qZWN0T3B0aW9ucyk7XG4gIH1cbiAgZm9yIChjb25zdCBrZXkgaW4gaW5qZWN0T3B0aW9ucykge1xuICAgIGNvbnN0IG9wdCA9IGluamVjdE9wdGlvbnNba2V5XTtcbiAgICBsZXQgaW5qZWN0ZWQ7XG4gICAgaWYgKGlzT2JqZWN0KG9wdCkpIHtcbiAgICAgIGlmIChcImRlZmF1bHRcIiBpbiBvcHQpIHtcbiAgICAgICAgaW5qZWN0ZWQgPSBpbmplY3QoXG4gICAgICAgICAgb3B0LmZyb20gfHwga2V5LFxuICAgICAgICAgIG9wdC5kZWZhdWx0LFxuICAgICAgICAgIHRydWVcbiAgICAgICAgICAvKiB0cmVhdCBkZWZhdWx0IGZ1bmN0aW9uIGFzIGZhY3RvcnkgKi9cbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluamVjdGVkID0gaW5qZWN0KG9wdC5mcm9tIHx8IGtleSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGluamVjdGVkID0gaW5qZWN0KG9wdCk7XG4gICAgfVxuICAgIGlmIChpc1JlZihpbmplY3RlZCkpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdHgsIGtleSwge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGdldDogKCkgPT4gaW5qZWN0ZWQudmFsdWUsXG4gICAgICAgIHNldDogKHYpID0+IGluamVjdGVkLnZhbHVlID0gdlxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN0eFtrZXldID0gaW5qZWN0ZWQ7XG4gICAgfVxuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICBjaGVja0R1cGxpY2F0ZVByb3BlcnRpZXMoXCJJbmplY3RcIiAvKiBJTkpFQ1QgKi8sIGtleSk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBjYWxsSG9vayhob29rLCBpbnN0YW5jZSwgdHlwZSkge1xuICBjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZyhcbiAgICBpc0FycmF5KGhvb2spID8gaG9vay5tYXAoKGgpID0+IGguYmluZChpbnN0YW5jZS5wcm94eSkpIDogaG9vay5iaW5kKGluc3RhbmNlLnByb3h5KSxcbiAgICBpbnN0YW5jZSxcbiAgICB0eXBlXG4gICk7XG59XG5mdW5jdGlvbiBjcmVhdGVXYXRjaGVyKHJhdywgY3R4LCBwdWJsaWNUaGlzLCBrZXkpIHtcbiAgY29uc3QgZ2V0dGVyID0ga2V5LmluY2x1ZGVzKFwiLlwiKSA/IGNyZWF0ZVBhdGhHZXR0ZXIocHVibGljVGhpcywga2V5KSA6ICgpID0+IHB1YmxpY1RoaXNba2V5XTtcbiAgaWYgKGlzU3RyaW5nKHJhdykpIHtcbiAgICBjb25zdCBoYW5kbGVyID0gY3R4W3Jhd107XG4gICAgaWYgKGlzRnVuY3Rpb24oaGFuZGxlcikpIHtcbiAgICAgIHdhdGNoKGdldHRlciwgaGFuZGxlcik7XG4gICAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICB3YXJuKGBJbnZhbGlkIHdhdGNoIGhhbmRsZXIgc3BlY2lmaWVkIGJ5IGtleSBcIiR7cmF3fVwiYCwgaGFuZGxlcik7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzRnVuY3Rpb24ocmF3KSkge1xuICAgIHdhdGNoKGdldHRlciwgcmF3LmJpbmQocHVibGljVGhpcykpO1xuICB9IGVsc2UgaWYgKGlzT2JqZWN0KHJhdykpIHtcbiAgICBpZiAoaXNBcnJheShyYXcpKSB7XG4gICAgICByYXcuZm9yRWFjaCgocikgPT4gY3JlYXRlV2F0Y2hlcihyLCBjdHgsIHB1YmxpY1RoaXMsIGtleSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBoYW5kbGVyID0gaXNGdW5jdGlvbihyYXcuaGFuZGxlcikgPyByYXcuaGFuZGxlci5iaW5kKHB1YmxpY1RoaXMpIDogY3R4W3Jhdy5oYW5kbGVyXTtcbiAgICAgIGlmIChpc0Z1bmN0aW9uKGhhbmRsZXIpKSB7XG4gICAgICAgIHdhdGNoKGdldHRlciwgaGFuZGxlciwgcmF3KTtcbiAgICAgIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICB3YXJuKGBJbnZhbGlkIHdhdGNoIGhhbmRsZXIgc3BlY2lmaWVkIGJ5IGtleSBcIiR7cmF3LmhhbmRsZXJ9XCJgLCBoYW5kbGVyKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIHdhcm4oYEludmFsaWQgd2F0Y2ggb3B0aW9uOiBcIiR7a2V5fVwiYCwgcmF3KTtcbiAgfVxufVxuZnVuY3Rpb24gcmVzb2x2ZU1lcmdlZE9wdGlvbnMoaW5zdGFuY2UpIHtcbiAgY29uc3QgYmFzZSA9IGluc3RhbmNlLnR5cGU7XG4gIGNvbnN0IHsgbWl4aW5zLCBleHRlbmRzOiBleHRlbmRzT3B0aW9ucyB9ID0gYmFzZTtcbiAgY29uc3Qge1xuICAgIG1peGluczogZ2xvYmFsTWl4aW5zLFxuICAgIG9wdGlvbnNDYWNoZTogY2FjaGUsXG4gICAgY29uZmlnOiB7IG9wdGlvbk1lcmdlU3RyYXRlZ2llcyB9XG4gIH0gPSBpbnN0YW5jZS5hcHBDb250ZXh0O1xuICBjb25zdCBjYWNoZWQgPSBjYWNoZS5nZXQoYmFzZSk7XG4gIGxldCByZXNvbHZlZDtcbiAgaWYgKGNhY2hlZCkge1xuICAgIHJlc29sdmVkID0gY2FjaGVkO1xuICB9IGVsc2UgaWYgKCFnbG9iYWxNaXhpbnMubGVuZ3RoICYmICFtaXhpbnMgJiYgIWV4dGVuZHNPcHRpb25zKSB7XG4gICAge1xuICAgICAgcmVzb2x2ZWQgPSBiYXNlO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXNvbHZlZCA9IHt9O1xuICAgIGlmIChnbG9iYWxNaXhpbnMubGVuZ3RoKSB7XG4gICAgICBnbG9iYWxNaXhpbnMuZm9yRWFjaChcbiAgICAgICAgKG0pID0+IG1lcmdlT3B0aW9ucyhyZXNvbHZlZCwgbSwgb3B0aW9uTWVyZ2VTdHJhdGVnaWVzLCB0cnVlKVxuICAgICAgKTtcbiAgICB9XG4gICAgbWVyZ2VPcHRpb25zKHJlc29sdmVkLCBiYXNlLCBvcHRpb25NZXJnZVN0cmF0ZWdpZXMpO1xuICB9XG4gIGlmIChpc09iamVjdChiYXNlKSkge1xuICAgIGNhY2hlLnNldChiYXNlLCByZXNvbHZlZCk7XG4gIH1cbiAgcmV0dXJuIHJlc29sdmVkO1xufVxuZnVuY3Rpb24gbWVyZ2VPcHRpb25zKHRvLCBmcm9tLCBzdHJhdHMsIGFzTWl4aW4gPSBmYWxzZSkge1xuICBjb25zdCB7IG1peGlucywgZXh0ZW5kczogZXh0ZW5kc09wdGlvbnMgfSA9IGZyb207XG4gIGlmIChleHRlbmRzT3B0aW9ucykge1xuICAgIG1lcmdlT3B0aW9ucyh0bywgZXh0ZW5kc09wdGlvbnMsIHN0cmF0cywgdHJ1ZSk7XG4gIH1cbiAgaWYgKG1peGlucykge1xuICAgIG1peGlucy5mb3JFYWNoKFxuICAgICAgKG0pID0+IG1lcmdlT3B0aW9ucyh0bywgbSwgc3RyYXRzLCB0cnVlKVxuICAgICk7XG4gIH1cbiAgZm9yIChjb25zdCBrZXkgaW4gZnJvbSkge1xuICAgIGlmIChhc01peGluICYmIGtleSA9PT0gXCJleHBvc2VcIikge1xuICAgICAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiB3YXJuKFxuICAgICAgICBgXCJleHBvc2VcIiBvcHRpb24gaXMgaWdub3JlZCB3aGVuIGRlY2xhcmVkIGluIG1peGlucyBvciBleHRlbmRzLiBJdCBzaG91bGQgb25seSBiZSBkZWNsYXJlZCBpbiB0aGUgYmFzZSBjb21wb25lbnQgaXRzZWxmLmBcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHN0cmF0ID0gaW50ZXJuYWxPcHRpb25NZXJnZVN0cmF0c1trZXldIHx8IHN0cmF0cyAmJiBzdHJhdHNba2V5XTtcbiAgICAgIHRvW2tleV0gPSBzdHJhdCA/IHN0cmF0KHRvW2tleV0sIGZyb21ba2V5XSkgOiBmcm9tW2tleV07XG4gICAgfVxuICB9XG4gIHJldHVybiB0bztcbn1cbmNvbnN0IGludGVybmFsT3B0aW9uTWVyZ2VTdHJhdHMgPSB7XG4gIGRhdGE6IG1lcmdlRGF0YUZuLFxuICBwcm9wczogbWVyZ2VFbWl0c09yUHJvcHNPcHRpb25zLFxuICBlbWl0czogbWVyZ2VFbWl0c09yUHJvcHNPcHRpb25zLFxuICAvLyBvYmplY3RzXG4gIG1ldGhvZHM6IG1lcmdlT2JqZWN0T3B0aW9ucyxcbiAgY29tcHV0ZWQ6IG1lcmdlT2JqZWN0T3B0aW9ucyxcbiAgLy8gbGlmZWN5Y2xlXG4gIGJlZm9yZUNyZWF0ZTogbWVyZ2VBc0FycmF5LFxuICBjcmVhdGVkOiBtZXJnZUFzQXJyYXksXG4gIGJlZm9yZU1vdW50OiBtZXJnZUFzQXJyYXksXG4gIG1vdW50ZWQ6IG1lcmdlQXNBcnJheSxcbiAgYmVmb3JlVXBkYXRlOiBtZXJnZUFzQXJyYXksXG4gIHVwZGF0ZWQ6IG1lcmdlQXNBcnJheSxcbiAgYmVmb3JlRGVzdHJveTogbWVyZ2VBc0FycmF5LFxuICBiZWZvcmVVbm1vdW50OiBtZXJnZUFzQXJyYXksXG4gIGRlc3Ryb3llZDogbWVyZ2VBc0FycmF5LFxuICB1bm1vdW50ZWQ6IG1lcmdlQXNBcnJheSxcbiAgYWN0aXZhdGVkOiBtZXJnZUFzQXJyYXksXG4gIGRlYWN0aXZhdGVkOiBtZXJnZUFzQXJyYXksXG4gIGVycm9yQ2FwdHVyZWQ6IG1lcmdlQXNBcnJheSxcbiAgc2VydmVyUHJlZmV0Y2g6IG1lcmdlQXNBcnJheSxcbiAgLy8gYXNzZXRzXG4gIGNvbXBvbmVudHM6IG1lcmdlT2JqZWN0T3B0aW9ucyxcbiAgZGlyZWN0aXZlczogbWVyZ2VPYmplY3RPcHRpb25zLFxuICAvLyB3YXRjaFxuICB3YXRjaDogbWVyZ2VXYXRjaE9wdGlvbnMsXG4gIC8vIHByb3ZpZGUgLyBpbmplY3RcbiAgcHJvdmlkZTogbWVyZ2VEYXRhRm4sXG4gIGluamVjdDogbWVyZ2VJbmplY3Rcbn07XG5mdW5jdGlvbiBtZXJnZURhdGFGbih0bywgZnJvbSkge1xuICBpZiAoIWZyb20pIHtcbiAgICByZXR1cm4gdG87XG4gIH1cbiAgaWYgKCF0bykge1xuICAgIHJldHVybiBmcm9tO1xuICB9XG4gIHJldHVybiBmdW5jdGlvbiBtZXJnZWREYXRhRm4oKSB7XG4gICAgcmV0dXJuIChleHRlbmQpKFxuICAgICAgaXNGdW5jdGlvbih0bykgPyB0by5jYWxsKHRoaXMsIHRoaXMpIDogdG8sXG4gICAgICBpc0Z1bmN0aW9uKGZyb20pID8gZnJvbS5jYWxsKHRoaXMsIHRoaXMpIDogZnJvbVxuICAgICk7XG4gIH07XG59XG5mdW5jdGlvbiBtZXJnZUluamVjdCh0bywgZnJvbSkge1xuICByZXR1cm4gbWVyZ2VPYmplY3RPcHRpb25zKG5vcm1hbGl6ZUluamVjdCh0byksIG5vcm1hbGl6ZUluamVjdChmcm9tKSk7XG59XG5mdW5jdGlvbiBub3JtYWxpemVJbmplY3QocmF3KSB7XG4gIGlmIChpc0FycmF5KHJhdykpIHtcbiAgICBjb25zdCByZXMgPSB7fTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJhdy5sZW5ndGg7IGkrKykge1xuICAgICAgcmVzW3Jhd1tpXV0gPSByYXdbaV07XG4gICAgfVxuICAgIHJldHVybiByZXM7XG4gIH1cbiAgcmV0dXJuIHJhdztcbn1cbmZ1bmN0aW9uIG1lcmdlQXNBcnJheSh0bywgZnJvbSkge1xuICByZXR1cm4gdG8gPyBbLi4ubmV3IFNldChbXS5jb25jYXQodG8sIGZyb20pKV0gOiBmcm9tO1xufVxuZnVuY3Rpb24gbWVyZ2VPYmplY3RPcHRpb25zKHRvLCBmcm9tKSB7XG4gIHJldHVybiB0byA/IGV4dGVuZCgvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKSwgdG8sIGZyb20pIDogZnJvbTtcbn1cbmZ1bmN0aW9uIG1lcmdlRW1pdHNPclByb3BzT3B0aW9ucyh0bywgZnJvbSkge1xuICBpZiAodG8pIHtcbiAgICBpZiAoaXNBcnJheSh0bykgJiYgaXNBcnJheShmcm9tKSkge1xuICAgICAgcmV0dXJuIFsuLi4vKiBAX19QVVJFX18gKi8gbmV3IFNldChbLi4udG8sIC4uLmZyb21dKV07XG4gICAgfVxuICAgIHJldHVybiBleHRlbmQoXG4gICAgICAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKSxcbiAgICAgIG5vcm1hbGl6ZVByb3BzT3JFbWl0cyh0byksXG4gICAgICBub3JtYWxpemVQcm9wc09yRW1pdHMoZnJvbSAhPSBudWxsID8gZnJvbSA6IHt9KVxuICAgICk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZyb207XG4gIH1cbn1cbmZ1bmN0aW9uIG1lcmdlV2F0Y2hPcHRpb25zKHRvLCBmcm9tKSB7XG4gIGlmICghdG8pXG4gICAgcmV0dXJuIGZyb207XG4gIGlmICghZnJvbSlcbiAgICByZXR1cm4gdG87XG4gIGNvbnN0IG1lcmdlZCA9IGV4dGVuZCgvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKSwgdG8pO1xuICBmb3IgKGNvbnN0IGtleSBpbiBmcm9tKSB7XG4gICAgbWVyZ2VkW2tleV0gPSBtZXJnZUFzQXJyYXkodG9ba2V5XSwgZnJvbVtrZXldKTtcbiAgfVxuICByZXR1cm4gbWVyZ2VkO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVBcHBDb250ZXh0KCkge1xuICByZXR1cm4ge1xuICAgIGFwcDogbnVsbCxcbiAgICBjb25maWc6IHtcbiAgICAgIGlzTmF0aXZlVGFnOiBOTyxcbiAgICAgIHBlcmZvcm1hbmNlOiBmYWxzZSxcbiAgICAgIGdsb2JhbFByb3BlcnRpZXM6IHt9LFxuICAgICAgb3B0aW9uTWVyZ2VTdHJhdGVnaWVzOiB7fSxcbiAgICAgIGVycm9ySGFuZGxlcjogdm9pZCAwLFxuICAgICAgd2FybkhhbmRsZXI6IHZvaWQgMCxcbiAgICAgIGNvbXBpbGVyT3B0aW9uczoge31cbiAgICB9LFxuICAgIG1peGluczogW10sXG4gICAgY29tcG9uZW50czoge30sXG4gICAgZGlyZWN0aXZlczoge30sXG4gICAgcHJvdmlkZXM6IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpLFxuICAgIG9wdGlvbnNDYWNoZTogLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCksXG4gICAgcHJvcHNDYWNoZTogLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCksXG4gICAgZW1pdHNDYWNoZTogLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKClcbiAgfTtcbn1cbmxldCB1aWQkMSA9IDA7XG5mdW5jdGlvbiBjcmVhdGVBcHBBUEkocmVuZGVyLCBoeWRyYXRlKSB7XG4gIHJldHVybiBmdW5jdGlvbiBjcmVhdGVBcHAocm9vdENvbXBvbmVudCwgcm9vdFByb3BzID0gbnVsbCkge1xuICAgIGlmICghaXNGdW5jdGlvbihyb290Q29tcG9uZW50KSkge1xuICAgICAgcm9vdENvbXBvbmVudCA9IGV4dGVuZCh7fSwgcm9vdENvbXBvbmVudCk7XG4gICAgfVxuICAgIGlmIChyb290UHJvcHMgIT0gbnVsbCAmJiAhaXNPYmplY3Qocm9vdFByb3BzKSkge1xuICAgICAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiB3YXJuKGByb290IHByb3BzIHBhc3NlZCB0byBhcHAubW91bnQoKSBtdXN0IGJlIGFuIG9iamVjdC5gKTtcbiAgICAgIHJvb3RQcm9wcyA9IG51bGw7XG4gICAgfVxuICAgIGNvbnN0IGNvbnRleHQgPSBjcmVhdGVBcHBDb250ZXh0KCk7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb250ZXh0LmNvbmZpZywgXCJ1bndyYXBJbmplY3RlZFJlZlwiLCB7XG4gICAgICAgIGdldCgpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0KCkge1xuICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICBgYXBwLmNvbmZpZy51bndyYXBJbmplY3RlZFJlZiBoYXMgYmVlbiBkZXByZWNhdGVkLiAzLjMgbm93IGFsYXd5cyB1bndyYXBzIGluamVjdGVkIHJlZnMgaW4gT3B0aW9ucyBBUEkuYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBpbnN0YWxsZWRQbHVnaW5zID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICBsZXQgaXNNb3VudGVkID0gZmFsc2U7XG4gICAgY29uc3QgYXBwID0gY29udGV4dC5hcHAgPSB7XG4gICAgICBfdWlkOiB1aWQkMSsrLFxuICAgICAgX2NvbXBvbmVudDogcm9vdENvbXBvbmVudCxcbiAgICAgIF9wcm9wczogcm9vdFByb3BzLFxuICAgICAgX2NvbnRhaW5lcjogbnVsbCxcbiAgICAgIF9jb250ZXh0OiBjb250ZXh0LFxuICAgICAgX2luc3RhbmNlOiBudWxsLFxuICAgICAgdmVyc2lvbixcbiAgICAgIGdldCBjb25maWcoKSB7XG4gICAgICAgIHJldHVybiBjb250ZXh0LmNvbmZpZztcbiAgICAgIH0sXG4gICAgICBzZXQgY29uZmlnKHYpIHtcbiAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgYGFwcC5jb25maWcgY2Fubm90IGJlIHJlcGxhY2VkLiBNb2RpZnkgaW5kaXZpZHVhbCBvcHRpb25zIGluc3RlYWQuYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB1c2UocGx1Z2luLCAuLi5vcHRpb25zKSB7XG4gICAgICAgIGlmIChpbnN0YWxsZWRQbHVnaW5zLmhhcyhwbHVnaW4pKSB7XG4gICAgICAgICAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiB3YXJuKGBQbHVnaW4gaGFzIGFscmVhZHkgYmVlbiBhcHBsaWVkIHRvIHRhcmdldCBhcHAuYCk7XG4gICAgICAgIH0gZWxzZSBpZiAocGx1Z2luICYmIGlzRnVuY3Rpb24ocGx1Z2luLmluc3RhbGwpKSB7XG4gICAgICAgICAgaW5zdGFsbGVkUGx1Z2lucy5hZGQocGx1Z2luKTtcbiAgICAgICAgICBwbHVnaW4uaW5zdGFsbChhcHAsIC4uLm9wdGlvbnMpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzRnVuY3Rpb24ocGx1Z2luKSkge1xuICAgICAgICAgIGluc3RhbGxlZFBsdWdpbnMuYWRkKHBsdWdpbik7XG4gICAgICAgICAgcGx1Z2luKGFwcCwgLi4ub3B0aW9ucyk7XG4gICAgICAgIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICBgQSBwbHVnaW4gbXVzdCBlaXRoZXIgYmUgYSBmdW5jdGlvbiBvciBhbiBvYmplY3Qgd2l0aCBhbiBcImluc3RhbGxcIiBmdW5jdGlvbi5gXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXBwO1xuICAgICAgfSxcbiAgICAgIG1peGluKG1peGluKSB7XG4gICAgICAgIGlmIChfX1ZVRV9PUFRJT05TX0FQSV9fKSB7XG4gICAgICAgICAgaWYgKCFjb250ZXh0Lm1peGlucy5pbmNsdWRlcyhtaXhpbikpIHtcbiAgICAgICAgICAgIGNvbnRleHQubWl4aW5zLnB1c2gobWl4aW4pO1xuICAgICAgICAgIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgICAgd2FybihcbiAgICAgICAgICAgICAgXCJNaXhpbiBoYXMgYWxyZWFkeSBiZWVuIGFwcGxpZWQgdG8gdGFyZ2V0IGFwcFwiICsgKG1peGluLm5hbWUgPyBgOiAke21peGluLm5hbWV9YCA6IFwiXCIpXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgd2FybihcIk1peGlucyBhcmUgb25seSBhdmFpbGFibGUgaW4gYnVpbGRzIHN1cHBvcnRpbmcgT3B0aW9ucyBBUElcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFwcDtcbiAgICAgIH0sXG4gICAgICBjb21wb25lbnQobmFtZSwgY29tcG9uZW50KSB7XG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgdmFsaWRhdGVDb21wb25lbnROYW1lKG5hbWUsIGNvbnRleHQuY29uZmlnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNvbXBvbmVudCkge1xuICAgICAgICAgIHJldHVybiBjb250ZXh0LmNvbXBvbmVudHNbbmFtZV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgY29udGV4dC5jb21wb25lbnRzW25hbWVdKSB7XG4gICAgICAgICAgd2FybihgQ29tcG9uZW50IFwiJHtuYW1lfVwiIGhhcyBhbHJlYWR5IGJlZW4gcmVnaXN0ZXJlZCBpbiB0YXJnZXQgYXBwLmApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRleHQuY29tcG9uZW50c1tuYW1lXSA9IGNvbXBvbmVudDtcbiAgICAgICAgcmV0dXJuIGFwcDtcbiAgICAgIH0sXG4gICAgICBkaXJlY3RpdmUobmFtZSwgZGlyZWN0aXZlKSB7XG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgdmFsaWRhdGVEaXJlY3RpdmVOYW1lKG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZGlyZWN0aXZlKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbnRleHQuZGlyZWN0aXZlc1tuYW1lXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBjb250ZXh0LmRpcmVjdGl2ZXNbbmFtZV0pIHtcbiAgICAgICAgICB3YXJuKGBEaXJlY3RpdmUgXCIke25hbWV9XCIgaGFzIGFscmVhZHkgYmVlbiByZWdpc3RlcmVkIGluIHRhcmdldCBhcHAuYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29udGV4dC5kaXJlY3RpdmVzW25hbWVdID0gZGlyZWN0aXZlO1xuICAgICAgICByZXR1cm4gYXBwO1xuICAgICAgfSxcbiAgICAgIG1vdW50KHJvb3RDb250YWluZXIsIGlzSHlkcmF0ZSwgaXNTVkcpIHtcbiAgICAgICAgaWYgKCFpc01vdW50ZWQpIHtcbiAgICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiByb290Q29udGFpbmVyLl9fdnVlX2FwcF9fKSB7XG4gICAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgICBgVGhlcmUgaXMgYWxyZWFkeSBhbiBhcHAgaW5zdGFuY2UgbW91bnRlZCBvbiB0aGUgaG9zdCBjb250YWluZXIuXG4gSWYgeW91IHdhbnQgdG8gbW91bnQgYW5vdGhlciBhcHAgb24gdGhlIHNhbWUgaG9zdCBjb250YWluZXIsIHlvdSBuZWVkIHRvIHVubW91bnQgdGhlIHByZXZpb3VzIGFwcCBieSBjYWxsaW5nIFxcYGFwcC51bm1vdW50KClcXGAgZmlyc3QuYFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3Qgdm5vZGUgPSBjcmVhdGVWTm9kZShcbiAgICAgICAgICAgIHJvb3RDb21wb25lbnQsXG4gICAgICAgICAgICByb290UHJvcHNcbiAgICAgICAgICApO1xuICAgICAgICAgIHZub2RlLmFwcENvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgICBjb250ZXh0LnJlbG9hZCA9ICgpID0+IHtcbiAgICAgICAgICAgICAgcmVuZGVyKGNsb25lVk5vZGUodm5vZGUpLCByb290Q29udGFpbmVyLCBpc1NWRyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNIeWRyYXRlICYmIGh5ZHJhdGUpIHtcbiAgICAgICAgICAgIGh5ZHJhdGUodm5vZGUsIHJvb3RDb250YWluZXIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZW5kZXIodm5vZGUsIHJvb3RDb250YWluZXIsIGlzU1ZHKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaXNNb3VudGVkID0gdHJ1ZTtcbiAgICAgICAgICBhcHAuX2NvbnRhaW5lciA9IHJvb3RDb250YWluZXI7XG4gICAgICAgICAgcm9vdENvbnRhaW5lci5fX3Z1ZV9hcHBfXyA9IGFwcDtcbiAgICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcbiAgICAgICAgICAgIGFwcC5faW5zdGFuY2UgPSB2bm9kZS5jb21wb25lbnQ7XG4gICAgICAgICAgICBkZXZ0b29sc0luaXRBcHAoYXBwLCB2ZXJzaW9uKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGdldEV4cG9zZVByb3h5KHZub2RlLmNvbXBvbmVudCkgfHwgdm5vZGUuY29tcG9uZW50LnByb3h5O1xuICAgICAgICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgYEFwcCBoYXMgYWxyZWFkeSBiZWVuIG1vdW50ZWQuXG5JZiB5b3Ugd2FudCB0byByZW1vdW50IHRoZSBzYW1lIGFwcCwgbW92ZSB5b3VyIGFwcCBjcmVhdGlvbiBsb2dpYyBpbnRvIGEgZmFjdG9yeSBmdW5jdGlvbiBhbmQgY3JlYXRlIGZyZXNoIGFwcCBpbnN0YW5jZXMgZm9yIGVhY2ggbW91bnQgLSBlLmcuIFxcYGNvbnN0IGNyZWF0ZU15QXBwID0gKCkgPT4gY3JlYXRlQXBwKEFwcClcXGBgXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHVubW91bnQoKSB7XG4gICAgICAgIGlmIChpc01vdW50ZWQpIHtcbiAgICAgICAgICByZW5kZXIobnVsbCwgYXBwLl9jb250YWluZXIpO1xuICAgICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykge1xuICAgICAgICAgICAgYXBwLl9pbnN0YW5jZSA9IG51bGw7XG4gICAgICAgICAgICBkZXZ0b29sc1VubW91bnRBcHAoYXBwKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZGVsZXRlIGFwcC5fY29udGFpbmVyLl9fdnVlX2FwcF9fO1xuICAgICAgICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICB3YXJuKGBDYW5ub3QgdW5tb3VudCBhbiBhcHAgdGhhdCBpcyBub3QgbW91bnRlZC5gKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHByb3ZpZGUoa2V5LCB2YWx1ZSkge1xuICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBrZXkgaW4gY29udGV4dC5wcm92aWRlcykge1xuICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICBgQXBwIGFscmVhZHkgcHJvdmlkZXMgcHJvcGVydHkgd2l0aCBrZXkgXCIke1N0cmluZyhrZXkpfVwiLiBJdCB3aWxsIGJlIG92ZXJ3cml0dGVuIHdpdGggdGhlIG5ldyB2YWx1ZS5gXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBjb250ZXh0LnByb3ZpZGVzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIGFwcDtcbiAgICAgIH0sXG4gICAgICBydW5XaXRoQ29udGV4dChmbikge1xuICAgICAgICBjdXJyZW50QXBwID0gYXBwO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBmbigpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGN1cnJlbnRBcHAgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gYXBwO1xuICB9O1xufVxubGV0IGN1cnJlbnRBcHAgPSBudWxsO1xuXG5mdW5jdGlvbiBwcm92aWRlKGtleSwgdmFsdWUpIHtcbiAgaWYgKCFjdXJyZW50SW5zdGFuY2UpIHtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgd2FybihgcHJvdmlkZSgpIGNhbiBvbmx5IGJlIHVzZWQgaW5zaWRlIHNldHVwKCkuYCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGxldCBwcm92aWRlcyA9IGN1cnJlbnRJbnN0YW5jZS5wcm92aWRlcztcbiAgICBjb25zdCBwYXJlbnRQcm92aWRlcyA9IGN1cnJlbnRJbnN0YW5jZS5wYXJlbnQgJiYgY3VycmVudEluc3RhbmNlLnBhcmVudC5wcm92aWRlcztcbiAgICBpZiAocGFyZW50UHJvdmlkZXMgPT09IHByb3ZpZGVzKSB7XG4gICAgICBwcm92aWRlcyA9IGN1cnJlbnRJbnN0YW5jZS5wcm92aWRlcyA9IE9iamVjdC5jcmVhdGUocGFyZW50UHJvdmlkZXMpO1xuICAgIH1cbiAgICBwcm92aWRlc1trZXldID0gdmFsdWU7XG4gIH1cbn1cbmZ1bmN0aW9uIGluamVjdChrZXksIGRlZmF1bHRWYWx1ZSwgdHJlYXREZWZhdWx0QXNGYWN0b3J5ID0gZmFsc2UpIHtcbiAgY29uc3QgaW5zdGFuY2UgPSBjdXJyZW50SW5zdGFuY2UgfHwgY3VycmVudFJlbmRlcmluZ0luc3RhbmNlO1xuICBpZiAoaW5zdGFuY2UgfHwgY3VycmVudEFwcCkge1xuICAgIGNvbnN0IHByb3ZpZGVzID0gaW5zdGFuY2UgPyBpbnN0YW5jZS5wYXJlbnQgPT0gbnVsbCA/IGluc3RhbmNlLnZub2RlLmFwcENvbnRleHQgJiYgaW5zdGFuY2Uudm5vZGUuYXBwQ29udGV4dC5wcm92aWRlcyA6IGluc3RhbmNlLnBhcmVudC5wcm92aWRlcyA6IGN1cnJlbnRBcHAuX2NvbnRleHQucHJvdmlkZXM7XG4gICAgaWYgKHByb3ZpZGVzICYmIGtleSBpbiBwcm92aWRlcykge1xuICAgICAgcmV0dXJuIHByb3ZpZGVzW2tleV07XG4gICAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgcmV0dXJuIHRyZWF0RGVmYXVsdEFzRmFjdG9yeSAmJiBpc0Z1bmN0aW9uKGRlZmF1bHRWYWx1ZSkgPyBkZWZhdWx0VmFsdWUuY2FsbChpbnN0YW5jZSAmJiBpbnN0YW5jZS5wcm94eSkgOiBkZWZhdWx0VmFsdWU7XG4gICAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICB3YXJuKGBpbmplY3Rpb24gXCIke1N0cmluZyhrZXkpfVwiIG5vdCBmb3VuZC5gKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIHdhcm4oYGluamVjdCgpIGNhbiBvbmx5IGJlIHVzZWQgaW5zaWRlIHNldHVwKCkgb3IgZnVuY3Rpb25hbCBjb21wb25lbnRzLmApO1xuICB9XG59XG5mdW5jdGlvbiBoYXNJbmplY3Rpb25Db250ZXh0KCkge1xuICByZXR1cm4gISEoY3VycmVudEluc3RhbmNlIHx8IGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSB8fCBjdXJyZW50QXBwKTtcbn1cblxuZnVuY3Rpb24gaW5pdFByb3BzKGluc3RhbmNlLCByYXdQcm9wcywgaXNTdGF0ZWZ1bCwgaXNTU1IgPSBmYWxzZSkge1xuICBjb25zdCBwcm9wcyA9IHt9O1xuICBjb25zdCBhdHRycyA9IHt9O1xuICBkZWYoYXR0cnMsIEludGVybmFsT2JqZWN0S2V5LCAxKTtcbiAgaW5zdGFuY2UucHJvcHNEZWZhdWx0cyA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBzZXRGdWxsUHJvcHMoaW5zdGFuY2UsIHJhd1Byb3BzLCBwcm9wcywgYXR0cnMpO1xuICBmb3IgKGNvbnN0IGtleSBpbiBpbnN0YW5jZS5wcm9wc09wdGlvbnNbMF0pIHtcbiAgICBpZiAoIShrZXkgaW4gcHJvcHMpKSB7XG4gICAgICBwcm9wc1trZXldID0gdm9pZCAwO1xuICAgIH1cbiAgfVxuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIHZhbGlkYXRlUHJvcHMocmF3UHJvcHMgfHwge30sIHByb3BzLCBpbnN0YW5jZSk7XG4gIH1cbiAgaWYgKGlzU3RhdGVmdWwpIHtcbiAgICBpbnN0YW5jZS5wcm9wcyA9IGlzU1NSID8gcHJvcHMgOiBzaGFsbG93UmVhY3RpdmUocHJvcHMpO1xuICB9IGVsc2Uge1xuICAgIGlmICghaW5zdGFuY2UudHlwZS5wcm9wcykge1xuICAgICAgaW5zdGFuY2UucHJvcHMgPSBhdHRycztcbiAgICB9IGVsc2Uge1xuICAgICAgaW5zdGFuY2UucHJvcHMgPSBwcm9wcztcbiAgICB9XG4gIH1cbiAgaW5zdGFuY2UuYXR0cnMgPSBhdHRycztcbn1cbmZ1bmN0aW9uIGlzSW5IbXJDb250ZXh0KGluc3RhbmNlKSB7XG4gIHdoaWxlIChpbnN0YW5jZSkge1xuICAgIGlmIChpbnN0YW5jZS50eXBlLl9faG1ySWQpXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBpbnN0YW5jZSA9IGluc3RhbmNlLnBhcmVudDtcbiAgfVxufVxuZnVuY3Rpb24gdXBkYXRlUHJvcHMoaW5zdGFuY2UsIHJhd1Byb3BzLCByYXdQcmV2UHJvcHMsIG9wdGltaXplZCkge1xuICBjb25zdCB7XG4gICAgcHJvcHMsXG4gICAgYXR0cnMsXG4gICAgdm5vZGU6IHsgcGF0Y2hGbGFnIH1cbiAgfSA9IGluc3RhbmNlO1xuICBjb25zdCByYXdDdXJyZW50UHJvcHMgPSB0b1Jhdyhwcm9wcyk7XG4gIGNvbnN0IFtvcHRpb25zXSA9IGluc3RhbmNlLnByb3BzT3B0aW9ucztcbiAgbGV0IGhhc0F0dHJzQ2hhbmdlZCA9IGZhbHNlO1xuICBpZiAoXG4gICAgLy8gYWx3YXlzIGZvcmNlIGZ1bGwgZGlmZiBpbiBkZXZcbiAgICAvLyAtICMxOTQyIGlmIGhtciBpcyBlbmFibGVkIHdpdGggc2ZjIGNvbXBvbmVudFxuICAgIC8vIC0gdml0ZSM4NzIgbm9uLXNmYyBjb21wb25lbnQgdXNlZCBieSBzZmMgY29tcG9uZW50XG4gICAgISghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGlzSW5IbXJDb250ZXh0KGluc3RhbmNlKSkgJiYgKG9wdGltaXplZCB8fCBwYXRjaEZsYWcgPiAwKSAmJiAhKHBhdGNoRmxhZyAmIDE2KVxuICApIHtcbiAgICBpZiAocGF0Y2hGbGFnICYgOCkge1xuICAgICAgY29uc3QgcHJvcHNUb1VwZGF0ZSA9IGluc3RhbmNlLnZub2RlLmR5bmFtaWNQcm9wcztcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJvcHNUb1VwZGF0ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQga2V5ID0gcHJvcHNUb1VwZGF0ZVtpXTtcbiAgICAgICAgaWYgKGlzRW1pdExpc3RlbmVyKGluc3RhbmNlLmVtaXRzT3B0aW9ucywga2V5KSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZhbHVlID0gcmF3UHJvcHNba2V5XTtcbiAgICAgICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgICAgICBpZiAoaGFzT3duKGF0dHJzLCBrZXkpKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgIT09IGF0dHJzW2tleV0pIHtcbiAgICAgICAgICAgICAgYXR0cnNba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICBoYXNBdHRyc0NoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBjYW1lbGl6ZWRLZXkgPSBjYW1lbGl6ZShrZXkpO1xuICAgICAgICAgICAgcHJvcHNbY2FtZWxpemVkS2V5XSA9IHJlc29sdmVQcm9wVmFsdWUoXG4gICAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgICAgIHJhd0N1cnJlbnRQcm9wcyxcbiAgICAgICAgICAgICAgY2FtZWxpemVkS2V5LFxuICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgaW5zdGFuY2UsXG4gICAgICAgICAgICAgIGZhbHNlXG4gICAgICAgICAgICAgIC8qIGlzQWJzZW50ICovXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAodmFsdWUgIT09IGF0dHJzW2tleV0pIHtcbiAgICAgICAgICAgIGF0dHJzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIGhhc0F0dHJzQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChzZXRGdWxsUHJvcHMoaW5zdGFuY2UsIHJhd1Byb3BzLCBwcm9wcywgYXR0cnMpKSB7XG4gICAgICBoYXNBdHRyc0NoYW5nZWQgPSB0cnVlO1xuICAgIH1cbiAgICBsZXQga2ViYWJLZXk7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gcmF3Q3VycmVudFByb3BzKSB7XG4gICAgICBpZiAoIXJhd1Byb3BzIHx8IC8vIGZvciBjYW1lbENhc2VcbiAgICAgICFoYXNPd24ocmF3UHJvcHMsIGtleSkgJiYgLy8gaXQncyBwb3NzaWJsZSB0aGUgb3JpZ2luYWwgcHJvcHMgd2FzIHBhc3NlZCBpbiBhcyBrZWJhYi1jYXNlXG4gICAgICAvLyBhbmQgY29udmVydGVkIHRvIGNhbWVsQ2FzZSAoIzk1NSlcbiAgICAgICgoa2ViYWJLZXkgPSBoeXBoZW5hdGUoa2V5KSkgPT09IGtleSB8fCAhaGFzT3duKHJhd1Byb3BzLCBrZWJhYktleSkpKSB7XG4gICAgICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgICAgaWYgKHJhd1ByZXZQcm9wcyAmJiAvLyBmb3IgY2FtZWxDYXNlXG4gICAgICAgICAgKHJhd1ByZXZQcm9wc1trZXldICE9PSB2b2lkIDAgfHwgLy8gZm9yIGtlYmFiLWNhc2VcbiAgICAgICAgICByYXdQcmV2UHJvcHNba2ViYWJLZXldICE9PSB2b2lkIDApKSB7XG4gICAgICAgICAgICBwcm9wc1trZXldID0gcmVzb2x2ZVByb3BWYWx1ZShcbiAgICAgICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICAgICAgcmF3Q3VycmVudFByb3BzLFxuICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgIHZvaWQgMCxcbiAgICAgICAgICAgICAgaW5zdGFuY2UsXG4gICAgICAgICAgICAgIHRydWVcbiAgICAgICAgICAgICAgLyogaXNBYnNlbnQgKi9cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlbGV0ZSBwcm9wc1trZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChhdHRycyAhPT0gcmF3Q3VycmVudFByb3BzKSB7XG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiBhdHRycykge1xuICAgICAgICBpZiAoIXJhd1Byb3BzIHx8ICFoYXNPd24ocmF3UHJvcHMsIGtleSkgJiYgdHJ1ZSkge1xuICAgICAgICAgIGRlbGV0ZSBhdHRyc1trZXldO1xuICAgICAgICAgIGhhc0F0dHJzQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKGhhc0F0dHJzQ2hhbmdlZCkge1xuICAgIHRyaWdnZXIoaW5zdGFuY2UsIFwic2V0XCIsIFwiJGF0dHJzXCIpO1xuICB9XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgdmFsaWRhdGVQcm9wcyhyYXdQcm9wcyB8fCB7fSwgcHJvcHMsIGluc3RhbmNlKTtcbiAgfVxufVxuZnVuY3Rpb24gc2V0RnVsbFByb3BzKGluc3RhbmNlLCByYXdQcm9wcywgcHJvcHMsIGF0dHJzKSB7XG4gIGNvbnN0IFtvcHRpb25zLCBuZWVkQ2FzdEtleXNdID0gaW5zdGFuY2UucHJvcHNPcHRpb25zO1xuICBsZXQgaGFzQXR0cnNDaGFuZ2VkID0gZmFsc2U7XG4gIGxldCByYXdDYXN0VmFsdWVzO1xuICBpZiAocmF3UHJvcHMpIHtcbiAgICBmb3IgKGxldCBrZXkgaW4gcmF3UHJvcHMpIHtcbiAgICAgIGlmIChpc1Jlc2VydmVkUHJvcChrZXkpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgdmFsdWUgPSByYXdQcm9wc1trZXldO1xuICAgICAgbGV0IGNhbWVsS2V5O1xuICAgICAgaWYgKG9wdGlvbnMgJiYgaGFzT3duKG9wdGlvbnMsIGNhbWVsS2V5ID0gY2FtZWxpemUoa2V5KSkpIHtcbiAgICAgICAgaWYgKCFuZWVkQ2FzdEtleXMgfHwgIW5lZWRDYXN0S2V5cy5pbmNsdWRlcyhjYW1lbEtleSkpIHtcbiAgICAgICAgICBwcm9wc1tjYW1lbEtleV0gPSB2YWx1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAocmF3Q2FzdFZhbHVlcyB8fCAocmF3Q2FzdFZhbHVlcyA9IHt9KSlbY2FtZWxLZXldID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoIWlzRW1pdExpc3RlbmVyKGluc3RhbmNlLmVtaXRzT3B0aW9ucywga2V5KSkge1xuICAgICAgICBpZiAoIShrZXkgaW4gYXR0cnMpIHx8IHZhbHVlICE9PSBhdHRyc1trZXldKSB7XG4gICAgICAgICAgYXR0cnNba2V5XSA9IHZhbHVlO1xuICAgICAgICAgIGhhc0F0dHJzQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKG5lZWRDYXN0S2V5cykge1xuICAgIGNvbnN0IHJhd0N1cnJlbnRQcm9wcyA9IHRvUmF3KHByb3BzKTtcbiAgICBjb25zdCBjYXN0VmFsdWVzID0gcmF3Q2FzdFZhbHVlcyB8fCBFTVBUWV9PQko7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuZWVkQ2FzdEtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGtleSA9IG5lZWRDYXN0S2V5c1tpXTtcbiAgICAgIHByb3BzW2tleV0gPSByZXNvbHZlUHJvcFZhbHVlKFxuICAgICAgICBvcHRpb25zLFxuICAgICAgICByYXdDdXJyZW50UHJvcHMsXG4gICAgICAgIGtleSxcbiAgICAgICAgY2FzdFZhbHVlc1trZXldLFxuICAgICAgICBpbnN0YW5jZSxcbiAgICAgICAgIWhhc093bihjYXN0VmFsdWVzLCBrZXkpXG4gICAgICApO1xuICAgIH1cbiAgfVxuICByZXR1cm4gaGFzQXR0cnNDaGFuZ2VkO1xufVxuZnVuY3Rpb24gcmVzb2x2ZVByb3BWYWx1ZShvcHRpb25zLCBwcm9wcywga2V5LCB2YWx1ZSwgaW5zdGFuY2UsIGlzQWJzZW50KSB7XG4gIGNvbnN0IG9wdCA9IG9wdGlvbnNba2V5XTtcbiAgaWYgKG9wdCAhPSBudWxsKSB7XG4gICAgY29uc3QgaGFzRGVmYXVsdCA9IGhhc093bihvcHQsIFwiZGVmYXVsdFwiKTtcbiAgICBpZiAoaGFzRGVmYXVsdCAmJiB2YWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgICBjb25zdCBkZWZhdWx0VmFsdWUgPSBvcHQuZGVmYXVsdDtcbiAgICAgIGlmIChvcHQudHlwZSAhPT0gRnVuY3Rpb24gJiYgIW9wdC5za2lwRmFjdG9yeSAmJiBpc0Z1bmN0aW9uKGRlZmF1bHRWYWx1ZSkpIHtcbiAgICAgICAgY29uc3QgeyBwcm9wc0RlZmF1bHRzIH0gPSBpbnN0YW5jZTtcbiAgICAgICAgaWYgKGtleSBpbiBwcm9wc0RlZmF1bHRzKSB7XG4gICAgICAgICAgdmFsdWUgPSBwcm9wc0RlZmF1bHRzW2tleV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2V0Q3VycmVudEluc3RhbmNlKGluc3RhbmNlKTtcbiAgICAgICAgICB2YWx1ZSA9IHByb3BzRGVmYXVsdHNba2V5XSA9IGRlZmF1bHRWYWx1ZS5jYWxsKFxuICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgIHByb3BzXG4gICAgICAgICAgKTtcbiAgICAgICAgICB1bnNldEN1cnJlbnRJbnN0YW5jZSgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWx1ZSA9IGRlZmF1bHRWYWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9wdFswIC8qIHNob3VsZENhc3QgKi9dKSB7XG4gICAgICBpZiAoaXNBYnNlbnQgJiYgIWhhc0RlZmF1bHQpIHtcbiAgICAgICAgdmFsdWUgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSBpZiAob3B0WzEgLyogc2hvdWxkQ2FzdFRydWUgKi9dICYmICh2YWx1ZSA9PT0gXCJcIiB8fCB2YWx1ZSA9PT0gaHlwaGVuYXRlKGtleSkpKSB7XG4gICAgICAgIHZhbHVlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplUHJvcHNPcHRpb25zKGNvbXAsIGFwcENvbnRleHQsIGFzTWl4aW4gPSBmYWxzZSkge1xuICBjb25zdCBjYWNoZSA9IGFwcENvbnRleHQucHJvcHNDYWNoZTtcbiAgY29uc3QgY2FjaGVkID0gY2FjaGUuZ2V0KGNvbXApO1xuICBpZiAoY2FjaGVkKSB7XG4gICAgcmV0dXJuIGNhY2hlZDtcbiAgfVxuICBjb25zdCByYXcgPSBjb21wLnByb3BzO1xuICBjb25zdCBub3JtYWxpemVkID0ge307XG4gIGNvbnN0IG5lZWRDYXN0S2V5cyA9IFtdO1xuICBsZXQgaGFzRXh0ZW5kcyA9IGZhbHNlO1xuICBpZiAoX19WVUVfT1BUSU9OU19BUElfXyAmJiAhaXNGdW5jdGlvbihjb21wKSkge1xuICAgIGNvbnN0IGV4dGVuZFByb3BzID0gKHJhdzIpID0+IHtcbiAgICAgIGhhc0V4dGVuZHMgPSB0cnVlO1xuICAgICAgY29uc3QgW3Byb3BzLCBrZXlzXSA9IG5vcm1hbGl6ZVByb3BzT3B0aW9ucyhyYXcyLCBhcHBDb250ZXh0LCB0cnVlKTtcbiAgICAgIGV4dGVuZChub3JtYWxpemVkLCBwcm9wcyk7XG4gICAgICBpZiAoa2V5cylcbiAgICAgICAgbmVlZENhc3RLZXlzLnB1c2goLi4ua2V5cyk7XG4gICAgfTtcbiAgICBpZiAoIWFzTWl4aW4gJiYgYXBwQ29udGV4dC5taXhpbnMubGVuZ3RoKSB7XG4gICAgICBhcHBDb250ZXh0Lm1peGlucy5mb3JFYWNoKGV4dGVuZFByb3BzKTtcbiAgICB9XG4gICAgaWYgKGNvbXAuZXh0ZW5kcykge1xuICAgICAgZXh0ZW5kUHJvcHMoY29tcC5leHRlbmRzKTtcbiAgICB9XG4gICAgaWYgKGNvbXAubWl4aW5zKSB7XG4gICAgICBjb21wLm1peGlucy5mb3JFYWNoKGV4dGVuZFByb3BzKTtcbiAgICB9XG4gIH1cbiAgaWYgKCFyYXcgJiYgIWhhc0V4dGVuZHMpIHtcbiAgICBpZiAoaXNPYmplY3QoY29tcCkpIHtcbiAgICAgIGNhY2hlLnNldChjb21wLCBFTVBUWV9BUlIpO1xuICAgIH1cbiAgICByZXR1cm4gRU1QVFlfQVJSO1xuICB9XG4gIGlmIChpc0FycmF5KHJhdykpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJhdy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgIWlzU3RyaW5nKHJhd1tpXSkpIHtcbiAgICAgICAgd2FybihgcHJvcHMgbXVzdCBiZSBzdHJpbmdzIHdoZW4gdXNpbmcgYXJyYXkgc3ludGF4LmAsIHJhd1tpXSk7XG4gICAgICB9XG4gICAgICBjb25zdCBub3JtYWxpemVkS2V5ID0gY2FtZWxpemUocmF3W2ldKTtcbiAgICAgIGlmICh2YWxpZGF0ZVByb3BOYW1lKG5vcm1hbGl6ZWRLZXkpKSB7XG4gICAgICAgIG5vcm1hbGl6ZWRbbm9ybWFsaXplZEtleV0gPSBFTVBUWV9PQko7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKHJhdykge1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICFpc09iamVjdChyYXcpKSB7XG4gICAgICB3YXJuKGBpbnZhbGlkIHByb3BzIG9wdGlvbnNgLCByYXcpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGtleSBpbiByYXcpIHtcbiAgICAgIGNvbnN0IG5vcm1hbGl6ZWRLZXkgPSBjYW1lbGl6ZShrZXkpO1xuICAgICAgaWYgKHZhbGlkYXRlUHJvcE5hbWUobm9ybWFsaXplZEtleSkpIHtcbiAgICAgICAgY29uc3Qgb3B0ID0gcmF3W2tleV07XG4gICAgICAgIGNvbnN0IHByb3AgPSBub3JtYWxpemVkW25vcm1hbGl6ZWRLZXldID0gaXNBcnJheShvcHQpIHx8IGlzRnVuY3Rpb24ob3B0KSA/IHsgdHlwZTogb3B0IH0gOiBleHRlbmQoe30sIG9wdCk7XG4gICAgICAgIGlmIChwcm9wKSB7XG4gICAgICAgICAgY29uc3QgYm9vbGVhbkluZGV4ID0gZ2V0VHlwZUluZGV4KEJvb2xlYW4sIHByb3AudHlwZSk7XG4gICAgICAgICAgY29uc3Qgc3RyaW5nSW5kZXggPSBnZXRUeXBlSW5kZXgoU3RyaW5nLCBwcm9wLnR5cGUpO1xuICAgICAgICAgIHByb3BbMCAvKiBzaG91bGRDYXN0ICovXSA9IGJvb2xlYW5JbmRleCA+IC0xO1xuICAgICAgICAgIHByb3BbMSAvKiBzaG91bGRDYXN0VHJ1ZSAqL10gPSBzdHJpbmdJbmRleCA8IDAgfHwgYm9vbGVhbkluZGV4IDwgc3RyaW5nSW5kZXg7XG4gICAgICAgICAgaWYgKGJvb2xlYW5JbmRleCA+IC0xIHx8IGhhc093bihwcm9wLCBcImRlZmF1bHRcIikpIHtcbiAgICAgICAgICAgIG5lZWRDYXN0S2V5cy5wdXNoKG5vcm1hbGl6ZWRLZXkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBjb25zdCByZXMgPSBbbm9ybWFsaXplZCwgbmVlZENhc3RLZXlzXTtcbiAgaWYgKGlzT2JqZWN0KGNvbXApKSB7XG4gICAgY2FjaGUuc2V0KGNvbXAsIHJlcyk7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcE5hbWUoa2V5KSB7XG4gIGlmIChrZXlbMF0gIT09IFwiJFwiKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIHdhcm4oYEludmFsaWQgcHJvcCBuYW1lOiBcIiR7a2V5fVwiIGlzIGEgcmVzZXJ2ZWQgcHJvcGVydHkuYCk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gZ2V0VHlwZShjdG9yKSB7XG4gIGNvbnN0IG1hdGNoID0gY3RvciAmJiBjdG9yLnRvU3RyaW5nKCkubWF0Y2goL15cXHMqKGZ1bmN0aW9ufGNsYXNzKSAoXFx3KykvKTtcbiAgcmV0dXJuIG1hdGNoID8gbWF0Y2hbMl0gOiBjdG9yID09PSBudWxsID8gXCJudWxsXCIgOiBcIlwiO1xufVxuZnVuY3Rpb24gaXNTYW1lVHlwZShhLCBiKSB7XG4gIHJldHVybiBnZXRUeXBlKGEpID09PSBnZXRUeXBlKGIpO1xufVxuZnVuY3Rpb24gZ2V0VHlwZUluZGV4KHR5cGUsIGV4cGVjdGVkVHlwZXMpIHtcbiAgaWYgKGlzQXJyYXkoZXhwZWN0ZWRUeXBlcykpIHtcbiAgICByZXR1cm4gZXhwZWN0ZWRUeXBlcy5maW5kSW5kZXgoKHQpID0+IGlzU2FtZVR5cGUodCwgdHlwZSkpO1xuICB9IGVsc2UgaWYgKGlzRnVuY3Rpb24oZXhwZWN0ZWRUeXBlcykpIHtcbiAgICByZXR1cm4gaXNTYW1lVHlwZShleHBlY3RlZFR5cGVzLCB0eXBlKSA/IDAgOiAtMTtcbiAgfVxuICByZXR1cm4gLTE7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BzKHJhd1Byb3BzLCBwcm9wcywgaW5zdGFuY2UpIHtcbiAgY29uc3QgcmVzb2x2ZWRWYWx1ZXMgPSB0b1Jhdyhwcm9wcyk7XG4gIGNvbnN0IG9wdGlvbnMgPSBpbnN0YW5jZS5wcm9wc09wdGlvbnNbMF07XG4gIGZvciAoY29uc3Qga2V5IGluIG9wdGlvbnMpIHtcbiAgICBsZXQgb3B0ID0gb3B0aW9uc1trZXldO1xuICAgIGlmIChvcHQgPT0gbnVsbClcbiAgICAgIGNvbnRpbnVlO1xuICAgIHZhbGlkYXRlUHJvcChcbiAgICAgIGtleSxcbiAgICAgIHJlc29sdmVkVmFsdWVzW2tleV0sXG4gICAgICBvcHQsXG4gICAgICAhaGFzT3duKHJhd1Byb3BzLCBrZXkpICYmICFoYXNPd24ocmF3UHJvcHMsIGh5cGhlbmF0ZShrZXkpKVxuICAgICk7XG4gIH1cbn1cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcChuYW1lLCB2YWx1ZSwgcHJvcCwgaXNBYnNlbnQpIHtcbiAgY29uc3QgeyB0eXBlLCByZXF1aXJlZCwgdmFsaWRhdG9yLCBza2lwQ2hlY2sgfSA9IHByb3A7XG4gIGlmIChyZXF1aXJlZCAmJiBpc0Fic2VudCkge1xuICAgIHdhcm4oJ01pc3NpbmcgcmVxdWlyZWQgcHJvcDogXCInICsgbmFtZSArICdcIicpO1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAodmFsdWUgPT0gbnVsbCAmJiAhcmVxdWlyZWQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHR5cGUgIT0gbnVsbCAmJiB0eXBlICE9PSB0cnVlICYmICFza2lwQ2hlY2spIHtcbiAgICBsZXQgaXNWYWxpZCA9IGZhbHNlO1xuICAgIGNvbnN0IHR5cGVzID0gaXNBcnJheSh0eXBlKSA/IHR5cGUgOiBbdHlwZV07XG4gICAgY29uc3QgZXhwZWN0ZWRUeXBlcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdHlwZXMubGVuZ3RoICYmICFpc1ZhbGlkOyBpKyspIHtcbiAgICAgIGNvbnN0IHsgdmFsaWQsIGV4cGVjdGVkVHlwZSB9ID0gYXNzZXJ0VHlwZSh2YWx1ZSwgdHlwZXNbaV0pO1xuICAgICAgZXhwZWN0ZWRUeXBlcy5wdXNoKGV4cGVjdGVkVHlwZSB8fCBcIlwiKTtcbiAgICAgIGlzVmFsaWQgPSB2YWxpZDtcbiAgICB9XG4gICAgaWYgKCFpc1ZhbGlkKSB7XG4gICAgICB3YXJuKGdldEludmFsaWRUeXBlTWVzc2FnZShuYW1lLCB2YWx1ZSwgZXhwZWN0ZWRUeXBlcykpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuICBpZiAodmFsaWRhdG9yICYmICF2YWxpZGF0b3IodmFsdWUpKSB7XG4gICAgd2FybignSW52YWxpZCBwcm9wOiBjdXN0b20gdmFsaWRhdG9yIGNoZWNrIGZhaWxlZCBmb3IgcHJvcCBcIicgKyBuYW1lICsgJ1wiLicpO1xuICB9XG59XG5jb25zdCBpc1NpbXBsZVR5cGUgPSAvKiBAX19QVVJFX18gKi8gbWFrZU1hcChcbiAgXCJTdHJpbmcsTnVtYmVyLEJvb2xlYW4sRnVuY3Rpb24sU3ltYm9sLEJpZ0ludFwiXG4pO1xuZnVuY3Rpb24gYXNzZXJ0VHlwZSh2YWx1ZSwgdHlwZSkge1xuICBsZXQgdmFsaWQ7XG4gIGNvbnN0IGV4cGVjdGVkVHlwZSA9IGdldFR5cGUodHlwZSk7XG4gIGlmIChpc1NpbXBsZVR5cGUoZXhwZWN0ZWRUeXBlKSkge1xuICAgIGNvbnN0IHQgPSB0eXBlb2YgdmFsdWU7XG4gICAgdmFsaWQgPSB0ID09PSBleHBlY3RlZFR5cGUudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAoIXZhbGlkICYmIHQgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgIHZhbGlkID0gdmFsdWUgaW5zdGFuY2VvZiB0eXBlO1xuICAgIH1cbiAgfSBlbHNlIGlmIChleHBlY3RlZFR5cGUgPT09IFwiT2JqZWN0XCIpIHtcbiAgICB2YWxpZCA9IGlzT2JqZWN0KHZhbHVlKTtcbiAgfSBlbHNlIGlmIChleHBlY3RlZFR5cGUgPT09IFwiQXJyYXlcIikge1xuICAgIHZhbGlkID0gaXNBcnJheSh2YWx1ZSk7XG4gIH0gZWxzZSBpZiAoZXhwZWN0ZWRUeXBlID09PSBcIm51bGxcIikge1xuICAgIHZhbGlkID0gdmFsdWUgPT09IG51bGw7XG4gIH0gZWxzZSB7XG4gICAgdmFsaWQgPSB2YWx1ZSBpbnN0YW5jZW9mIHR5cGU7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB2YWxpZCxcbiAgICBleHBlY3RlZFR5cGVcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldEludmFsaWRUeXBlTWVzc2FnZShuYW1lLCB2YWx1ZSwgZXhwZWN0ZWRUeXBlcykge1xuICBsZXQgbWVzc2FnZSA9IGBJbnZhbGlkIHByb3A6IHR5cGUgY2hlY2sgZmFpbGVkIGZvciBwcm9wIFwiJHtuYW1lfVwiLiBFeHBlY3RlZCAke2V4cGVjdGVkVHlwZXMubWFwKGNhcGl0YWxpemUpLmpvaW4oXCIgfCBcIil9YDtcbiAgY29uc3QgZXhwZWN0ZWRUeXBlID0gZXhwZWN0ZWRUeXBlc1swXTtcbiAgY29uc3QgcmVjZWl2ZWRUeXBlID0gdG9SYXdUeXBlKHZhbHVlKTtcbiAgY29uc3QgZXhwZWN0ZWRWYWx1ZSA9IHN0eWxlVmFsdWUodmFsdWUsIGV4cGVjdGVkVHlwZSk7XG4gIGNvbnN0IHJlY2VpdmVkVmFsdWUgPSBzdHlsZVZhbHVlKHZhbHVlLCByZWNlaXZlZFR5cGUpO1xuICBpZiAoZXhwZWN0ZWRUeXBlcy5sZW5ndGggPT09IDEgJiYgaXNFeHBsaWNhYmxlKGV4cGVjdGVkVHlwZSkgJiYgIWlzQm9vbGVhbihleHBlY3RlZFR5cGUsIHJlY2VpdmVkVHlwZSkpIHtcbiAgICBtZXNzYWdlICs9IGAgd2l0aCB2YWx1ZSAke2V4cGVjdGVkVmFsdWV9YDtcbiAgfVxuICBtZXNzYWdlICs9IGAsIGdvdCAke3JlY2VpdmVkVHlwZX0gYDtcbiAgaWYgKGlzRXhwbGljYWJsZShyZWNlaXZlZFR5cGUpKSB7XG4gICAgbWVzc2FnZSArPSBgd2l0aCB2YWx1ZSAke3JlY2VpdmVkVmFsdWV9LmA7XG4gIH1cbiAgcmV0dXJuIG1lc3NhZ2U7XG59XG5mdW5jdGlvbiBzdHlsZVZhbHVlKHZhbHVlLCB0eXBlKSB7XG4gIGlmICh0eXBlID09PSBcIlN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIGBcIiR7dmFsdWV9XCJgO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09IFwiTnVtYmVyXCIpIHtcbiAgICByZXR1cm4gYCR7TnVtYmVyKHZhbHVlKX1gO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBgJHt2YWx1ZX1gO1xuICB9XG59XG5mdW5jdGlvbiBpc0V4cGxpY2FibGUodHlwZSkge1xuICBjb25zdCBleHBsaWNpdFR5cGVzID0gW1wic3RyaW5nXCIsIFwibnVtYmVyXCIsIFwiYm9vbGVhblwiXTtcbiAgcmV0dXJuIGV4cGxpY2l0VHlwZXMuc29tZSgoZWxlbSkgPT4gdHlwZS50b0xvd2VyQ2FzZSgpID09PSBlbGVtKTtcbn1cbmZ1bmN0aW9uIGlzQm9vbGVhbiguLi5hcmdzKSB7XG4gIHJldHVybiBhcmdzLnNvbWUoKGVsZW0pID0+IGVsZW0udG9Mb3dlckNhc2UoKSA9PT0gXCJib29sZWFuXCIpO1xufVxuXG5jb25zdCBpc0ludGVybmFsS2V5ID0gKGtleSkgPT4ga2V5WzBdID09PSBcIl9cIiB8fCBrZXkgPT09IFwiJHN0YWJsZVwiO1xuY29uc3Qgbm9ybWFsaXplU2xvdFZhbHVlID0gKHZhbHVlKSA9PiBpc0FycmF5KHZhbHVlKSA/IHZhbHVlLm1hcChub3JtYWxpemVWTm9kZSkgOiBbbm9ybWFsaXplVk5vZGUodmFsdWUpXTtcbmNvbnN0IG5vcm1hbGl6ZVNsb3QgPSAoa2V5LCByYXdTbG90LCBjdHgpID0+IHtcbiAgaWYgKHJhd1Nsb3QuX24pIHtcbiAgICByZXR1cm4gcmF3U2xvdDtcbiAgfVxuICBjb25zdCBub3JtYWxpemVkID0gd2l0aEN0eCgoLi4uYXJncykgPT4ge1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGN1cnJlbnRJbnN0YW5jZSkge1xuICAgICAgd2FybihcbiAgICAgICAgYFNsb3QgXCIke2tleX1cIiBpbnZva2VkIG91dHNpZGUgb2YgdGhlIHJlbmRlciBmdW5jdGlvbjogdGhpcyB3aWxsIG5vdCB0cmFjayBkZXBlbmRlbmNpZXMgdXNlZCBpbiB0aGUgc2xvdC4gSW52b2tlIHRoZSBzbG90IGZ1bmN0aW9uIGluc2lkZSB0aGUgcmVuZGVyIGZ1bmN0aW9uIGluc3RlYWQuYFxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIG5vcm1hbGl6ZVNsb3RWYWx1ZShyYXdTbG90KC4uLmFyZ3MpKTtcbiAgfSwgY3R4KTtcbiAgbm9ybWFsaXplZC5fYyA9IGZhbHNlO1xuICByZXR1cm4gbm9ybWFsaXplZDtcbn07XG5jb25zdCBub3JtYWxpemVPYmplY3RTbG90cyA9IChyYXdTbG90cywgc2xvdHMsIGluc3RhbmNlKSA9PiB7XG4gIGNvbnN0IGN0eCA9IHJhd1Nsb3RzLl9jdHg7XG4gIGZvciAoY29uc3Qga2V5IGluIHJhd1Nsb3RzKSB7XG4gICAgaWYgKGlzSW50ZXJuYWxLZXkoa2V5KSlcbiAgICAgIGNvbnRpbnVlO1xuICAgIGNvbnN0IHZhbHVlID0gcmF3U2xvdHNba2V5XTtcbiAgICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICAgIHNsb3RzW2tleV0gPSBub3JtYWxpemVTbG90KGtleSwgdmFsdWUsIGN0eCk7XG4gICAgfSBlbHNlIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiB0cnVlKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgYE5vbi1mdW5jdGlvbiB2YWx1ZSBlbmNvdW50ZXJlZCBmb3Igc2xvdCBcIiR7a2V5fVwiLiBQcmVmZXIgZnVuY3Rpb24gc2xvdHMgZm9yIGJldHRlciBwZXJmb3JtYW5jZS5gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBjb25zdCBub3JtYWxpemVkID0gbm9ybWFsaXplU2xvdFZhbHVlKHZhbHVlKTtcbiAgICAgIHNsb3RzW2tleV0gPSAoKSA9PiBub3JtYWxpemVkO1xuICAgIH1cbiAgfVxufTtcbmNvbnN0IG5vcm1hbGl6ZVZOb2RlU2xvdHMgPSAoaW5zdGFuY2UsIGNoaWxkcmVuKSA9PiB7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICFpc0tlZXBBbGl2ZShpbnN0YW5jZS52bm9kZSkgJiYgdHJ1ZSkge1xuICAgIHdhcm4oXG4gICAgICBgTm9uLWZ1bmN0aW9uIHZhbHVlIGVuY291bnRlcmVkIGZvciBkZWZhdWx0IHNsb3QuIFByZWZlciBmdW5jdGlvbiBzbG90cyBmb3IgYmV0dGVyIHBlcmZvcm1hbmNlLmBcbiAgICApO1xuICB9XG4gIGNvbnN0IG5vcm1hbGl6ZWQgPSBub3JtYWxpemVTbG90VmFsdWUoY2hpbGRyZW4pO1xuICBpbnN0YW5jZS5zbG90cy5kZWZhdWx0ID0gKCkgPT4gbm9ybWFsaXplZDtcbn07XG5jb25zdCBpbml0U2xvdHMgPSAoaW5zdGFuY2UsIGNoaWxkcmVuKSA9PiB7XG4gIGlmIChpbnN0YW5jZS52bm9kZS5zaGFwZUZsYWcgJiAzMikge1xuICAgIGNvbnN0IHR5cGUgPSBjaGlsZHJlbi5fO1xuICAgIGlmICh0eXBlKSB7XG4gICAgICBpbnN0YW5jZS5zbG90cyA9IHRvUmF3KGNoaWxkcmVuKTtcbiAgICAgIGRlZihjaGlsZHJlbiwgXCJfXCIsIHR5cGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBub3JtYWxpemVPYmplY3RTbG90cyhcbiAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgIGluc3RhbmNlLnNsb3RzID0ge30pO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpbnN0YW5jZS5zbG90cyA9IHt9O1xuICAgIGlmIChjaGlsZHJlbikge1xuICAgICAgbm9ybWFsaXplVk5vZGVTbG90cyhpbnN0YW5jZSwgY2hpbGRyZW4pO1xuICAgIH1cbiAgfVxuICBkZWYoaW5zdGFuY2Uuc2xvdHMsIEludGVybmFsT2JqZWN0S2V5LCAxKTtcbn07XG5jb25zdCB1cGRhdGVTbG90cyA9IChpbnN0YW5jZSwgY2hpbGRyZW4sIG9wdGltaXplZCkgPT4ge1xuICBjb25zdCB7IHZub2RlLCBzbG90cyB9ID0gaW5zdGFuY2U7XG4gIGxldCBuZWVkRGVsZXRpb25DaGVjayA9IHRydWU7XG4gIGxldCBkZWxldGlvbkNvbXBhcmlzb25UYXJnZXQgPSBFTVBUWV9PQko7XG4gIGlmICh2bm9kZS5zaGFwZUZsYWcgJiAzMikge1xuICAgIGNvbnN0IHR5cGUgPSBjaGlsZHJlbi5fO1xuICAgIGlmICh0eXBlKSB7XG4gICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBpc0htclVwZGF0aW5nKSB7XG4gICAgICAgIGV4dGVuZChzbG90cywgY2hpbGRyZW4pO1xuICAgICAgICB0cmlnZ2VyKGluc3RhbmNlLCBcInNldFwiLCBcIiRzbG90c1wiKTtcbiAgICAgIH0gZWxzZSBpZiAob3B0aW1pemVkICYmIHR5cGUgPT09IDEpIHtcbiAgICAgICAgbmVlZERlbGV0aW9uQ2hlY2sgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGV4dGVuZChzbG90cywgY2hpbGRyZW4pO1xuICAgICAgICBpZiAoIW9wdGltaXplZCAmJiB0eXBlID09PSAxKSB7XG4gICAgICAgICAgZGVsZXRlIHNsb3RzLl87XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbmVlZERlbGV0aW9uQ2hlY2sgPSAhY2hpbGRyZW4uJHN0YWJsZTtcbiAgICAgIG5vcm1hbGl6ZU9iamVjdFNsb3RzKGNoaWxkcmVuLCBzbG90cyk7XG4gICAgfVxuICAgIGRlbGV0aW9uQ29tcGFyaXNvblRhcmdldCA9IGNoaWxkcmVuO1xuICB9IGVsc2UgaWYgKGNoaWxkcmVuKSB7XG4gICAgbm9ybWFsaXplVk5vZGVTbG90cyhpbnN0YW5jZSwgY2hpbGRyZW4pO1xuICAgIGRlbGV0aW9uQ29tcGFyaXNvblRhcmdldCA9IHsgZGVmYXVsdDogMSB9O1xuICB9XG4gIGlmIChuZWVkRGVsZXRpb25DaGVjaykge1xuICAgIGZvciAoY29uc3Qga2V5IGluIHNsb3RzKSB7XG4gICAgICBpZiAoIWlzSW50ZXJuYWxLZXkoa2V5KSAmJiAhKGtleSBpbiBkZWxldGlvbkNvbXBhcmlzb25UYXJnZXQpKSB7XG4gICAgICAgIGRlbGV0ZSBzbG90c1trZXldO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gc2V0UmVmKHJhd1JlZiwgb2xkUmF3UmVmLCBwYXJlbnRTdXNwZW5zZSwgdm5vZGUsIGlzVW5tb3VudCA9IGZhbHNlKSB7XG4gIGlmIChpc0FycmF5KHJhd1JlZikpIHtcbiAgICByYXdSZWYuZm9yRWFjaChcbiAgICAgIChyLCBpKSA9PiBzZXRSZWYoXG4gICAgICAgIHIsXG4gICAgICAgIG9sZFJhd1JlZiAmJiAoaXNBcnJheShvbGRSYXdSZWYpID8gb2xkUmF3UmVmW2ldIDogb2xkUmF3UmVmKSxcbiAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgIHZub2RlLFxuICAgICAgICBpc1VubW91bnRcbiAgICAgIClcbiAgICApO1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoaXNBc3luY1dyYXBwZXIodm5vZGUpICYmICFpc1VubW91bnQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgcmVmVmFsdWUgPSB2bm9kZS5zaGFwZUZsYWcgJiA0ID8gZ2V0RXhwb3NlUHJveHkodm5vZGUuY29tcG9uZW50KSB8fCB2bm9kZS5jb21wb25lbnQucHJveHkgOiB2bm9kZS5lbDtcbiAgY29uc3QgdmFsdWUgPSBpc1VubW91bnQgPyBudWxsIDogcmVmVmFsdWU7XG4gIGNvbnN0IHsgaTogb3duZXIsIHI6IHJlZiB9ID0gcmF3UmVmO1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhb3duZXIpIHtcbiAgICB3YXJuKFxuICAgICAgYE1pc3NpbmcgcmVmIG93bmVyIGNvbnRleHQuIHJlZiBjYW5ub3QgYmUgdXNlZCBvbiBob2lzdGVkIHZub2Rlcy4gQSB2bm9kZSB3aXRoIHJlZiBtdXN0IGJlIGNyZWF0ZWQgaW5zaWRlIHRoZSByZW5kZXIgZnVuY3Rpb24uYFxuICAgICk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IG9sZFJlZiA9IG9sZFJhd1JlZiAmJiBvbGRSYXdSZWYucjtcbiAgY29uc3QgcmVmcyA9IG93bmVyLnJlZnMgPT09IEVNUFRZX09CSiA/IG93bmVyLnJlZnMgPSB7fSA6IG93bmVyLnJlZnM7XG4gIGNvbnN0IHNldHVwU3RhdGUgPSBvd25lci5zZXR1cFN0YXRlO1xuICBpZiAob2xkUmVmICE9IG51bGwgJiYgb2xkUmVmICE9PSByZWYpIHtcbiAgICBpZiAoaXNTdHJpbmcob2xkUmVmKSkge1xuICAgICAgcmVmc1tvbGRSZWZdID0gbnVsbDtcbiAgICAgIGlmIChoYXNPd24oc2V0dXBTdGF0ZSwgb2xkUmVmKSkge1xuICAgICAgICBzZXR1cFN0YXRlW29sZFJlZl0gPSBudWxsO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNSZWYob2xkUmVmKSkge1xuICAgICAgb2xkUmVmLnZhbHVlID0gbnVsbDtcbiAgICB9XG4gIH1cbiAgaWYgKGlzRnVuY3Rpb24ocmVmKSkge1xuICAgIGNhbGxXaXRoRXJyb3JIYW5kbGluZyhyZWYsIG93bmVyLCAxMiwgW3ZhbHVlLCByZWZzXSk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgX2lzU3RyaW5nID0gaXNTdHJpbmcocmVmKTtcbiAgICBjb25zdCBfaXNSZWYgPSBpc1JlZihyZWYpO1xuICAgIGlmIChfaXNTdHJpbmcgfHwgX2lzUmVmKSB7XG4gICAgICBjb25zdCBkb1NldCA9ICgpID0+IHtcbiAgICAgICAgaWYgKHJhd1JlZi5mKSB7XG4gICAgICAgICAgY29uc3QgZXhpc3RpbmcgPSBfaXNTdHJpbmcgPyBoYXNPd24oc2V0dXBTdGF0ZSwgcmVmKSA/IHNldHVwU3RhdGVbcmVmXSA6IHJlZnNbcmVmXSA6IHJlZi52YWx1ZTtcbiAgICAgICAgICBpZiAoaXNVbm1vdW50KSB7XG4gICAgICAgICAgICBpc0FycmF5KGV4aXN0aW5nKSAmJiByZW1vdmUoZXhpc3RpbmcsIHJlZlZhbHVlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFpc0FycmF5KGV4aXN0aW5nKSkge1xuICAgICAgICAgICAgICBpZiAoX2lzU3RyaW5nKSB7XG4gICAgICAgICAgICAgICAgcmVmc1tyZWZdID0gW3JlZlZhbHVlXTtcbiAgICAgICAgICAgICAgICBpZiAoaGFzT3duKHNldHVwU3RhdGUsIHJlZikpIHtcbiAgICAgICAgICAgICAgICAgIHNldHVwU3RhdGVbcmVmXSA9IHJlZnNbcmVmXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVmLnZhbHVlID0gW3JlZlZhbHVlXTtcbiAgICAgICAgICAgICAgICBpZiAocmF3UmVmLmspXG4gICAgICAgICAgICAgICAgICByZWZzW3Jhd1JlZi5rXSA9IHJlZi52YWx1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICghZXhpc3RpbmcuaW5jbHVkZXMocmVmVmFsdWUpKSB7XG4gICAgICAgICAgICAgIGV4aXN0aW5nLnB1c2gocmVmVmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChfaXNTdHJpbmcpIHtcbiAgICAgICAgICByZWZzW3JlZl0gPSB2YWx1ZTtcbiAgICAgICAgICBpZiAoaGFzT3duKHNldHVwU3RhdGUsIHJlZikpIHtcbiAgICAgICAgICAgIHNldHVwU3RhdGVbcmVmXSA9IHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChfaXNSZWYpIHtcbiAgICAgICAgICByZWYudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICBpZiAocmF3UmVmLmspXG4gICAgICAgICAgICByZWZzW3Jhd1JlZi5rXSA9IHZhbHVlO1xuICAgICAgICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICB3YXJuKFwiSW52YWxpZCB0ZW1wbGF0ZSByZWYgdHlwZTpcIiwgcmVmLCBgKCR7dHlwZW9mIHJlZn0pYCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgZG9TZXQuaWQgPSAtMTtcbiAgICAgICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KGRvU2V0LCBwYXJlbnRTdXNwZW5zZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkb1NldCgpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgd2FybihcIkludmFsaWQgdGVtcGxhdGUgcmVmIHR5cGU6XCIsIHJlZiwgYCgke3R5cGVvZiByZWZ9KWApO1xuICAgIH1cbiAgfVxufVxuXG5sZXQgaGFzTWlzbWF0Y2ggPSBmYWxzZTtcbmNvbnN0IGlzU1ZHQ29udGFpbmVyID0gKGNvbnRhaW5lcikgPT4gL3N2Zy8udGVzdChjb250YWluZXIubmFtZXNwYWNlVVJJKSAmJiBjb250YWluZXIudGFnTmFtZSAhPT0gXCJmb3JlaWduT2JqZWN0XCI7XG5jb25zdCBpc0NvbW1lbnQgPSAobm9kZSkgPT4gbm9kZS5ub2RlVHlwZSA9PT0gOCAvKiBDT01NRU5UICovO1xuZnVuY3Rpb24gY3JlYXRlSHlkcmF0aW9uRnVuY3Rpb25zKHJlbmRlcmVySW50ZXJuYWxzKSB7XG4gIGNvbnN0IHtcbiAgICBtdDogbW91bnRDb21wb25lbnQsXG4gICAgcDogcGF0Y2gsXG4gICAgbzoge1xuICAgICAgcGF0Y2hQcm9wLFxuICAgICAgY3JlYXRlVGV4dCxcbiAgICAgIG5leHRTaWJsaW5nLFxuICAgICAgcGFyZW50Tm9kZSxcbiAgICAgIHJlbW92ZSxcbiAgICAgIGluc2VydCxcbiAgICAgIGNyZWF0ZUNvbW1lbnRcbiAgICB9XG4gIH0gPSByZW5kZXJlckludGVybmFscztcbiAgY29uc3QgaHlkcmF0ZSA9ICh2bm9kZSwgY29udGFpbmVyKSA9PiB7XG4gICAgaWYgKCFjb250YWluZXIuaGFzQ2hpbGROb2RlcygpKSB7XG4gICAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHdhcm4oXG4gICAgICAgIGBBdHRlbXB0aW5nIHRvIGh5ZHJhdGUgZXhpc3RpbmcgbWFya3VwIGJ1dCBjb250YWluZXIgaXMgZW1wdHkuIFBlcmZvcm1pbmcgZnVsbCBtb3VudCBpbnN0ZWFkLmBcbiAgICAgICk7XG4gICAgICBwYXRjaChudWxsLCB2bm9kZSwgY29udGFpbmVyKTtcbiAgICAgIGZsdXNoUG9zdEZsdXNoQ2JzKCk7XG4gICAgICBjb250YWluZXIuX3Zub2RlID0gdm5vZGU7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGhhc01pc21hdGNoID0gZmFsc2U7XG4gICAgaHlkcmF0ZU5vZGUoY29udGFpbmVyLmZpcnN0Q2hpbGQsIHZub2RlLCBudWxsLCBudWxsLCBudWxsKTtcbiAgICBmbHVzaFBvc3RGbHVzaENicygpO1xuICAgIGNvbnRhaW5lci5fdm5vZGUgPSB2bm9kZTtcbiAgICBpZiAoaGFzTWlzbWF0Y2ggJiYgdHJ1ZSkge1xuICAgICAgY29uc29sZS5lcnJvcihgSHlkcmF0aW9uIGNvbXBsZXRlZCBidXQgY29udGFpbnMgbWlzbWF0Y2hlcy5gKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IGh5ZHJhdGVOb2RlID0gKG5vZGUsIHZub2RlLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCA9IGZhbHNlKSA9PiB7XG4gICAgY29uc3QgaXNGcmFnbWVudFN0YXJ0ID0gaXNDb21tZW50KG5vZGUpICYmIG5vZGUuZGF0YSA9PT0gXCJbXCI7XG4gICAgY29uc3Qgb25NaXNtYXRjaCA9ICgpID0+IGhhbmRsZU1pc21hdGNoKFxuICAgICAgbm9kZSxcbiAgICAgIHZub2RlLFxuICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICBzbG90U2NvcGVJZHMsXG4gICAgICBpc0ZyYWdtZW50U3RhcnRcbiAgICApO1xuICAgIGNvbnN0IHsgdHlwZSwgcmVmLCBzaGFwZUZsYWcsIHBhdGNoRmxhZyB9ID0gdm5vZGU7XG4gICAgbGV0IGRvbVR5cGUgPSBub2RlLm5vZGVUeXBlO1xuICAgIHZub2RlLmVsID0gbm9kZTtcbiAgICBpZiAocGF0Y2hGbGFnID09PSAtMikge1xuICAgICAgb3B0aW1pemVkID0gZmFsc2U7XG4gICAgICB2bm9kZS5keW5hbWljQ2hpbGRyZW4gPSBudWxsO1xuICAgIH1cbiAgICBsZXQgbmV4dE5vZGUgPSBudWxsO1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSBUZXh0OlxuICAgICAgICBpZiAoZG9tVHlwZSAhPT0gMyAvKiBURVhUICovKSB7XG4gICAgICAgICAgaWYgKHZub2RlLmNoaWxkcmVuID09PSBcIlwiKSB7XG4gICAgICAgICAgICBpbnNlcnQodm5vZGUuZWwgPSBjcmVhdGVUZXh0KFwiXCIpLCBwYXJlbnROb2RlKG5vZGUpLCBub2RlKTtcbiAgICAgICAgICAgIG5leHROb2RlID0gbm9kZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV4dE5vZGUgPSBvbk1pc21hdGNoKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChub2RlLmRhdGEgIT09IHZub2RlLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICBoYXNNaXNtYXRjaCA9IHRydWU7XG4gICAgICAgICAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHdhcm4oXG4gICAgICAgICAgICAgIGBIeWRyYXRpb24gdGV4dCBtaXNtYXRjaDpcbi0gQ2xpZW50OiAke0pTT04uc3RyaW5naWZ5KG5vZGUuZGF0YSl9XG4tIFNlcnZlcjogJHtKU09OLnN0cmluZ2lmeSh2bm9kZS5jaGlsZHJlbil9YFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIG5vZGUuZGF0YSA9IHZub2RlLmNoaWxkcmVuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBuZXh0Tm9kZSA9IG5leHRTaWJsaW5nKG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBDb21tZW50OlxuICAgICAgICBpZiAoZG9tVHlwZSAhPT0gOCAvKiBDT01NRU5UICovIHx8IGlzRnJhZ21lbnRTdGFydCkge1xuICAgICAgICAgIG5leHROb2RlID0gb25NaXNtYXRjaCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5leHROb2RlID0gbmV4dFNpYmxpbmcobm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFN0YXRpYzpcbiAgICAgICAgaWYgKGlzRnJhZ21lbnRTdGFydCkge1xuICAgICAgICAgIG5vZGUgPSBuZXh0U2libGluZyhub2RlKTtcbiAgICAgICAgICBkb21UeXBlID0gbm9kZS5ub2RlVHlwZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZG9tVHlwZSA9PT0gMSAvKiBFTEVNRU5UICovIHx8IGRvbVR5cGUgPT09IDMgLyogVEVYVCAqLykge1xuICAgICAgICAgIG5leHROb2RlID0gbm9kZTtcbiAgICAgICAgICBjb25zdCBuZWVkVG9BZG9wdENvbnRlbnQgPSAhdm5vZGUuY2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdm5vZGUuc3RhdGljQ291bnQ7IGkrKykge1xuICAgICAgICAgICAgaWYgKG5lZWRUb0Fkb3B0Q29udGVudClcbiAgICAgICAgICAgICAgdm5vZGUuY2hpbGRyZW4gKz0gbmV4dE5vZGUubm9kZVR5cGUgPT09IDEgLyogRUxFTUVOVCAqLyA/IG5leHROb2RlLm91dGVySFRNTCA6IG5leHROb2RlLmRhdGE7XG4gICAgICAgICAgICBpZiAoaSA9PT0gdm5vZGUuc3RhdGljQ291bnQgLSAxKSB7XG4gICAgICAgICAgICAgIHZub2RlLmFuY2hvciA9IG5leHROb2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV4dE5vZGUgPSBuZXh0U2libGluZyhuZXh0Tm9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBpc0ZyYWdtZW50U3RhcnQgPyBuZXh0U2libGluZyhuZXh0Tm9kZSkgOiBuZXh0Tm9kZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvbk1pc21hdGNoKCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEZyYWdtZW50OlxuICAgICAgICBpZiAoIWlzRnJhZ21lbnRTdGFydCkge1xuICAgICAgICAgIG5leHROb2RlID0gb25NaXNtYXRjaCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5leHROb2RlID0gaHlkcmF0ZUZyYWdtZW50KFxuICAgICAgICAgICAgbm9kZSxcbiAgICAgICAgICAgIHZub2RlLFxuICAgICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKHNoYXBlRmxhZyAmIDEpIHtcbiAgICAgICAgICBpZiAoZG9tVHlwZSAhPT0gMSAvKiBFTEVNRU5UICovIHx8IHZub2RlLnR5cGUudG9Mb3dlckNhc2UoKSAhPT0gbm9kZS50YWdOYW1lLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICAgIG5leHROb2RlID0gb25NaXNtYXRjaCgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXh0Tm9kZSA9IGh5ZHJhdGVFbGVtZW50KFxuICAgICAgICAgICAgICBub2RlLFxuICAgICAgICAgICAgICB2bm9kZSxcbiAgICAgICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHNoYXBlRmxhZyAmIDYpIHtcbiAgICAgICAgICB2bm9kZS5zbG90U2NvcGVJZHMgPSBzbG90U2NvcGVJZHM7XG4gICAgICAgICAgY29uc3QgY29udGFpbmVyID0gcGFyZW50Tm9kZShub2RlKTtcbiAgICAgICAgICBtb3VudENvbXBvbmVudChcbiAgICAgICAgICAgIHZub2RlLFxuICAgICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgICAgaXNTVkdDb250YWluZXIoY29udGFpbmVyKSxcbiAgICAgICAgICAgIG9wdGltaXplZFxuICAgICAgICAgICk7XG4gICAgICAgICAgbmV4dE5vZGUgPSBpc0ZyYWdtZW50U3RhcnQgPyBsb2NhdGVDbG9zaW5nQXN5bmNBbmNob3Iobm9kZSkgOiBuZXh0U2libGluZyhub2RlKTtcbiAgICAgICAgICBpZiAobmV4dE5vZGUgJiYgaXNDb21tZW50KG5leHROb2RlKSAmJiBuZXh0Tm9kZS5kYXRhID09PSBcInRlbGVwb3J0IGVuZFwiKSB7XG4gICAgICAgICAgICBuZXh0Tm9kZSA9IG5leHRTaWJsaW5nKG5leHROb2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzQXN5bmNXcmFwcGVyKHZub2RlKSkge1xuICAgICAgICAgICAgbGV0IHN1YlRyZWU7XG4gICAgICAgICAgICBpZiAoaXNGcmFnbWVudFN0YXJ0KSB7XG4gICAgICAgICAgICAgIHN1YlRyZWUgPSBjcmVhdGVWTm9kZShGcmFnbWVudCk7XG4gICAgICAgICAgICAgIHN1YlRyZWUuYW5jaG9yID0gbmV4dE5vZGUgPyBuZXh0Tm9kZS5wcmV2aW91c1NpYmxpbmcgOiBjb250YWluZXIubGFzdENoaWxkO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc3ViVHJlZSA9IG5vZGUubm9kZVR5cGUgPT09IDMgPyBjcmVhdGVUZXh0Vk5vZGUoXCJcIikgOiBjcmVhdGVWTm9kZShcImRpdlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN1YlRyZWUuZWwgPSBub2RlO1xuICAgICAgICAgICAgdm5vZGUuY29tcG9uZW50LnN1YlRyZWUgPSBzdWJUcmVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChzaGFwZUZsYWcgJiA2NCkge1xuICAgICAgICAgIGlmIChkb21UeXBlICE9PSA4IC8qIENPTU1FTlQgKi8pIHtcbiAgICAgICAgICAgIG5leHROb2RlID0gb25NaXNtYXRjaCgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXh0Tm9kZSA9IHZub2RlLnR5cGUuaHlkcmF0ZShcbiAgICAgICAgICAgICAgbm9kZSxcbiAgICAgICAgICAgICAgdm5vZGUsXG4gICAgICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICAgICAgb3B0aW1pemVkLFxuICAgICAgICAgICAgICByZW5kZXJlckludGVybmFscyxcbiAgICAgICAgICAgICAgaHlkcmF0ZUNoaWxkcmVuXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChzaGFwZUZsYWcgJiAxMjgpIHtcbiAgICAgICAgICBuZXh0Tm9kZSA9IHZub2RlLnR5cGUuaHlkcmF0ZShcbiAgICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgICB2bm9kZSxcbiAgICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgICAgaXNTVkdDb250YWluZXIocGFyZW50Tm9kZShub2RlKSksXG4gICAgICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgICAgICBvcHRpbWl6ZWQsXG4gICAgICAgICAgICByZW5kZXJlckludGVybmFscyxcbiAgICAgICAgICAgIGh5ZHJhdGVOb2RlXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgd2FybihcIkludmFsaWQgSG9zdFZOb2RlIHR5cGU6XCIsIHR5cGUsIGAoJHt0eXBlb2YgdHlwZX0pYCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHJlZiAhPSBudWxsKSB7XG4gICAgICBzZXRSZWYocmVmLCBudWxsLCBwYXJlbnRTdXNwZW5zZSwgdm5vZGUpO1xuICAgIH1cbiAgICByZXR1cm4gbmV4dE5vZGU7XG4gIH07XG4gIGNvbnN0IGh5ZHJhdGVFbGVtZW50ID0gKGVsLCB2bm9kZSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpID0+IHtcbiAgICBvcHRpbWl6ZWQgPSBvcHRpbWl6ZWQgfHwgISF2bm9kZS5keW5hbWljQ2hpbGRyZW47XG4gICAgY29uc3QgeyB0eXBlLCBwcm9wcywgcGF0Y2hGbGFnLCBzaGFwZUZsYWcsIGRpcnMgfSA9IHZub2RlO1xuICAgIGNvbnN0IGZvcmNlUGF0Y2hWYWx1ZSA9IHR5cGUgPT09IFwiaW5wdXRcIiAmJiBkaXJzIHx8IHR5cGUgPT09IFwib3B0aW9uXCI7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgfHwgZm9yY2VQYXRjaFZhbHVlIHx8IHBhdGNoRmxhZyAhPT0gLTEpIHtcbiAgICAgIGlmIChkaXJzKSB7XG4gICAgICAgIGludm9rZURpcmVjdGl2ZUhvb2sodm5vZGUsIG51bGwsIHBhcmVudENvbXBvbmVudCwgXCJjcmVhdGVkXCIpO1xuICAgICAgfVxuICAgICAgaWYgKHByb3BzKSB7XG4gICAgICAgIGlmIChmb3JjZVBhdGNoVmFsdWUgfHwgIW9wdGltaXplZCB8fCBwYXRjaEZsYWcgJiAoMTYgfCAzMikpIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwcm9wcykge1xuICAgICAgICAgICAgaWYgKGZvcmNlUGF0Y2hWYWx1ZSAmJiBrZXkuZW5kc1dpdGgoXCJ2YWx1ZVwiKSB8fCBpc09uKGtleSkgJiYgIWlzUmVzZXJ2ZWRQcm9wKGtleSkpIHtcbiAgICAgICAgICAgICAgcGF0Y2hQcm9wKFxuICAgICAgICAgICAgICAgIGVsLFxuICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgIHByb3BzW2tleV0sXG4gICAgICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAgICAgdm9pZCAwLFxuICAgICAgICAgICAgICAgIHBhcmVudENvbXBvbmVudFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChwcm9wcy5vbkNsaWNrKSB7XG4gICAgICAgICAgcGF0Y2hQcm9wKFxuICAgICAgICAgICAgZWwsXG4gICAgICAgICAgICBcIm9uQ2xpY2tcIixcbiAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICBwcm9wcy5vbkNsaWNrLFxuICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICB2b2lkIDAsXG4gICAgICAgICAgICBwYXJlbnRDb21wb25lbnRcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBsZXQgdm5vZGVIb29rcztcbiAgICAgIGlmICh2bm9kZUhvb2tzID0gcHJvcHMgJiYgcHJvcHMub25Wbm9kZUJlZm9yZU1vdW50KSB7XG4gICAgICAgIGludm9rZVZOb2RlSG9vayh2bm9kZUhvb2tzLCBwYXJlbnRDb21wb25lbnQsIHZub2RlKTtcbiAgICAgIH1cbiAgICAgIGlmIChkaXJzKSB7XG4gICAgICAgIGludm9rZURpcmVjdGl2ZUhvb2sodm5vZGUsIG51bGwsIHBhcmVudENvbXBvbmVudCwgXCJiZWZvcmVNb3VudFwiKTtcbiAgICAgIH1cbiAgICAgIGlmICgodm5vZGVIb29rcyA9IHByb3BzICYmIHByb3BzLm9uVm5vZGVNb3VudGVkKSB8fCBkaXJzKSB7XG4gICAgICAgIHF1ZXVlRWZmZWN0V2l0aFN1c3BlbnNlKCgpID0+IHtcbiAgICAgICAgICB2bm9kZUhvb2tzICYmIGludm9rZVZOb2RlSG9vayh2bm9kZUhvb2tzLCBwYXJlbnRDb21wb25lbnQsIHZub2RlKTtcbiAgICAgICAgICBkaXJzICYmIGludm9rZURpcmVjdGl2ZUhvb2sodm5vZGUsIG51bGwsIHBhcmVudENvbXBvbmVudCwgXCJtb3VudGVkXCIpO1xuICAgICAgICB9LCBwYXJlbnRTdXNwZW5zZSk7XG4gICAgICB9XG4gICAgICBpZiAoc2hhcGVGbGFnICYgMTYgJiYgLy8gc2tpcCBpZiBlbGVtZW50IGhhcyBpbm5lckhUTUwgLyB0ZXh0Q29udGVudFxuICAgICAgIShwcm9wcyAmJiAocHJvcHMuaW5uZXJIVE1MIHx8IHByb3BzLnRleHRDb250ZW50KSkpIHtcbiAgICAgICAgbGV0IG5leHQgPSBoeWRyYXRlQ2hpbGRyZW4oXG4gICAgICAgICAgZWwuZmlyc3RDaGlsZCxcbiAgICAgICAgICB2bm9kZSxcbiAgICAgICAgICBlbCxcbiAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgIG9wdGltaXplZFxuICAgICAgICApO1xuICAgICAgICBsZXQgaGFzV2FybmVkID0gZmFsc2U7XG4gICAgICAgIHdoaWxlIChuZXh0KSB7XG4gICAgICAgICAgaGFzTWlzbWF0Y2ggPSB0cnVlO1xuICAgICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICFoYXNXYXJuZWQpIHtcbiAgICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAgIGBIeWRyYXRpb24gY2hpbGRyZW4gbWlzbWF0Y2ggaW4gPCR7dm5vZGUudHlwZX0+OiBzZXJ2ZXIgcmVuZGVyZWQgZWxlbWVudCBjb250YWlucyBtb3JlIGNoaWxkIG5vZGVzIHRoYW4gY2xpZW50IHZkb20uYFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGhhc1dhcm5lZCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGN1ciA9IG5leHQ7XG4gICAgICAgICAgbmV4dCA9IG5leHQubmV4dFNpYmxpbmc7XG4gICAgICAgICAgcmVtb3ZlKGN1cik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoc2hhcGVGbGFnICYgOCkge1xuICAgICAgICBpZiAoZWwudGV4dENvbnRlbnQgIT09IHZub2RlLmNoaWxkcmVuKSB7XG4gICAgICAgICAgaGFzTWlzbWF0Y2ggPSB0cnVlO1xuICAgICAgICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgd2FybihcbiAgICAgICAgICAgIGBIeWRyYXRpb24gdGV4dCBjb250ZW50IG1pc21hdGNoIGluIDwke3Zub2RlLnR5cGV9Pjpcbi0gQ2xpZW50OiAke2VsLnRleHRDb250ZW50fVxuLSBTZXJ2ZXI6ICR7dm5vZGUuY2hpbGRyZW59YFxuICAgICAgICAgICk7XG4gICAgICAgICAgZWwudGV4dENvbnRlbnQgPSB2bm9kZS5jaGlsZHJlbjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZWwubmV4dFNpYmxpbmc7XG4gIH07XG4gIGNvbnN0IGh5ZHJhdGVDaGlsZHJlbiA9IChub2RlLCBwYXJlbnRWTm9kZSwgY29udGFpbmVyLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCkgPT4ge1xuICAgIG9wdGltaXplZCA9IG9wdGltaXplZCB8fCAhIXBhcmVudFZOb2RlLmR5bmFtaWNDaGlsZHJlbjtcbiAgICBjb25zdCBjaGlsZHJlbiA9IHBhcmVudFZOb2RlLmNoaWxkcmVuO1xuICAgIGNvbnN0IGwgPSBjaGlsZHJlbi5sZW5ndGg7XG4gICAgbGV0IGhhc1dhcm5lZCA9IGZhbHNlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICBjb25zdCB2bm9kZSA9IG9wdGltaXplZCA/IGNoaWxkcmVuW2ldIDogY2hpbGRyZW5baV0gPSBub3JtYWxpemVWTm9kZShjaGlsZHJlbltpXSk7XG4gICAgICBpZiAobm9kZSkge1xuICAgICAgICBub2RlID0gaHlkcmF0ZU5vZGUoXG4gICAgICAgICAgbm9kZSxcbiAgICAgICAgICB2bm9kZSxcbiAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgIG9wdGltaXplZFxuICAgICAgICApO1xuICAgICAgfSBlbHNlIGlmICh2bm9kZS50eXBlID09PSBUZXh0ICYmICF2bm9kZS5jaGlsZHJlbikge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGhhc01pc21hdGNoID0gdHJ1ZTtcbiAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgIWhhc1dhcm5lZCkge1xuICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICBgSHlkcmF0aW9uIGNoaWxkcmVuIG1pc21hdGNoIGluIDwke2NvbnRhaW5lci50YWdOYW1lLnRvTG93ZXJDYXNlKCl9Pjogc2VydmVyIHJlbmRlcmVkIGVsZW1lbnQgY29udGFpbnMgZmV3ZXIgY2hpbGQgbm9kZXMgdGhhbiBjbGllbnQgdmRvbS5gXG4gICAgICAgICAgKTtcbiAgICAgICAgICBoYXNXYXJuZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHBhdGNoKFxuICAgICAgICAgIG51bGwsXG4gICAgICAgICAgdm5vZGUsXG4gICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgIG51bGwsXG4gICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgIGlzU1ZHQ29udGFpbmVyKGNvbnRhaW5lciksXG4gICAgICAgICAgc2xvdFNjb3BlSWRzXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBub2RlO1xuICB9O1xuICBjb25zdCBoeWRyYXRlRnJhZ21lbnQgPSAobm9kZSwgdm5vZGUsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKSA9PiB7XG4gICAgY29uc3QgeyBzbG90U2NvcGVJZHM6IGZyYWdtZW50U2xvdFNjb3BlSWRzIH0gPSB2bm9kZTtcbiAgICBpZiAoZnJhZ21lbnRTbG90U2NvcGVJZHMpIHtcbiAgICAgIHNsb3RTY29wZUlkcyA9IHNsb3RTY29wZUlkcyA/IHNsb3RTY29wZUlkcy5jb25jYXQoZnJhZ21lbnRTbG90U2NvcGVJZHMpIDogZnJhZ21lbnRTbG90U2NvcGVJZHM7XG4gICAgfVxuICAgIGNvbnN0IGNvbnRhaW5lciA9IHBhcmVudE5vZGUobm9kZSk7XG4gICAgY29uc3QgbmV4dCA9IGh5ZHJhdGVDaGlsZHJlbihcbiAgICAgIG5leHRTaWJsaW5nKG5vZGUpLFxuICAgICAgdm5vZGUsXG4gICAgICBjb250YWluZXIsXG4gICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgIG9wdGltaXplZFxuICAgICk7XG4gICAgaWYgKG5leHQgJiYgaXNDb21tZW50KG5leHQpICYmIG5leHQuZGF0YSA9PT0gXCJdXCIpIHtcbiAgICAgIHJldHVybiBuZXh0U2libGluZyh2bm9kZS5hbmNob3IgPSBuZXh0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgaGFzTWlzbWF0Y2ggPSB0cnVlO1xuICAgICAgaW5zZXJ0KHZub2RlLmFuY2hvciA9IGNyZWF0ZUNvbW1lbnQoYF1gKSwgY29udGFpbmVyLCBuZXh0KTtcbiAgICAgIHJldHVybiBuZXh0O1xuICAgIH1cbiAgfTtcbiAgY29uc3QgaGFuZGxlTWlzbWF0Y2ggPSAobm9kZSwgdm5vZGUsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHNsb3RTY29wZUlkcywgaXNGcmFnbWVudCkgPT4ge1xuICAgIGhhc01pc21hdGNoID0gdHJ1ZTtcbiAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHdhcm4oXG4gICAgICBgSHlkcmF0aW9uIG5vZGUgbWlzbWF0Y2g6XG4tIENsaWVudCB2bm9kZTpgLFxuICAgICAgdm5vZGUudHlwZSxcbiAgICAgIGBcbi0gU2VydmVyIHJlbmRlcmVkIERPTTpgLFxuICAgICAgbm9kZSxcbiAgICAgIG5vZGUubm9kZVR5cGUgPT09IDMgLyogVEVYVCAqLyA/IGAodGV4dClgIDogaXNDb21tZW50KG5vZGUpICYmIG5vZGUuZGF0YSA9PT0gXCJbXCIgPyBgKHN0YXJ0IG9mIGZyYWdtZW50KWAgOiBgYFxuICAgICk7XG4gICAgdm5vZGUuZWwgPSBudWxsO1xuICAgIGlmIChpc0ZyYWdtZW50KSB7XG4gICAgICBjb25zdCBlbmQgPSBsb2NhdGVDbG9zaW5nQXN5bmNBbmNob3Iobm9kZSk7XG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBjb25zdCBuZXh0MiA9IG5leHRTaWJsaW5nKG5vZGUpO1xuICAgICAgICBpZiAobmV4dDIgJiYgbmV4dDIgIT09IGVuZCkge1xuICAgICAgICAgIHJlbW92ZShuZXh0Mik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgbmV4dCA9IG5leHRTaWJsaW5nKG5vZGUpO1xuICAgIGNvbnN0IGNvbnRhaW5lciA9IHBhcmVudE5vZGUobm9kZSk7XG4gICAgcmVtb3ZlKG5vZGUpO1xuICAgIHBhdGNoKFxuICAgICAgbnVsbCxcbiAgICAgIHZub2RlLFxuICAgICAgY29udGFpbmVyLFxuICAgICAgbmV4dCxcbiAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgaXNTVkdDb250YWluZXIoY29udGFpbmVyKSxcbiAgICAgIHNsb3RTY29wZUlkc1xuICAgICk7XG4gICAgcmV0dXJuIG5leHQ7XG4gIH07XG4gIGNvbnN0IGxvY2F0ZUNsb3NpbmdBc3luY0FuY2hvciA9IChub2RlKSA9PiB7XG4gICAgbGV0IG1hdGNoID0gMDtcbiAgICB3aGlsZSAobm9kZSkge1xuICAgICAgbm9kZSA9IG5leHRTaWJsaW5nKG5vZGUpO1xuICAgICAgaWYgKG5vZGUgJiYgaXNDb21tZW50KG5vZGUpKSB7XG4gICAgICAgIGlmIChub2RlLmRhdGEgPT09IFwiW1wiKVxuICAgICAgICAgIG1hdGNoKys7XG4gICAgICAgIGlmIChub2RlLmRhdGEgPT09IFwiXVwiKSB7XG4gICAgICAgICAgaWYgKG1hdGNoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV4dFNpYmxpbmcobm9kZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1hdGNoLS07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBub2RlO1xuICB9O1xuICByZXR1cm4gW2h5ZHJhdGUsIGh5ZHJhdGVOb2RlXTtcbn1cblxubGV0IHN1cHBvcnRlZDtcbmxldCBwZXJmO1xuZnVuY3Rpb24gc3RhcnRNZWFzdXJlKGluc3RhbmNlLCB0eXBlKSB7XG4gIGlmIChpbnN0YW5jZS5hcHBDb250ZXh0LmNvbmZpZy5wZXJmb3JtYW5jZSAmJiBpc1N1cHBvcnRlZCgpKSB7XG4gICAgcGVyZi5tYXJrKGB2dWUtJHt0eXBlfS0ke2luc3RhbmNlLnVpZH1gKTtcbiAgfVxuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcbiAgICBkZXZ0b29sc1BlcmZTdGFydChpbnN0YW5jZSwgdHlwZSwgaXNTdXBwb3J0ZWQoKSA/IHBlcmYubm93KCkgOiBEYXRlLm5vdygpKTtcbiAgfVxufVxuZnVuY3Rpb24gZW5kTWVhc3VyZShpbnN0YW5jZSwgdHlwZSkge1xuICBpZiAoaW5zdGFuY2UuYXBwQ29udGV4dC5jb25maWcucGVyZm9ybWFuY2UgJiYgaXNTdXBwb3J0ZWQoKSkge1xuICAgIGNvbnN0IHN0YXJ0VGFnID0gYHZ1ZS0ke3R5cGV9LSR7aW5zdGFuY2UudWlkfWA7XG4gICAgY29uc3QgZW5kVGFnID0gc3RhcnRUYWcgKyBgOmVuZGA7XG4gICAgcGVyZi5tYXJrKGVuZFRhZyk7XG4gICAgcGVyZi5tZWFzdXJlKFxuICAgICAgYDwke2Zvcm1hdENvbXBvbmVudE5hbWUoaW5zdGFuY2UsIGluc3RhbmNlLnR5cGUpfT4gJHt0eXBlfWAsXG4gICAgICBzdGFydFRhZyxcbiAgICAgIGVuZFRhZ1xuICAgICk7XG4gICAgcGVyZi5jbGVhck1hcmtzKHN0YXJ0VGFnKTtcbiAgICBwZXJmLmNsZWFyTWFya3MoZW5kVGFnKTtcbiAgfVxuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcbiAgICBkZXZ0b29sc1BlcmZFbmQoaW5zdGFuY2UsIHR5cGUsIGlzU3VwcG9ydGVkKCkgPyBwZXJmLm5vdygpIDogRGF0ZS5ub3coKSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGlzU3VwcG9ydGVkKCkge1xuICBpZiAoc3VwcG9ydGVkICE9PSB2b2lkIDApIHtcbiAgICByZXR1cm4gc3VwcG9ydGVkO1xuICB9XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5wZXJmb3JtYW5jZSkge1xuICAgIHN1cHBvcnRlZCA9IHRydWU7XG4gICAgcGVyZiA9IHdpbmRvdy5wZXJmb3JtYW5jZTtcbiAgfSBlbHNlIHtcbiAgICBzdXBwb3J0ZWQgPSBmYWxzZTtcbiAgfVxuICByZXR1cm4gc3VwcG9ydGVkO1xufVxuXG5mdW5jdGlvbiBpbml0RmVhdHVyZUZsYWdzKCkge1xuICBjb25zdCBuZWVkV2FybiA9IFtdO1xuICBpZiAodHlwZW9mIF9fVlVFX09QVElPTlNfQVBJX18gIT09IFwiYm9vbGVhblwiKSB7XG4gICAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBuZWVkV2Fybi5wdXNoKGBfX1ZVRV9PUFRJT05TX0FQSV9fYCk7XG4gICAgZ2V0R2xvYmFsVGhpcygpLl9fVlVFX09QVElPTlNfQVBJX18gPSB0cnVlO1xuICB9XG4gIGlmICh0eXBlb2YgX19WVUVfUFJPRF9ERVZUT09MU19fICE9PSBcImJvb2xlYW5cIikge1xuICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgbmVlZFdhcm4ucHVzaChgX19WVUVfUFJPRF9ERVZUT09MU19fYCk7XG4gICAgZ2V0R2xvYmFsVGhpcygpLl9fVlVFX1BST0RfREVWVE9PTFNfXyA9IGZhbHNlO1xuICB9XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIG5lZWRXYXJuLmxlbmd0aCkge1xuICAgIGNvbnN0IG11bHRpID0gbmVlZFdhcm4ubGVuZ3RoID4gMTtcbiAgICBjb25zb2xlLndhcm4oXG4gICAgICBgRmVhdHVyZSBmbGFnJHttdWx0aSA/IGBzYCA6IGBgfSAke25lZWRXYXJuLmpvaW4oXCIsIFwiKX0gJHttdWx0aSA/IGBhcmVgIDogYGlzYH0gbm90IGV4cGxpY2l0bHkgZGVmaW5lZC4gWW91IGFyZSBydW5uaW5nIHRoZSBlc20tYnVuZGxlciBidWlsZCBvZiBWdWUsIHdoaWNoIGV4cGVjdHMgdGhlc2UgY29tcGlsZS10aW1lIGZlYXR1cmUgZmxhZ3MgdG8gYmUgZ2xvYmFsbHkgaW5qZWN0ZWQgdmlhIHRoZSBidW5kbGVyIGNvbmZpZyBpbiBvcmRlciB0byBnZXQgYmV0dGVyIHRyZWUtc2hha2luZyBpbiB0aGUgcHJvZHVjdGlvbiBidW5kbGUuXG5cbkZvciBtb3JlIGRldGFpbHMsIHNlZSBodHRwczovL2xpbmsudnVlanMub3JnL2ZlYXR1cmUtZmxhZ3MuYFxuICAgICk7XG4gIH1cbn1cblxuY29uc3QgcXVldWVQb3N0UmVuZGVyRWZmZWN0ID0gcXVldWVFZmZlY3RXaXRoU3VzcGVuc2UgO1xuZnVuY3Rpb24gY3JlYXRlUmVuZGVyZXIob3B0aW9ucykge1xuICByZXR1cm4gYmFzZUNyZWF0ZVJlbmRlcmVyKG9wdGlvbnMpO1xufVxuZnVuY3Rpb24gY3JlYXRlSHlkcmF0aW9uUmVuZGVyZXIob3B0aW9ucykge1xuICByZXR1cm4gYmFzZUNyZWF0ZVJlbmRlcmVyKG9wdGlvbnMsIGNyZWF0ZUh5ZHJhdGlvbkZ1bmN0aW9ucyk7XG59XG5mdW5jdGlvbiBiYXNlQ3JlYXRlUmVuZGVyZXIob3B0aW9ucywgY3JlYXRlSHlkcmF0aW9uRm5zKSB7XG4gIHtcbiAgICBpbml0RmVhdHVyZUZsYWdzKCk7XG4gIH1cbiAgY29uc3QgdGFyZ2V0ID0gZ2V0R2xvYmFsVGhpcygpO1xuICB0YXJnZXQuX19WVUVfXyA9IHRydWU7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykge1xuICAgIHNldERldnRvb2xzSG9vayh0YXJnZXQuX19WVUVfREVWVE9PTFNfR0xPQkFMX0hPT0tfXywgdGFyZ2V0KTtcbiAgfVxuICBjb25zdCB7XG4gICAgaW5zZXJ0OiBob3N0SW5zZXJ0LFxuICAgIHJlbW92ZTogaG9zdFJlbW92ZSxcbiAgICBwYXRjaFByb3A6IGhvc3RQYXRjaFByb3AsXG4gICAgY3JlYXRlRWxlbWVudDogaG9zdENyZWF0ZUVsZW1lbnQsXG4gICAgY3JlYXRlVGV4dDogaG9zdENyZWF0ZVRleHQsXG4gICAgY3JlYXRlQ29tbWVudDogaG9zdENyZWF0ZUNvbW1lbnQsXG4gICAgc2V0VGV4dDogaG9zdFNldFRleHQsXG4gICAgc2V0RWxlbWVudFRleHQ6IGhvc3RTZXRFbGVtZW50VGV4dCxcbiAgICBwYXJlbnROb2RlOiBob3N0UGFyZW50Tm9kZSxcbiAgICBuZXh0U2libGluZzogaG9zdE5leHRTaWJsaW5nLFxuICAgIHNldFNjb3BlSWQ6IGhvc3RTZXRTY29wZUlkID0gTk9PUCxcbiAgICBpbnNlcnRTdGF0aWNDb250ZW50OiBob3N0SW5zZXJ0U3RhdGljQ29udGVudFxuICB9ID0gb3B0aW9ucztcbiAgY29uc3QgcGF0Y2ggPSAobjEsIG4yLCBjb250YWluZXIsIGFuY2hvciA9IG51bGwsIHBhcmVudENvbXBvbmVudCA9IG51bGwsIHBhcmVudFN1c3BlbnNlID0gbnVsbCwgaXNTVkcgPSBmYWxzZSwgc2xvdFNjb3BlSWRzID0gbnVsbCwgb3B0aW1pemVkID0gISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBpc0htclVwZGF0aW5nID8gZmFsc2UgOiAhIW4yLmR5bmFtaWNDaGlsZHJlbikgPT4ge1xuICAgIGlmIChuMSA9PT0gbjIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKG4xICYmICFpc1NhbWVWTm9kZVR5cGUobjEsIG4yKSkge1xuICAgICAgYW5jaG9yID0gZ2V0TmV4dEhvc3ROb2RlKG4xKTtcbiAgICAgIHVubW91bnQobjEsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHRydWUpO1xuICAgICAgbjEgPSBudWxsO1xuICAgIH1cbiAgICBpZiAobjIucGF0Y2hGbGFnID09PSAtMikge1xuICAgICAgb3B0aW1pemVkID0gZmFsc2U7XG4gICAgICBuMi5keW5hbWljQ2hpbGRyZW4gPSBudWxsO1xuICAgIH1cbiAgICBjb25zdCB7IHR5cGUsIHJlZiwgc2hhcGVGbGFnIH0gPSBuMjtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgVGV4dDpcbiAgICAgICAgcHJvY2Vzc1RleHQobjEsIG4yLCBjb250YWluZXIsIGFuY2hvcik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBDb21tZW50OlxuICAgICAgICBwcm9jZXNzQ29tbWVudE5vZGUobjEsIG4yLCBjb250YWluZXIsIGFuY2hvcik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBTdGF0aWM6XG4gICAgICAgIGlmIChuMSA9PSBudWxsKSB7XG4gICAgICAgICAgbW91bnRTdGF0aWNOb2RlKG4yLCBjb250YWluZXIsIGFuY2hvciwgaXNTVkcpO1xuICAgICAgICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICBwYXRjaFN0YXRpY05vZGUobjEsIG4yLCBjb250YWluZXIsIGlzU1ZHKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRnJhZ21lbnQ6XG4gICAgICAgIHByb2Nlc3NGcmFnbWVudChcbiAgICAgICAgICBuMSxcbiAgICAgICAgICBuMixcbiAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgYW5jaG9yLFxuICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICBpc1NWRyxcbiAgICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgICAgb3B0aW1pemVkXG4gICAgICAgICk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKHNoYXBlRmxhZyAmIDEpIHtcbiAgICAgICAgICBwcm9jZXNzRWxlbWVudChcbiAgICAgICAgICAgIG4xLFxuICAgICAgICAgICAgbjIsXG4gICAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgICBhbmNob3IsXG4gICAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICAgIGlzU1ZHLFxuICAgICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgICAgb3B0aW1pemVkXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIGlmIChzaGFwZUZsYWcgJiA2KSB7XG4gICAgICAgICAgcHJvY2Vzc0NvbXBvbmVudChcbiAgICAgICAgICAgIG4xLFxuICAgICAgICAgICAgbjIsXG4gICAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgICBhbmNob3IsXG4gICAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICAgIGlzU1ZHLFxuICAgICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgICAgb3B0aW1pemVkXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIGlmIChzaGFwZUZsYWcgJiA2NCkge1xuICAgICAgICAgIHR5cGUucHJvY2VzcyhcbiAgICAgICAgICAgIG4xLFxuICAgICAgICAgICAgbjIsXG4gICAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgICBhbmNob3IsXG4gICAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICAgIGlzU1ZHLFxuICAgICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgICAgb3B0aW1pemVkLFxuICAgICAgICAgICAgaW50ZXJuYWxzXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIGlmIChzaGFwZUZsYWcgJiAxMjgpIHtcbiAgICAgICAgICB0eXBlLnByb2Nlc3MoXG4gICAgICAgICAgICBuMSxcbiAgICAgICAgICAgIG4yLFxuICAgICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgICAgYW5jaG9yLFxuICAgICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgICBpc1NWRyxcbiAgICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICAgIG9wdGltaXplZCxcbiAgICAgICAgICAgIGludGVybmFsc1xuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgIHdhcm4oXCJJbnZhbGlkIFZOb2RlIHR5cGU6XCIsIHR5cGUsIGAoJHt0eXBlb2YgdHlwZX0pYCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHJlZiAhPSBudWxsICYmIHBhcmVudENvbXBvbmVudCkge1xuICAgICAgc2V0UmVmKHJlZiwgbjEgJiYgbjEucmVmLCBwYXJlbnRTdXNwZW5zZSwgbjIgfHwgbjEsICFuMik7XG4gICAgfVxuICB9O1xuICBjb25zdCBwcm9jZXNzVGV4dCA9IChuMSwgbjIsIGNvbnRhaW5lciwgYW5jaG9yKSA9PiB7XG4gICAgaWYgKG4xID09IG51bGwpIHtcbiAgICAgIGhvc3RJbnNlcnQoXG4gICAgICAgIG4yLmVsID0gaG9zdENyZWF0ZVRleHQobjIuY2hpbGRyZW4pLFxuICAgICAgICBjb250YWluZXIsXG4gICAgICAgIGFuY2hvclxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgZWwgPSBuMi5lbCA9IG4xLmVsO1xuICAgICAgaWYgKG4yLmNoaWxkcmVuICE9PSBuMS5jaGlsZHJlbikge1xuICAgICAgICBob3N0U2V0VGV4dChlbCwgbjIuY2hpbGRyZW4pO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgY29uc3QgcHJvY2Vzc0NvbW1lbnROb2RlID0gKG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IpID0+IHtcbiAgICBpZiAobjEgPT0gbnVsbCkge1xuICAgICAgaG9zdEluc2VydChcbiAgICAgICAgbjIuZWwgPSBob3N0Q3JlYXRlQ29tbWVudChuMi5jaGlsZHJlbiB8fCBcIlwiKSxcbiAgICAgICAgY29udGFpbmVyLFxuICAgICAgICBhbmNob3JcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG4yLmVsID0gbjEuZWw7XG4gICAgfVxuICB9O1xuICBjb25zdCBtb3VudFN0YXRpY05vZGUgPSAobjIsIGNvbnRhaW5lciwgYW5jaG9yLCBpc1NWRykgPT4ge1xuICAgIFtuMi5lbCwgbjIuYW5jaG9yXSA9IGhvc3RJbnNlcnRTdGF0aWNDb250ZW50KFxuICAgICAgbjIuY2hpbGRyZW4sXG4gICAgICBjb250YWluZXIsXG4gICAgICBhbmNob3IsXG4gICAgICBpc1NWRyxcbiAgICAgIG4yLmVsLFxuICAgICAgbjIuYW5jaG9yXG4gICAgKTtcbiAgfTtcbiAgY29uc3QgcGF0Y2hTdGF0aWNOb2RlID0gKG4xLCBuMiwgY29udGFpbmVyLCBpc1NWRykgPT4ge1xuICAgIGlmIChuMi5jaGlsZHJlbiAhPT0gbjEuY2hpbGRyZW4pIHtcbiAgICAgIGNvbnN0IGFuY2hvciA9IGhvc3ROZXh0U2libGluZyhuMS5hbmNob3IpO1xuICAgICAgcmVtb3ZlU3RhdGljTm9kZShuMSk7XG4gICAgICBbbjIuZWwsIG4yLmFuY2hvcl0gPSBob3N0SW5zZXJ0U3RhdGljQ29udGVudChcbiAgICAgICAgbjIuY2hpbGRyZW4sXG4gICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgYW5jaG9yLFxuICAgICAgICBpc1NWR1xuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbjIuZWwgPSBuMS5lbDtcbiAgICAgIG4yLmFuY2hvciA9IG4xLmFuY2hvcjtcbiAgICB9XG4gIH07XG4gIGNvbnN0IG1vdmVTdGF0aWNOb2RlID0gKHsgZWwsIGFuY2hvciB9LCBjb250YWluZXIsIG5leHRTaWJsaW5nKSA9PiB7XG4gICAgbGV0IG5leHQ7XG4gICAgd2hpbGUgKGVsICYmIGVsICE9PSBhbmNob3IpIHtcbiAgICAgIG5leHQgPSBob3N0TmV4dFNpYmxpbmcoZWwpO1xuICAgICAgaG9zdEluc2VydChlbCwgY29udGFpbmVyLCBuZXh0U2libGluZyk7XG4gICAgICBlbCA9IG5leHQ7XG4gICAgfVxuICAgIGhvc3RJbnNlcnQoYW5jaG9yLCBjb250YWluZXIsIG5leHRTaWJsaW5nKTtcbiAgfTtcbiAgY29uc3QgcmVtb3ZlU3RhdGljTm9kZSA9ICh7IGVsLCBhbmNob3IgfSkgPT4ge1xuICAgIGxldCBuZXh0O1xuICAgIHdoaWxlIChlbCAmJiBlbCAhPT0gYW5jaG9yKSB7XG4gICAgICBuZXh0ID0gaG9zdE5leHRTaWJsaW5nKGVsKTtcbiAgICAgIGhvc3RSZW1vdmUoZWwpO1xuICAgICAgZWwgPSBuZXh0O1xuICAgIH1cbiAgICBob3N0UmVtb3ZlKGFuY2hvcik7XG4gIH07XG4gIGNvbnN0IHByb2Nlc3NFbGVtZW50ID0gKG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCkgPT4ge1xuICAgIGlzU1ZHID0gaXNTVkcgfHwgbjIudHlwZSA9PT0gXCJzdmdcIjtcbiAgICBpZiAobjEgPT0gbnVsbCkge1xuICAgICAgbW91bnRFbGVtZW50KFxuICAgICAgICBuMixcbiAgICAgICAgY29udGFpbmVyLFxuICAgICAgICBhbmNob3IsXG4gICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgIGlzU1ZHLFxuICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgIG9wdGltaXplZFxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGF0Y2hFbGVtZW50KFxuICAgICAgICBuMSxcbiAgICAgICAgbjIsXG4gICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgIGlzU1ZHLFxuICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgIG9wdGltaXplZFxuICAgICAgKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IG1vdW50RWxlbWVudCA9ICh2bm9kZSwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCkgPT4ge1xuICAgIGxldCBlbDtcbiAgICBsZXQgdm5vZGVIb29rO1xuICAgIGNvbnN0IHsgdHlwZSwgcHJvcHMsIHNoYXBlRmxhZywgdHJhbnNpdGlvbiwgZGlycyB9ID0gdm5vZGU7XG4gICAgZWwgPSB2bm9kZS5lbCA9IGhvc3RDcmVhdGVFbGVtZW50KFxuICAgICAgdm5vZGUudHlwZSxcbiAgICAgIGlzU1ZHLFxuICAgICAgcHJvcHMgJiYgcHJvcHMuaXMsXG4gICAgICBwcm9wc1xuICAgICk7XG4gICAgaWYgKHNoYXBlRmxhZyAmIDgpIHtcbiAgICAgIGhvc3RTZXRFbGVtZW50VGV4dChlbCwgdm5vZGUuY2hpbGRyZW4pO1xuICAgIH0gZWxzZSBpZiAoc2hhcGVGbGFnICYgMTYpIHtcbiAgICAgIG1vdW50Q2hpbGRyZW4oXG4gICAgICAgIHZub2RlLmNoaWxkcmVuLFxuICAgICAgICBlbCxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgaXNTVkcgJiYgdHlwZSAhPT0gXCJmb3JlaWduT2JqZWN0XCIsXG4gICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgb3B0aW1pemVkXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoZGlycykge1xuICAgICAgaW52b2tlRGlyZWN0aXZlSG9vayh2bm9kZSwgbnVsbCwgcGFyZW50Q29tcG9uZW50LCBcImNyZWF0ZWRcIik7XG4gICAgfVxuICAgIHNldFNjb3BlSWQoZWwsIHZub2RlLCB2bm9kZS5zY29wZUlkLCBzbG90U2NvcGVJZHMsIHBhcmVudENvbXBvbmVudCk7XG4gICAgaWYgKHByb3BzKSB7XG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiBwcm9wcykge1xuICAgICAgICBpZiAoa2V5ICE9PSBcInZhbHVlXCIgJiYgIWlzUmVzZXJ2ZWRQcm9wKGtleSkpIHtcbiAgICAgICAgICBob3N0UGF0Y2hQcm9wKFxuICAgICAgICAgICAgZWwsXG4gICAgICAgICAgICBrZXksXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgcHJvcHNba2V5XSxcbiAgICAgICAgICAgIGlzU1ZHLFxuICAgICAgICAgICAgdm5vZGUuY2hpbGRyZW4sXG4gICAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICAgIHVubW91bnRDaGlsZHJlblxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChcInZhbHVlXCIgaW4gcHJvcHMpIHtcbiAgICAgICAgaG9zdFBhdGNoUHJvcChlbCwgXCJ2YWx1ZVwiLCBudWxsLCBwcm9wcy52YWx1ZSk7XG4gICAgICB9XG4gICAgICBpZiAodm5vZGVIb29rID0gcHJvcHMub25Wbm9kZUJlZm9yZU1vdW50KSB7XG4gICAgICAgIGludm9rZVZOb2RlSG9vayh2bm9kZUhvb2ssIHBhcmVudENvbXBvbmVudCwgdm5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbCwgXCJfX3Zub2RlXCIsIHtcbiAgICAgICAgdmFsdWU6IHZub2RlLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZVxuICAgICAgfSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWwsIFwiX192dWVQYXJlbnRDb21wb25lbnRcIiwge1xuICAgICAgICB2YWx1ZTogcGFyZW50Q29tcG9uZW50LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChkaXJzKSB7XG4gICAgICBpbnZva2VEaXJlY3RpdmVIb29rKHZub2RlLCBudWxsLCBwYXJlbnRDb21wb25lbnQsIFwiYmVmb3JlTW91bnRcIik7XG4gICAgfVxuICAgIGNvbnN0IG5lZWRDYWxsVHJhbnNpdGlvbkhvb2tzID0gKCFwYXJlbnRTdXNwZW5zZSB8fCBwYXJlbnRTdXNwZW5zZSAmJiAhcGFyZW50U3VzcGVuc2UucGVuZGluZ0JyYW5jaCkgJiYgdHJhbnNpdGlvbiAmJiAhdHJhbnNpdGlvbi5wZXJzaXN0ZWQ7XG4gICAgaWYgKG5lZWRDYWxsVHJhbnNpdGlvbkhvb2tzKSB7XG4gICAgICB0cmFuc2l0aW9uLmJlZm9yZUVudGVyKGVsKTtcbiAgICB9XG4gICAgaG9zdEluc2VydChlbCwgY29udGFpbmVyLCBhbmNob3IpO1xuICAgIGlmICgodm5vZGVIb29rID0gcHJvcHMgJiYgcHJvcHMub25Wbm9kZU1vdW50ZWQpIHx8IG5lZWRDYWxsVHJhbnNpdGlvbkhvb2tzIHx8IGRpcnMpIHtcbiAgICAgIHF1ZXVlUG9zdFJlbmRlckVmZmVjdCgoKSA9PiB7XG4gICAgICAgIHZub2RlSG9vayAmJiBpbnZva2VWTm9kZUhvb2sodm5vZGVIb29rLCBwYXJlbnRDb21wb25lbnQsIHZub2RlKTtcbiAgICAgICAgbmVlZENhbGxUcmFuc2l0aW9uSG9va3MgJiYgdHJhbnNpdGlvbi5lbnRlcihlbCk7XG4gICAgICAgIGRpcnMgJiYgaW52b2tlRGlyZWN0aXZlSG9vayh2bm9kZSwgbnVsbCwgcGFyZW50Q29tcG9uZW50LCBcIm1vdW50ZWRcIik7XG4gICAgICB9LCBwYXJlbnRTdXNwZW5zZSk7XG4gICAgfVxuICB9O1xuICBjb25zdCBzZXRTY29wZUlkID0gKGVsLCB2bm9kZSwgc2NvcGVJZCwgc2xvdFNjb3BlSWRzLCBwYXJlbnRDb21wb25lbnQpID0+IHtcbiAgICBpZiAoc2NvcGVJZCkge1xuICAgICAgaG9zdFNldFNjb3BlSWQoZWwsIHNjb3BlSWQpO1xuICAgIH1cbiAgICBpZiAoc2xvdFNjb3BlSWRzKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNsb3RTY29wZUlkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBob3N0U2V0U2NvcGVJZChlbCwgc2xvdFNjb3BlSWRzW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHBhcmVudENvbXBvbmVudCkge1xuICAgICAgbGV0IHN1YlRyZWUgPSBwYXJlbnRDb21wb25lbnQuc3ViVHJlZTtcbiAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHN1YlRyZWUucGF0Y2hGbGFnID4gMCAmJiBzdWJUcmVlLnBhdGNoRmxhZyAmIDIwNDgpIHtcbiAgICAgICAgc3ViVHJlZSA9IGZpbHRlclNpbmdsZVJvb3Qoc3ViVHJlZS5jaGlsZHJlbikgfHwgc3ViVHJlZTtcbiAgICAgIH1cbiAgICAgIGlmICh2bm9kZSA9PT0gc3ViVHJlZSkge1xuICAgICAgICBjb25zdCBwYXJlbnRWTm9kZSA9IHBhcmVudENvbXBvbmVudC52bm9kZTtcbiAgICAgICAgc2V0U2NvcGVJZChcbiAgICAgICAgICBlbCxcbiAgICAgICAgICBwYXJlbnRWTm9kZSxcbiAgICAgICAgICBwYXJlbnRWTm9kZS5zY29wZUlkLFxuICAgICAgICAgIHBhcmVudFZOb2RlLnNsb3RTY29wZUlkcyxcbiAgICAgICAgICBwYXJlbnRDb21wb25lbnQucGFyZW50XG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBjb25zdCBtb3VudENoaWxkcmVuID0gKGNoaWxkcmVuLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkLCBzdGFydCA9IDApID0+IHtcbiAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgY2hpbGQgPSBjaGlsZHJlbltpXSA9IG9wdGltaXplZCA/IGNsb25lSWZNb3VudGVkKGNoaWxkcmVuW2ldKSA6IG5vcm1hbGl6ZVZOb2RlKGNoaWxkcmVuW2ldKTtcbiAgICAgIHBhdGNoKFxuICAgICAgICBudWxsLFxuICAgICAgICBjaGlsZCxcbiAgICAgICAgY29udGFpbmVyLFxuICAgICAgICBhbmNob3IsXG4gICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgIGlzU1ZHLFxuICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgIG9wdGltaXplZFxuICAgICAgKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHBhdGNoRWxlbWVudCA9IChuMSwgbjIsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCkgPT4ge1xuICAgIGNvbnN0IGVsID0gbjIuZWwgPSBuMS5lbDtcbiAgICBsZXQgeyBwYXRjaEZsYWcsIGR5bmFtaWNDaGlsZHJlbiwgZGlycyB9ID0gbjI7XG4gICAgcGF0Y2hGbGFnIHw9IG4xLnBhdGNoRmxhZyAmIDE2O1xuICAgIGNvbnN0IG9sZFByb3BzID0gbjEucHJvcHMgfHwgRU1QVFlfT0JKO1xuICAgIGNvbnN0IG5ld1Byb3BzID0gbjIucHJvcHMgfHwgRU1QVFlfT0JKO1xuICAgIGxldCB2bm9kZUhvb2s7XG4gICAgcGFyZW50Q29tcG9uZW50ICYmIHRvZ2dsZVJlY3Vyc2UocGFyZW50Q29tcG9uZW50LCBmYWxzZSk7XG4gICAgaWYgKHZub2RlSG9vayA9IG5ld1Byb3BzLm9uVm5vZGVCZWZvcmVVcGRhdGUpIHtcbiAgICAgIGludm9rZVZOb2RlSG9vayh2bm9kZUhvb2ssIHBhcmVudENvbXBvbmVudCwgbjIsIG4xKTtcbiAgICB9XG4gICAgaWYgKGRpcnMpIHtcbiAgICAgIGludm9rZURpcmVjdGl2ZUhvb2sobjIsIG4xLCBwYXJlbnRDb21wb25lbnQsIFwiYmVmb3JlVXBkYXRlXCIpO1xuICAgIH1cbiAgICBwYXJlbnRDb21wb25lbnQgJiYgdG9nZ2xlUmVjdXJzZShwYXJlbnRDb21wb25lbnQsIHRydWUpO1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGlzSG1yVXBkYXRpbmcpIHtcbiAgICAgIHBhdGNoRmxhZyA9IDA7XG4gICAgICBvcHRpbWl6ZWQgPSBmYWxzZTtcbiAgICAgIGR5bmFtaWNDaGlsZHJlbiA9IG51bGw7XG4gICAgfVxuICAgIGNvbnN0IGFyZUNoaWxkcmVuU1ZHID0gaXNTVkcgJiYgbjIudHlwZSAhPT0gXCJmb3JlaWduT2JqZWN0XCI7XG4gICAgaWYgKGR5bmFtaWNDaGlsZHJlbikge1xuICAgICAgcGF0Y2hCbG9ja0NoaWxkcmVuKFxuICAgICAgICBuMS5keW5hbWljQ2hpbGRyZW4sXG4gICAgICAgIGR5bmFtaWNDaGlsZHJlbixcbiAgICAgICAgZWwsXG4gICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgIGFyZUNoaWxkcmVuU1ZHLFxuICAgICAgICBzbG90U2NvcGVJZHNcbiAgICAgICk7XG4gICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICB0cmF2ZXJzZVN0YXRpY0NoaWxkcmVuKG4xLCBuMik7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghb3B0aW1pemVkKSB7XG4gICAgICBwYXRjaENoaWxkcmVuKFxuICAgICAgICBuMSxcbiAgICAgICAgbjIsXG4gICAgICAgIGVsLFxuICAgICAgICBudWxsLFxuICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICBhcmVDaGlsZHJlblNWRyxcbiAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICBmYWxzZVxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKHBhdGNoRmxhZyA+IDApIHtcbiAgICAgIGlmIChwYXRjaEZsYWcgJiAxNikge1xuICAgICAgICBwYXRjaFByb3BzKFxuICAgICAgICAgIGVsLFxuICAgICAgICAgIG4yLFxuICAgICAgICAgIG9sZFByb3BzLFxuICAgICAgICAgIG5ld1Byb3BzLFxuICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICBpc1NWR1xuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHBhdGNoRmxhZyAmIDIpIHtcbiAgICAgICAgICBpZiAob2xkUHJvcHMuY2xhc3MgIT09IG5ld1Byb3BzLmNsYXNzKSB7XG4gICAgICAgICAgICBob3N0UGF0Y2hQcm9wKGVsLCBcImNsYXNzXCIsIG51bGwsIG5ld1Byb3BzLmNsYXNzLCBpc1NWRyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChwYXRjaEZsYWcgJiA0KSB7XG4gICAgICAgICAgaG9zdFBhdGNoUHJvcChlbCwgXCJzdHlsZVwiLCBvbGRQcm9wcy5zdHlsZSwgbmV3UHJvcHMuc3R5bGUsIGlzU1ZHKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGF0Y2hGbGFnICYgOCkge1xuICAgICAgICAgIGNvbnN0IHByb3BzVG9VcGRhdGUgPSBuMi5keW5hbWljUHJvcHM7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcm9wc1RvVXBkYXRlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSBwcm9wc1RvVXBkYXRlW2ldO1xuICAgICAgICAgICAgY29uc3QgcHJldiA9IG9sZFByb3BzW2tleV07XG4gICAgICAgICAgICBjb25zdCBuZXh0ID0gbmV3UHJvcHNba2V5XTtcbiAgICAgICAgICAgIGlmIChuZXh0ICE9PSBwcmV2IHx8IGtleSA9PT0gXCJ2YWx1ZVwiKSB7XG4gICAgICAgICAgICAgIGhvc3RQYXRjaFByb3AoXG4gICAgICAgICAgICAgICAgZWwsXG4gICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgIHByZXYsXG4gICAgICAgICAgICAgICAgbmV4dCxcbiAgICAgICAgICAgICAgICBpc1NWRyxcbiAgICAgICAgICAgICAgICBuMS5jaGlsZHJlbixcbiAgICAgICAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgICAgICAgdW5tb3VudENoaWxkcmVuXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocGF0Y2hGbGFnICYgMSkge1xuICAgICAgICBpZiAobjEuY2hpbGRyZW4gIT09IG4yLmNoaWxkcmVuKSB7XG4gICAgICAgICAgaG9zdFNldEVsZW1lbnRUZXh0KGVsLCBuMi5jaGlsZHJlbik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFvcHRpbWl6ZWQgJiYgZHluYW1pY0NoaWxkcmVuID09IG51bGwpIHtcbiAgICAgIHBhdGNoUHJvcHMoXG4gICAgICAgIGVsLFxuICAgICAgICBuMixcbiAgICAgICAgb2xkUHJvcHMsXG4gICAgICAgIG5ld1Byb3BzLFxuICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICBpc1NWR1xuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKCh2bm9kZUhvb2sgPSBuZXdQcm9wcy5vblZub2RlVXBkYXRlZCkgfHwgZGlycykge1xuICAgICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KCgpID0+IHtcbiAgICAgICAgdm5vZGVIb29rICYmIGludm9rZVZOb2RlSG9vayh2bm9kZUhvb2ssIHBhcmVudENvbXBvbmVudCwgbjIsIG4xKTtcbiAgICAgICAgZGlycyAmJiBpbnZva2VEaXJlY3RpdmVIb29rKG4yLCBuMSwgcGFyZW50Q29tcG9uZW50LCBcInVwZGF0ZWRcIik7XG4gICAgICB9LCBwYXJlbnRTdXNwZW5zZSk7XG4gICAgfVxuICB9O1xuICBjb25zdCBwYXRjaEJsb2NrQ2hpbGRyZW4gPSAob2xkQ2hpbGRyZW4sIG5ld0NoaWxkcmVuLCBmYWxsYmFja0NvbnRhaW5lciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcykgPT4ge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmV3Q2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IG9sZFZOb2RlID0gb2xkQ2hpbGRyZW5baV07XG4gICAgICBjb25zdCBuZXdWTm9kZSA9IG5ld0NoaWxkcmVuW2ldO1xuICAgICAgY29uc3QgY29udGFpbmVyID0gKFxuICAgICAgICAvLyBvbGRWTm9kZSBtYXkgYmUgYW4gZXJyb3JlZCBhc3luYyBzZXR1cCgpIGNvbXBvbmVudCBpbnNpZGUgU3VzcGVuc2VcbiAgICAgICAgLy8gd2hpY2ggd2lsbCBub3QgaGF2ZSBhIG1vdW50ZWQgZWxlbWVudFxuICAgICAgICBvbGRWTm9kZS5lbCAmJiAvLyAtIEluIHRoZSBjYXNlIG9mIGEgRnJhZ21lbnQsIHdlIG5lZWQgdG8gcHJvdmlkZSB0aGUgYWN0dWFsIHBhcmVudFxuICAgICAgICAvLyBvZiB0aGUgRnJhZ21lbnQgaXRzZWxmIHNvIGl0IGNhbiBtb3ZlIGl0cyBjaGlsZHJlbi5cbiAgICAgICAgKG9sZFZOb2RlLnR5cGUgPT09IEZyYWdtZW50IHx8IC8vIC0gSW4gdGhlIGNhc2Ugb2YgZGlmZmVyZW50IG5vZGVzLCB0aGVyZSBpcyBnb2luZyB0byBiZSBhIHJlcGxhY2VtZW50XG4gICAgICAgIC8vIHdoaWNoIGFsc28gcmVxdWlyZXMgdGhlIGNvcnJlY3QgcGFyZW50IGNvbnRhaW5lclxuICAgICAgICAhaXNTYW1lVk5vZGVUeXBlKG9sZFZOb2RlLCBuZXdWTm9kZSkgfHwgLy8gLSBJbiB0aGUgY2FzZSBvZiBhIGNvbXBvbmVudCwgaXQgY291bGQgY29udGFpbiBhbnl0aGluZy5cbiAgICAgICAgb2xkVk5vZGUuc2hhcGVGbGFnICYgKDYgfCA2NCkpID8gaG9zdFBhcmVudE5vZGUob2xkVk5vZGUuZWwpIDogKFxuICAgICAgICAgIC8vIEluIG90aGVyIGNhc2VzLCB0aGUgcGFyZW50IGNvbnRhaW5lciBpcyBub3QgYWN0dWFsbHkgdXNlZCBzbyB3ZVxuICAgICAgICAgIC8vIGp1c3QgcGFzcyB0aGUgYmxvY2sgZWxlbWVudCBoZXJlIHRvIGF2b2lkIGEgRE9NIHBhcmVudE5vZGUgY2FsbC5cbiAgICAgICAgICBmYWxsYmFja0NvbnRhaW5lclxuICAgICAgICApXG4gICAgICApO1xuICAgICAgcGF0Y2goXG4gICAgICAgIG9sZFZOb2RlLFxuICAgICAgICBuZXdWTm9kZSxcbiAgICAgICAgY29udGFpbmVyLFxuICAgICAgICBudWxsLFxuICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICBpc1NWRyxcbiAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICB0cnVlXG4gICAgICApO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgcGF0Y2hQcm9wcyA9IChlbCwgdm5vZGUsIG9sZFByb3BzLCBuZXdQcm9wcywgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcpID0+IHtcbiAgICBpZiAob2xkUHJvcHMgIT09IG5ld1Byb3BzKSB7XG4gICAgICBpZiAob2xkUHJvcHMgIT09IEVNUFRZX09CSikge1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBvbGRQcm9wcykge1xuICAgICAgICAgIGlmICghaXNSZXNlcnZlZFByb3Aoa2V5KSAmJiAhKGtleSBpbiBuZXdQcm9wcykpIHtcbiAgICAgICAgICAgIGhvc3RQYXRjaFByb3AoXG4gICAgICAgICAgICAgIGVsLFxuICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgIG9sZFByb3BzW2tleV0sXG4gICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgIGlzU1ZHLFxuICAgICAgICAgICAgICB2bm9kZS5jaGlsZHJlbixcbiAgICAgICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICAgICAgdW5tb3VudENoaWxkcmVuXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBrZXkgaW4gbmV3UHJvcHMpIHtcbiAgICAgICAgaWYgKGlzUmVzZXJ2ZWRQcm9wKGtleSkpXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIGNvbnN0IG5leHQgPSBuZXdQcm9wc1trZXldO1xuICAgICAgICBjb25zdCBwcmV2ID0gb2xkUHJvcHNba2V5XTtcbiAgICAgICAgaWYgKG5leHQgIT09IHByZXYgJiYga2V5ICE9PSBcInZhbHVlXCIpIHtcbiAgICAgICAgICBob3N0UGF0Y2hQcm9wKFxuICAgICAgICAgICAgZWwsXG4gICAgICAgICAgICBrZXksXG4gICAgICAgICAgICBwcmV2LFxuICAgICAgICAgICAgbmV4dCxcbiAgICAgICAgICAgIGlzU1ZHLFxuICAgICAgICAgICAgdm5vZGUuY2hpbGRyZW4sXG4gICAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICAgIHVubW91bnRDaGlsZHJlblxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChcInZhbHVlXCIgaW4gbmV3UHJvcHMpIHtcbiAgICAgICAgaG9zdFBhdGNoUHJvcChlbCwgXCJ2YWx1ZVwiLCBvbGRQcm9wcy52YWx1ZSwgbmV3UHJvcHMudmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgY29uc3QgcHJvY2Vzc0ZyYWdtZW50ID0gKG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCkgPT4ge1xuICAgIGNvbnN0IGZyYWdtZW50U3RhcnRBbmNob3IgPSBuMi5lbCA9IG4xID8gbjEuZWwgOiBob3N0Q3JlYXRlVGV4dChcIlwiKTtcbiAgICBjb25zdCBmcmFnbWVudEVuZEFuY2hvciA9IG4yLmFuY2hvciA9IG4xID8gbjEuYW5jaG9yIDogaG9zdENyZWF0ZVRleHQoXCJcIik7XG4gICAgbGV0IHsgcGF0Y2hGbGFnLCBkeW5hbWljQ2hpbGRyZW4sIHNsb3RTY29wZUlkczogZnJhZ21lbnRTbG90U2NvcGVJZHMgfSA9IG4yO1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIC8vICM1NTIzIGRldiByb290IGZyYWdtZW50IG1heSBpbmhlcml0IGRpcmVjdGl2ZXNcbiAgICAoaXNIbXJVcGRhdGluZyB8fCBwYXRjaEZsYWcgJiAyMDQ4KSkge1xuICAgICAgcGF0Y2hGbGFnID0gMDtcbiAgICAgIG9wdGltaXplZCA9IGZhbHNlO1xuICAgICAgZHluYW1pY0NoaWxkcmVuID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKGZyYWdtZW50U2xvdFNjb3BlSWRzKSB7XG4gICAgICBzbG90U2NvcGVJZHMgPSBzbG90U2NvcGVJZHMgPyBzbG90U2NvcGVJZHMuY29uY2F0KGZyYWdtZW50U2xvdFNjb3BlSWRzKSA6IGZyYWdtZW50U2xvdFNjb3BlSWRzO1xuICAgIH1cbiAgICBpZiAobjEgPT0gbnVsbCkge1xuICAgICAgaG9zdEluc2VydChmcmFnbWVudFN0YXJ0QW5jaG9yLCBjb250YWluZXIsIGFuY2hvcik7XG4gICAgICBob3N0SW5zZXJ0KGZyYWdtZW50RW5kQW5jaG9yLCBjb250YWluZXIsIGFuY2hvcik7XG4gICAgICBtb3VudENoaWxkcmVuKFxuICAgICAgICBuMi5jaGlsZHJlbixcbiAgICAgICAgY29udGFpbmVyLFxuICAgICAgICBmcmFnbWVudEVuZEFuY2hvcixcbiAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgaXNTVkcsXG4gICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgb3B0aW1pemVkXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocGF0Y2hGbGFnID4gMCAmJiBwYXRjaEZsYWcgJiA2NCAmJiBkeW5hbWljQ2hpbGRyZW4gJiYgLy8gIzI3MTUgdGhlIHByZXZpb3VzIGZyYWdtZW50IGNvdWxkJ3ZlIGJlZW4gYSBCQUlMZWQgb25lIGFzIGEgcmVzdWx0XG4gICAgICAvLyBvZiByZW5kZXJTbG90KCkgd2l0aCBubyB2YWxpZCBjaGlsZHJlblxuICAgICAgbjEuZHluYW1pY0NoaWxkcmVuKSB7XG4gICAgICAgIHBhdGNoQmxvY2tDaGlsZHJlbihcbiAgICAgICAgICBuMS5keW5hbWljQ2hpbGRyZW4sXG4gICAgICAgICAgZHluYW1pY0NoaWxkcmVuLFxuICAgICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgaXNTVkcsXG4gICAgICAgICAgc2xvdFNjb3BlSWRzXG4gICAgICAgICk7XG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgdHJhdmVyc2VTdGF0aWNDaGlsZHJlbihuMSwgbjIpO1xuICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgIC8vICMyMDgwIGlmIHRoZSBzdGFibGUgZnJhZ21lbnQgaGFzIGEga2V5LCBpdCdzIGEgPHRlbXBsYXRlIHYtZm9yPiB0aGF0IG1heVxuICAgICAgICAgIC8vICBnZXQgbW92ZWQgYXJvdW5kLiBNYWtlIHN1cmUgYWxsIHJvb3QgbGV2ZWwgdm5vZGVzIGluaGVyaXQgZWwuXG4gICAgICAgICAgLy8gIzIxMzQgb3IgaWYgaXQncyBhIGNvbXBvbmVudCByb290LCBpdCBtYXkgYWxzbyBnZXQgbW92ZWQgYXJvdW5kXG4gICAgICAgICAgLy8gYXMgdGhlIGNvbXBvbmVudCBpcyBiZWluZyBtb3ZlZC5cbiAgICAgICAgICBuMi5rZXkgIT0gbnVsbCB8fCBwYXJlbnRDb21wb25lbnQgJiYgbjIgPT09IHBhcmVudENvbXBvbmVudC5zdWJUcmVlXG4gICAgICAgICkge1xuICAgICAgICAgIHRyYXZlcnNlU3RhdGljQ2hpbGRyZW4oXG4gICAgICAgICAgICBuMSxcbiAgICAgICAgICAgIG4yLFxuICAgICAgICAgICAgdHJ1ZVxuICAgICAgICAgICAgLyogc2hhbGxvdyAqL1xuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhdGNoQ2hpbGRyZW4oXG4gICAgICAgICAgbjEsXG4gICAgICAgICAgbjIsXG4gICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgIGZyYWdtZW50RW5kQW5jaG9yLFxuICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICBpc1NWRyxcbiAgICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgICAgb3B0aW1pemVkXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBjb25zdCBwcm9jZXNzQ29tcG9uZW50ID0gKG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCkgPT4ge1xuICAgIG4yLnNsb3RTY29wZUlkcyA9IHNsb3RTY29wZUlkcztcbiAgICBpZiAobjEgPT0gbnVsbCkge1xuICAgICAgaWYgKG4yLnNoYXBlRmxhZyAmIDUxMikge1xuICAgICAgICBwYXJlbnRDb21wb25lbnQuY3R4LmFjdGl2YXRlKFxuICAgICAgICAgIG4yLFxuICAgICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgICBhbmNob3IsXG4gICAgICAgICAgaXNTVkcsXG4gICAgICAgICAgb3B0aW1pemVkXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtb3VudENvbXBvbmVudChcbiAgICAgICAgICBuMixcbiAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgYW5jaG9yLFxuICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICBpc1NWRyxcbiAgICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdXBkYXRlQ29tcG9uZW50KG4xLCBuMiwgb3B0aW1pemVkKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IG1vdW50Q29tcG9uZW50ID0gKGluaXRpYWxWTm9kZSwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBvcHRpbWl6ZWQpID0+IHtcbiAgICBjb25zdCBpbnN0YW5jZSA9IChpbml0aWFsVk5vZGUuY29tcG9uZW50ID0gY3JlYXRlQ29tcG9uZW50SW5zdGFuY2UoXG4gICAgICBpbml0aWFsVk5vZGUsXG4gICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICBwYXJlbnRTdXNwZW5zZVxuICAgICkpO1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGluc3RhbmNlLnR5cGUuX19obXJJZCkge1xuICAgICAgcmVnaXN0ZXJITVIoaW5zdGFuY2UpO1xuICAgIH1cbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgcHVzaFdhcm5pbmdDb250ZXh0KGluaXRpYWxWTm9kZSk7XG4gICAgICBzdGFydE1lYXN1cmUoaW5zdGFuY2UsIGBtb3VudGApO1xuICAgIH1cbiAgICBpZiAoaXNLZWVwQWxpdmUoaW5pdGlhbFZOb2RlKSkge1xuICAgICAgaW5zdGFuY2UuY3R4LnJlbmRlcmVyID0gaW50ZXJuYWxzO1xuICAgIH1cbiAgICB7XG4gICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICBzdGFydE1lYXN1cmUoaW5zdGFuY2UsIGBpbml0YCk7XG4gICAgICB9XG4gICAgICBzZXR1cENvbXBvbmVudChpbnN0YW5jZSk7XG4gICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICBlbmRNZWFzdXJlKGluc3RhbmNlLCBgaW5pdGApO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaW5zdGFuY2UuYXN5bmNEZXApIHtcbiAgICAgIHBhcmVudFN1c3BlbnNlICYmIHBhcmVudFN1c3BlbnNlLnJlZ2lzdGVyRGVwKGluc3RhbmNlLCBzZXR1cFJlbmRlckVmZmVjdCk7XG4gICAgICBpZiAoIWluaXRpYWxWTm9kZS5lbCkge1xuICAgICAgICBjb25zdCBwbGFjZWhvbGRlciA9IGluc3RhbmNlLnN1YlRyZWUgPSBjcmVhdGVWTm9kZShDb21tZW50KTtcbiAgICAgICAgcHJvY2Vzc0NvbW1lbnROb2RlKG51bGwsIHBsYWNlaG9sZGVyLCBjb250YWluZXIsIGFuY2hvcik7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHNldHVwUmVuZGVyRWZmZWN0KFxuICAgICAgaW5zdGFuY2UsXG4gICAgICBpbml0aWFsVk5vZGUsXG4gICAgICBjb250YWluZXIsXG4gICAgICBhbmNob3IsXG4gICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgIGlzU1ZHLFxuICAgICAgb3B0aW1pemVkXG4gICAgKTtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgcG9wV2FybmluZ0NvbnRleHQoKTtcbiAgICAgIGVuZE1lYXN1cmUoaW5zdGFuY2UsIGBtb3VudGApO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgdXBkYXRlQ29tcG9uZW50ID0gKG4xLCBuMiwgb3B0aW1pemVkKSA9PiB7XG4gICAgY29uc3QgaW5zdGFuY2UgPSBuMi5jb21wb25lbnQgPSBuMS5jb21wb25lbnQ7XG4gICAgaWYgKHNob3VsZFVwZGF0ZUNvbXBvbmVudChuMSwgbjIsIG9wdGltaXplZCkpIHtcbiAgICAgIGlmIChpbnN0YW5jZS5hc3luY0RlcCAmJiAhaW5zdGFuY2UuYXN5bmNSZXNvbHZlZCkge1xuICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgIHB1c2hXYXJuaW5nQ29udGV4dChuMik7XG4gICAgICAgIH1cbiAgICAgICAgdXBkYXRlQ29tcG9uZW50UHJlUmVuZGVyKGluc3RhbmNlLCBuMiwgb3B0aW1pemVkKTtcbiAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICBwb3BXYXJuaW5nQ29udGV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluc3RhbmNlLm5leHQgPSBuMjtcbiAgICAgICAgaW52YWxpZGF0ZUpvYihpbnN0YW5jZS51cGRhdGUpO1xuICAgICAgICBpbnN0YW5jZS51cGRhdGUoKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbjIuZWwgPSBuMS5lbDtcbiAgICAgIGluc3RhbmNlLnZub2RlID0gbjI7XG4gICAgfVxuICB9O1xuICBjb25zdCBzZXR1cFJlbmRlckVmZmVjdCA9IChpbnN0YW5jZSwgaW5pdGlhbFZOb2RlLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBvcHRpbWl6ZWQpID0+IHtcbiAgICBjb25zdCBjb21wb25lbnRVcGRhdGVGbiA9ICgpID0+IHtcbiAgICAgIGlmICghaW5zdGFuY2UuaXNNb3VudGVkKSB7XG4gICAgICAgIGxldCB2bm9kZUhvb2s7XG4gICAgICAgIGNvbnN0IHsgZWwsIHByb3BzIH0gPSBpbml0aWFsVk5vZGU7XG4gICAgICAgIGNvbnN0IHsgYm0sIG0sIHBhcmVudCB9ID0gaW5zdGFuY2U7XG4gICAgICAgIGNvbnN0IGlzQXN5bmNXcmFwcGVyVk5vZGUgPSBpc0FzeW5jV3JhcHBlcihpbml0aWFsVk5vZGUpO1xuICAgICAgICB0b2dnbGVSZWN1cnNlKGluc3RhbmNlLCBmYWxzZSk7XG4gICAgICAgIGlmIChibSkge1xuICAgICAgICAgIGludm9rZUFycmF5Rm5zKGJtKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzQXN5bmNXcmFwcGVyVk5vZGUgJiYgKHZub2RlSG9vayA9IHByb3BzICYmIHByb3BzLm9uVm5vZGVCZWZvcmVNb3VudCkpIHtcbiAgICAgICAgICBpbnZva2VWTm9kZUhvb2sodm5vZGVIb29rLCBwYXJlbnQsIGluaXRpYWxWTm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgdG9nZ2xlUmVjdXJzZShpbnN0YW5jZSwgdHJ1ZSk7XG4gICAgICAgIGlmIChlbCAmJiBoeWRyYXRlTm9kZSkge1xuICAgICAgICAgIGNvbnN0IGh5ZHJhdGVTdWJUcmVlID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICAgICAgc3RhcnRNZWFzdXJlKGluc3RhbmNlLCBgcmVuZGVyYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbnN0YW5jZS5zdWJUcmVlID0gcmVuZGVyQ29tcG9uZW50Um9vdChpbnN0YW5jZSk7XG4gICAgICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgICAgICBlbmRNZWFzdXJlKGluc3RhbmNlLCBgcmVuZGVyYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgICAgICBzdGFydE1lYXN1cmUoaW5zdGFuY2UsIGBoeWRyYXRlYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBoeWRyYXRlTm9kZShcbiAgICAgICAgICAgICAgZWwsXG4gICAgICAgICAgICAgIGluc3RhbmNlLnN1YlRyZWUsXG4gICAgICAgICAgICAgIGluc3RhbmNlLFxuICAgICAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICAgICAgbnVsbFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgICAgIGVuZE1lYXN1cmUoaW5zdGFuY2UsIGBoeWRyYXRlYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgICBpZiAoaXNBc3luY1dyYXBwZXJWTm9kZSkge1xuICAgICAgICAgICAgaW5pdGlhbFZOb2RlLnR5cGUuX19hc3luY0xvYWRlcigpLnRoZW4oXG4gICAgICAgICAgICAgIC8vIG5vdGU6IHdlIGFyZSBtb3ZpbmcgdGhlIHJlbmRlciBjYWxsIGludG8gYW4gYXN5bmMgY2FsbGJhY2ssXG4gICAgICAgICAgICAgIC8vIHdoaWNoIG1lYW5zIGl0IHdvbid0IHRyYWNrIGRlcGVuZGVuY2llcyAtIGJ1dCBpdCdzIG9rIGJlY2F1c2VcbiAgICAgICAgICAgICAgLy8gYSBzZXJ2ZXItcmVuZGVyZWQgYXN5bmMgd3JhcHBlciBpcyBhbHJlYWR5IGluIHJlc29sdmVkIHN0YXRlXG4gICAgICAgICAgICAgIC8vIGFuZCBpdCB3aWxsIG5ldmVyIG5lZWQgdG8gY2hhbmdlLlxuICAgICAgICAgICAgICAoKSA9PiAhaW5zdGFuY2UuaXNVbm1vdW50ZWQgJiYgaHlkcmF0ZVN1YlRyZWUoKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaHlkcmF0ZVN1YlRyZWUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICAgIHN0YXJ0TWVhc3VyZShpbnN0YW5jZSwgYHJlbmRlcmApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBzdWJUcmVlID0gaW5zdGFuY2Uuc3ViVHJlZSA9IHJlbmRlckNvbXBvbmVudFJvb3QoaW5zdGFuY2UpO1xuICAgICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgICBlbmRNZWFzdXJlKGluc3RhbmNlLCBgcmVuZGVyYCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgICBzdGFydE1lYXN1cmUoaW5zdGFuY2UsIGBwYXRjaGApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwYXRjaChcbiAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICBzdWJUcmVlLFxuICAgICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgICAgYW5jaG9yLFxuICAgICAgICAgICAgaW5zdGFuY2UsXG4gICAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICAgIGlzU1ZHXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgICAgZW5kTWVhc3VyZShpbnN0YW5jZSwgYHBhdGNoYCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGluaXRpYWxWTm9kZS5lbCA9IHN1YlRyZWUuZWw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG0pIHtcbiAgICAgICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QobSwgcGFyZW50U3VzcGVuc2UpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNBc3luY1dyYXBwZXJWTm9kZSAmJiAodm5vZGVIb29rID0gcHJvcHMgJiYgcHJvcHMub25Wbm9kZU1vdW50ZWQpKSB7XG4gICAgICAgICAgY29uc3Qgc2NvcGVkSW5pdGlhbFZOb2RlID0gaW5pdGlhbFZOb2RlO1xuICAgICAgICAgIHF1ZXVlUG9zdFJlbmRlckVmZmVjdChcbiAgICAgICAgICAgICgpID0+IGludm9rZVZOb2RlSG9vayh2bm9kZUhvb2ssIHBhcmVudCwgc2NvcGVkSW5pdGlhbFZOb2RlKSxcbiAgICAgICAgICAgIHBhcmVudFN1c3BlbnNlXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5pdGlhbFZOb2RlLnNoYXBlRmxhZyAmIDI1NiB8fCBwYXJlbnQgJiYgaXNBc3luY1dyYXBwZXIocGFyZW50LnZub2RlKSAmJiBwYXJlbnQudm5vZGUuc2hhcGVGbGFnICYgMjU2KSB7XG4gICAgICAgICAgaW5zdGFuY2UuYSAmJiBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QoaW5zdGFuY2UuYSwgcGFyZW50U3VzcGVuc2UpO1xuICAgICAgICB9XG4gICAgICAgIGluc3RhbmNlLmlzTW91bnRlZCA9IHRydWU7XG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykge1xuICAgICAgICAgIGRldnRvb2xzQ29tcG9uZW50QWRkZWQoaW5zdGFuY2UpO1xuICAgICAgICB9XG4gICAgICAgIGluaXRpYWxWTm9kZSA9IGNvbnRhaW5lciA9IGFuY2hvciA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgeyBuZXh0LCBidSwgdSwgcGFyZW50LCB2bm9kZSB9ID0gaW5zdGFuY2U7XG4gICAgICAgIGxldCBvcmlnaW5OZXh0ID0gbmV4dDtcbiAgICAgICAgbGV0IHZub2RlSG9vaztcbiAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICBwdXNoV2FybmluZ0NvbnRleHQobmV4dCB8fCBpbnN0YW5jZS52bm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgdG9nZ2xlUmVjdXJzZShpbnN0YW5jZSwgZmFsc2UpO1xuICAgICAgICBpZiAobmV4dCkge1xuICAgICAgICAgIG5leHQuZWwgPSB2bm9kZS5lbDtcbiAgICAgICAgICB1cGRhdGVDb21wb25lbnRQcmVSZW5kZXIoaW5zdGFuY2UsIG5leHQsIG9wdGltaXplZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV4dCA9IHZub2RlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChidSkge1xuICAgICAgICAgIGludm9rZUFycmF5Rm5zKGJ1KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodm5vZGVIb29rID0gbmV4dC5wcm9wcyAmJiBuZXh0LnByb3BzLm9uVm5vZGVCZWZvcmVVcGRhdGUpIHtcbiAgICAgICAgICBpbnZva2VWTm9kZUhvb2sodm5vZGVIb29rLCBwYXJlbnQsIG5leHQsIHZub2RlKTtcbiAgICAgICAgfVxuICAgICAgICB0b2dnbGVSZWN1cnNlKGluc3RhbmNlLCB0cnVlKTtcbiAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICBzdGFydE1lYXN1cmUoaW5zdGFuY2UsIGByZW5kZXJgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZXh0VHJlZSA9IHJlbmRlckNvbXBvbmVudFJvb3QoaW5zdGFuY2UpO1xuICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgIGVuZE1lYXN1cmUoaW5zdGFuY2UsIGByZW5kZXJgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcmV2VHJlZSA9IGluc3RhbmNlLnN1YlRyZWU7XG4gICAgICAgIGluc3RhbmNlLnN1YlRyZWUgPSBuZXh0VHJlZTtcbiAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICBzdGFydE1lYXN1cmUoaW5zdGFuY2UsIGBwYXRjaGApO1xuICAgICAgICB9XG4gICAgICAgIHBhdGNoKFxuICAgICAgICAgIHByZXZUcmVlLFxuICAgICAgICAgIG5leHRUcmVlLFxuICAgICAgICAgIC8vIHBhcmVudCBtYXkgaGF2ZSBjaGFuZ2VkIGlmIGl0J3MgaW4gYSB0ZWxlcG9ydFxuICAgICAgICAgIGhvc3RQYXJlbnROb2RlKHByZXZUcmVlLmVsKSxcbiAgICAgICAgICAvLyBhbmNob3IgbWF5IGhhdmUgY2hhbmdlZCBpZiBpdCdzIGluIGEgZnJhZ21lbnRcbiAgICAgICAgICBnZXROZXh0SG9zdE5vZGUocHJldlRyZWUpLFxuICAgICAgICAgIGluc3RhbmNlLFxuICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgIGlzU1ZHXG4gICAgICAgICk7XG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgZW5kTWVhc3VyZShpbnN0YW5jZSwgYHBhdGNoYCk7XG4gICAgICAgIH1cbiAgICAgICAgbmV4dC5lbCA9IG5leHRUcmVlLmVsO1xuICAgICAgICBpZiAob3JpZ2luTmV4dCA9PT0gbnVsbCkge1xuICAgICAgICAgIHVwZGF0ZUhPQ0hvc3RFbChpbnN0YW5jZSwgbmV4dFRyZWUuZWwpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1KSB7XG4gICAgICAgICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KHUsIHBhcmVudFN1c3BlbnNlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodm5vZGVIb29rID0gbmV4dC5wcm9wcyAmJiBuZXh0LnByb3BzLm9uVm5vZGVVcGRhdGVkKSB7XG4gICAgICAgICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KFxuICAgICAgICAgICAgKCkgPT4gaW52b2tlVk5vZGVIb29rKHZub2RlSG9vaywgcGFyZW50LCBuZXh0LCB2bm9kZSksXG4gICAgICAgICAgICBwYXJlbnRTdXNwZW5zZVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XG4gICAgICAgICAgZGV2dG9vbHNDb21wb25lbnRVcGRhdGVkKGluc3RhbmNlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgIHBvcFdhcm5pbmdDb250ZXh0KCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGVmZmVjdCA9IGluc3RhbmNlLmVmZmVjdCA9IG5ldyBSZWFjdGl2ZUVmZmVjdChcbiAgICAgIGNvbXBvbmVudFVwZGF0ZUZuLFxuICAgICAgKCkgPT4gcXVldWVKb2IodXBkYXRlKSxcbiAgICAgIGluc3RhbmNlLnNjb3BlXG4gICAgICAvLyB0cmFjayBpdCBpbiBjb21wb25lbnQncyBlZmZlY3Qgc2NvcGVcbiAgICApO1xuICAgIGNvbnN0IHVwZGF0ZSA9IGluc3RhbmNlLnVwZGF0ZSA9ICgpID0+IGVmZmVjdC5ydW4oKTtcbiAgICB1cGRhdGUuaWQgPSBpbnN0YW5jZS51aWQ7XG4gICAgdG9nZ2xlUmVjdXJzZShpbnN0YW5jZSwgdHJ1ZSk7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgIGVmZmVjdC5vblRyYWNrID0gaW5zdGFuY2UucnRjID8gKGUpID0+IGludm9rZUFycmF5Rm5zKGluc3RhbmNlLnJ0YywgZSkgOiB2b2lkIDA7XG4gICAgICBlZmZlY3Qub25UcmlnZ2VyID0gaW5zdGFuY2UucnRnID8gKGUpID0+IGludm9rZUFycmF5Rm5zKGluc3RhbmNlLnJ0ZywgZSkgOiB2b2lkIDA7XG4gICAgICB1cGRhdGUub3duZXJJbnN0YW5jZSA9IGluc3RhbmNlO1xuICAgIH1cbiAgICB1cGRhdGUoKTtcbiAgfTtcbiAgY29uc3QgdXBkYXRlQ29tcG9uZW50UHJlUmVuZGVyID0gKGluc3RhbmNlLCBuZXh0Vk5vZGUsIG9wdGltaXplZCkgPT4ge1xuICAgIG5leHRWTm9kZS5jb21wb25lbnQgPSBpbnN0YW5jZTtcbiAgICBjb25zdCBwcmV2UHJvcHMgPSBpbnN0YW5jZS52bm9kZS5wcm9wcztcbiAgICBpbnN0YW5jZS52bm9kZSA9IG5leHRWTm9kZTtcbiAgICBpbnN0YW5jZS5uZXh0ID0gbnVsbDtcbiAgICB1cGRhdGVQcm9wcyhpbnN0YW5jZSwgbmV4dFZOb2RlLnByb3BzLCBwcmV2UHJvcHMsIG9wdGltaXplZCk7XG4gICAgdXBkYXRlU2xvdHMoaW5zdGFuY2UsIG5leHRWTm9kZS5jaGlsZHJlbiwgb3B0aW1pemVkKTtcbiAgICBwYXVzZVRyYWNraW5nKCk7XG4gICAgZmx1c2hQcmVGbHVzaENicygpO1xuICAgIHJlc2V0VHJhY2tpbmcoKTtcbiAgfTtcbiAgY29uc3QgcGF0Y2hDaGlsZHJlbiA9IChuMSwgbjIsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQgPSBmYWxzZSkgPT4ge1xuICAgIGNvbnN0IGMxID0gbjEgJiYgbjEuY2hpbGRyZW47XG4gICAgY29uc3QgcHJldlNoYXBlRmxhZyA9IG4xID8gbjEuc2hhcGVGbGFnIDogMDtcbiAgICBjb25zdCBjMiA9IG4yLmNoaWxkcmVuO1xuICAgIGNvbnN0IHsgcGF0Y2hGbGFnLCBzaGFwZUZsYWcgfSA9IG4yO1xuICAgIGlmIChwYXRjaEZsYWcgPiAwKSB7XG4gICAgICBpZiAocGF0Y2hGbGFnICYgMTI4KSB7XG4gICAgICAgIHBhdGNoS2V5ZWRDaGlsZHJlbihcbiAgICAgICAgICBjMSxcbiAgICAgICAgICBjMixcbiAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgYW5jaG9yLFxuICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICBpc1NWRyxcbiAgICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgICAgb3B0aW1pemVkXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSBpZiAocGF0Y2hGbGFnICYgMjU2KSB7XG4gICAgICAgIHBhdGNoVW5rZXllZENoaWxkcmVuKFxuICAgICAgICAgIGMxLFxuICAgICAgICAgIGMyLFxuICAgICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgICBhbmNob3IsXG4gICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgIGlzU1ZHLFxuICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoc2hhcGVGbGFnICYgOCkge1xuICAgICAgaWYgKHByZXZTaGFwZUZsYWcgJiAxNikge1xuICAgICAgICB1bm1vdW50Q2hpbGRyZW4oYzEsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UpO1xuICAgICAgfVxuICAgICAgaWYgKGMyICE9PSBjMSkge1xuICAgICAgICBob3N0U2V0RWxlbWVudFRleHQoY29udGFpbmVyLCBjMik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChwcmV2U2hhcGVGbGFnICYgMTYpIHtcbiAgICAgICAgaWYgKHNoYXBlRmxhZyAmIDE2KSB7XG4gICAgICAgICAgcGF0Y2hLZXllZENoaWxkcmVuKFxuICAgICAgICAgICAgYzEsXG4gICAgICAgICAgICBjMixcbiAgICAgICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgICAgIGFuY2hvcixcbiAgICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgICAgaXNTVkcsXG4gICAgICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHVubW91bnRDaGlsZHJlbihjMSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChwcmV2U2hhcGVGbGFnICYgOCkge1xuICAgICAgICAgIGhvc3RTZXRFbGVtZW50VGV4dChjb250YWluZXIsIFwiXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzaGFwZUZsYWcgJiAxNikge1xuICAgICAgICAgIG1vdW50Q2hpbGRyZW4oXG4gICAgICAgICAgICBjMixcbiAgICAgICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgICAgIGFuY2hvcixcbiAgICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgICAgaXNTVkcsXG4gICAgICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBjb25zdCBwYXRjaFVua2V5ZWRDaGlsZHJlbiA9IChjMSwgYzIsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpID0+IHtcbiAgICBjMSA9IGMxIHx8IEVNUFRZX0FSUjtcbiAgICBjMiA9IGMyIHx8IEVNUFRZX0FSUjtcbiAgICBjb25zdCBvbGRMZW5ndGggPSBjMS5sZW5ndGg7XG4gICAgY29uc3QgbmV3TGVuZ3RoID0gYzIubGVuZ3RoO1xuICAgIGNvbnN0IGNvbW1vbkxlbmd0aCA9IE1hdGgubWluKG9sZExlbmd0aCwgbmV3TGVuZ3RoKTtcbiAgICBsZXQgaTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgY29tbW9uTGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IG5leHRDaGlsZCA9IGMyW2ldID0gb3B0aW1pemVkID8gY2xvbmVJZk1vdW50ZWQoYzJbaV0pIDogbm9ybWFsaXplVk5vZGUoYzJbaV0pO1xuICAgICAgcGF0Y2goXG4gICAgICAgIGMxW2ldLFxuICAgICAgICBuZXh0Q2hpbGQsXG4gICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgbnVsbCxcbiAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgaXNTVkcsXG4gICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgb3B0aW1pemVkXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAob2xkTGVuZ3RoID4gbmV3TGVuZ3RoKSB7XG4gICAgICB1bm1vdW50Q2hpbGRyZW4oXG4gICAgICAgIGMxLFxuICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICB0cnVlLFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgY29tbW9uTGVuZ3RoXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBtb3VudENoaWxkcmVuKFxuICAgICAgICBjMixcbiAgICAgICAgY29udGFpbmVyLFxuICAgICAgICBhbmNob3IsXG4gICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgIGlzU1ZHLFxuICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgIG9wdGltaXplZCxcbiAgICAgICAgY29tbW9uTGVuZ3RoXG4gICAgICApO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgcGF0Y2hLZXllZENoaWxkcmVuID0gKGMxLCBjMiwgY29udGFpbmVyLCBwYXJlbnRBbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCkgPT4ge1xuICAgIGxldCBpID0gMDtcbiAgICBjb25zdCBsMiA9IGMyLmxlbmd0aDtcbiAgICBsZXQgZTEgPSBjMS5sZW5ndGggLSAxO1xuICAgIGxldCBlMiA9IGwyIC0gMTtcbiAgICB3aGlsZSAoaSA8PSBlMSAmJiBpIDw9IGUyKSB7XG4gICAgICBjb25zdCBuMSA9IGMxW2ldO1xuICAgICAgY29uc3QgbjIgPSBjMltpXSA9IG9wdGltaXplZCA/IGNsb25lSWZNb3VudGVkKGMyW2ldKSA6IG5vcm1hbGl6ZVZOb2RlKGMyW2ldKTtcbiAgICAgIGlmIChpc1NhbWVWTm9kZVR5cGUobjEsIG4yKSkge1xuICAgICAgICBwYXRjaChcbiAgICAgICAgICBuMSxcbiAgICAgICAgICBuMixcbiAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgbnVsbCxcbiAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgaXNTVkcsXG4gICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgIG9wdGltaXplZFxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpKys7XG4gICAgfVxuICAgIHdoaWxlIChpIDw9IGUxICYmIGkgPD0gZTIpIHtcbiAgICAgIGNvbnN0IG4xID0gYzFbZTFdO1xuICAgICAgY29uc3QgbjIgPSBjMltlMl0gPSBvcHRpbWl6ZWQgPyBjbG9uZUlmTW91bnRlZChjMltlMl0pIDogbm9ybWFsaXplVk5vZGUoYzJbZTJdKTtcbiAgICAgIGlmIChpc1NhbWVWTm9kZVR5cGUobjEsIG4yKSkge1xuICAgICAgICBwYXRjaChcbiAgICAgICAgICBuMSxcbiAgICAgICAgICBuMixcbiAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgbnVsbCxcbiAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgaXNTVkcsXG4gICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgIG9wdGltaXplZFxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBlMS0tO1xuICAgICAgZTItLTtcbiAgICB9XG4gICAgaWYgKGkgPiBlMSkge1xuICAgICAgaWYgKGkgPD0gZTIpIHtcbiAgICAgICAgY29uc3QgbmV4dFBvcyA9IGUyICsgMTtcbiAgICAgICAgY29uc3QgYW5jaG9yID0gbmV4dFBvcyA8IGwyID8gYzJbbmV4dFBvc10uZWwgOiBwYXJlbnRBbmNob3I7XG4gICAgICAgIHdoaWxlIChpIDw9IGUyKSB7XG4gICAgICAgICAgcGF0Y2goXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgYzJbaV0gPSBvcHRpbWl6ZWQgPyBjbG9uZUlmTW91bnRlZChjMltpXSkgOiBub3JtYWxpemVWTm9kZShjMltpXSksXG4gICAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgICBhbmNob3IsXG4gICAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICAgIGlzU1ZHLFxuICAgICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgICAgb3B0aW1pemVkXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGkgPiBlMikge1xuICAgICAgd2hpbGUgKGkgPD0gZTEpIHtcbiAgICAgICAgdW5tb3VudChjMVtpXSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgdHJ1ZSk7XG4gICAgICAgIGkrKztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgczEgPSBpO1xuICAgICAgY29uc3QgczIgPSBpO1xuICAgICAgY29uc3Qga2V5VG9OZXdJbmRleE1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICBmb3IgKGkgPSBzMjsgaSA8PSBlMjsgaSsrKSB7XG4gICAgICAgIGNvbnN0IG5leHRDaGlsZCA9IGMyW2ldID0gb3B0aW1pemVkID8gY2xvbmVJZk1vdW50ZWQoYzJbaV0pIDogbm9ybWFsaXplVk5vZGUoYzJbaV0pO1xuICAgICAgICBpZiAobmV4dENoaWxkLmtleSAhPSBudWxsKSB7XG4gICAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYga2V5VG9OZXdJbmRleE1hcC5oYXMobmV4dENoaWxkLmtleSkpIHtcbiAgICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAgIGBEdXBsaWNhdGUga2V5cyBmb3VuZCBkdXJpbmcgdXBkYXRlOmAsXG4gICAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KG5leHRDaGlsZC5rZXkpLFxuICAgICAgICAgICAgICBgTWFrZSBzdXJlIGtleXMgYXJlIHVuaXF1ZS5gXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBrZXlUb05ld0luZGV4TWFwLnNldChuZXh0Q2hpbGQua2V5LCBpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbGV0IGo7XG4gICAgICBsZXQgcGF0Y2hlZCA9IDA7XG4gICAgICBjb25zdCB0b0JlUGF0Y2hlZCA9IGUyIC0gczIgKyAxO1xuICAgICAgbGV0IG1vdmVkID0gZmFsc2U7XG4gICAgICBsZXQgbWF4TmV3SW5kZXhTb0ZhciA9IDA7XG4gICAgICBjb25zdCBuZXdJbmRleFRvT2xkSW5kZXhNYXAgPSBuZXcgQXJyYXkodG9CZVBhdGNoZWQpO1xuICAgICAgZm9yIChpID0gMDsgaSA8IHRvQmVQYXRjaGVkOyBpKyspXG4gICAgICAgIG5ld0luZGV4VG9PbGRJbmRleE1hcFtpXSA9IDA7XG4gICAgICBmb3IgKGkgPSBzMTsgaSA8PSBlMTsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHByZXZDaGlsZCA9IGMxW2ldO1xuICAgICAgICBpZiAocGF0Y2hlZCA+PSB0b0JlUGF0Y2hlZCkge1xuICAgICAgICAgIHVubW91bnQocHJldkNoaWxkLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCB0cnVlKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbmV3SW5kZXg7XG4gICAgICAgIGlmIChwcmV2Q2hpbGQua2V5ICE9IG51bGwpIHtcbiAgICAgICAgICBuZXdJbmRleCA9IGtleVRvTmV3SW5kZXhNYXAuZ2V0KHByZXZDaGlsZC5rZXkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZvciAoaiA9IHMyOyBqIDw9IGUyOyBqKyspIHtcbiAgICAgICAgICAgIGlmIChuZXdJbmRleFRvT2xkSW5kZXhNYXBbaiAtIHMyXSA9PT0gMCAmJiBpc1NhbWVWTm9kZVR5cGUocHJldkNoaWxkLCBjMltqXSkpIHtcbiAgICAgICAgICAgICAgbmV3SW5kZXggPSBqO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5ld0luZGV4ID09PSB2b2lkIDApIHtcbiAgICAgICAgICB1bm1vdW50KHByZXZDaGlsZCwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgdHJ1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV3SW5kZXhUb09sZEluZGV4TWFwW25ld0luZGV4IC0gczJdID0gaSArIDE7XG4gICAgICAgICAgaWYgKG5ld0luZGV4ID49IG1heE5ld0luZGV4U29GYXIpIHtcbiAgICAgICAgICAgIG1heE5ld0luZGV4U29GYXIgPSBuZXdJbmRleDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbW92ZWQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwYXRjaChcbiAgICAgICAgICAgIHByZXZDaGlsZCxcbiAgICAgICAgICAgIGMyW25ld0luZGV4XSxcbiAgICAgICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICAgIGlzU1ZHLFxuICAgICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgICAgb3B0aW1pemVkXG4gICAgICAgICAgKTtcbiAgICAgICAgICBwYXRjaGVkKys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IGluY3JlYXNpbmdOZXdJbmRleFNlcXVlbmNlID0gbW92ZWQgPyBnZXRTZXF1ZW5jZShuZXdJbmRleFRvT2xkSW5kZXhNYXApIDogRU1QVFlfQVJSO1xuICAgICAgaiA9IGluY3JlYXNpbmdOZXdJbmRleFNlcXVlbmNlLmxlbmd0aCAtIDE7XG4gICAgICBmb3IgKGkgPSB0b0JlUGF0Y2hlZCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGNvbnN0IG5leHRJbmRleCA9IHMyICsgaTtcbiAgICAgICAgY29uc3QgbmV4dENoaWxkID0gYzJbbmV4dEluZGV4XTtcbiAgICAgICAgY29uc3QgYW5jaG9yID0gbmV4dEluZGV4ICsgMSA8IGwyID8gYzJbbmV4dEluZGV4ICsgMV0uZWwgOiBwYXJlbnRBbmNob3I7XG4gICAgICAgIGlmIChuZXdJbmRleFRvT2xkSW5kZXhNYXBbaV0gPT09IDApIHtcbiAgICAgICAgICBwYXRjaChcbiAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICBuZXh0Q2hpbGQsXG4gICAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgICBhbmNob3IsXG4gICAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICAgIGlzU1ZHLFxuICAgICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgICAgb3B0aW1pemVkXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIGlmIChtb3ZlZCkge1xuICAgICAgICAgIGlmIChqIDwgMCB8fCBpICE9PSBpbmNyZWFzaW5nTmV3SW5kZXhTZXF1ZW5jZVtqXSkge1xuICAgICAgICAgICAgbW92ZShuZXh0Q2hpbGQsIGNvbnRhaW5lciwgYW5jaG9yLCAyKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgai0tO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgY29uc3QgbW92ZSA9ICh2bm9kZSwgY29udGFpbmVyLCBhbmNob3IsIG1vdmVUeXBlLCBwYXJlbnRTdXNwZW5zZSA9IG51bGwpID0+IHtcbiAgICBjb25zdCB7IGVsLCB0eXBlLCB0cmFuc2l0aW9uLCBjaGlsZHJlbiwgc2hhcGVGbGFnIH0gPSB2bm9kZTtcbiAgICBpZiAoc2hhcGVGbGFnICYgNikge1xuICAgICAgbW92ZSh2bm9kZS5jb21wb25lbnQuc3ViVHJlZSwgY29udGFpbmVyLCBhbmNob3IsIG1vdmVUeXBlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHNoYXBlRmxhZyAmIDEyOCkge1xuICAgICAgdm5vZGUuc3VzcGVuc2UubW92ZShjb250YWluZXIsIGFuY2hvciwgbW92ZVR5cGUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoc2hhcGVGbGFnICYgNjQpIHtcbiAgICAgIHR5cGUubW92ZSh2bm9kZSwgY29udGFpbmVyLCBhbmNob3IsIGludGVybmFscyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0eXBlID09PSBGcmFnbWVudCkge1xuICAgICAgaG9zdEluc2VydChlbCwgY29udGFpbmVyLCBhbmNob3IpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICBtb3ZlKGNoaWxkcmVuW2ldLCBjb250YWluZXIsIGFuY2hvciwgbW92ZVR5cGUpO1xuICAgICAgfVxuICAgICAgaG9zdEluc2VydCh2bm9kZS5hbmNob3IsIGNvbnRhaW5lciwgYW5jaG9yKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHR5cGUgPT09IFN0YXRpYykge1xuICAgICAgbW92ZVN0YXRpY05vZGUodm5vZGUsIGNvbnRhaW5lciwgYW5jaG9yKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbmVlZFRyYW5zaXRpb24gPSBtb3ZlVHlwZSAhPT0gMiAmJiBzaGFwZUZsYWcgJiAxICYmIHRyYW5zaXRpb247XG4gICAgaWYgKG5lZWRUcmFuc2l0aW9uKSB7XG4gICAgICBpZiAobW92ZVR5cGUgPT09IDApIHtcbiAgICAgICAgdHJhbnNpdGlvbi5iZWZvcmVFbnRlcihlbCk7XG4gICAgICAgIGhvc3RJbnNlcnQoZWwsIGNvbnRhaW5lciwgYW5jaG9yKTtcbiAgICAgICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KCgpID0+IHRyYW5zaXRpb24uZW50ZXIoZWwpLCBwYXJlbnRTdXNwZW5zZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCB7IGxlYXZlLCBkZWxheUxlYXZlLCBhZnRlckxlYXZlIH0gPSB0cmFuc2l0aW9uO1xuICAgICAgICBjb25zdCByZW1vdmUyID0gKCkgPT4gaG9zdEluc2VydChlbCwgY29udGFpbmVyLCBhbmNob3IpO1xuICAgICAgICBjb25zdCBwZXJmb3JtTGVhdmUgPSAoKSA9PiB7XG4gICAgICAgICAgbGVhdmUoZWwsICgpID0+IHtcbiAgICAgICAgICAgIHJlbW92ZTIoKTtcbiAgICAgICAgICAgIGFmdGVyTGVhdmUgJiYgYWZ0ZXJMZWF2ZSgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBpZiAoZGVsYXlMZWF2ZSkge1xuICAgICAgICAgIGRlbGF5TGVhdmUoZWwsIHJlbW92ZTIsIHBlcmZvcm1MZWF2ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGVyZm9ybUxlYXZlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaG9zdEluc2VydChlbCwgY29udGFpbmVyLCBhbmNob3IpO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgdW5tb3VudCA9ICh2bm9kZSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgZG9SZW1vdmUgPSBmYWxzZSwgb3B0aW1pemVkID0gZmFsc2UpID0+IHtcbiAgICBjb25zdCB7XG4gICAgICB0eXBlLFxuICAgICAgcHJvcHMsXG4gICAgICByZWYsXG4gICAgICBjaGlsZHJlbixcbiAgICAgIGR5bmFtaWNDaGlsZHJlbixcbiAgICAgIHNoYXBlRmxhZyxcbiAgICAgIHBhdGNoRmxhZyxcbiAgICAgIGRpcnNcbiAgICB9ID0gdm5vZGU7XG4gICAgaWYgKHJlZiAhPSBudWxsKSB7XG4gICAgICBzZXRSZWYocmVmLCBudWxsLCBwYXJlbnRTdXNwZW5zZSwgdm5vZGUsIHRydWUpO1xuICAgIH1cbiAgICBpZiAoc2hhcGVGbGFnICYgMjU2KSB7XG4gICAgICBwYXJlbnRDb21wb25lbnQuY3R4LmRlYWN0aXZhdGUodm5vZGUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzaG91bGRJbnZva2VEaXJzID0gc2hhcGVGbGFnICYgMSAmJiBkaXJzO1xuICAgIGNvbnN0IHNob3VsZEludm9rZVZub2RlSG9vayA9ICFpc0FzeW5jV3JhcHBlcih2bm9kZSk7XG4gICAgbGV0IHZub2RlSG9vaztcbiAgICBpZiAoc2hvdWxkSW52b2tlVm5vZGVIb29rICYmICh2bm9kZUhvb2sgPSBwcm9wcyAmJiBwcm9wcy5vblZub2RlQmVmb3JlVW5tb3VudCkpIHtcbiAgICAgIGludm9rZVZOb2RlSG9vayh2bm9kZUhvb2ssIHBhcmVudENvbXBvbmVudCwgdm5vZGUpO1xuICAgIH1cbiAgICBpZiAoc2hhcGVGbGFnICYgNikge1xuICAgICAgdW5tb3VudENvbXBvbmVudCh2bm9kZS5jb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBkb1JlbW92ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChzaGFwZUZsYWcgJiAxMjgpIHtcbiAgICAgICAgdm5vZGUuc3VzcGVuc2UudW5tb3VudChwYXJlbnRTdXNwZW5zZSwgZG9SZW1vdmUpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoc2hvdWxkSW52b2tlRGlycykge1xuICAgICAgICBpbnZva2VEaXJlY3RpdmVIb29rKHZub2RlLCBudWxsLCBwYXJlbnRDb21wb25lbnQsIFwiYmVmb3JlVW5tb3VudFwiKTtcbiAgICAgIH1cbiAgICAgIGlmIChzaGFwZUZsYWcgJiA2NCkge1xuICAgICAgICB2bm9kZS50eXBlLnJlbW92ZShcbiAgICAgICAgICB2bm9kZSxcbiAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgb3B0aW1pemVkLFxuICAgICAgICAgIGludGVybmFscyxcbiAgICAgICAgICBkb1JlbW92ZVxuICAgICAgICApO1xuICAgICAgfSBlbHNlIGlmIChkeW5hbWljQ2hpbGRyZW4gJiYgLy8gIzExNTM6IGZhc3QgcGF0aCBzaG91bGQgbm90IGJlIHRha2VuIGZvciBub24tc3RhYmxlICh2LWZvcikgZnJhZ21lbnRzXG4gICAgICAodHlwZSAhPT0gRnJhZ21lbnQgfHwgcGF0Y2hGbGFnID4gMCAmJiBwYXRjaEZsYWcgJiA2NCkpIHtcbiAgICAgICAgdW5tb3VudENoaWxkcmVuKFxuICAgICAgICAgIGR5bmFtaWNDaGlsZHJlbixcbiAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgdHJ1ZVxuICAgICAgICApO1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBGcmFnbWVudCAmJiBwYXRjaEZsYWcgJiAoMTI4IHwgMjU2KSB8fCAhb3B0aW1pemVkICYmIHNoYXBlRmxhZyAmIDE2KSB7XG4gICAgICAgIHVubW91bnRDaGlsZHJlbihjaGlsZHJlbiwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSk7XG4gICAgICB9XG4gICAgICBpZiAoZG9SZW1vdmUpIHtcbiAgICAgICAgcmVtb3ZlKHZub2RlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHNob3VsZEludm9rZVZub2RlSG9vayAmJiAodm5vZGVIb29rID0gcHJvcHMgJiYgcHJvcHMub25Wbm9kZVVubW91bnRlZCkgfHwgc2hvdWxkSW52b2tlRGlycykge1xuICAgICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KCgpID0+IHtcbiAgICAgICAgdm5vZGVIb29rICYmIGludm9rZVZOb2RlSG9vayh2bm9kZUhvb2ssIHBhcmVudENvbXBvbmVudCwgdm5vZGUpO1xuICAgICAgICBzaG91bGRJbnZva2VEaXJzICYmIGludm9rZURpcmVjdGl2ZUhvb2sodm5vZGUsIG51bGwsIHBhcmVudENvbXBvbmVudCwgXCJ1bm1vdW50ZWRcIik7XG4gICAgICB9LCBwYXJlbnRTdXNwZW5zZSk7XG4gICAgfVxuICB9O1xuICBjb25zdCByZW1vdmUgPSAodm5vZGUpID0+IHtcbiAgICBjb25zdCB7IHR5cGUsIGVsLCBhbmNob3IsIHRyYW5zaXRpb24gfSA9IHZub2RlO1xuICAgIGlmICh0eXBlID09PSBGcmFnbWVudCkge1xuICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgdm5vZGUucGF0Y2hGbGFnID4gMCAmJiB2bm9kZS5wYXRjaEZsYWcgJiAyMDQ4ICYmIHRyYW5zaXRpb24gJiYgIXRyYW5zaXRpb24ucGVyc2lzdGVkKSB7XG4gICAgICAgIHZub2RlLmNoaWxkcmVuLmZvckVhY2goKGNoaWxkKSA9PiB7XG4gICAgICAgICAgaWYgKGNoaWxkLnR5cGUgPT09IENvbW1lbnQpIHtcbiAgICAgICAgICAgIGhvc3RSZW1vdmUoY2hpbGQuZWwpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZW1vdmUoY2hpbGQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZW1vdmVGcmFnbWVudChlbCwgYW5jaG9yKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHR5cGUgPT09IFN0YXRpYykge1xuICAgICAgcmVtb3ZlU3RhdGljTm9kZSh2bm9kZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHBlcmZvcm1SZW1vdmUgPSAoKSA9PiB7XG4gICAgICBob3N0UmVtb3ZlKGVsKTtcbiAgICAgIGlmICh0cmFuc2l0aW9uICYmICF0cmFuc2l0aW9uLnBlcnNpc3RlZCAmJiB0cmFuc2l0aW9uLmFmdGVyTGVhdmUpIHtcbiAgICAgICAgdHJhbnNpdGlvbi5hZnRlckxlYXZlKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBpZiAodm5vZGUuc2hhcGVGbGFnICYgMSAmJiB0cmFuc2l0aW9uICYmICF0cmFuc2l0aW9uLnBlcnNpc3RlZCkge1xuICAgICAgY29uc3QgeyBsZWF2ZSwgZGVsYXlMZWF2ZSB9ID0gdHJhbnNpdGlvbjtcbiAgICAgIGNvbnN0IHBlcmZvcm1MZWF2ZSA9ICgpID0+IGxlYXZlKGVsLCBwZXJmb3JtUmVtb3ZlKTtcbiAgICAgIGlmIChkZWxheUxlYXZlKSB7XG4gICAgICAgIGRlbGF5TGVhdmUodm5vZGUuZWwsIHBlcmZvcm1SZW1vdmUsIHBlcmZvcm1MZWF2ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwZXJmb3JtTGVhdmUoKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcGVyZm9ybVJlbW92ZSgpO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgcmVtb3ZlRnJhZ21lbnQgPSAoY3VyLCBlbmQpID0+IHtcbiAgICBsZXQgbmV4dDtcbiAgICB3aGlsZSAoY3VyICE9PSBlbmQpIHtcbiAgICAgIG5leHQgPSBob3N0TmV4dFNpYmxpbmcoY3VyKTtcbiAgICAgIGhvc3RSZW1vdmUoY3VyKTtcbiAgICAgIGN1ciA9IG5leHQ7XG4gICAgfVxuICAgIGhvc3RSZW1vdmUoZW5kKTtcbiAgfTtcbiAgY29uc3QgdW5tb3VudENvbXBvbmVudCA9IChpbnN0YW5jZSwgcGFyZW50U3VzcGVuc2UsIGRvUmVtb3ZlKSA9PiB7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgaW5zdGFuY2UudHlwZS5fX2htcklkKSB7XG4gICAgICB1bnJlZ2lzdGVySE1SKGluc3RhbmNlKTtcbiAgICB9XG4gICAgY29uc3QgeyBidW0sIHNjb3BlLCB1cGRhdGUsIHN1YlRyZWUsIHVtIH0gPSBpbnN0YW5jZTtcbiAgICBpZiAoYnVtKSB7XG4gICAgICBpbnZva2VBcnJheUZucyhidW0pO1xuICAgIH1cbiAgICBzY29wZS5zdG9wKCk7XG4gICAgaWYgKHVwZGF0ZSkge1xuICAgICAgdXBkYXRlLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgdW5tb3VudChzdWJUcmVlLCBpbnN0YW5jZSwgcGFyZW50U3VzcGVuc2UsIGRvUmVtb3ZlKTtcbiAgICB9XG4gICAgaWYgKHVtKSB7XG4gICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QodW0sIHBhcmVudFN1c3BlbnNlKTtcbiAgICB9XG4gICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KCgpID0+IHtcbiAgICAgIGluc3RhbmNlLmlzVW5tb3VudGVkID0gdHJ1ZTtcbiAgICB9LCBwYXJlbnRTdXNwZW5zZSk7XG4gICAgaWYgKHBhcmVudFN1c3BlbnNlICYmIHBhcmVudFN1c3BlbnNlLnBlbmRpbmdCcmFuY2ggJiYgIXBhcmVudFN1c3BlbnNlLmlzVW5tb3VudGVkICYmIGluc3RhbmNlLmFzeW5jRGVwICYmICFpbnN0YW5jZS5hc3luY1Jlc29sdmVkICYmIGluc3RhbmNlLnN1c3BlbnNlSWQgPT09IHBhcmVudFN1c3BlbnNlLnBlbmRpbmdJZCkge1xuICAgICAgcGFyZW50U3VzcGVuc2UuZGVwcy0tO1xuICAgICAgaWYgKHBhcmVudFN1c3BlbnNlLmRlcHMgPT09IDApIHtcbiAgICAgICAgcGFyZW50U3VzcGVuc2UucmVzb2x2ZSgpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcbiAgICAgIGRldnRvb2xzQ29tcG9uZW50UmVtb3ZlZChpbnN0YW5jZSk7XG4gICAgfVxuICB9O1xuICBjb25zdCB1bm1vdW50Q2hpbGRyZW4gPSAoY2hpbGRyZW4sIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGRvUmVtb3ZlID0gZmFsc2UsIG9wdGltaXplZCA9IGZhbHNlLCBzdGFydCA9IDApID0+IHtcbiAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgdW5tb3VudChjaGlsZHJlbltpXSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgZG9SZW1vdmUsIG9wdGltaXplZCk7XG4gICAgfVxuICB9O1xuICBjb25zdCBnZXROZXh0SG9zdE5vZGUgPSAodm5vZGUpID0+IHtcbiAgICBpZiAodm5vZGUuc2hhcGVGbGFnICYgNikge1xuICAgICAgcmV0dXJuIGdldE5leHRIb3N0Tm9kZSh2bm9kZS5jb21wb25lbnQuc3ViVHJlZSk7XG4gICAgfVxuICAgIGlmICh2bm9kZS5zaGFwZUZsYWcgJiAxMjgpIHtcbiAgICAgIHJldHVybiB2bm9kZS5zdXNwZW5zZS5uZXh0KCk7XG4gICAgfVxuICAgIHJldHVybiBob3N0TmV4dFNpYmxpbmcodm5vZGUuYW5jaG9yIHx8IHZub2RlLmVsKTtcbiAgfTtcbiAgY29uc3QgcmVuZGVyID0gKHZub2RlLCBjb250YWluZXIsIGlzU1ZHKSA9PiB7XG4gICAgaWYgKHZub2RlID09IG51bGwpIHtcbiAgICAgIGlmIChjb250YWluZXIuX3Zub2RlKSB7XG4gICAgICAgIHVubW91bnQoY29udGFpbmVyLl92bm9kZSwgbnVsbCwgbnVsbCwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhdGNoKGNvbnRhaW5lci5fdm5vZGUgfHwgbnVsbCwgdm5vZGUsIGNvbnRhaW5lciwgbnVsbCwgbnVsbCwgbnVsbCwgaXNTVkcpO1xuICAgIH1cbiAgICBmbHVzaFByZUZsdXNoQ2JzKCk7XG4gICAgZmx1c2hQb3N0Rmx1c2hDYnMoKTtcbiAgICBjb250YWluZXIuX3Zub2RlID0gdm5vZGU7XG4gIH07XG4gIGNvbnN0IGludGVybmFscyA9IHtcbiAgICBwOiBwYXRjaCxcbiAgICB1bTogdW5tb3VudCxcbiAgICBtOiBtb3ZlLFxuICAgIHI6IHJlbW92ZSxcbiAgICBtdDogbW91bnRDb21wb25lbnQsXG4gICAgbWM6IG1vdW50Q2hpbGRyZW4sXG4gICAgcGM6IHBhdGNoQ2hpbGRyZW4sXG4gICAgcGJjOiBwYXRjaEJsb2NrQ2hpbGRyZW4sXG4gICAgbjogZ2V0TmV4dEhvc3ROb2RlLFxuICAgIG86IG9wdGlvbnNcbiAgfTtcbiAgbGV0IGh5ZHJhdGU7XG4gIGxldCBoeWRyYXRlTm9kZTtcbiAgaWYgKGNyZWF0ZUh5ZHJhdGlvbkZucykge1xuICAgIFtoeWRyYXRlLCBoeWRyYXRlTm9kZV0gPSBjcmVhdGVIeWRyYXRpb25GbnMoXG4gICAgICBpbnRlcm5hbHNcbiAgICApO1xuICB9XG4gIHJldHVybiB7XG4gICAgcmVuZGVyLFxuICAgIGh5ZHJhdGUsXG4gICAgY3JlYXRlQXBwOiBjcmVhdGVBcHBBUEkocmVuZGVyLCBoeWRyYXRlKVxuICB9O1xufVxuZnVuY3Rpb24gdG9nZ2xlUmVjdXJzZSh7IGVmZmVjdCwgdXBkYXRlIH0sIGFsbG93ZWQpIHtcbiAgZWZmZWN0LmFsbG93UmVjdXJzZSA9IHVwZGF0ZS5hbGxvd1JlY3Vyc2UgPSBhbGxvd2VkO1xufVxuZnVuY3Rpb24gdHJhdmVyc2VTdGF0aWNDaGlsZHJlbihuMSwgbjIsIHNoYWxsb3cgPSBmYWxzZSkge1xuICBjb25zdCBjaDEgPSBuMS5jaGlsZHJlbjtcbiAgY29uc3QgY2gyID0gbjIuY2hpbGRyZW47XG4gIGlmIChpc0FycmF5KGNoMSkgJiYgaXNBcnJheShjaDIpKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaDEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGMxID0gY2gxW2ldO1xuICAgICAgbGV0IGMyID0gY2gyW2ldO1xuICAgICAgaWYgKGMyLnNoYXBlRmxhZyAmIDEgJiYgIWMyLmR5bmFtaWNDaGlsZHJlbikge1xuICAgICAgICBpZiAoYzIucGF0Y2hGbGFnIDw9IDAgfHwgYzIucGF0Y2hGbGFnID09PSAzMikge1xuICAgICAgICAgIGMyID0gY2gyW2ldID0gY2xvbmVJZk1vdW50ZWQoY2gyW2ldKTtcbiAgICAgICAgICBjMi5lbCA9IGMxLmVsO1xuICAgICAgICB9XG4gICAgICAgIGlmICghc2hhbGxvdylcbiAgICAgICAgICB0cmF2ZXJzZVN0YXRpY0NoaWxkcmVuKGMxLCBjMik7XG4gICAgICB9XG4gICAgICBpZiAoYzIudHlwZSA9PT0gVGV4dCkge1xuICAgICAgICBjMi5lbCA9IGMxLmVsO1xuICAgICAgfVxuICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgYzIudHlwZSA9PT0gQ29tbWVudCAmJiAhYzIuZWwpIHtcbiAgICAgICAgYzIuZWwgPSBjMS5lbDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGdldFNlcXVlbmNlKGFycikge1xuICBjb25zdCBwID0gYXJyLnNsaWNlKCk7XG4gIGNvbnN0IHJlc3VsdCA9IFswXTtcbiAgbGV0IGksIGosIHUsIHYsIGM7XG4gIGNvbnN0IGxlbiA9IGFyci5sZW5ndGg7XG4gIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIGNvbnN0IGFyckkgPSBhcnJbaV07XG4gICAgaWYgKGFyckkgIT09IDApIHtcbiAgICAgIGogPSByZXN1bHRbcmVzdWx0Lmxlbmd0aCAtIDFdO1xuICAgICAgaWYgKGFycltqXSA8IGFyckkpIHtcbiAgICAgICAgcFtpXSA9IGo7XG4gICAgICAgIHJlc3VsdC5wdXNoKGkpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHUgPSAwO1xuICAgICAgdiA9IHJlc3VsdC5sZW5ndGggLSAxO1xuICAgICAgd2hpbGUgKHUgPCB2KSB7XG4gICAgICAgIGMgPSB1ICsgdiA+PiAxO1xuICAgICAgICBpZiAoYXJyW3Jlc3VsdFtjXV0gPCBhcnJJKSB7XG4gICAgICAgICAgdSA9IGMgKyAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHYgPSBjO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoYXJySSA8IGFycltyZXN1bHRbdV1dKSB7XG4gICAgICAgIGlmICh1ID4gMCkge1xuICAgICAgICAgIHBbaV0gPSByZXN1bHRbdSAtIDFdO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdFt1XSA9IGk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHUgPSByZXN1bHQubGVuZ3RoO1xuICB2ID0gcmVzdWx0W3UgLSAxXTtcbiAgd2hpbGUgKHUtLSA+IDApIHtcbiAgICByZXN1bHRbdV0gPSB2O1xuICAgIHYgPSBwW3ZdO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmNvbnN0IGlzVGVsZXBvcnQgPSAodHlwZSkgPT4gdHlwZS5fX2lzVGVsZXBvcnQ7XG5jb25zdCBpc1RlbGVwb3J0RGlzYWJsZWQgPSAocHJvcHMpID0+IHByb3BzICYmIChwcm9wcy5kaXNhYmxlZCB8fCBwcm9wcy5kaXNhYmxlZCA9PT0gXCJcIik7XG5jb25zdCBpc1RhcmdldFNWRyA9ICh0YXJnZXQpID0+IHR5cGVvZiBTVkdFbGVtZW50ICE9PSBcInVuZGVmaW5lZFwiICYmIHRhcmdldCBpbnN0YW5jZW9mIFNWR0VsZW1lbnQ7XG5jb25zdCByZXNvbHZlVGFyZ2V0ID0gKHByb3BzLCBzZWxlY3QpID0+IHtcbiAgY29uc3QgdGFyZ2V0U2VsZWN0b3IgPSBwcm9wcyAmJiBwcm9wcy50bztcbiAgaWYgKGlzU3RyaW5nKHRhcmdldFNlbGVjdG9yKSkge1xuICAgIGlmICghc2VsZWN0KSB7XG4gICAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHdhcm4oXG4gICAgICAgIGBDdXJyZW50IHJlbmRlcmVyIGRvZXMgbm90IHN1cHBvcnQgc3RyaW5nIHRhcmdldCBmb3IgVGVsZXBvcnRzLiAobWlzc2luZyBxdWVyeVNlbGVjdG9yIHJlbmRlcmVyIG9wdGlvbilgXG4gICAgICApO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHRhcmdldCA9IHNlbGVjdCh0YXJnZXRTZWxlY3Rvcik7XG4gICAgICBpZiAoIXRhcmdldCkge1xuICAgICAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHdhcm4oXG4gICAgICAgICAgYEZhaWxlZCB0byBsb2NhdGUgVGVsZXBvcnQgdGFyZ2V0IHdpdGggc2VsZWN0b3IgXCIke3RhcmdldFNlbGVjdG9yfVwiLiBOb3RlIHRoZSB0YXJnZXQgZWxlbWVudCBtdXN0IGV4aXN0IGJlZm9yZSB0aGUgY29tcG9uZW50IGlzIG1vdW50ZWQgLSBpLmUuIHRoZSB0YXJnZXQgY2Fubm90IGJlIHJlbmRlcmVkIGJ5IHRoZSBjb21wb25lbnQgaXRzZWxmLCBhbmQgaWRlYWxseSBzaG91bGQgYmUgb3V0c2lkZSBvZiB0aGUgZW50aXJlIFZ1ZSBjb21wb25lbnQgdHJlZS5gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhdGFyZ2V0U2VsZWN0b3IgJiYgIWlzVGVsZXBvcnREaXNhYmxlZChwcm9wcykpIHtcbiAgICAgIHdhcm4oYEludmFsaWQgVGVsZXBvcnQgdGFyZ2V0OiAke3RhcmdldFNlbGVjdG9yfWApO1xuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0U2VsZWN0b3I7XG4gIH1cbn07XG5jb25zdCBUZWxlcG9ydEltcGwgPSB7XG4gIF9faXNUZWxlcG9ydDogdHJ1ZSxcbiAgcHJvY2VzcyhuMSwgbjIsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQsIGludGVybmFscykge1xuICAgIGNvbnN0IHtcbiAgICAgIG1jOiBtb3VudENoaWxkcmVuLFxuICAgICAgcGM6IHBhdGNoQ2hpbGRyZW4sXG4gICAgICBwYmM6IHBhdGNoQmxvY2tDaGlsZHJlbixcbiAgICAgIG86IHsgaW5zZXJ0LCBxdWVyeVNlbGVjdG9yLCBjcmVhdGVUZXh0LCBjcmVhdGVDb21tZW50IH1cbiAgICB9ID0gaW50ZXJuYWxzO1xuICAgIGNvbnN0IGRpc2FibGVkID0gaXNUZWxlcG9ydERpc2FibGVkKG4yLnByb3BzKTtcbiAgICBsZXQgeyBzaGFwZUZsYWcsIGNoaWxkcmVuLCBkeW5hbWljQ2hpbGRyZW4gfSA9IG4yO1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGlzSG1yVXBkYXRpbmcpIHtcbiAgICAgIG9wdGltaXplZCA9IGZhbHNlO1xuICAgICAgZHluYW1pY0NoaWxkcmVuID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKG4xID09IG51bGwpIHtcbiAgICAgIGNvbnN0IHBsYWNlaG9sZGVyID0gbjIuZWwgPSAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gY3JlYXRlQ29tbWVudChcInRlbGVwb3J0IHN0YXJ0XCIpIDogY3JlYXRlVGV4dChcIlwiKTtcbiAgICAgIGNvbnN0IG1haW5BbmNob3IgPSBuMi5hbmNob3IgPSAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gY3JlYXRlQ29tbWVudChcInRlbGVwb3J0IGVuZFwiKSA6IGNyZWF0ZVRleHQoXCJcIik7XG4gICAgICBpbnNlcnQocGxhY2Vob2xkZXIsIGNvbnRhaW5lciwgYW5jaG9yKTtcbiAgICAgIGluc2VydChtYWluQW5jaG9yLCBjb250YWluZXIsIGFuY2hvcik7XG4gICAgICBjb25zdCB0YXJnZXQgPSBuMi50YXJnZXQgPSByZXNvbHZlVGFyZ2V0KG4yLnByb3BzLCBxdWVyeVNlbGVjdG9yKTtcbiAgICAgIGNvbnN0IHRhcmdldEFuY2hvciA9IG4yLnRhcmdldEFuY2hvciA9IGNyZWF0ZVRleHQoXCJcIik7XG4gICAgICBpZiAodGFyZ2V0KSB7XG4gICAgICAgIGluc2VydCh0YXJnZXRBbmNob3IsIHRhcmdldCk7XG4gICAgICAgIGlzU1ZHID0gaXNTVkcgfHwgaXNUYXJnZXRTVkcodGFyZ2V0KTtcbiAgICAgIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhZGlzYWJsZWQpIHtcbiAgICAgICAgd2FybihcIkludmFsaWQgVGVsZXBvcnQgdGFyZ2V0IG9uIG1vdW50OlwiLCB0YXJnZXQsIGAoJHt0eXBlb2YgdGFyZ2V0fSlgKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG1vdW50ID0gKGNvbnRhaW5lcjIsIGFuY2hvcjIpID0+IHtcbiAgICAgICAgaWYgKHNoYXBlRmxhZyAmIDE2KSB7XG4gICAgICAgICAgbW91bnRDaGlsZHJlbihcbiAgICAgICAgICAgIGNoaWxkcmVuLFxuICAgICAgICAgICAgY29udGFpbmVyMixcbiAgICAgICAgICAgIGFuY2hvcjIsXG4gICAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICAgIGlzU1ZHLFxuICAgICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgICAgb3B0aW1pemVkXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGlmIChkaXNhYmxlZCkge1xuICAgICAgICBtb3VudChjb250YWluZXIsIG1haW5BbmNob3IpO1xuICAgICAgfSBlbHNlIGlmICh0YXJnZXQpIHtcbiAgICAgICAgbW91bnQodGFyZ2V0LCB0YXJnZXRBbmNob3IpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBuMi5lbCA9IG4xLmVsO1xuICAgICAgY29uc3QgbWFpbkFuY2hvciA9IG4yLmFuY2hvciA9IG4xLmFuY2hvcjtcbiAgICAgIGNvbnN0IHRhcmdldCA9IG4yLnRhcmdldCA9IG4xLnRhcmdldDtcbiAgICAgIGNvbnN0IHRhcmdldEFuY2hvciA9IG4yLnRhcmdldEFuY2hvciA9IG4xLnRhcmdldEFuY2hvcjtcbiAgICAgIGNvbnN0IHdhc0Rpc2FibGVkID0gaXNUZWxlcG9ydERpc2FibGVkKG4xLnByb3BzKTtcbiAgICAgIGNvbnN0IGN1cnJlbnRDb250YWluZXIgPSB3YXNEaXNhYmxlZCA/IGNvbnRhaW5lciA6IHRhcmdldDtcbiAgICAgIGNvbnN0IGN1cnJlbnRBbmNob3IgPSB3YXNEaXNhYmxlZCA/IG1haW5BbmNob3IgOiB0YXJnZXRBbmNob3I7XG4gICAgICBpc1NWRyA9IGlzU1ZHIHx8IGlzVGFyZ2V0U1ZHKHRhcmdldCk7XG4gICAgICBpZiAoZHluYW1pY0NoaWxkcmVuKSB7XG4gICAgICAgIHBhdGNoQmxvY2tDaGlsZHJlbihcbiAgICAgICAgICBuMS5keW5hbWljQ2hpbGRyZW4sXG4gICAgICAgICAgZHluYW1pY0NoaWxkcmVuLFxuICAgICAgICAgIGN1cnJlbnRDb250YWluZXIsXG4gICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgIGlzU1ZHLFxuICAgICAgICAgIHNsb3RTY29wZUlkc1xuICAgICAgICApO1xuICAgICAgICB0cmF2ZXJzZVN0YXRpY0NoaWxkcmVuKG4xLCBuMiwgdHJ1ZSk7XG4gICAgICB9IGVsc2UgaWYgKCFvcHRpbWl6ZWQpIHtcbiAgICAgICAgcGF0Y2hDaGlsZHJlbihcbiAgICAgICAgICBuMSxcbiAgICAgICAgICBuMixcbiAgICAgICAgICBjdXJyZW50Q29udGFpbmVyLFxuICAgICAgICAgIGN1cnJlbnRBbmNob3IsXG4gICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgIGlzU1ZHLFxuICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICBmYWxzZVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKGRpc2FibGVkKSB7XG4gICAgICAgIGlmICghd2FzRGlzYWJsZWQpIHtcbiAgICAgICAgICBtb3ZlVGVsZXBvcnQoXG4gICAgICAgICAgICBuMixcbiAgICAgICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgICAgIG1haW5BbmNob3IsXG4gICAgICAgICAgICBpbnRlcm5hbHMsXG4gICAgICAgICAgICAxXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKChuMi5wcm9wcyAmJiBuMi5wcm9wcy50bykgIT09IChuMS5wcm9wcyAmJiBuMS5wcm9wcy50bykpIHtcbiAgICAgICAgICBjb25zdCBuZXh0VGFyZ2V0ID0gbjIudGFyZ2V0ID0gcmVzb2x2ZVRhcmdldChcbiAgICAgICAgICAgIG4yLnByb3BzLFxuICAgICAgICAgICAgcXVlcnlTZWxlY3RvclxuICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKG5leHRUYXJnZXQpIHtcbiAgICAgICAgICAgIG1vdmVUZWxlcG9ydChcbiAgICAgICAgICAgICAgbjIsXG4gICAgICAgICAgICAgIG5leHRUYXJnZXQsXG4gICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgIGludGVybmFscyxcbiAgICAgICAgICAgICAgMFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAgIFwiSW52YWxpZCBUZWxlcG9ydCB0YXJnZXQgb24gdXBkYXRlOlwiLFxuICAgICAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgICAgIGAoJHt0eXBlb2YgdGFyZ2V0fSlgXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh3YXNEaXNhYmxlZCkge1xuICAgICAgICAgIG1vdmVUZWxlcG9ydChcbiAgICAgICAgICAgIG4yLFxuICAgICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgICAgdGFyZ2V0QW5jaG9yLFxuICAgICAgICAgICAgaW50ZXJuYWxzLFxuICAgICAgICAgICAgMVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdXBkYXRlQ3NzVmFycyhuMik7XG4gIH0sXG4gIHJlbW92ZSh2bm9kZSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgb3B0aW1pemVkLCB7IHVtOiB1bm1vdW50LCBvOiB7IHJlbW92ZTogaG9zdFJlbW92ZSB9IH0sIGRvUmVtb3ZlKSB7XG4gICAgY29uc3QgeyBzaGFwZUZsYWcsIGNoaWxkcmVuLCBhbmNob3IsIHRhcmdldEFuY2hvciwgdGFyZ2V0LCBwcm9wcyB9ID0gdm5vZGU7XG4gICAgaWYgKHRhcmdldCkge1xuICAgICAgaG9zdFJlbW92ZSh0YXJnZXRBbmNob3IpO1xuICAgIH1cbiAgICBpZiAoZG9SZW1vdmUgfHwgIWlzVGVsZXBvcnREaXNhYmxlZChwcm9wcykpIHtcbiAgICAgIGhvc3RSZW1vdmUoYW5jaG9yKTtcbiAgICAgIGlmIChzaGFwZUZsYWcgJiAxNikge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY29uc3QgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgICAgICB1bm1vdW50KFxuICAgICAgICAgICAgY2hpbGQsXG4gICAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICAgIHRydWUsXG4gICAgICAgICAgICAhIWNoaWxkLmR5bmFtaWNDaGlsZHJlblxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIG1vdmU6IG1vdmVUZWxlcG9ydCxcbiAgaHlkcmF0ZTogaHlkcmF0ZVRlbGVwb3J0XG59O1xuZnVuY3Rpb24gbW92ZVRlbGVwb3J0KHZub2RlLCBjb250YWluZXIsIHBhcmVudEFuY2hvciwgeyBvOiB7IGluc2VydCB9LCBtOiBtb3ZlIH0sIG1vdmVUeXBlID0gMikge1xuICBpZiAobW92ZVR5cGUgPT09IDApIHtcbiAgICBpbnNlcnQodm5vZGUudGFyZ2V0QW5jaG9yLCBjb250YWluZXIsIHBhcmVudEFuY2hvcik7XG4gIH1cbiAgY29uc3QgeyBlbCwgYW5jaG9yLCBzaGFwZUZsYWcsIGNoaWxkcmVuLCBwcm9wcyB9ID0gdm5vZGU7XG4gIGNvbnN0IGlzUmVvcmRlciA9IG1vdmVUeXBlID09PSAyO1xuICBpZiAoaXNSZW9yZGVyKSB7XG4gICAgaW5zZXJ0KGVsLCBjb250YWluZXIsIHBhcmVudEFuY2hvcik7XG4gIH1cbiAgaWYgKCFpc1Jlb3JkZXIgfHwgaXNUZWxlcG9ydERpc2FibGVkKHByb3BzKSkge1xuICAgIGlmIChzaGFwZUZsYWcgJiAxNikge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICBtb3ZlKFxuICAgICAgICAgIGNoaWxkcmVuW2ldLFxuICAgICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgICBwYXJlbnRBbmNob3IsXG4gICAgICAgICAgMlxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoaXNSZW9yZGVyKSB7XG4gICAgaW5zZXJ0KGFuY2hvciwgY29udGFpbmVyLCBwYXJlbnRBbmNob3IpO1xuICB9XG59XG5mdW5jdGlvbiBoeWRyYXRlVGVsZXBvcnQobm9kZSwgdm5vZGUsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkLCB7XG4gIG86IHsgbmV4dFNpYmxpbmcsIHBhcmVudE5vZGUsIHF1ZXJ5U2VsZWN0b3IgfVxufSwgaHlkcmF0ZUNoaWxkcmVuKSB7XG4gIGNvbnN0IHRhcmdldCA9IHZub2RlLnRhcmdldCA9IHJlc29sdmVUYXJnZXQoXG4gICAgdm5vZGUucHJvcHMsXG4gICAgcXVlcnlTZWxlY3RvclxuICApO1xuICBpZiAodGFyZ2V0KSB7XG4gICAgY29uc3QgdGFyZ2V0Tm9kZSA9IHRhcmdldC5fbHBhIHx8IHRhcmdldC5maXJzdENoaWxkO1xuICAgIGlmICh2bm9kZS5zaGFwZUZsYWcgJiAxNikge1xuICAgICAgaWYgKGlzVGVsZXBvcnREaXNhYmxlZCh2bm9kZS5wcm9wcykpIHtcbiAgICAgICAgdm5vZGUuYW5jaG9yID0gaHlkcmF0ZUNoaWxkcmVuKFxuICAgICAgICAgIG5leHRTaWJsaW5nKG5vZGUpLFxuICAgICAgICAgIHZub2RlLFxuICAgICAgICAgIHBhcmVudE5vZGUobm9kZSksXG4gICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICAgKTtcbiAgICAgICAgdm5vZGUudGFyZ2V0QW5jaG9yID0gdGFyZ2V0Tm9kZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZub2RlLmFuY2hvciA9IG5leHRTaWJsaW5nKG5vZGUpO1xuICAgICAgICBsZXQgdGFyZ2V0QW5jaG9yID0gdGFyZ2V0Tm9kZTtcbiAgICAgICAgd2hpbGUgKHRhcmdldEFuY2hvcikge1xuICAgICAgICAgIHRhcmdldEFuY2hvciA9IG5leHRTaWJsaW5nKHRhcmdldEFuY2hvcik7XG4gICAgICAgICAgaWYgKHRhcmdldEFuY2hvciAmJiB0YXJnZXRBbmNob3Iubm9kZVR5cGUgPT09IDggJiYgdGFyZ2V0QW5jaG9yLmRhdGEgPT09IFwidGVsZXBvcnQgYW5jaG9yXCIpIHtcbiAgICAgICAgICAgIHZub2RlLnRhcmdldEFuY2hvciA9IHRhcmdldEFuY2hvcjtcbiAgICAgICAgICAgIHRhcmdldC5fbHBhID0gdm5vZGUudGFyZ2V0QW5jaG9yICYmIG5leHRTaWJsaW5nKHZub2RlLnRhcmdldEFuY2hvcik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaHlkcmF0ZUNoaWxkcmVuKFxuICAgICAgICAgIHRhcmdldE5vZGUsXG4gICAgICAgICAgdm5vZGUsXG4gICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgICAgb3B0aW1pemVkXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZUNzc1ZhcnModm5vZGUpO1xuICB9XG4gIHJldHVybiB2bm9kZS5hbmNob3IgJiYgbmV4dFNpYmxpbmcodm5vZGUuYW5jaG9yKTtcbn1cbmNvbnN0IFRlbGVwb3J0ID0gVGVsZXBvcnRJbXBsO1xuZnVuY3Rpb24gdXBkYXRlQ3NzVmFycyh2bm9kZSkge1xuICBjb25zdCBjdHggPSB2bm9kZS5jdHg7XG4gIGlmIChjdHggJiYgY3R4LnV0KSB7XG4gICAgbGV0IG5vZGUgPSB2bm9kZS5jaGlsZHJlblswXS5lbDtcbiAgICB3aGlsZSAobm9kZSAhPT0gdm5vZGUudGFyZ2V0QW5jaG9yKSB7XG4gICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gMSlcbiAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJkYXRhLXYtb3duZXJcIiwgY3R4LnVpZCk7XG4gICAgICBub2RlID0gbm9kZS5uZXh0U2libGluZztcbiAgICB9XG4gICAgY3R4LnV0KCk7XG4gIH1cbn1cblxuY29uc3QgRnJhZ21lbnQgPSBTeW1ib2wuZm9yKFwidi1mZ3RcIik7XG5jb25zdCBUZXh0ID0gU3ltYm9sLmZvcihcInYtdHh0XCIpO1xuY29uc3QgQ29tbWVudCA9IFN5bWJvbC5mb3IoXCJ2LWNtdFwiKTtcbmNvbnN0IFN0YXRpYyA9IFN5bWJvbC5mb3IoXCJ2LXN0Y1wiKTtcbmNvbnN0IGJsb2NrU3RhY2sgPSBbXTtcbmxldCBjdXJyZW50QmxvY2sgPSBudWxsO1xuZnVuY3Rpb24gb3BlbkJsb2NrKGRpc2FibGVUcmFja2luZyA9IGZhbHNlKSB7XG4gIGJsb2NrU3RhY2sucHVzaChjdXJyZW50QmxvY2sgPSBkaXNhYmxlVHJhY2tpbmcgPyBudWxsIDogW10pO1xufVxuZnVuY3Rpb24gY2xvc2VCbG9jaygpIHtcbiAgYmxvY2tTdGFjay5wb3AoKTtcbiAgY3VycmVudEJsb2NrID0gYmxvY2tTdGFja1tibG9ja1N0YWNrLmxlbmd0aCAtIDFdIHx8IG51bGw7XG59XG5sZXQgaXNCbG9ja1RyZWVFbmFibGVkID0gMTtcbmZ1bmN0aW9uIHNldEJsb2NrVHJhY2tpbmcodmFsdWUpIHtcbiAgaXNCbG9ja1RyZWVFbmFibGVkICs9IHZhbHVlO1xufVxuZnVuY3Rpb24gc2V0dXBCbG9jayh2bm9kZSkge1xuICB2bm9kZS5keW5hbWljQ2hpbGRyZW4gPSBpc0Jsb2NrVHJlZUVuYWJsZWQgPiAwID8gY3VycmVudEJsb2NrIHx8IEVNUFRZX0FSUiA6IG51bGw7XG4gIGNsb3NlQmxvY2soKTtcbiAgaWYgKGlzQmxvY2tUcmVlRW5hYmxlZCA+IDAgJiYgY3VycmVudEJsb2NrKSB7XG4gICAgY3VycmVudEJsb2NrLnB1c2godm5vZGUpO1xuICB9XG4gIHJldHVybiB2bm9kZTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnRCbG9jayh0eXBlLCBwcm9wcywgY2hpbGRyZW4sIHBhdGNoRmxhZywgZHluYW1pY1Byb3BzLCBzaGFwZUZsYWcpIHtcbiAgcmV0dXJuIHNldHVwQmxvY2soXG4gICAgY3JlYXRlQmFzZVZOb2RlKFxuICAgICAgdHlwZSxcbiAgICAgIHByb3BzLFxuICAgICAgY2hpbGRyZW4sXG4gICAgICBwYXRjaEZsYWcsXG4gICAgICBkeW5hbWljUHJvcHMsXG4gICAgICBzaGFwZUZsYWcsXG4gICAgICB0cnVlXG4gICAgICAvKiBpc0Jsb2NrICovXG4gICAgKVxuICApO1xufVxuZnVuY3Rpb24gY3JlYXRlQmxvY2sodHlwZSwgcHJvcHMsIGNoaWxkcmVuLCBwYXRjaEZsYWcsIGR5bmFtaWNQcm9wcykge1xuICByZXR1cm4gc2V0dXBCbG9jayhcbiAgICBjcmVhdGVWTm9kZShcbiAgICAgIHR5cGUsXG4gICAgICBwcm9wcyxcbiAgICAgIGNoaWxkcmVuLFxuICAgICAgcGF0Y2hGbGFnLFxuICAgICAgZHluYW1pY1Byb3BzLFxuICAgICAgdHJ1ZVxuICAgICAgLyogaXNCbG9jazogcHJldmVudCBhIGJsb2NrIGZyb20gdHJhY2tpbmcgaXRzZWxmICovXG4gICAgKVxuICApO1xufVxuZnVuY3Rpb24gaXNWTm9kZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPyB2YWx1ZS5fX3ZfaXNWTm9kZSA9PT0gdHJ1ZSA6IGZhbHNlO1xufVxuZnVuY3Rpb24gaXNTYW1lVk5vZGVUeXBlKG4xLCBuMikge1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBuMi5zaGFwZUZsYWcgJiA2ICYmIGhtckRpcnR5Q29tcG9uZW50cy5oYXMobjIudHlwZSkpIHtcbiAgICBuMS5zaGFwZUZsYWcgJj0gfjI1NjtcbiAgICBuMi5zaGFwZUZsYWcgJj0gfjUxMjtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIG4xLnR5cGUgPT09IG4yLnR5cGUgJiYgbjEua2V5ID09PSBuMi5rZXk7XG59XG5sZXQgdm5vZGVBcmdzVHJhbnNmb3JtZXI7XG5mdW5jdGlvbiB0cmFuc2Zvcm1WTm9kZUFyZ3ModHJhbnNmb3JtZXIpIHtcbiAgdm5vZGVBcmdzVHJhbnNmb3JtZXIgPSB0cmFuc2Zvcm1lcjtcbn1cbmNvbnN0IGNyZWF0ZVZOb2RlV2l0aEFyZ3NUcmFuc2Zvcm0gPSAoLi4uYXJncykgPT4ge1xuICByZXR1cm4gX2NyZWF0ZVZOb2RlKFxuICAgIC4uLnZub2RlQXJnc1RyYW5zZm9ybWVyID8gdm5vZGVBcmdzVHJhbnNmb3JtZXIoYXJncywgY3VycmVudFJlbmRlcmluZ0luc3RhbmNlKSA6IGFyZ3NcbiAgKTtcbn07XG5jb25zdCBJbnRlcm5hbE9iamVjdEtleSA9IGBfX3ZJbnRlcm5hbGA7XG5jb25zdCBub3JtYWxpemVLZXkgPSAoeyBrZXkgfSkgPT4ga2V5ICE9IG51bGwgPyBrZXkgOiBudWxsO1xuY29uc3Qgbm9ybWFsaXplUmVmID0gKHtcbiAgcmVmLFxuICByZWZfa2V5LFxuICByZWZfZm9yXG59KSA9PiB7XG4gIGlmICh0eXBlb2YgcmVmID09PSBcIm51bWJlclwiKSB7XG4gICAgcmVmID0gXCJcIiArIHJlZjtcbiAgfVxuICByZXR1cm4gcmVmICE9IG51bGwgPyBpc1N0cmluZyhyZWYpIHx8IGlzUmVmKHJlZikgfHwgaXNGdW5jdGlvbihyZWYpID8geyBpOiBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UsIHI6IHJlZiwgazogcmVmX2tleSwgZjogISFyZWZfZm9yIH0gOiByZWYgOiBudWxsO1xufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VWTm9kZSh0eXBlLCBwcm9wcyA9IG51bGwsIGNoaWxkcmVuID0gbnVsbCwgcGF0Y2hGbGFnID0gMCwgZHluYW1pY1Byb3BzID0gbnVsbCwgc2hhcGVGbGFnID0gdHlwZSA9PT0gRnJhZ21lbnQgPyAwIDogMSwgaXNCbG9ja05vZGUgPSBmYWxzZSwgbmVlZEZ1bGxDaGlsZHJlbk5vcm1hbGl6YXRpb24gPSBmYWxzZSkge1xuICBjb25zdCB2bm9kZSA9IHtcbiAgICBfX3ZfaXNWTm9kZTogdHJ1ZSxcbiAgICBfX3Zfc2tpcDogdHJ1ZSxcbiAgICB0eXBlLFxuICAgIHByb3BzLFxuICAgIGtleTogcHJvcHMgJiYgbm9ybWFsaXplS2V5KHByb3BzKSxcbiAgICByZWY6IHByb3BzICYmIG5vcm1hbGl6ZVJlZihwcm9wcyksXG4gICAgc2NvcGVJZDogY3VycmVudFNjb3BlSWQsXG4gICAgc2xvdFNjb3BlSWRzOiBudWxsLFxuICAgIGNoaWxkcmVuLFxuICAgIGNvbXBvbmVudDogbnVsbCxcbiAgICBzdXNwZW5zZTogbnVsbCxcbiAgICBzc0NvbnRlbnQ6IG51bGwsXG4gICAgc3NGYWxsYmFjazogbnVsbCxcbiAgICBkaXJzOiBudWxsLFxuICAgIHRyYW5zaXRpb246IG51bGwsXG4gICAgZWw6IG51bGwsXG4gICAgYW5jaG9yOiBudWxsLFxuICAgIHRhcmdldDogbnVsbCxcbiAgICB0YXJnZXRBbmNob3I6IG51bGwsXG4gICAgc3RhdGljQ291bnQ6IDAsXG4gICAgc2hhcGVGbGFnLFxuICAgIHBhdGNoRmxhZyxcbiAgICBkeW5hbWljUHJvcHMsXG4gICAgZHluYW1pY0NoaWxkcmVuOiBudWxsLFxuICAgIGFwcENvbnRleHQ6IG51bGwsXG4gICAgY3R4OiBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2VcbiAgfTtcbiAgaWYgKG5lZWRGdWxsQ2hpbGRyZW5Ob3JtYWxpemF0aW9uKSB7XG4gICAgbm9ybWFsaXplQ2hpbGRyZW4odm5vZGUsIGNoaWxkcmVuKTtcbiAgICBpZiAoc2hhcGVGbGFnICYgMTI4KSB7XG4gICAgICB0eXBlLm5vcm1hbGl6ZSh2bm9kZSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGNoaWxkcmVuKSB7XG4gICAgdm5vZGUuc2hhcGVGbGFnIHw9IGlzU3RyaW5nKGNoaWxkcmVuKSA/IDggOiAxNjtcbiAgfVxuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiB2bm9kZS5rZXkgIT09IHZub2RlLmtleSkge1xuICAgIHdhcm4oYFZOb2RlIGNyZWF0ZWQgd2l0aCBpbnZhbGlkIGtleSAoTmFOKS4gVk5vZGUgdHlwZTpgLCB2bm9kZS50eXBlKTtcbiAgfVxuICBpZiAoaXNCbG9ja1RyZWVFbmFibGVkID4gMCAmJiAvLyBhdm9pZCBhIGJsb2NrIG5vZGUgZnJvbSB0cmFja2luZyBpdHNlbGZcbiAgIWlzQmxvY2tOb2RlICYmIC8vIGhhcyBjdXJyZW50IHBhcmVudCBibG9ja1xuICBjdXJyZW50QmxvY2sgJiYgLy8gcHJlc2VuY2Ugb2YgYSBwYXRjaCBmbGFnIGluZGljYXRlcyB0aGlzIG5vZGUgbmVlZHMgcGF0Y2hpbmcgb24gdXBkYXRlcy5cbiAgLy8gY29tcG9uZW50IG5vZGVzIGFsc28gc2hvdWxkIGFsd2F5cyBiZSBwYXRjaGVkLCBiZWNhdXNlIGV2ZW4gaWYgdGhlXG4gIC8vIGNvbXBvbmVudCBkb2Vzbid0IG5lZWQgdG8gdXBkYXRlLCBpdCBuZWVkcyB0byBwZXJzaXN0IHRoZSBpbnN0YW5jZSBvbiB0b1xuICAvLyB0aGUgbmV4dCB2bm9kZSBzbyB0aGF0IGl0IGNhbiBiZSBwcm9wZXJseSB1bm1vdW50ZWQgbGF0ZXIuXG4gICh2bm9kZS5wYXRjaEZsYWcgPiAwIHx8IHNoYXBlRmxhZyAmIDYpICYmIC8vIHRoZSBFVkVOVFMgZmxhZyBpcyBvbmx5IGZvciBoeWRyYXRpb24gYW5kIGlmIGl0IGlzIHRoZSBvbmx5IGZsYWcsIHRoZVxuICAvLyB2bm9kZSBzaG91bGQgbm90IGJlIGNvbnNpZGVyZWQgZHluYW1pYyBkdWUgdG8gaGFuZGxlciBjYWNoaW5nLlxuICB2bm9kZS5wYXRjaEZsYWcgIT09IDMyKSB7XG4gICAgY3VycmVudEJsb2NrLnB1c2godm5vZGUpO1xuICB9XG4gIHJldHVybiB2bm9kZTtcbn1cbmNvbnN0IGNyZWF0ZVZOb2RlID0gISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IGNyZWF0ZVZOb2RlV2l0aEFyZ3NUcmFuc2Zvcm0gOiBfY3JlYXRlVk5vZGU7XG5mdW5jdGlvbiBfY3JlYXRlVk5vZGUodHlwZSwgcHJvcHMgPSBudWxsLCBjaGlsZHJlbiA9IG51bGwsIHBhdGNoRmxhZyA9IDAsIGR5bmFtaWNQcm9wcyA9IG51bGwsIGlzQmxvY2tOb2RlID0gZmFsc2UpIHtcbiAgaWYgKCF0eXBlIHx8IHR5cGUgPT09IE5VTExfRFlOQU1JQ19DT01QT05FTlQpIHtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhdHlwZSkge1xuICAgICAgd2FybihgSW52YWxpZCB2bm9kZSB0eXBlIHdoZW4gY3JlYXRpbmcgdm5vZGU6ICR7dHlwZX0uYCk7XG4gICAgfVxuICAgIHR5cGUgPSBDb21tZW50O1xuICB9XG4gIGlmIChpc1ZOb2RlKHR5cGUpKSB7XG4gICAgY29uc3QgY2xvbmVkID0gY2xvbmVWTm9kZShcbiAgICAgIHR5cGUsXG4gICAgICBwcm9wcyxcbiAgICAgIHRydWVcbiAgICAgIC8qIG1lcmdlUmVmOiB0cnVlICovXG4gICAgKTtcbiAgICBpZiAoY2hpbGRyZW4pIHtcbiAgICAgIG5vcm1hbGl6ZUNoaWxkcmVuKGNsb25lZCwgY2hpbGRyZW4pO1xuICAgIH1cbiAgICBpZiAoaXNCbG9ja1RyZWVFbmFibGVkID4gMCAmJiAhaXNCbG9ja05vZGUgJiYgY3VycmVudEJsb2NrKSB7XG4gICAgICBpZiAoY2xvbmVkLnNoYXBlRmxhZyAmIDYpIHtcbiAgICAgICAgY3VycmVudEJsb2NrW2N1cnJlbnRCbG9jay5pbmRleE9mKHR5cGUpXSA9IGNsb25lZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN1cnJlbnRCbG9jay5wdXNoKGNsb25lZCk7XG4gICAgICB9XG4gICAgfVxuICAgIGNsb25lZC5wYXRjaEZsYWcgfD0gLTI7XG4gICAgcmV0dXJuIGNsb25lZDtcbiAgfVxuICBpZiAoaXNDbGFzc0NvbXBvbmVudCh0eXBlKSkge1xuICAgIHR5cGUgPSB0eXBlLl9fdmNjT3B0cztcbiAgfVxuICBpZiAocHJvcHMpIHtcbiAgICBwcm9wcyA9IGd1YXJkUmVhY3RpdmVQcm9wcyhwcm9wcyk7XG4gICAgbGV0IHsgY2xhc3M6IGtsYXNzLCBzdHlsZSB9ID0gcHJvcHM7XG4gICAgaWYgKGtsYXNzICYmICFpc1N0cmluZyhrbGFzcykpIHtcbiAgICAgIHByb3BzLmNsYXNzID0gbm9ybWFsaXplQ2xhc3Moa2xhc3MpO1xuICAgIH1cbiAgICBpZiAoaXNPYmplY3Qoc3R5bGUpKSB7XG4gICAgICBpZiAoaXNQcm94eShzdHlsZSkgJiYgIWlzQXJyYXkoc3R5bGUpKSB7XG4gICAgICAgIHN0eWxlID0gZXh0ZW5kKHt9LCBzdHlsZSk7XG4gICAgICB9XG4gICAgICBwcm9wcy5zdHlsZSA9IG5vcm1hbGl6ZVN0eWxlKHN0eWxlKTtcbiAgICB9XG4gIH1cbiAgY29uc3Qgc2hhcGVGbGFnID0gaXNTdHJpbmcodHlwZSkgPyAxIDogaXNTdXNwZW5zZSh0eXBlKSA/IDEyOCA6IGlzVGVsZXBvcnQodHlwZSkgPyA2NCA6IGlzT2JqZWN0KHR5cGUpID8gNCA6IGlzRnVuY3Rpb24odHlwZSkgPyAyIDogMDtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgc2hhcGVGbGFnICYgNCAmJiBpc1Byb3h5KHR5cGUpKSB7XG4gICAgdHlwZSA9IHRvUmF3KHR5cGUpO1xuICAgIHdhcm4oXG4gICAgICBgVnVlIHJlY2VpdmVkIGEgQ29tcG9uZW50IHdoaWNoIHdhcyBtYWRlIGEgcmVhY3RpdmUgb2JqZWN0LiBUaGlzIGNhbiBsZWFkIHRvIHVubmVjZXNzYXJ5IHBlcmZvcm1hbmNlIG92ZXJoZWFkLCBhbmQgc2hvdWxkIGJlIGF2b2lkZWQgYnkgbWFya2luZyB0aGUgY29tcG9uZW50IHdpdGggXFxgbWFya1Jhd1xcYCBvciB1c2luZyBcXGBzaGFsbG93UmVmXFxgIGluc3RlYWQgb2YgXFxgcmVmXFxgLmAsXG4gICAgICBgXG5Db21wb25lbnQgdGhhdCB3YXMgbWFkZSByZWFjdGl2ZTogYCxcbiAgICAgIHR5cGVcbiAgICApO1xuICB9XG4gIHJldHVybiBjcmVhdGVCYXNlVk5vZGUoXG4gICAgdHlwZSxcbiAgICBwcm9wcyxcbiAgICBjaGlsZHJlbixcbiAgICBwYXRjaEZsYWcsXG4gICAgZHluYW1pY1Byb3BzLFxuICAgIHNoYXBlRmxhZyxcbiAgICBpc0Jsb2NrTm9kZSxcbiAgICB0cnVlXG4gICk7XG59XG5mdW5jdGlvbiBndWFyZFJlYWN0aXZlUHJvcHMocHJvcHMpIHtcbiAgaWYgKCFwcm9wcylcbiAgICByZXR1cm4gbnVsbDtcbiAgcmV0dXJuIGlzUHJveHkocHJvcHMpIHx8IEludGVybmFsT2JqZWN0S2V5IGluIHByb3BzID8gZXh0ZW5kKHt9LCBwcm9wcykgOiBwcm9wcztcbn1cbmZ1bmN0aW9uIGNsb25lVk5vZGUodm5vZGUsIGV4dHJhUHJvcHMsIG1lcmdlUmVmID0gZmFsc2UpIHtcbiAgY29uc3QgeyBwcm9wcywgcmVmLCBwYXRjaEZsYWcsIGNoaWxkcmVuIH0gPSB2bm9kZTtcbiAgY29uc3QgbWVyZ2VkUHJvcHMgPSBleHRyYVByb3BzID8gbWVyZ2VQcm9wcyhwcm9wcyB8fCB7fSwgZXh0cmFQcm9wcykgOiBwcm9wcztcbiAgY29uc3QgY2xvbmVkID0ge1xuICAgIF9fdl9pc1ZOb2RlOiB0cnVlLFxuICAgIF9fdl9za2lwOiB0cnVlLFxuICAgIHR5cGU6IHZub2RlLnR5cGUsXG4gICAgcHJvcHM6IG1lcmdlZFByb3BzLFxuICAgIGtleTogbWVyZ2VkUHJvcHMgJiYgbm9ybWFsaXplS2V5KG1lcmdlZFByb3BzKSxcbiAgICByZWY6IGV4dHJhUHJvcHMgJiYgZXh0cmFQcm9wcy5yZWYgPyAoXG4gICAgICAvLyAjMjA3OCBpbiB0aGUgY2FzZSBvZiA8Y29tcG9uZW50IDppcz1cInZub2RlXCIgcmVmPVwiZXh0cmFcIi8+XG4gICAgICAvLyBpZiB0aGUgdm5vZGUgaXRzZWxmIGFscmVhZHkgaGFzIGEgcmVmLCBjbG9uZVZOb2RlIHdpbGwgbmVlZCB0byBtZXJnZVxuICAgICAgLy8gdGhlIHJlZnMgc28gdGhlIHNpbmdsZSB2bm9kZSBjYW4gYmUgc2V0IG9uIG11bHRpcGxlIHJlZnNcbiAgICAgIG1lcmdlUmVmICYmIHJlZiA/IGlzQXJyYXkocmVmKSA/IHJlZi5jb25jYXQobm9ybWFsaXplUmVmKGV4dHJhUHJvcHMpKSA6IFtyZWYsIG5vcm1hbGl6ZVJlZihleHRyYVByb3BzKV0gOiBub3JtYWxpemVSZWYoZXh0cmFQcm9wcylcbiAgICApIDogcmVmLFxuICAgIHNjb3BlSWQ6IHZub2RlLnNjb3BlSWQsXG4gICAgc2xvdFNjb3BlSWRzOiB2bm9kZS5zbG90U2NvcGVJZHMsXG4gICAgY2hpbGRyZW46ICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgcGF0Y2hGbGFnID09PSAtMSAmJiBpc0FycmF5KGNoaWxkcmVuKSA/IGNoaWxkcmVuLm1hcChkZWVwQ2xvbmVWTm9kZSkgOiBjaGlsZHJlbixcbiAgICB0YXJnZXQ6IHZub2RlLnRhcmdldCxcbiAgICB0YXJnZXRBbmNob3I6IHZub2RlLnRhcmdldEFuY2hvcixcbiAgICBzdGF0aWNDb3VudDogdm5vZGUuc3RhdGljQ291bnQsXG4gICAgc2hhcGVGbGFnOiB2bm9kZS5zaGFwZUZsYWcsXG4gICAgLy8gaWYgdGhlIHZub2RlIGlzIGNsb25lZCB3aXRoIGV4dHJhIHByb3BzLCB3ZSBjYW4gbm8gbG9uZ2VyIGFzc3VtZSBpdHNcbiAgICAvLyBleGlzdGluZyBwYXRjaCBmbGFnIHRvIGJlIHJlbGlhYmxlIGFuZCBuZWVkIHRvIGFkZCB0aGUgRlVMTF9QUk9QUyBmbGFnLlxuICAgIC8vIG5vdGU6IHByZXNlcnZlIGZsYWcgZm9yIGZyYWdtZW50cyBzaW5jZSB0aGV5IHVzZSB0aGUgZmxhZyBmb3IgY2hpbGRyZW5cbiAgICAvLyBmYXN0IHBhdGhzIG9ubHkuXG4gICAgcGF0Y2hGbGFnOiBleHRyYVByb3BzICYmIHZub2RlLnR5cGUgIT09IEZyYWdtZW50ID8gcGF0Y2hGbGFnID09PSAtMSA/IDE2IDogcGF0Y2hGbGFnIHwgMTYgOiBwYXRjaEZsYWcsXG4gICAgZHluYW1pY1Byb3BzOiB2bm9kZS5keW5hbWljUHJvcHMsXG4gICAgZHluYW1pY0NoaWxkcmVuOiB2bm9kZS5keW5hbWljQ2hpbGRyZW4sXG4gICAgYXBwQ29udGV4dDogdm5vZGUuYXBwQ29udGV4dCxcbiAgICBkaXJzOiB2bm9kZS5kaXJzLFxuICAgIHRyYW5zaXRpb246IHZub2RlLnRyYW5zaXRpb24sXG4gICAgLy8gVGhlc2Ugc2hvdWxkIHRlY2huaWNhbGx5IG9ubHkgYmUgbm9uLW51bGwgb24gbW91bnRlZCBWTm9kZXMuIEhvd2V2ZXIsXG4gICAgLy8gdGhleSAqc2hvdWxkKiBiZSBjb3BpZWQgZm9yIGtlcHQtYWxpdmUgdm5vZGVzLiBTbyB3ZSBqdXN0IGFsd2F5cyBjb3B5XG4gICAgLy8gdGhlbSBzaW5jZSB0aGVtIGJlaW5nIG5vbi1udWxsIGR1cmluZyBhIG1vdW50IGRvZXNuJ3QgYWZmZWN0IHRoZSBsb2dpYyBhc1xuICAgIC8vIHRoZXkgd2lsbCBzaW1wbHkgYmUgb3ZlcndyaXR0ZW4uXG4gICAgY29tcG9uZW50OiB2bm9kZS5jb21wb25lbnQsXG4gICAgc3VzcGVuc2U6IHZub2RlLnN1c3BlbnNlLFxuICAgIHNzQ29udGVudDogdm5vZGUuc3NDb250ZW50ICYmIGNsb25lVk5vZGUodm5vZGUuc3NDb250ZW50KSxcbiAgICBzc0ZhbGxiYWNrOiB2bm9kZS5zc0ZhbGxiYWNrICYmIGNsb25lVk5vZGUodm5vZGUuc3NGYWxsYmFjayksXG4gICAgZWw6IHZub2RlLmVsLFxuICAgIGFuY2hvcjogdm5vZGUuYW5jaG9yLFxuICAgIGN0eDogdm5vZGUuY3R4LFxuICAgIGNlOiB2bm9kZS5jZVxuICB9O1xuICByZXR1cm4gY2xvbmVkO1xufVxuZnVuY3Rpb24gZGVlcENsb25lVk5vZGUodm5vZGUpIHtcbiAgY29uc3QgY2xvbmVkID0gY2xvbmVWTm9kZSh2bm9kZSk7XG4gIGlmIChpc0FycmF5KHZub2RlLmNoaWxkcmVuKSkge1xuICAgIGNsb25lZC5jaGlsZHJlbiA9IHZub2RlLmNoaWxkcmVuLm1hcChkZWVwQ2xvbmVWTm9kZSk7XG4gIH1cbiAgcmV0dXJuIGNsb25lZDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVRleHRWTm9kZSh0ZXh0ID0gXCIgXCIsIGZsYWcgPSAwKSB7XG4gIHJldHVybiBjcmVhdGVWTm9kZShUZXh0LCBudWxsLCB0ZXh0LCBmbGFnKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVN0YXRpY1ZOb2RlKGNvbnRlbnQsIG51bWJlck9mTm9kZXMpIHtcbiAgY29uc3Qgdm5vZGUgPSBjcmVhdGVWTm9kZShTdGF0aWMsIG51bGwsIGNvbnRlbnQpO1xuICB2bm9kZS5zdGF0aWNDb3VudCA9IG51bWJlck9mTm9kZXM7XG4gIHJldHVybiB2bm9kZTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUNvbW1lbnRWTm9kZSh0ZXh0ID0gXCJcIiwgYXNCbG9jayA9IGZhbHNlKSB7XG4gIHJldHVybiBhc0Jsb2NrID8gKG9wZW5CbG9jaygpLCBjcmVhdGVCbG9jayhDb21tZW50LCBudWxsLCB0ZXh0KSkgOiBjcmVhdGVWTm9kZShDb21tZW50LCBudWxsLCB0ZXh0KTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZVZOb2RlKGNoaWxkKSB7XG4gIGlmIChjaGlsZCA9PSBudWxsIHx8IHR5cGVvZiBjaGlsZCA9PT0gXCJib29sZWFuXCIpIHtcbiAgICByZXR1cm4gY3JlYXRlVk5vZGUoQ29tbWVudCk7XG4gIH0gZWxzZSBpZiAoaXNBcnJheShjaGlsZCkpIHtcbiAgICByZXR1cm4gY3JlYXRlVk5vZGUoXG4gICAgICBGcmFnbWVudCxcbiAgICAgIG51bGwsXG4gICAgICAvLyAjMzY2NiwgYXZvaWQgcmVmZXJlbmNlIHBvbGx1dGlvbiB3aGVuIHJldXNpbmcgdm5vZGVcbiAgICAgIGNoaWxkLnNsaWNlKClcbiAgICApO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBjaGlsZCA9PT0gXCJvYmplY3RcIikge1xuICAgIHJldHVybiBjbG9uZUlmTW91bnRlZChjaGlsZCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGNyZWF0ZVZOb2RlKFRleHQsIG51bGwsIFN0cmluZyhjaGlsZCkpO1xuICB9XG59XG5mdW5jdGlvbiBjbG9uZUlmTW91bnRlZChjaGlsZCkge1xuICByZXR1cm4gY2hpbGQuZWwgPT09IG51bGwgJiYgY2hpbGQucGF0Y2hGbGFnICE9PSAtMSB8fCBjaGlsZC5tZW1vID8gY2hpbGQgOiBjbG9uZVZOb2RlKGNoaWxkKTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZUNoaWxkcmVuKHZub2RlLCBjaGlsZHJlbikge1xuICBsZXQgdHlwZSA9IDA7XG4gIGNvbnN0IHsgc2hhcGVGbGFnIH0gPSB2bm9kZTtcbiAgaWYgKGNoaWxkcmVuID09IG51bGwpIHtcbiAgICBjaGlsZHJlbiA9IG51bGw7XG4gIH0gZWxzZSBpZiAoaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICB0eXBlID0gMTY7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGNoaWxkcmVuID09PSBcIm9iamVjdFwiKSB7XG4gICAgaWYgKHNoYXBlRmxhZyAmICgxIHwgNjQpKSB7XG4gICAgICBjb25zdCBzbG90ID0gY2hpbGRyZW4uZGVmYXVsdDtcbiAgICAgIGlmIChzbG90KSB7XG4gICAgICAgIHNsb3QuX2MgJiYgKHNsb3QuX2QgPSBmYWxzZSk7XG4gICAgICAgIG5vcm1hbGl6ZUNoaWxkcmVuKHZub2RlLCBzbG90KCkpO1xuICAgICAgICBzbG90Ll9jICYmIChzbG90Ll9kID0gdHJ1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIHtcbiAgICAgIHR5cGUgPSAzMjtcbiAgICAgIGNvbnN0IHNsb3RGbGFnID0gY2hpbGRyZW4uXztcbiAgICAgIGlmICghc2xvdEZsYWcgJiYgIShJbnRlcm5hbE9iamVjdEtleSBpbiBjaGlsZHJlbikpIHtcbiAgICAgICAgY2hpbGRyZW4uX2N0eCA9IGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZTtcbiAgICAgIH0gZWxzZSBpZiAoc2xvdEZsYWcgPT09IDMgJiYgY3VycmVudFJlbmRlcmluZ0luc3RhbmNlKSB7XG4gICAgICAgIGlmIChjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2Uuc2xvdHMuXyA9PT0gMSkge1xuICAgICAgICAgIGNoaWxkcmVuLl8gPSAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNoaWxkcmVuLl8gPSAyO1xuICAgICAgICAgIHZub2RlLnBhdGNoRmxhZyB8PSAxMDI0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzRnVuY3Rpb24oY2hpbGRyZW4pKSB7XG4gICAgY2hpbGRyZW4gPSB7IGRlZmF1bHQ6IGNoaWxkcmVuLCBfY3R4OiBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UgfTtcbiAgICB0eXBlID0gMzI7XG4gIH0gZWxzZSB7XG4gICAgY2hpbGRyZW4gPSBTdHJpbmcoY2hpbGRyZW4pO1xuICAgIGlmIChzaGFwZUZsYWcgJiA2NCkge1xuICAgICAgdHlwZSA9IDE2O1xuICAgICAgY2hpbGRyZW4gPSBbY3JlYXRlVGV4dFZOb2RlKGNoaWxkcmVuKV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHR5cGUgPSA4O1xuICAgIH1cbiAgfVxuICB2bm9kZS5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICB2bm9kZS5zaGFwZUZsYWcgfD0gdHlwZTtcbn1cbmZ1bmN0aW9uIG1lcmdlUHJvcHMoLi4uYXJncykge1xuICBjb25zdCByZXQgPSB7fTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgdG9NZXJnZSA9IGFyZ3NbaV07XG4gICAgZm9yIChjb25zdCBrZXkgaW4gdG9NZXJnZSkge1xuICAgICAgaWYgKGtleSA9PT0gXCJjbGFzc1wiKSB7XG4gICAgICAgIGlmIChyZXQuY2xhc3MgIT09IHRvTWVyZ2UuY2xhc3MpIHtcbiAgICAgICAgICByZXQuY2xhc3MgPSBub3JtYWxpemVDbGFzcyhbcmV0LmNsYXNzLCB0b01lcmdlLmNsYXNzXSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSBcInN0eWxlXCIpIHtcbiAgICAgICAgcmV0LnN0eWxlID0gbm9ybWFsaXplU3R5bGUoW3JldC5zdHlsZSwgdG9NZXJnZS5zdHlsZV0pO1xuICAgICAgfSBlbHNlIGlmIChpc09uKGtleSkpIHtcbiAgICAgICAgY29uc3QgZXhpc3RpbmcgPSByZXRba2V5XTtcbiAgICAgICAgY29uc3QgaW5jb21pbmcgPSB0b01lcmdlW2tleV07XG4gICAgICAgIGlmIChpbmNvbWluZyAmJiBleGlzdGluZyAhPT0gaW5jb21pbmcgJiYgIShpc0FycmF5KGV4aXN0aW5nKSAmJiBleGlzdGluZy5pbmNsdWRlcyhpbmNvbWluZykpKSB7XG4gICAgICAgICAgcmV0W2tleV0gPSBleGlzdGluZyA/IFtdLmNvbmNhdChleGlzdGluZywgaW5jb21pbmcpIDogaW5jb21pbmc7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoa2V5ICE9PSBcIlwiKSB7XG4gICAgICAgIHJldFtrZXldID0gdG9NZXJnZVtrZXldO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmV0O1xufVxuZnVuY3Rpb24gaW52b2tlVk5vZGVIb29rKGhvb2ssIGluc3RhbmNlLCB2bm9kZSwgcHJldlZOb2RlID0gbnVsbCkge1xuICBjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZyhob29rLCBpbnN0YW5jZSwgNywgW1xuICAgIHZub2RlLFxuICAgIHByZXZWTm9kZVxuICBdKTtcbn1cblxuY29uc3QgZW1wdHlBcHBDb250ZXh0ID0gY3JlYXRlQXBwQ29udGV4dCgpO1xubGV0IHVpZCA9IDA7XG5mdW5jdGlvbiBjcmVhdGVDb21wb25lbnRJbnN0YW5jZSh2bm9kZSwgcGFyZW50LCBzdXNwZW5zZSkge1xuICBjb25zdCB0eXBlID0gdm5vZGUudHlwZTtcbiAgY29uc3QgYXBwQ29udGV4dCA9IChwYXJlbnQgPyBwYXJlbnQuYXBwQ29udGV4dCA6IHZub2RlLmFwcENvbnRleHQpIHx8IGVtcHR5QXBwQ29udGV4dDtcbiAgY29uc3QgaW5zdGFuY2UgPSB7XG4gICAgdWlkOiB1aWQrKyxcbiAgICB2bm9kZSxcbiAgICB0eXBlLFxuICAgIHBhcmVudCxcbiAgICBhcHBDb250ZXh0LFxuICAgIHJvb3Q6IG51bGwsXG4gICAgLy8gdG8gYmUgaW1tZWRpYXRlbHkgc2V0XG4gICAgbmV4dDogbnVsbCxcbiAgICBzdWJUcmVlOiBudWxsLFxuICAgIC8vIHdpbGwgYmUgc2V0IHN5bmNocm9ub3VzbHkgcmlnaHQgYWZ0ZXIgY3JlYXRpb25cbiAgICBlZmZlY3Q6IG51bGwsXG4gICAgdXBkYXRlOiBudWxsLFxuICAgIC8vIHdpbGwgYmUgc2V0IHN5bmNocm9ub3VzbHkgcmlnaHQgYWZ0ZXIgY3JlYXRpb25cbiAgICBzY29wZTogbmV3IEVmZmVjdFNjb3BlKFxuICAgICAgdHJ1ZVxuICAgICAgLyogZGV0YWNoZWQgKi9cbiAgICApLFxuICAgIHJlbmRlcjogbnVsbCxcbiAgICBwcm94eTogbnVsbCxcbiAgICBleHBvc2VkOiBudWxsLFxuICAgIGV4cG9zZVByb3h5OiBudWxsLFxuICAgIHdpdGhQcm94eTogbnVsbCxcbiAgICBwcm92aWRlczogcGFyZW50ID8gcGFyZW50LnByb3ZpZGVzIDogT2JqZWN0LmNyZWF0ZShhcHBDb250ZXh0LnByb3ZpZGVzKSxcbiAgICBhY2Nlc3NDYWNoZTogbnVsbCxcbiAgICByZW5kZXJDYWNoZTogW10sXG4gICAgLy8gbG9jYWwgcmVzb2x2ZWQgYXNzZXRzXG4gICAgY29tcG9uZW50czogbnVsbCxcbiAgICBkaXJlY3RpdmVzOiBudWxsLFxuICAgIC8vIHJlc29sdmVkIHByb3BzIGFuZCBlbWl0cyBvcHRpb25zXG4gICAgcHJvcHNPcHRpb25zOiBub3JtYWxpemVQcm9wc09wdGlvbnModHlwZSwgYXBwQ29udGV4dCksXG4gICAgZW1pdHNPcHRpb25zOiBub3JtYWxpemVFbWl0c09wdGlvbnModHlwZSwgYXBwQ29udGV4dCksXG4gICAgLy8gZW1pdFxuICAgIGVtaXQ6IG51bGwsXG4gICAgLy8gdG8gYmUgc2V0IGltbWVkaWF0ZWx5XG4gICAgZW1pdHRlZDogbnVsbCxcbiAgICAvLyBwcm9wcyBkZWZhdWx0IHZhbHVlXG4gICAgcHJvcHNEZWZhdWx0czogRU1QVFlfT0JKLFxuICAgIC8vIGluaGVyaXRBdHRyc1xuICAgIGluaGVyaXRBdHRyczogdHlwZS5pbmhlcml0QXR0cnMsXG4gICAgLy8gc3RhdGVcbiAgICBjdHg6IEVNUFRZX09CSixcbiAgICBkYXRhOiBFTVBUWV9PQkosXG4gICAgcHJvcHM6IEVNUFRZX09CSixcbiAgICBhdHRyczogRU1QVFlfT0JKLFxuICAgIHNsb3RzOiBFTVBUWV9PQkosXG4gICAgcmVmczogRU1QVFlfT0JKLFxuICAgIHNldHVwU3RhdGU6IEVNUFRZX09CSixcbiAgICBzZXR1cENvbnRleHQ6IG51bGwsXG4gICAgYXR0cnNQcm94eTogbnVsbCxcbiAgICBzbG90c1Byb3h5OiBudWxsLFxuICAgIC8vIHN1c3BlbnNlIHJlbGF0ZWRcbiAgICBzdXNwZW5zZSxcbiAgICBzdXNwZW5zZUlkOiBzdXNwZW5zZSA/IHN1c3BlbnNlLnBlbmRpbmdJZCA6IDAsXG4gICAgYXN5bmNEZXA6IG51bGwsXG4gICAgYXN5bmNSZXNvbHZlZDogZmFsc2UsXG4gICAgLy8gbGlmZWN5Y2xlIGhvb2tzXG4gICAgLy8gbm90IHVzaW5nIGVudW1zIGhlcmUgYmVjYXVzZSBpdCByZXN1bHRzIGluIGNvbXB1dGVkIHByb3BlcnRpZXNcbiAgICBpc01vdW50ZWQ6IGZhbHNlLFxuICAgIGlzVW5tb3VudGVkOiBmYWxzZSxcbiAgICBpc0RlYWN0aXZhdGVkOiBmYWxzZSxcbiAgICBiYzogbnVsbCxcbiAgICBjOiBudWxsLFxuICAgIGJtOiBudWxsLFxuICAgIG06IG51bGwsXG4gICAgYnU6IG51bGwsXG4gICAgdTogbnVsbCxcbiAgICB1bTogbnVsbCxcbiAgICBidW06IG51bGwsXG4gICAgZGE6IG51bGwsXG4gICAgYTogbnVsbCxcbiAgICBydGc6IG51bGwsXG4gICAgcnRjOiBudWxsLFxuICAgIGVjOiBudWxsLFxuICAgIHNwOiBudWxsXG4gIH07XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgaW5zdGFuY2UuY3R4ID0gY3JlYXRlRGV2UmVuZGVyQ29udGV4dChpbnN0YW5jZSk7XG4gIH0gZWxzZSB7XG4gICAgaW5zdGFuY2UuY3R4ID0geyBfOiBpbnN0YW5jZSB9O1xuICB9XG4gIGluc3RhbmNlLnJvb3QgPSBwYXJlbnQgPyBwYXJlbnQucm9vdCA6IGluc3RhbmNlO1xuICBpbnN0YW5jZS5lbWl0ID0gZW1pdC5iaW5kKG51bGwsIGluc3RhbmNlKTtcbiAgaWYgKHZub2RlLmNlKSB7XG4gICAgdm5vZGUuY2UoaW5zdGFuY2UpO1xuICB9XG4gIHJldHVybiBpbnN0YW5jZTtcbn1cbmxldCBjdXJyZW50SW5zdGFuY2UgPSBudWxsO1xuY29uc3QgZ2V0Q3VycmVudEluc3RhbmNlID0gKCkgPT4gY3VycmVudEluc3RhbmNlIHx8IGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZTtcbmxldCBpbnRlcm5hbFNldEN1cnJlbnRJbnN0YW5jZTtcbmxldCBnbG9iYWxDdXJyZW50SW5zdGFuY2VTZXR0ZXJzO1xubGV0IHNldHRlcnNLZXkgPSBcIl9fVlVFX0lOU1RBTkNFX1NFVFRFUlNfX1wiO1xue1xuICBpZiAoIShnbG9iYWxDdXJyZW50SW5zdGFuY2VTZXR0ZXJzID0gZ2V0R2xvYmFsVGhpcygpW3NldHRlcnNLZXldKSkge1xuICAgIGdsb2JhbEN1cnJlbnRJbnN0YW5jZVNldHRlcnMgPSBnZXRHbG9iYWxUaGlzKClbc2V0dGVyc0tleV0gPSBbXTtcbiAgfVxuICBnbG9iYWxDdXJyZW50SW5zdGFuY2VTZXR0ZXJzLnB1c2goKGkpID0+IGN1cnJlbnRJbnN0YW5jZSA9IGkpO1xuICBpbnRlcm5hbFNldEN1cnJlbnRJbnN0YW5jZSA9IChpbnN0YW5jZSkgPT4ge1xuICAgIGlmIChnbG9iYWxDdXJyZW50SW5zdGFuY2VTZXR0ZXJzLmxlbmd0aCA+IDEpIHtcbiAgICAgIGdsb2JhbEN1cnJlbnRJbnN0YW5jZVNldHRlcnMuZm9yRWFjaCgocykgPT4gcyhpbnN0YW5jZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBnbG9iYWxDdXJyZW50SW5zdGFuY2VTZXR0ZXJzWzBdKGluc3RhbmNlKTtcbiAgICB9XG4gIH07XG59XG5jb25zdCBzZXRDdXJyZW50SW5zdGFuY2UgPSAoaW5zdGFuY2UpID0+IHtcbiAgaW50ZXJuYWxTZXRDdXJyZW50SW5zdGFuY2UoaW5zdGFuY2UpO1xuICBpbnN0YW5jZS5zY29wZS5vbigpO1xufTtcbmNvbnN0IHVuc2V0Q3VycmVudEluc3RhbmNlID0gKCkgPT4ge1xuICBjdXJyZW50SW5zdGFuY2UgJiYgY3VycmVudEluc3RhbmNlLnNjb3BlLm9mZigpO1xuICBpbnRlcm5hbFNldEN1cnJlbnRJbnN0YW5jZShudWxsKTtcbn07XG5jb25zdCBpc0J1aWx0SW5UYWcgPSAvKiBAX19QVVJFX18gKi8gbWFrZU1hcChcInNsb3QsY29tcG9uZW50XCIpO1xuZnVuY3Rpb24gdmFsaWRhdGVDb21wb25lbnROYW1lKG5hbWUsIGNvbmZpZykge1xuICBjb25zdCBhcHBJc05hdGl2ZVRhZyA9IGNvbmZpZy5pc05hdGl2ZVRhZyB8fCBOTztcbiAgaWYgKGlzQnVpbHRJblRhZyhuYW1lKSB8fCBhcHBJc05hdGl2ZVRhZyhuYW1lKSkge1xuICAgIHdhcm4oXG4gICAgICBcIkRvIG5vdCB1c2UgYnVpbHQtaW4gb3IgcmVzZXJ2ZWQgSFRNTCBlbGVtZW50cyBhcyBjb21wb25lbnQgaWQ6IFwiICsgbmFtZVxuICAgICk7XG4gIH1cbn1cbmZ1bmN0aW9uIGlzU3RhdGVmdWxDb21wb25lbnQoaW5zdGFuY2UpIHtcbiAgcmV0dXJuIGluc3RhbmNlLnZub2RlLnNoYXBlRmxhZyAmIDQ7XG59XG5sZXQgaXNJblNTUkNvbXBvbmVudFNldHVwID0gZmFsc2U7XG5mdW5jdGlvbiBzZXR1cENvbXBvbmVudChpbnN0YW5jZSwgaXNTU1IgPSBmYWxzZSkge1xuICBpc0luU1NSQ29tcG9uZW50U2V0dXAgPSBpc1NTUjtcbiAgY29uc3QgeyBwcm9wcywgY2hpbGRyZW4gfSA9IGluc3RhbmNlLnZub2RlO1xuICBjb25zdCBpc1N0YXRlZnVsID0gaXNTdGF0ZWZ1bENvbXBvbmVudChpbnN0YW5jZSk7XG4gIGluaXRQcm9wcyhpbnN0YW5jZSwgcHJvcHMsIGlzU3RhdGVmdWwsIGlzU1NSKTtcbiAgaW5pdFNsb3RzKGluc3RhbmNlLCBjaGlsZHJlbik7XG4gIGNvbnN0IHNldHVwUmVzdWx0ID0gaXNTdGF0ZWZ1bCA/IHNldHVwU3RhdGVmdWxDb21wb25lbnQoaW5zdGFuY2UsIGlzU1NSKSA6IHZvaWQgMDtcbiAgaXNJblNTUkNvbXBvbmVudFNldHVwID0gZmFsc2U7XG4gIHJldHVybiBzZXR1cFJlc3VsdDtcbn1cbmZ1bmN0aW9uIHNldHVwU3RhdGVmdWxDb21wb25lbnQoaW5zdGFuY2UsIGlzU1NSKSB7XG4gIHZhciBfYTtcbiAgY29uc3QgQ29tcG9uZW50ID0gaW5zdGFuY2UudHlwZTtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICBpZiAoQ29tcG9uZW50Lm5hbWUpIHtcbiAgICAgIHZhbGlkYXRlQ29tcG9uZW50TmFtZShDb21wb25lbnQubmFtZSwgaW5zdGFuY2UuYXBwQ29udGV4dC5jb25maWcpO1xuICAgIH1cbiAgICBpZiAoQ29tcG9uZW50LmNvbXBvbmVudHMpIHtcbiAgICAgIGNvbnN0IG5hbWVzID0gT2JqZWN0LmtleXMoQ29tcG9uZW50LmNvbXBvbmVudHMpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YWxpZGF0ZUNvbXBvbmVudE5hbWUobmFtZXNbaV0sIGluc3RhbmNlLmFwcENvbnRleHQuY29uZmlnKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKENvbXBvbmVudC5kaXJlY3RpdmVzKSB7XG4gICAgICBjb25zdCBuYW1lcyA9IE9iamVjdC5rZXlzKENvbXBvbmVudC5kaXJlY3RpdmVzKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFsaWRhdGVEaXJlY3RpdmVOYW1lKG5hbWVzW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKENvbXBvbmVudC5jb21waWxlck9wdGlvbnMgJiYgaXNSdW50aW1lT25seSgpKSB7XG4gICAgICB3YXJuKFxuICAgICAgICBgXCJjb21waWxlck9wdGlvbnNcIiBpcyBvbmx5IHN1cHBvcnRlZCB3aGVuIHVzaW5nIGEgYnVpbGQgb2YgVnVlIHRoYXQgaW5jbHVkZXMgdGhlIHJ1bnRpbWUgY29tcGlsZXIuIFNpbmNlIHlvdSBhcmUgdXNpbmcgYSBydW50aW1lLW9ubHkgYnVpbGQsIHRoZSBvcHRpb25zIHNob3VsZCBiZSBwYXNzZWQgdmlhIHlvdXIgYnVpbGQgdG9vbCBjb25maWcgaW5zdGVhZC5gXG4gICAgICApO1xuICAgIH1cbiAgfVxuICBpbnN0YW5jZS5hY2Nlc3NDYWNoZSA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBpbnN0YW5jZS5wcm94eSA9IG1hcmtSYXcobmV3IFByb3h5KGluc3RhbmNlLmN0eCwgUHVibGljSW5zdGFuY2VQcm94eUhhbmRsZXJzKSk7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgZXhwb3NlUHJvcHNPblJlbmRlckNvbnRleHQoaW5zdGFuY2UpO1xuICB9XG4gIGNvbnN0IHsgc2V0dXAgfSA9IENvbXBvbmVudDtcbiAgaWYgKHNldHVwKSB7XG4gICAgY29uc3Qgc2V0dXBDb250ZXh0ID0gaW5zdGFuY2Uuc2V0dXBDb250ZXh0ID0gc2V0dXAubGVuZ3RoID4gMSA/IGNyZWF0ZVNldHVwQ29udGV4dChpbnN0YW5jZSkgOiBudWxsO1xuICAgIHNldEN1cnJlbnRJbnN0YW5jZShpbnN0YW5jZSk7XG4gICAgcGF1c2VUcmFja2luZygpO1xuICAgIGNvbnN0IHNldHVwUmVzdWx0ID0gY2FsbFdpdGhFcnJvckhhbmRsaW5nKFxuICAgICAgc2V0dXAsXG4gICAgICBpbnN0YW5jZSxcbiAgICAgIDAsXG4gICAgICBbISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IHNoYWxsb3dSZWFkb25seShpbnN0YW5jZS5wcm9wcykgOiBpbnN0YW5jZS5wcm9wcywgc2V0dXBDb250ZXh0XVxuICAgICk7XG4gICAgcmVzZXRUcmFja2luZygpO1xuICAgIHVuc2V0Q3VycmVudEluc3RhbmNlKCk7XG4gICAgaWYgKGlzUHJvbWlzZShzZXR1cFJlc3VsdCkpIHtcbiAgICAgIHNldHVwUmVzdWx0LnRoZW4odW5zZXRDdXJyZW50SW5zdGFuY2UsIHVuc2V0Q3VycmVudEluc3RhbmNlKTtcbiAgICAgIGlmIChpc1NTUikge1xuICAgICAgICByZXR1cm4gc2V0dXBSZXN1bHQudGhlbigocmVzb2x2ZWRSZXN1bHQpID0+IHtcbiAgICAgICAgICBoYW5kbGVTZXR1cFJlc3VsdChpbnN0YW5jZSwgcmVzb2x2ZWRSZXN1bHQsIGlzU1NSKTtcbiAgICAgICAgfSkuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICBoYW5kbGVFcnJvcihlLCBpbnN0YW5jZSwgMCk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5zdGFuY2UuYXN5bmNEZXAgPSBzZXR1cFJlc3VsdDtcbiAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgIWluc3RhbmNlLnN1c3BlbnNlKSB7XG4gICAgICAgICAgY29uc3QgbmFtZSA9IChfYSA9IENvbXBvbmVudC5uYW1lKSAhPSBudWxsID8gX2EgOiBcIkFub255bW91c1wiO1xuICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICBgQ29tcG9uZW50IDwke25hbWV9Pjogc2V0dXAgZnVuY3Rpb24gcmV0dXJuZWQgYSBwcm9taXNlLCBidXQgbm8gPFN1c3BlbnNlPiBib3VuZGFyeSB3YXMgZm91bmQgaW4gdGhlIHBhcmVudCBjb21wb25lbnQgdHJlZS4gQSBjb21wb25lbnQgd2l0aCBhc3luYyBzZXR1cCgpIG11c3QgYmUgbmVzdGVkIGluIGEgPFN1c3BlbnNlPiBpbiBvcmRlciB0byBiZSByZW5kZXJlZC5gXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBoYW5kbGVTZXR1cFJlc3VsdChpbnN0YW5jZSwgc2V0dXBSZXN1bHQsIGlzU1NSKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZmluaXNoQ29tcG9uZW50U2V0dXAoaW5zdGFuY2UsIGlzU1NSKTtcbiAgfVxufVxuZnVuY3Rpb24gaGFuZGxlU2V0dXBSZXN1bHQoaW5zdGFuY2UsIHNldHVwUmVzdWx0LCBpc1NTUikge1xuICBpZiAoaXNGdW5jdGlvbihzZXR1cFJlc3VsdCkpIHtcbiAgICBpZiAoaW5zdGFuY2UudHlwZS5fX3NzcklubGluZVJlbmRlcikge1xuICAgICAgaW5zdGFuY2Uuc3NyUmVuZGVyID0gc2V0dXBSZXN1bHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGluc3RhbmNlLnJlbmRlciA9IHNldHVwUmVzdWx0O1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc09iamVjdChzZXR1cFJlc3VsdCkpIHtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBpc1ZOb2RlKHNldHVwUmVzdWx0KSkge1xuICAgICAgd2FybihcbiAgICAgICAgYHNldHVwKCkgc2hvdWxkIG5vdCByZXR1cm4gVk5vZGVzIGRpcmVjdGx5IC0gcmV0dXJuIGEgcmVuZGVyIGZ1bmN0aW9uIGluc3RlYWQuYFxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XG4gICAgICBpbnN0YW5jZS5kZXZ0b29sc1Jhd1NldHVwU3RhdGUgPSBzZXR1cFJlc3VsdDtcbiAgICB9XG4gICAgaW5zdGFuY2Uuc2V0dXBTdGF0ZSA9IHByb3h5UmVmcyhzZXR1cFJlc3VsdCk7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgIGV4cG9zZVNldHVwU3RhdGVPblJlbmRlckNvbnRleHQoaW5zdGFuY2UpO1xuICAgIH1cbiAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHNldHVwUmVzdWx0ICE9PSB2b2lkIDApIHtcbiAgICB3YXJuKFxuICAgICAgYHNldHVwKCkgc2hvdWxkIHJldHVybiBhbiBvYmplY3QuIFJlY2VpdmVkOiAke3NldHVwUmVzdWx0ID09PSBudWxsID8gXCJudWxsXCIgOiB0eXBlb2Ygc2V0dXBSZXN1bHR9YFxuICAgICk7XG4gIH1cbiAgZmluaXNoQ29tcG9uZW50U2V0dXAoaW5zdGFuY2UsIGlzU1NSKTtcbn1cbmxldCBjb21waWxlO1xubGV0IGluc3RhbGxXaXRoUHJveHk7XG5mdW5jdGlvbiByZWdpc3RlclJ1bnRpbWVDb21waWxlcihfY29tcGlsZSkge1xuICBjb21waWxlID0gX2NvbXBpbGU7XG4gIGluc3RhbGxXaXRoUHJveHkgPSAoaSkgPT4ge1xuICAgIGlmIChpLnJlbmRlci5fcmMpIHtcbiAgICAgIGkud2l0aFByb3h5ID0gbmV3IFByb3h5KGkuY3R4LCBSdW50aW1lQ29tcGlsZWRQdWJsaWNJbnN0YW5jZVByb3h5SGFuZGxlcnMpO1xuICAgIH1cbiAgfTtcbn1cbmNvbnN0IGlzUnVudGltZU9ubHkgPSAoKSA9PiAhY29tcGlsZTtcbmZ1bmN0aW9uIGZpbmlzaENvbXBvbmVudFNldHVwKGluc3RhbmNlLCBpc1NTUiwgc2tpcE9wdGlvbnMpIHtcbiAgY29uc3QgQ29tcG9uZW50ID0gaW5zdGFuY2UudHlwZTtcbiAgaWYgKCFpbnN0YW5jZS5yZW5kZXIpIHtcbiAgICBpZiAoIWlzU1NSICYmIGNvbXBpbGUgJiYgIUNvbXBvbmVudC5yZW5kZXIpIHtcbiAgICAgIGNvbnN0IHRlbXBsYXRlID0gQ29tcG9uZW50LnRlbXBsYXRlIHx8IHJlc29sdmVNZXJnZWRPcHRpb25zKGluc3RhbmNlKS50ZW1wbGF0ZTtcbiAgICAgIGlmICh0ZW1wbGF0ZSkge1xuICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgIHN0YXJ0TWVhc3VyZShpbnN0YW5jZSwgYGNvbXBpbGVgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IGlzQ3VzdG9tRWxlbWVudCwgY29tcGlsZXJPcHRpb25zIH0gPSBpbnN0YW5jZS5hcHBDb250ZXh0LmNvbmZpZztcbiAgICAgICAgY29uc3QgeyBkZWxpbWl0ZXJzLCBjb21waWxlck9wdGlvbnM6IGNvbXBvbmVudENvbXBpbGVyT3B0aW9ucyB9ID0gQ29tcG9uZW50O1xuICAgICAgICBjb25zdCBmaW5hbENvbXBpbGVyT3B0aW9ucyA9IGV4dGVuZChcbiAgICAgICAgICBleHRlbmQoXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGlzQ3VzdG9tRWxlbWVudCxcbiAgICAgICAgICAgICAgZGVsaW1pdGVyc1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbXBpbGVyT3B0aW9uc1xuICAgICAgICAgICksXG4gICAgICAgICAgY29tcG9uZW50Q29tcGlsZXJPcHRpb25zXG4gICAgICAgICk7XG4gICAgICAgIENvbXBvbmVudC5yZW5kZXIgPSBjb21waWxlKHRlbXBsYXRlLCBmaW5hbENvbXBpbGVyT3B0aW9ucyk7XG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgZW5kTWVhc3VyZShpbnN0YW5jZSwgYGNvbXBpbGVgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpbnN0YW5jZS5yZW5kZXIgPSBDb21wb25lbnQucmVuZGVyIHx8IE5PT1A7XG4gICAgaWYgKGluc3RhbGxXaXRoUHJveHkpIHtcbiAgICAgIGluc3RhbGxXaXRoUHJveHkoaW5zdGFuY2UpO1xuICAgIH1cbiAgfVxuICBpZiAoX19WVUVfT1BUSU9OU19BUElfXyAmJiB0cnVlKSB7XG4gICAgc2V0Q3VycmVudEluc3RhbmNlKGluc3RhbmNlKTtcbiAgICBwYXVzZVRyYWNraW5nKCk7XG4gICAgYXBwbHlPcHRpb25zKGluc3RhbmNlKTtcbiAgICByZXNldFRyYWNraW5nKCk7XG4gICAgdW5zZXRDdXJyZW50SW5zdGFuY2UoKTtcbiAgfVxuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhQ29tcG9uZW50LnJlbmRlciAmJiBpbnN0YW5jZS5yZW5kZXIgPT09IE5PT1AgJiYgIWlzU1NSKSB7XG4gICAgaWYgKCFjb21waWxlICYmIENvbXBvbmVudC50ZW1wbGF0ZSkge1xuICAgICAgd2FybihcbiAgICAgICAgYENvbXBvbmVudCBwcm92aWRlZCB0ZW1wbGF0ZSBvcHRpb24gYnV0IHJ1bnRpbWUgY29tcGlsYXRpb24gaXMgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJ1aWxkIG9mIFZ1ZS5gICsgKGAgQ29uZmlndXJlIHlvdXIgYnVuZGxlciB0byBhbGlhcyBcInZ1ZVwiIHRvIFwidnVlL2Rpc3QvdnVlLmVzbS1idW5kbGVyLmpzXCIuYCApXG4gICAgICAgIC8qIHNob3VsZCBub3QgaGFwcGVuICovXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICB3YXJuKGBDb21wb25lbnQgaXMgbWlzc2luZyB0ZW1wbGF0ZSBvciByZW5kZXIgZnVuY3Rpb24uYCk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBnZXRBdHRyc1Byb3h5KGluc3RhbmNlKSB7XG4gIHJldHVybiBpbnN0YW5jZS5hdHRyc1Byb3h5IHx8IChpbnN0YW5jZS5hdHRyc1Byb3h5ID0gbmV3IFByb3h5KFxuICAgIGluc3RhbmNlLmF0dHJzLFxuICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyB7XG4gICAgICBnZXQodGFyZ2V0LCBrZXkpIHtcbiAgICAgICAgbWFya0F0dHJzQWNjZXNzZWQoKTtcbiAgICAgICAgdHJhY2soaW5zdGFuY2UsIFwiZ2V0XCIsIFwiJGF0dHJzXCIpO1xuICAgICAgICByZXR1cm4gdGFyZ2V0W2tleV07XG4gICAgICB9LFxuICAgICAgc2V0KCkge1xuICAgICAgICB3YXJuKGBzZXR1cENvbnRleHQuYXR0cnMgaXMgcmVhZG9ubHkuYCk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0sXG4gICAgICBkZWxldGVQcm9wZXJ0eSgpIHtcbiAgICAgICAgd2Fybihgc2V0dXBDb250ZXh0LmF0dHJzIGlzIHJlYWRvbmx5LmApO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSA6IHtcbiAgICAgIGdldCh0YXJnZXQsIGtleSkge1xuICAgICAgICB0cmFjayhpbnN0YW5jZSwgXCJnZXRcIiwgXCIkYXR0cnNcIik7XG4gICAgICAgIHJldHVybiB0YXJnZXRba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gICkpO1xufVxuZnVuY3Rpb24gZ2V0U2xvdHNQcm94eShpbnN0YW5jZSkge1xuICByZXR1cm4gaW5zdGFuY2Uuc2xvdHNQcm94eSB8fCAoaW5zdGFuY2Uuc2xvdHNQcm94eSA9IG5ldyBQcm94eShpbnN0YW5jZS5zbG90cywge1xuICAgIGdldCh0YXJnZXQsIGtleSkge1xuICAgICAgdHJhY2soaW5zdGFuY2UsIFwiZ2V0XCIsIFwiJHNsb3RzXCIpO1xuICAgICAgcmV0dXJuIHRhcmdldFtrZXldO1xuICAgIH1cbiAgfSkpO1xufVxuZnVuY3Rpb24gY3JlYXRlU2V0dXBDb250ZXh0KGluc3RhbmNlKSB7XG4gIGNvbnN0IGV4cG9zZSA9IChleHBvc2VkKSA9PiB7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgIGlmIChpbnN0YW5jZS5leHBvc2VkKSB7XG4gICAgICAgIHdhcm4oYGV4cG9zZSgpIHNob3VsZCBiZSBjYWxsZWQgb25seSBvbmNlIHBlciBzZXR1cCgpLmApO1xuICAgICAgfVxuICAgICAgaWYgKGV4cG9zZWQgIT0gbnVsbCkge1xuICAgICAgICBsZXQgZXhwb3NlZFR5cGUgPSB0eXBlb2YgZXhwb3NlZDtcbiAgICAgICAgaWYgKGV4cG9zZWRUeXBlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgaWYgKGlzQXJyYXkoZXhwb3NlZCkpIHtcbiAgICAgICAgICAgIGV4cG9zZWRUeXBlID0gXCJhcnJheVwiO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaXNSZWYoZXhwb3NlZCkpIHtcbiAgICAgICAgICAgIGV4cG9zZWRUeXBlID0gXCJyZWZcIjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV4cG9zZWRUeXBlICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgd2FybihcbiAgICAgICAgICAgIGBleHBvc2UoKSBzaG91bGQgYmUgcGFzc2VkIGEgcGxhaW4gb2JqZWN0LCByZWNlaXZlZCAke2V4cG9zZWRUeXBlfS5gXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpbnN0YW5jZS5leHBvc2VkID0gZXhwb3NlZCB8fCB7fTtcbiAgfTtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7XG4gICAgICBnZXQgYXR0cnMoKSB7XG4gICAgICAgIHJldHVybiBnZXRBdHRyc1Byb3h5KGluc3RhbmNlKTtcbiAgICAgIH0sXG4gICAgICBnZXQgc2xvdHMoKSB7XG4gICAgICAgIHJldHVybiBnZXRTbG90c1Byb3h5KGluc3RhbmNlKTtcbiAgICAgIH0sXG4gICAgICBnZXQgZW1pdCgpIHtcbiAgICAgICAgcmV0dXJuIChldmVudCwgLi4uYXJncykgPT4gaW5zdGFuY2UuZW1pdChldmVudCwgLi4uYXJncyk7XG4gICAgICB9LFxuICAgICAgZXhwb3NlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGdldCBhdHRycygpIHtcbiAgICAgICAgcmV0dXJuIGdldEF0dHJzUHJveHkoaW5zdGFuY2UpO1xuICAgICAgfSxcbiAgICAgIHNsb3RzOiBpbnN0YW5jZS5zbG90cyxcbiAgICAgIGVtaXQ6IGluc3RhbmNlLmVtaXQsXG4gICAgICBleHBvc2VcbiAgICB9O1xuICB9XG59XG5mdW5jdGlvbiBnZXRFeHBvc2VQcm94eShpbnN0YW5jZSkge1xuICBpZiAoaW5zdGFuY2UuZXhwb3NlZCkge1xuICAgIHJldHVybiBpbnN0YW5jZS5leHBvc2VQcm94eSB8fCAoaW5zdGFuY2UuZXhwb3NlUHJveHkgPSBuZXcgUHJveHkocHJveHlSZWZzKG1hcmtSYXcoaW5zdGFuY2UuZXhwb3NlZCkpLCB7XG4gICAgICBnZXQodGFyZ2V0LCBrZXkpIHtcbiAgICAgICAgaWYgKGtleSBpbiB0YXJnZXQpIHtcbiAgICAgICAgICByZXR1cm4gdGFyZ2V0W2tleV07XG4gICAgICAgIH0gZWxzZSBpZiAoa2V5IGluIHB1YmxpY1Byb3BlcnRpZXNNYXApIHtcbiAgICAgICAgICByZXR1cm4gcHVibGljUHJvcGVydGllc01hcFtrZXldKGluc3RhbmNlKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGhhcyh0YXJnZXQsIGtleSkge1xuICAgICAgICByZXR1cm4ga2V5IGluIHRhcmdldCB8fCBrZXkgaW4gcHVibGljUHJvcGVydGllc01hcDtcbiAgICAgIH1cbiAgICB9KSk7XG4gIH1cbn1cbmNvbnN0IGNsYXNzaWZ5UkUgPSAvKD86XnxbLV9dKShcXHcpL2c7XG5jb25zdCBjbGFzc2lmeSA9IChzdHIpID0+IHN0ci5yZXBsYWNlKGNsYXNzaWZ5UkUsIChjKSA9PiBjLnRvVXBwZXJDYXNlKCkpLnJlcGxhY2UoL1stX10vZywgXCJcIik7XG5mdW5jdGlvbiBnZXRDb21wb25lbnROYW1lKENvbXBvbmVudCwgaW5jbHVkZUluZmVycmVkID0gdHJ1ZSkge1xuICByZXR1cm4gaXNGdW5jdGlvbihDb21wb25lbnQpID8gQ29tcG9uZW50LmRpc3BsYXlOYW1lIHx8IENvbXBvbmVudC5uYW1lIDogQ29tcG9uZW50Lm5hbWUgfHwgaW5jbHVkZUluZmVycmVkICYmIENvbXBvbmVudC5fX25hbWU7XG59XG5mdW5jdGlvbiBmb3JtYXRDb21wb25lbnROYW1lKGluc3RhbmNlLCBDb21wb25lbnQsIGlzUm9vdCA9IGZhbHNlKSB7XG4gIGxldCBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShDb21wb25lbnQpO1xuICBpZiAoIW5hbWUgJiYgQ29tcG9uZW50Ll9fZmlsZSkge1xuICAgIGNvbnN0IG1hdGNoID0gQ29tcG9uZW50Ll9fZmlsZS5tYXRjaCgvKFteL1xcXFxdKylcXC5cXHcrJC8pO1xuICAgIGlmIChtYXRjaCkge1xuICAgICAgbmFtZSA9IG1hdGNoWzFdO1xuICAgIH1cbiAgfVxuICBpZiAoIW5hbWUgJiYgaW5zdGFuY2UgJiYgaW5zdGFuY2UucGFyZW50KSB7XG4gICAgY29uc3QgaW5mZXJGcm9tUmVnaXN0cnkgPSAocmVnaXN0cnkpID0+IHtcbiAgICAgIGZvciAoY29uc3Qga2V5IGluIHJlZ2lzdHJ5KSB7XG4gICAgICAgIGlmIChyZWdpc3RyeVtrZXldID09PSBDb21wb25lbnQpIHtcbiAgICAgICAgICByZXR1cm4ga2V5O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBuYW1lID0gaW5mZXJGcm9tUmVnaXN0cnkoXG4gICAgICBpbnN0YW5jZS5jb21wb25lbnRzIHx8IGluc3RhbmNlLnBhcmVudC50eXBlLmNvbXBvbmVudHNcbiAgICApIHx8IGluZmVyRnJvbVJlZ2lzdHJ5KGluc3RhbmNlLmFwcENvbnRleHQuY29tcG9uZW50cyk7XG4gIH1cbiAgcmV0dXJuIG5hbWUgPyBjbGFzc2lmeShuYW1lKSA6IGlzUm9vdCA/IGBBcHBgIDogYEFub255bW91c2A7XG59XG5mdW5jdGlvbiBpc0NsYXNzQ29tcG9uZW50KHZhbHVlKSB7XG4gIHJldHVybiBpc0Z1bmN0aW9uKHZhbHVlKSAmJiBcIl9fdmNjT3B0c1wiIGluIHZhbHVlO1xufVxuXG5jb25zdCBjb21wdXRlZCA9IChnZXR0ZXJPck9wdGlvbnMsIGRlYnVnT3B0aW9ucykgPT4ge1xuICByZXR1cm4gY29tcHV0ZWQkMShnZXR0ZXJPck9wdGlvbnMsIGRlYnVnT3B0aW9ucywgaXNJblNTUkNvbXBvbmVudFNldHVwKTtcbn07XG5cbmZ1bmN0aW9uIGgodHlwZSwgcHJvcHNPckNoaWxkcmVuLCBjaGlsZHJlbikge1xuICBjb25zdCBsID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgaWYgKGwgPT09IDIpIHtcbiAgICBpZiAoaXNPYmplY3QocHJvcHNPckNoaWxkcmVuKSAmJiAhaXNBcnJheShwcm9wc09yQ2hpbGRyZW4pKSB7XG4gICAgICBpZiAoaXNWTm9kZShwcm9wc09yQ2hpbGRyZW4pKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVWTm9kZSh0eXBlLCBudWxsLCBbcHJvcHNPckNoaWxkcmVuXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY3JlYXRlVk5vZGUodHlwZSwgcHJvcHNPckNoaWxkcmVuKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGNyZWF0ZVZOb2RlKHR5cGUsIG51bGwsIHByb3BzT3JDaGlsZHJlbik7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChsID4gMykge1xuICAgICAgY2hpbGRyZW4gPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuICAgIH0gZWxzZSBpZiAobCA9PT0gMyAmJiBpc1ZOb2RlKGNoaWxkcmVuKSkge1xuICAgICAgY2hpbGRyZW4gPSBbY2hpbGRyZW5dO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlVk5vZGUodHlwZSwgcHJvcHNPckNoaWxkcmVuLCBjaGlsZHJlbik7XG4gIH1cbn1cblxuY29uc3Qgc3NyQ29udGV4dEtleSA9IFN5bWJvbC5mb3IoXCJ2LXNjeFwiKTtcbmNvbnN0IHVzZVNTUkNvbnRleHQgPSAoKSA9PiB7XG4gIHtcbiAgICBjb25zdCBjdHggPSBpbmplY3Qoc3NyQ29udGV4dEtleSk7XG4gICAgaWYgKCFjdHgpIHtcbiAgICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgd2FybihcbiAgICAgICAgYFNlcnZlciByZW5kZXJpbmcgY29udGV4dCBub3QgcHJvdmlkZWQuIE1ha2Ugc3VyZSB0byBvbmx5IGNhbGwgdXNlU1NSQ29udGV4dCgpIGNvbmRpdGlvbmFsbHkgaW4gdGhlIHNlcnZlciBidWlsZC5gXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gY3R4O1xuICB9XG59O1xuXG5mdW5jdGlvbiBpc1NoYWxsb3codmFsdWUpIHtcbiAgcmV0dXJuICEhKHZhbHVlICYmIHZhbHVlW1wiX192X2lzU2hhbGxvd1wiXSk7XG59XG5cbmZ1bmN0aW9uIGluaXRDdXN0b21Gb3JtYXR0ZXIoKSB7XG4gIGlmICghISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB8fCB0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHZ1ZVN0eWxlID0geyBzdHlsZTogXCJjb2xvcjojM2JhNzc2XCIgfTtcbiAgY29uc3QgbnVtYmVyU3R5bGUgPSB7IHN0eWxlOiBcImNvbG9yOiMwYjFiYzlcIiB9O1xuICBjb25zdCBzdHJpbmdTdHlsZSA9IHsgc3R5bGU6IFwiY29sb3I6I2I2MmUyNFwiIH07XG4gIGNvbnN0IGtleXdvcmRTdHlsZSA9IHsgc3R5bGU6IFwiY29sb3I6IzlkMjg4Y1wiIH07XG4gIGNvbnN0IGZvcm1hdHRlciA9IHtcbiAgICBoZWFkZXIob2JqKSB7XG4gICAgICBpZiAoIWlzT2JqZWN0KG9iaikpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBpZiAob2JqLl9faXNWdWUpIHtcbiAgICAgICAgcmV0dXJuIFtcImRpdlwiLCB2dWVTdHlsZSwgYFZ1ZUluc3RhbmNlYF07XG4gICAgICB9IGVsc2UgaWYgKGlzUmVmKG9iaikpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICBcImRpdlwiLFxuICAgICAgICAgIHt9LFxuICAgICAgICAgIFtcInNwYW5cIiwgdnVlU3R5bGUsIGdlblJlZkZsYWcob2JqKV0sXG4gICAgICAgICAgXCI8XCIsXG4gICAgICAgICAgZm9ybWF0VmFsdWUob2JqLnZhbHVlKSxcbiAgICAgICAgICBgPmBcbiAgICAgICAgXTtcbiAgICAgIH0gZWxzZSBpZiAoaXNSZWFjdGl2ZShvYmopKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgXCJkaXZcIixcbiAgICAgICAgICB7fSxcbiAgICAgICAgICBbXCJzcGFuXCIsIHZ1ZVN0eWxlLCBpc1NoYWxsb3cob2JqKSA/IFwiU2hhbGxvd1JlYWN0aXZlXCIgOiBcIlJlYWN0aXZlXCJdLFxuICAgICAgICAgIFwiPFwiLFxuICAgICAgICAgIGZvcm1hdFZhbHVlKG9iaiksXG4gICAgICAgICAgYD4ke2lzUmVhZG9ubHkob2JqKSA/IGAgKHJlYWRvbmx5KWAgOiBgYH1gXG4gICAgICAgIF07XG4gICAgICB9IGVsc2UgaWYgKGlzUmVhZG9ubHkob2JqKSkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgIFwiZGl2XCIsXG4gICAgICAgICAge30sXG4gICAgICAgICAgW1wic3BhblwiLCB2dWVTdHlsZSwgaXNTaGFsbG93KG9iaikgPyBcIlNoYWxsb3dSZWFkb25seVwiIDogXCJSZWFkb25seVwiXSxcbiAgICAgICAgICBcIjxcIixcbiAgICAgICAgICBmb3JtYXRWYWx1ZShvYmopLFxuICAgICAgICAgIFwiPlwiXG4gICAgICAgIF07XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuICAgIGhhc0JvZHkob2JqKSB7XG4gICAgICByZXR1cm4gb2JqICYmIG9iai5fX2lzVnVlO1xuICAgIH0sXG4gICAgYm9keShvYmopIHtcbiAgICAgIGlmIChvYmogJiYgb2JqLl9faXNWdWUpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICBcImRpdlwiLFxuICAgICAgICAgIHt9LFxuICAgICAgICAgIC4uLmZvcm1hdEluc3RhbmNlKG9iai4kKVxuICAgICAgICBdO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgZnVuY3Rpb24gZm9ybWF0SW5zdGFuY2UoaW5zdGFuY2UpIHtcbiAgICBjb25zdCBibG9ja3MgPSBbXTtcbiAgICBpZiAoaW5zdGFuY2UudHlwZS5wcm9wcyAmJiBpbnN0YW5jZS5wcm9wcykge1xuICAgICAgYmxvY2tzLnB1c2goY3JlYXRlSW5zdGFuY2VCbG9jayhcInByb3BzXCIsIHRvUmF3KGluc3RhbmNlLnByb3BzKSkpO1xuICAgIH1cbiAgICBpZiAoaW5zdGFuY2Uuc2V0dXBTdGF0ZSAhPT0gRU1QVFlfT0JKKSB7XG4gICAgICBibG9ja3MucHVzaChjcmVhdGVJbnN0YW5jZUJsb2NrKFwic2V0dXBcIiwgaW5zdGFuY2Uuc2V0dXBTdGF0ZSkpO1xuICAgIH1cbiAgICBpZiAoaW5zdGFuY2UuZGF0YSAhPT0gRU1QVFlfT0JKKSB7XG4gICAgICBibG9ja3MucHVzaChjcmVhdGVJbnN0YW5jZUJsb2NrKFwiZGF0YVwiLCB0b1JhdyhpbnN0YW5jZS5kYXRhKSkpO1xuICAgIH1cbiAgICBjb25zdCBjb21wdXRlZCA9IGV4dHJhY3RLZXlzKGluc3RhbmNlLCBcImNvbXB1dGVkXCIpO1xuICAgIGlmIChjb21wdXRlZCkge1xuICAgICAgYmxvY2tzLnB1c2goY3JlYXRlSW5zdGFuY2VCbG9jayhcImNvbXB1dGVkXCIsIGNvbXB1dGVkKSk7XG4gICAgfVxuICAgIGNvbnN0IGluamVjdGVkID0gZXh0cmFjdEtleXMoaW5zdGFuY2UsIFwiaW5qZWN0XCIpO1xuICAgIGlmIChpbmplY3RlZCkge1xuICAgICAgYmxvY2tzLnB1c2goY3JlYXRlSW5zdGFuY2VCbG9jayhcImluamVjdGVkXCIsIGluamVjdGVkKSk7XG4gICAgfVxuICAgIGJsb2Nrcy5wdXNoKFtcbiAgICAgIFwiZGl2XCIsXG4gICAgICB7fSxcbiAgICAgIFtcbiAgICAgICAgXCJzcGFuXCIsXG4gICAgICAgIHtcbiAgICAgICAgICBzdHlsZToga2V5d29yZFN0eWxlLnN0eWxlICsgXCI7b3BhY2l0eTowLjY2XCJcbiAgICAgICAgfSxcbiAgICAgICAgXCIkIChpbnRlcm5hbCk6IFwiXG4gICAgICBdLFxuICAgICAgW1wib2JqZWN0XCIsIHsgb2JqZWN0OiBpbnN0YW5jZSB9XVxuICAgIF0pO1xuICAgIHJldHVybiBibG9ja3M7XG4gIH1cbiAgZnVuY3Rpb24gY3JlYXRlSW5zdGFuY2VCbG9jayh0eXBlLCB0YXJnZXQpIHtcbiAgICB0YXJnZXQgPSBleHRlbmQoe30sIHRhcmdldCk7XG4gICAgaWYgKCFPYmplY3Qua2V5cyh0YXJnZXQpLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIFtcInNwYW5cIiwge31dO1xuICAgIH1cbiAgICByZXR1cm4gW1xuICAgICAgXCJkaXZcIixcbiAgICAgIHsgc3R5bGU6IFwibGluZS1oZWlnaHQ6MS4yNWVtO21hcmdpbi1ib3R0b206MC42ZW1cIiB9LFxuICAgICAgW1xuICAgICAgICBcImRpdlwiLFxuICAgICAgICB7XG4gICAgICAgICAgc3R5bGU6IFwiY29sb3I6IzQ3NjU4MlwiXG4gICAgICAgIH0sXG4gICAgICAgIHR5cGVcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgIFwiZGl2XCIsXG4gICAgICAgIHtcbiAgICAgICAgICBzdHlsZTogXCJwYWRkaW5nLWxlZnQ6MS4yNWVtXCJcbiAgICAgICAgfSxcbiAgICAgICAgLi4uT2JqZWN0LmtleXModGFyZ2V0KS5tYXAoKGtleSkgPT4ge1xuICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBcImRpdlwiLFxuICAgICAgICAgICAge30sXG4gICAgICAgICAgICBbXCJzcGFuXCIsIGtleXdvcmRTdHlsZSwga2V5ICsgXCI6IFwiXSxcbiAgICAgICAgICAgIGZvcm1hdFZhbHVlKHRhcmdldFtrZXldLCBmYWxzZSlcbiAgICAgICAgICBdO1xuICAgICAgICB9KVxuICAgICAgXVxuICAgIF07XG4gIH1cbiAgZnVuY3Rpb24gZm9ybWF0VmFsdWUodiwgYXNSYXcgPSB0cnVlKSB7XG4gICAgaWYgKHR5cGVvZiB2ID09PSBcIm51bWJlclwiKSB7XG4gICAgICByZXR1cm4gW1wic3BhblwiLCBudW1iZXJTdHlsZSwgdl07XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgcmV0dXJuIFtcInNwYW5cIiwgc3RyaW5nU3R5bGUsIEpTT04uc3RyaW5naWZ5KHYpXTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB2ID09PSBcImJvb2xlYW5cIikge1xuICAgICAgcmV0dXJuIFtcInNwYW5cIiwga2V5d29yZFN0eWxlLCB2XTtcbiAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KHYpKSB7XG4gICAgICByZXR1cm4gW1wib2JqZWN0XCIsIHsgb2JqZWN0OiBhc1JhdyA/IHRvUmF3KHYpIDogdiB9XTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFtcInNwYW5cIiwgc3RyaW5nU3R5bGUsIFN0cmluZyh2KV07XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGV4dHJhY3RLZXlzKGluc3RhbmNlLCB0eXBlKSB7XG4gICAgY29uc3QgQ29tcCA9IGluc3RhbmNlLnR5cGU7XG4gICAgaWYgKGlzRnVuY3Rpb24oQ29tcCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZXh0cmFjdGVkID0ge307XG4gICAgZm9yIChjb25zdCBrZXkgaW4gaW5zdGFuY2UuY3R4KSB7XG4gICAgICBpZiAoaXNLZXlPZlR5cGUoQ29tcCwga2V5LCB0eXBlKSkge1xuICAgICAgICBleHRyYWN0ZWRba2V5XSA9IGluc3RhbmNlLmN0eFtrZXldO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZXh0cmFjdGVkO1xuICB9XG4gIGZ1bmN0aW9uIGlzS2V5T2ZUeXBlKENvbXAsIGtleSwgdHlwZSkge1xuICAgIGNvbnN0IG9wdHMgPSBDb21wW3R5cGVdO1xuICAgIGlmIChpc0FycmF5KG9wdHMpICYmIG9wdHMuaW5jbHVkZXMoa2V5KSB8fCBpc09iamVjdChvcHRzKSAmJiBrZXkgaW4gb3B0cykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChDb21wLmV4dGVuZHMgJiYgaXNLZXlPZlR5cGUoQ29tcC5leHRlbmRzLCBrZXksIHR5cGUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKENvbXAubWl4aW5zICYmIENvbXAubWl4aW5zLnNvbWUoKG0pID0+IGlzS2V5T2ZUeXBlKG0sIGtleSwgdHlwZSkpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZ2VuUmVmRmxhZyh2KSB7XG4gICAgaWYgKGlzU2hhbGxvdyh2KSkge1xuICAgICAgcmV0dXJuIGBTaGFsbG93UmVmYDtcbiAgICB9XG4gICAgaWYgKHYuZWZmZWN0KSB7XG4gICAgICByZXR1cm4gYENvbXB1dGVkUmVmYDtcbiAgICB9XG4gICAgcmV0dXJuIGBSZWZgO1xuICB9XG4gIGlmICh3aW5kb3cuZGV2dG9vbHNGb3JtYXR0ZXJzKSB7XG4gICAgd2luZG93LmRldnRvb2xzRm9ybWF0dGVycy5wdXNoKGZvcm1hdHRlcik7XG4gIH0gZWxzZSB7XG4gICAgd2luZG93LmRldnRvb2xzRm9ybWF0dGVycyA9IFtmb3JtYXR0ZXJdO1xuICB9XG59XG5cbmZ1bmN0aW9uIHdpdGhNZW1vKG1lbW8sIHJlbmRlciwgY2FjaGUsIGluZGV4KSB7XG4gIGNvbnN0IGNhY2hlZCA9IGNhY2hlW2luZGV4XTtcbiAgaWYgKGNhY2hlZCAmJiBpc01lbW9TYW1lKGNhY2hlZCwgbWVtbykpIHtcbiAgICByZXR1cm4gY2FjaGVkO1xuICB9XG4gIGNvbnN0IHJldCA9IHJlbmRlcigpO1xuICByZXQubWVtbyA9IG1lbW8uc2xpY2UoKTtcbiAgcmV0dXJuIGNhY2hlW2luZGV4XSA9IHJldDtcbn1cbmZ1bmN0aW9uIGlzTWVtb1NhbWUoY2FjaGVkLCBtZW1vKSB7XG4gIGNvbnN0IHByZXYgPSBjYWNoZWQubWVtbztcbiAgaWYgKHByZXYubGVuZ3RoICE9IG1lbW8ubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcHJldi5sZW5ndGg7IGkrKykge1xuICAgIGlmIChoYXNDaGFuZ2VkKHByZXZbaV0sIG1lbW9baV0pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIGlmIChpc0Jsb2NrVHJlZUVuYWJsZWQgPiAwICYmIGN1cnJlbnRCbG9jaykge1xuICAgIGN1cnJlbnRCbG9jay5wdXNoKGNhY2hlZCk7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbmNvbnN0IHZlcnNpb24gPSBcIjMuMy40XCI7XG5jb25zdCBfc3NyVXRpbHMgPSB7XG4gIGNyZWF0ZUNvbXBvbmVudEluc3RhbmNlLFxuICBzZXR1cENvbXBvbmVudCxcbiAgcmVuZGVyQ29tcG9uZW50Um9vdCxcbiAgc2V0Q3VycmVudFJlbmRlcmluZ0luc3RhbmNlLFxuICBpc1ZOb2RlOiBpc1ZOb2RlLFxuICBub3JtYWxpemVWTm9kZVxufTtcbmNvbnN0IHNzclV0aWxzID0gX3NzclV0aWxzIDtcbmNvbnN0IHJlc29sdmVGaWx0ZXIgPSBudWxsO1xuY29uc3QgY29tcGF0VXRpbHMgPSBudWxsO1xuXG5leHBvcnQgeyBCYXNlVHJhbnNpdGlvbiwgQmFzZVRyYW5zaXRpb25Qcm9wc1ZhbGlkYXRvcnMsIENvbW1lbnQsIEZyYWdtZW50LCBLZWVwQWxpdmUsIFN0YXRpYywgU3VzcGVuc2UsIFRlbGVwb3J0LCBUZXh0LCBhc3NlcnROdW1iZXIsIGNhbGxXaXRoQXN5bmNFcnJvckhhbmRsaW5nLCBjYWxsV2l0aEVycm9ySGFuZGxpbmcsIGNsb25lVk5vZGUsIGNvbXBhdFV0aWxzLCBjb21wdXRlZCwgY3JlYXRlQmxvY2ssIGNyZWF0ZUNvbW1lbnRWTm9kZSwgY3JlYXRlRWxlbWVudEJsb2NrLCBjcmVhdGVCYXNlVk5vZGUgYXMgY3JlYXRlRWxlbWVudFZOb2RlLCBjcmVhdGVIeWRyYXRpb25SZW5kZXJlciwgY3JlYXRlUHJvcHNSZXN0UHJveHksIGNyZWF0ZVJlbmRlcmVyLCBjcmVhdGVTbG90cywgY3JlYXRlU3RhdGljVk5vZGUsIGNyZWF0ZVRleHRWTm9kZSwgY3JlYXRlVk5vZGUsIGRlZmluZUFzeW5jQ29tcG9uZW50LCBkZWZpbmVDb21wb25lbnQsIGRlZmluZUVtaXRzLCBkZWZpbmVFeHBvc2UsIGRlZmluZU1vZGVsLCBkZWZpbmVPcHRpb25zLCBkZWZpbmVQcm9wcywgZGVmaW5lU2xvdHMsIGRldnRvb2xzLCBnZXRDdXJyZW50SW5zdGFuY2UsIGdldFRyYW5zaXRpb25SYXdDaGlsZHJlbiwgZ3VhcmRSZWFjdGl2ZVByb3BzLCBoLCBoYW5kbGVFcnJvciwgaGFzSW5qZWN0aW9uQ29udGV4dCwgaW5pdEN1c3RvbUZvcm1hdHRlciwgaW5qZWN0LCBpc01lbW9TYW1lLCBpc1J1bnRpbWVPbmx5LCBpc1ZOb2RlLCBtZXJnZURlZmF1bHRzLCBtZXJnZU1vZGVscywgbWVyZ2VQcm9wcywgbmV4dFRpY2ssIG9uQWN0aXZhdGVkLCBvbkJlZm9yZU1vdW50LCBvbkJlZm9yZVVubW91bnQsIG9uQmVmb3JlVXBkYXRlLCBvbkRlYWN0aXZhdGVkLCBvbkVycm9yQ2FwdHVyZWQsIG9uTW91bnRlZCwgb25SZW5kZXJUcmFja2VkLCBvblJlbmRlclRyaWdnZXJlZCwgb25TZXJ2ZXJQcmVmZXRjaCwgb25Vbm1vdW50ZWQsIG9uVXBkYXRlZCwgb3BlbkJsb2NrLCBwb3BTY29wZUlkLCBwcm92aWRlLCBwdXNoU2NvcGVJZCwgcXVldWVQb3N0Rmx1c2hDYiwgcmVnaXN0ZXJSdW50aW1lQ29tcGlsZXIsIHJlbmRlckxpc3QsIHJlbmRlclNsb3QsIHJlc29sdmVDb21wb25lbnQsIHJlc29sdmVEaXJlY3RpdmUsIHJlc29sdmVEeW5hbWljQ29tcG9uZW50LCByZXNvbHZlRmlsdGVyLCByZXNvbHZlVHJhbnNpdGlvbkhvb2tzLCBzZXRCbG9ja1RyYWNraW5nLCBzZXREZXZ0b29sc0hvb2ssIHNldFRyYW5zaXRpb25Ib29rcywgc3NyQ29udGV4dEtleSwgc3NyVXRpbHMsIHRvSGFuZGxlcnMsIHRyYW5zZm9ybVZOb2RlQXJncywgdXNlQXR0cnMsIHVzZU1vZGVsLCB1c2VTU1JDb250ZXh0LCB1c2VTbG90cywgdXNlVHJhbnNpdGlvblN0YXRlLCB2ZXJzaW9uLCB3YXJuLCB3YXRjaCwgd2F0Y2hFZmZlY3QsIHdhdGNoUG9zdEVmZmVjdCwgd2F0Y2hTeW5jRWZmZWN0LCB3aXRoQXN5bmNDb250ZXh0LCB3aXRoQ3R4LCB3aXRoRGVmYXVsdHMsIHdpdGhEaXJlY3RpdmVzLCB3aXRoTWVtbywgd2l0aFNjb3BlSWQgfTtcbiIsImltcG9ydCB7IGV4dGVuZCwgaXNBcnJheSwgaXNNYXAsIGlzSW50ZWdlcktleSwgaGFzT3duLCBpc1N5bWJvbCwgaXNPYmplY3QsIGhhc0NoYW5nZWQsIG1ha2VNYXAsIGNhcGl0YWxpemUsIHRvUmF3VHlwZSwgZGVmLCBpc0Z1bmN0aW9uLCBOT09QIH0gZnJvbSAnQHZ1ZS9zaGFyZWQnO1xuXG5mdW5jdGlvbiB3YXJuKG1zZywgLi4uYXJncykge1xuICBjb25zb2xlLndhcm4oYFtWdWUgd2Fybl0gJHttc2d9YCwgLi4uYXJncyk7XG59XG5cbmxldCBhY3RpdmVFZmZlY3RTY29wZTtcbmNsYXNzIEVmZmVjdFNjb3BlIHtcbiAgY29uc3RydWN0b3IoZGV0YWNoZWQgPSBmYWxzZSkge1xuICAgIHRoaXMuZGV0YWNoZWQgPSBkZXRhY2hlZDtcbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICB0aGlzLl9hY3RpdmUgPSB0cnVlO1xuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHRoaXMuZWZmZWN0cyA9IFtdO1xuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHRoaXMuY2xlYW51cHMgPSBbXTtcbiAgICB0aGlzLnBhcmVudCA9IGFjdGl2ZUVmZmVjdFNjb3BlO1xuICAgIGlmICghZGV0YWNoZWQgJiYgYWN0aXZlRWZmZWN0U2NvcGUpIHtcbiAgICAgIHRoaXMuaW5kZXggPSAoYWN0aXZlRWZmZWN0U2NvcGUuc2NvcGVzIHx8IChhY3RpdmVFZmZlY3RTY29wZS5zY29wZXMgPSBbXSkpLnB1c2goXG4gICAgICAgIHRoaXNcbiAgICAgICkgLSAxO1xuICAgIH1cbiAgfVxuICBnZXQgYWN0aXZlKCkge1xuICAgIHJldHVybiB0aGlzLl9hY3RpdmU7XG4gIH1cbiAgcnVuKGZuKSB7XG4gICAgaWYgKHRoaXMuX2FjdGl2ZSkge1xuICAgICAgY29uc3QgY3VycmVudEVmZmVjdFNjb3BlID0gYWN0aXZlRWZmZWN0U2NvcGU7XG4gICAgICB0cnkge1xuICAgICAgICBhY3RpdmVFZmZlY3RTY29wZSA9IHRoaXM7XG4gICAgICAgIHJldHVybiBmbigpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgYWN0aXZlRWZmZWN0U2NvcGUgPSBjdXJyZW50RWZmZWN0U2NvcGU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICB3YXJuKGBjYW5ub3QgcnVuIGFuIGluYWN0aXZlIGVmZmVjdCBzY29wZS5gKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFRoaXMgc2hvdWxkIG9ubHkgYmUgY2FsbGVkIG9uIG5vbi1kZXRhY2hlZCBzY29wZXNcbiAgICogQGludGVybmFsXG4gICAqL1xuICBvbigpIHtcbiAgICBhY3RpdmVFZmZlY3RTY29wZSA9IHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIFRoaXMgc2hvdWxkIG9ubHkgYmUgY2FsbGVkIG9uIG5vbi1kZXRhY2hlZCBzY29wZXNcbiAgICogQGludGVybmFsXG4gICAqL1xuICBvZmYoKSB7XG4gICAgYWN0aXZlRWZmZWN0U2NvcGUgPSB0aGlzLnBhcmVudDtcbiAgfVxuICBzdG9wKGZyb21QYXJlbnQpIHtcbiAgICBpZiAodGhpcy5fYWN0aXZlKSB7XG4gICAgICBsZXQgaSwgbDtcbiAgICAgIGZvciAoaSA9IDAsIGwgPSB0aGlzLmVmZmVjdHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHRoaXMuZWZmZWN0c1tpXS5zdG9wKCk7XG4gICAgICB9XG4gICAgICBmb3IgKGkgPSAwLCBsID0gdGhpcy5jbGVhbnVwcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdGhpcy5jbGVhbnVwc1tpXSgpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuc2NvcGVzKSB7XG4gICAgICAgIGZvciAoaSA9IDAsIGwgPSB0aGlzLnNjb3Blcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICB0aGlzLnNjb3Blc1tpXS5zdG9wKHRydWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuZGV0YWNoZWQgJiYgdGhpcy5wYXJlbnQgJiYgIWZyb21QYXJlbnQpIHtcbiAgICAgICAgY29uc3QgbGFzdCA9IHRoaXMucGFyZW50LnNjb3Blcy5wb3AoKTtcbiAgICAgICAgaWYgKGxhc3QgJiYgbGFzdCAhPT0gdGhpcykge1xuICAgICAgICAgIHRoaXMucGFyZW50LnNjb3Blc1t0aGlzLmluZGV4XSA9IGxhc3Q7XG4gICAgICAgICAgbGFzdC5pbmRleCA9IHRoaXMuaW5kZXg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMucGFyZW50ID0gdm9pZCAwO1xuICAgICAgdGhpcy5fYWN0aXZlID0gZmFsc2U7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBlZmZlY3RTY29wZShkZXRhY2hlZCkge1xuICByZXR1cm4gbmV3IEVmZmVjdFNjb3BlKGRldGFjaGVkKTtcbn1cbmZ1bmN0aW9uIHJlY29yZEVmZmVjdFNjb3BlKGVmZmVjdCwgc2NvcGUgPSBhY3RpdmVFZmZlY3RTY29wZSkge1xuICBpZiAoc2NvcGUgJiYgc2NvcGUuYWN0aXZlKSB7XG4gICAgc2NvcGUuZWZmZWN0cy5wdXNoKGVmZmVjdCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldEN1cnJlbnRTY29wZSgpIHtcbiAgcmV0dXJuIGFjdGl2ZUVmZmVjdFNjb3BlO1xufVxuZnVuY3Rpb24gb25TY29wZURpc3Bvc2UoZm4pIHtcbiAgaWYgKGFjdGl2ZUVmZmVjdFNjb3BlKSB7XG4gICAgYWN0aXZlRWZmZWN0U2NvcGUuY2xlYW51cHMucHVzaChmbik7XG4gIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIHdhcm4oXG4gICAgICBgb25TY29wZURpc3Bvc2UoKSBpcyBjYWxsZWQgd2hlbiB0aGVyZSBpcyBubyBhY3RpdmUgZWZmZWN0IHNjb3BlIHRvIGJlIGFzc29jaWF0ZWQgd2l0aC5gXG4gICAgKTtcbiAgfVxufVxuXG5jb25zdCBjcmVhdGVEZXAgPSAoZWZmZWN0cykgPT4ge1xuICBjb25zdCBkZXAgPSBuZXcgU2V0KGVmZmVjdHMpO1xuICBkZXAudyA9IDA7XG4gIGRlcC5uID0gMDtcbiAgcmV0dXJuIGRlcDtcbn07XG5jb25zdCB3YXNUcmFja2VkID0gKGRlcCkgPT4gKGRlcC53ICYgdHJhY2tPcEJpdCkgPiAwO1xuY29uc3QgbmV3VHJhY2tlZCA9IChkZXApID0+IChkZXAubiAmIHRyYWNrT3BCaXQpID4gMDtcbmNvbnN0IGluaXREZXBNYXJrZXJzID0gKHsgZGVwcyB9KSA9PiB7XG4gIGlmIChkZXBzLmxlbmd0aCkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGVwcy5sZW5ndGg7IGkrKykge1xuICAgICAgZGVwc1tpXS53IHw9IHRyYWNrT3BCaXQ7XG4gICAgfVxuICB9XG59O1xuY29uc3QgZmluYWxpemVEZXBNYXJrZXJzID0gKGVmZmVjdCkgPT4ge1xuICBjb25zdCB7IGRlcHMgfSA9IGVmZmVjdDtcbiAgaWYgKGRlcHMubGVuZ3RoKSB7XG4gICAgbGV0IHB0ciA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkZXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBkZXAgPSBkZXBzW2ldO1xuICAgICAgaWYgKHdhc1RyYWNrZWQoZGVwKSAmJiAhbmV3VHJhY2tlZChkZXApKSB7XG4gICAgICAgIGRlcC5kZWxldGUoZWZmZWN0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlcHNbcHRyKytdID0gZGVwO1xuICAgICAgfVxuICAgICAgZGVwLncgJj0gfnRyYWNrT3BCaXQ7XG4gICAgICBkZXAubiAmPSB+dHJhY2tPcEJpdDtcbiAgICB9XG4gICAgZGVwcy5sZW5ndGggPSBwdHI7XG4gIH1cbn07XG5cbmNvbnN0IHRhcmdldE1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xubGV0IGVmZmVjdFRyYWNrRGVwdGggPSAwO1xubGV0IHRyYWNrT3BCaXQgPSAxO1xuY29uc3QgbWF4TWFya2VyQml0cyA9IDMwO1xubGV0IGFjdGl2ZUVmZmVjdDtcbmNvbnN0IElURVJBVEVfS0VZID0gU3ltYm9sKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyBcIml0ZXJhdGVcIiA6IFwiXCIpO1xuY29uc3QgTUFQX0tFWV9JVEVSQVRFX0tFWSA9IFN5bWJvbCghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gXCJNYXAga2V5IGl0ZXJhdGVcIiA6IFwiXCIpO1xuY2xhc3MgUmVhY3RpdmVFZmZlY3Qge1xuICBjb25zdHJ1Y3Rvcihmbiwgc2NoZWR1bGVyID0gbnVsbCwgc2NvcGUpIHtcbiAgICB0aGlzLmZuID0gZm47XG4gICAgdGhpcy5zY2hlZHVsZXIgPSBzY2hlZHVsZXI7XG4gICAgdGhpcy5hY3RpdmUgPSB0cnVlO1xuICAgIHRoaXMuZGVwcyA9IFtdO1xuICAgIHRoaXMucGFyZW50ID0gdm9pZCAwO1xuICAgIHJlY29yZEVmZmVjdFNjb3BlKHRoaXMsIHNjb3BlKTtcbiAgfVxuICBydW4oKSB7XG4gICAgaWYgKCF0aGlzLmFjdGl2ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuZm4oKTtcbiAgICB9XG4gICAgbGV0IHBhcmVudCA9IGFjdGl2ZUVmZmVjdDtcbiAgICBsZXQgbGFzdFNob3VsZFRyYWNrID0gc2hvdWxkVHJhY2s7XG4gICAgd2hpbGUgKHBhcmVudCkge1xuICAgICAgaWYgKHBhcmVudCA9PT0gdGhpcykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgdGhpcy5wYXJlbnQgPSBhY3RpdmVFZmZlY3Q7XG4gICAgICBhY3RpdmVFZmZlY3QgPSB0aGlzO1xuICAgICAgc2hvdWxkVHJhY2sgPSB0cnVlO1xuICAgICAgdHJhY2tPcEJpdCA9IDEgPDwgKytlZmZlY3RUcmFja0RlcHRoO1xuICAgICAgaWYgKGVmZmVjdFRyYWNrRGVwdGggPD0gbWF4TWFya2VyQml0cykge1xuICAgICAgICBpbml0RGVwTWFya2Vycyh0aGlzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNsZWFudXBFZmZlY3QodGhpcyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5mbigpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAoZWZmZWN0VHJhY2tEZXB0aCA8PSBtYXhNYXJrZXJCaXRzKSB7XG4gICAgICAgIGZpbmFsaXplRGVwTWFya2Vycyh0aGlzKTtcbiAgICAgIH1cbiAgICAgIHRyYWNrT3BCaXQgPSAxIDw8IC0tZWZmZWN0VHJhY2tEZXB0aDtcbiAgICAgIGFjdGl2ZUVmZmVjdCA9IHRoaXMucGFyZW50O1xuICAgICAgc2hvdWxkVHJhY2sgPSBsYXN0U2hvdWxkVHJhY2s7XG4gICAgICB0aGlzLnBhcmVudCA9IHZvaWQgMDtcbiAgICAgIGlmICh0aGlzLmRlZmVyU3RvcCkge1xuICAgICAgICB0aGlzLnN0b3AoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgc3RvcCgpIHtcbiAgICBpZiAoYWN0aXZlRWZmZWN0ID09PSB0aGlzKSB7XG4gICAgICB0aGlzLmRlZmVyU3RvcCA9IHRydWU7XG4gICAgfSBlbHNlIGlmICh0aGlzLmFjdGl2ZSkge1xuICAgICAgY2xlYW51cEVmZmVjdCh0aGlzKTtcbiAgICAgIGlmICh0aGlzLm9uU3RvcCkge1xuICAgICAgICB0aGlzLm9uU3RvcCgpO1xuICAgICAgfVxuICAgICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGNsZWFudXBFZmZlY3QoZWZmZWN0Mikge1xuICBjb25zdCB7IGRlcHMgfSA9IGVmZmVjdDI7XG4gIGlmIChkZXBzLmxlbmd0aCkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGVwcy5sZW5ndGg7IGkrKykge1xuICAgICAgZGVwc1tpXS5kZWxldGUoZWZmZWN0Mik7XG4gICAgfVxuICAgIGRlcHMubGVuZ3RoID0gMDtcbiAgfVxufVxuZnVuY3Rpb24gZWZmZWN0KGZuLCBvcHRpb25zKSB7XG4gIGlmIChmbi5lZmZlY3QpIHtcbiAgICBmbiA9IGZuLmVmZmVjdC5mbjtcbiAgfVxuICBjb25zdCBfZWZmZWN0ID0gbmV3IFJlYWN0aXZlRWZmZWN0KGZuKTtcbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBleHRlbmQoX2VmZmVjdCwgb3B0aW9ucyk7XG4gICAgaWYgKG9wdGlvbnMuc2NvcGUpXG4gICAgICByZWNvcmRFZmZlY3RTY29wZShfZWZmZWN0LCBvcHRpb25zLnNjb3BlKTtcbiAgfVxuICBpZiAoIW9wdGlvbnMgfHwgIW9wdGlvbnMubGF6eSkge1xuICAgIF9lZmZlY3QucnVuKCk7XG4gIH1cbiAgY29uc3QgcnVubmVyID0gX2VmZmVjdC5ydW4uYmluZChfZWZmZWN0KTtcbiAgcnVubmVyLmVmZmVjdCA9IF9lZmZlY3Q7XG4gIHJldHVybiBydW5uZXI7XG59XG5mdW5jdGlvbiBzdG9wKHJ1bm5lcikge1xuICBydW5uZXIuZWZmZWN0LnN0b3AoKTtcbn1cbmxldCBzaG91bGRUcmFjayA9IHRydWU7XG5jb25zdCB0cmFja1N0YWNrID0gW107XG5mdW5jdGlvbiBwYXVzZVRyYWNraW5nKCkge1xuICB0cmFja1N0YWNrLnB1c2goc2hvdWxkVHJhY2spO1xuICBzaG91bGRUcmFjayA9IGZhbHNlO1xufVxuZnVuY3Rpb24gZW5hYmxlVHJhY2tpbmcoKSB7XG4gIHRyYWNrU3RhY2sucHVzaChzaG91bGRUcmFjayk7XG4gIHNob3VsZFRyYWNrID0gdHJ1ZTtcbn1cbmZ1bmN0aW9uIHJlc2V0VHJhY2tpbmcoKSB7XG4gIGNvbnN0IGxhc3QgPSB0cmFja1N0YWNrLnBvcCgpO1xuICBzaG91bGRUcmFjayA9IGxhc3QgPT09IHZvaWQgMCA/IHRydWUgOiBsYXN0O1xufVxuZnVuY3Rpb24gdHJhY2sodGFyZ2V0LCB0eXBlLCBrZXkpIHtcbiAgaWYgKHNob3VsZFRyYWNrICYmIGFjdGl2ZUVmZmVjdCkge1xuICAgIGxldCBkZXBzTWFwID0gdGFyZ2V0TWFwLmdldCh0YXJnZXQpO1xuICAgIGlmICghZGVwc01hcCkge1xuICAgICAgdGFyZ2V0TWFwLnNldCh0YXJnZXQsIGRlcHNNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpKTtcbiAgICB9XG4gICAgbGV0IGRlcCA9IGRlcHNNYXAuZ2V0KGtleSk7XG4gICAgaWYgKCFkZXApIHtcbiAgICAgIGRlcHNNYXAuc2V0KGtleSwgZGVwID0gY3JlYXRlRGVwKCkpO1xuICAgIH1cbiAgICBjb25zdCBldmVudEluZm8gPSAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8geyBlZmZlY3Q6IGFjdGl2ZUVmZmVjdCwgdGFyZ2V0LCB0eXBlLCBrZXkgfSA6IHZvaWQgMDtcbiAgICB0cmFja0VmZmVjdHMoZGVwLCBldmVudEluZm8pO1xuICB9XG59XG5mdW5jdGlvbiB0cmFja0VmZmVjdHMoZGVwLCBkZWJ1Z2dlckV2ZW50RXh0cmFJbmZvKSB7XG4gIGxldCBzaG91bGRUcmFjazIgPSBmYWxzZTtcbiAgaWYgKGVmZmVjdFRyYWNrRGVwdGggPD0gbWF4TWFya2VyQml0cykge1xuICAgIGlmICghbmV3VHJhY2tlZChkZXApKSB7XG4gICAgICBkZXAubiB8PSB0cmFja09wQml0O1xuICAgICAgc2hvdWxkVHJhY2syID0gIXdhc1RyYWNrZWQoZGVwKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgc2hvdWxkVHJhY2syID0gIWRlcC5oYXMoYWN0aXZlRWZmZWN0KTtcbiAgfVxuICBpZiAoc2hvdWxkVHJhY2syKSB7XG4gICAgZGVwLmFkZChhY3RpdmVFZmZlY3QpO1xuICAgIGFjdGl2ZUVmZmVjdC5kZXBzLnB1c2goZGVwKTtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBhY3RpdmVFZmZlY3Qub25UcmFjaykge1xuICAgICAgYWN0aXZlRWZmZWN0Lm9uVHJhY2soXG4gICAgICAgIGV4dGVuZChcbiAgICAgICAgICB7XG4gICAgICAgICAgICBlZmZlY3Q6IGFjdGl2ZUVmZmVjdFxuICAgICAgICAgIH0sXG4gICAgICAgICAgZGVidWdnZXJFdmVudEV4dHJhSW5mb1xuICAgICAgICApXG4gICAgICApO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gdHJpZ2dlcih0YXJnZXQsIHR5cGUsIGtleSwgbmV3VmFsdWUsIG9sZFZhbHVlLCBvbGRUYXJnZXQpIHtcbiAgY29uc3QgZGVwc01hcCA9IHRhcmdldE1hcC5nZXQodGFyZ2V0KTtcbiAgaWYgKCFkZXBzTWFwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGxldCBkZXBzID0gW107XG4gIGlmICh0eXBlID09PSBcImNsZWFyXCIpIHtcbiAgICBkZXBzID0gWy4uLmRlcHNNYXAudmFsdWVzKCldO1xuICB9IGVsc2UgaWYgKGtleSA9PT0gXCJsZW5ndGhcIiAmJiBpc0FycmF5KHRhcmdldCkpIHtcbiAgICBjb25zdCBuZXdMZW5ndGggPSBOdW1iZXIobmV3VmFsdWUpO1xuICAgIGRlcHNNYXAuZm9yRWFjaCgoZGVwLCBrZXkyKSA9PiB7XG4gICAgICBpZiAoa2V5MiA9PT0gXCJsZW5ndGhcIiB8fCBrZXkyID49IG5ld0xlbmd0aCkge1xuICAgICAgICBkZXBzLnB1c2goZGVwKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoa2V5ICE9PSB2b2lkIDApIHtcbiAgICAgIGRlcHMucHVzaChkZXBzTWFwLmdldChrZXkpKTtcbiAgICB9XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlIFwiYWRkXCI6XG4gICAgICAgIGlmICghaXNBcnJheSh0YXJnZXQpKSB7XG4gICAgICAgICAgZGVwcy5wdXNoKGRlcHNNYXAuZ2V0KElURVJBVEVfS0VZKSk7XG4gICAgICAgICAgaWYgKGlzTWFwKHRhcmdldCkpIHtcbiAgICAgICAgICAgIGRlcHMucHVzaChkZXBzTWFwLmdldChNQVBfS0VZX0lURVJBVEVfS0VZKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGlzSW50ZWdlcktleShrZXkpKSB7XG4gICAgICAgICAgZGVwcy5wdXNoKGRlcHNNYXAuZ2V0KFwibGVuZ3RoXCIpKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJkZWxldGVcIjpcbiAgICAgICAgaWYgKCFpc0FycmF5KHRhcmdldCkpIHtcbiAgICAgICAgICBkZXBzLnB1c2goZGVwc01hcC5nZXQoSVRFUkFURV9LRVkpKTtcbiAgICAgICAgICBpZiAoaXNNYXAodGFyZ2V0KSkge1xuICAgICAgICAgICAgZGVwcy5wdXNoKGRlcHNNYXAuZ2V0KE1BUF9LRVlfSVRFUkFURV9LRVkpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwic2V0XCI6XG4gICAgICAgIGlmIChpc01hcCh0YXJnZXQpKSB7XG4gICAgICAgICAgZGVwcy5wdXNoKGRlcHNNYXAuZ2V0KElURVJBVEVfS0VZKSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIGNvbnN0IGV2ZW50SW5mbyA9ICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyB7IHRhcmdldCwgdHlwZSwga2V5LCBuZXdWYWx1ZSwgb2xkVmFsdWUsIG9sZFRhcmdldCB9IDogdm9pZCAwO1xuICBpZiAoZGVwcy5sZW5ndGggPT09IDEpIHtcbiAgICBpZiAoZGVwc1swXSkge1xuICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgdHJpZ2dlckVmZmVjdHMoZGVwc1swXSwgZXZlbnRJbmZvKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyaWdnZXJFZmZlY3RzKGRlcHNbMF0pO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBjb25zdCBlZmZlY3RzID0gW107XG4gICAgZm9yIChjb25zdCBkZXAgb2YgZGVwcykge1xuICAgICAgaWYgKGRlcCkge1xuICAgICAgICBlZmZlY3RzLnB1c2goLi4uZGVwKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgIHRyaWdnZXJFZmZlY3RzKGNyZWF0ZURlcChlZmZlY3RzKSwgZXZlbnRJbmZvKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdHJpZ2dlckVmZmVjdHMoY3JlYXRlRGVwKGVmZmVjdHMpKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHRyaWdnZXJFZmZlY3RzKGRlcCwgZGVidWdnZXJFdmVudEV4dHJhSW5mbykge1xuICBjb25zdCBlZmZlY3RzID0gaXNBcnJheShkZXApID8gZGVwIDogWy4uLmRlcF07XG4gIGZvciAoY29uc3QgZWZmZWN0MiBvZiBlZmZlY3RzKSB7XG4gICAgaWYgKGVmZmVjdDIuY29tcHV0ZWQpIHtcbiAgICAgIHRyaWdnZXJFZmZlY3QoZWZmZWN0MiwgZGVidWdnZXJFdmVudEV4dHJhSW5mbyk7XG4gICAgfVxuICB9XG4gIGZvciAoY29uc3QgZWZmZWN0MiBvZiBlZmZlY3RzKSB7XG4gICAgaWYgKCFlZmZlY3QyLmNvbXB1dGVkKSB7XG4gICAgICB0cmlnZ2VyRWZmZWN0KGVmZmVjdDIsIGRlYnVnZ2VyRXZlbnRFeHRyYUluZm8pO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gdHJpZ2dlckVmZmVjdChlZmZlY3QyLCBkZWJ1Z2dlckV2ZW50RXh0cmFJbmZvKSB7XG4gIGlmIChlZmZlY3QyICE9PSBhY3RpdmVFZmZlY3QgfHwgZWZmZWN0Mi5hbGxvd1JlY3Vyc2UpIHtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBlZmZlY3QyLm9uVHJpZ2dlcikge1xuICAgICAgZWZmZWN0Mi5vblRyaWdnZXIoZXh0ZW5kKHsgZWZmZWN0OiBlZmZlY3QyIH0sIGRlYnVnZ2VyRXZlbnRFeHRyYUluZm8pKTtcbiAgICB9XG4gICAgaWYgKGVmZmVjdDIuc2NoZWR1bGVyKSB7XG4gICAgICBlZmZlY3QyLnNjaGVkdWxlcigpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlZmZlY3QyLnJ1bigpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZ2V0RGVwRnJvbVJlYWN0aXZlKG9iamVjdCwga2V5KSB7XG4gIHZhciBfYTtcbiAgcmV0dXJuIChfYSA9IHRhcmdldE1hcC5nZXQob2JqZWN0KSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmdldChrZXkpO1xufVxuXG5jb25zdCBpc05vblRyYWNrYWJsZUtleXMgPSAvKiBAX19QVVJFX18gKi8gbWFrZU1hcChgX19wcm90b19fLF9fdl9pc1JlZixfX2lzVnVlYCk7XG5jb25zdCBidWlsdEluU3ltYm9scyA9IG5ldyBTZXQoXG4gIC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhTeW1ib2wpLmZpbHRlcigoa2V5KSA9PiBrZXkgIT09IFwiYXJndW1lbnRzXCIgJiYga2V5ICE9PSBcImNhbGxlclwiKS5tYXAoKGtleSkgPT4gU3ltYm9sW2tleV0pLmZpbHRlcihpc1N5bWJvbClcbik7XG5jb25zdCBnZXQkMSA9IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVHZXR0ZXIoKTtcbmNvbnN0IHNoYWxsb3dHZXQgPSAvKiBAX19QVVJFX18gKi8gY3JlYXRlR2V0dGVyKGZhbHNlLCB0cnVlKTtcbmNvbnN0IHJlYWRvbmx5R2V0ID0gLyogQF9fUFVSRV9fICovIGNyZWF0ZUdldHRlcih0cnVlKTtcbmNvbnN0IHNoYWxsb3dSZWFkb25seUdldCA9IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVHZXR0ZXIodHJ1ZSwgdHJ1ZSk7XG5jb25zdCBhcnJheUluc3RydW1lbnRhdGlvbnMgPSAvKiBAX19QVVJFX18gKi8gY3JlYXRlQXJyYXlJbnN0cnVtZW50YXRpb25zKCk7XG5mdW5jdGlvbiBjcmVhdGVBcnJheUluc3RydW1lbnRhdGlvbnMoKSB7XG4gIGNvbnN0IGluc3RydW1lbnRhdGlvbnMgPSB7fTtcbiAgW1wiaW5jbHVkZXNcIiwgXCJpbmRleE9mXCIsIFwibGFzdEluZGV4T2ZcIl0uZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgaW5zdHJ1bWVudGF0aW9uc1trZXldID0gZnVuY3Rpb24oLi4uYXJncykge1xuICAgICAgY29uc3QgYXJyID0gdG9SYXcodGhpcyk7XG4gICAgICBmb3IgKGxldCBpID0gMCwgbCA9IHRoaXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHRyYWNrKGFyciwgXCJnZXRcIiwgaSArIFwiXCIpO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVzID0gYXJyW2tleV0oLi4uYXJncyk7XG4gICAgICBpZiAocmVzID09PSAtMSB8fCByZXMgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiBhcnJba2V5XSguLi5hcmdzLm1hcCh0b1JhdykpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgIH1cbiAgICB9O1xuICB9KTtcbiAgW1wicHVzaFwiLCBcInBvcFwiLCBcInNoaWZ0XCIsIFwidW5zaGlmdFwiLCBcInNwbGljZVwiXS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICBpbnN0cnVtZW50YXRpb25zW2tleV0gPSBmdW5jdGlvbiguLi5hcmdzKSB7XG4gICAgICBwYXVzZVRyYWNraW5nKCk7XG4gICAgICBjb25zdCByZXMgPSB0b1Jhdyh0aGlzKVtrZXldLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgcmVzZXRUcmFja2luZygpO1xuICAgICAgcmV0dXJuIHJlcztcbiAgICB9O1xuICB9KTtcbiAgcmV0dXJuIGluc3RydW1lbnRhdGlvbnM7XG59XG5mdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShrZXkpIHtcbiAgY29uc3Qgb2JqID0gdG9SYXcodGhpcyk7XG4gIHRyYWNrKG9iaiwgXCJoYXNcIiwga2V5KTtcbiAgcmV0dXJuIG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpO1xufVxuZnVuY3Rpb24gY3JlYXRlR2V0dGVyKGlzUmVhZG9ubHkyID0gZmFsc2UsIHNoYWxsb3cgPSBmYWxzZSkge1xuICByZXR1cm4gZnVuY3Rpb24gZ2V0Mih0YXJnZXQsIGtleSwgcmVjZWl2ZXIpIHtcbiAgICBpZiAoa2V5ID09PSBcIl9fdl9pc1JlYWN0aXZlXCIpIHtcbiAgICAgIHJldHVybiAhaXNSZWFkb25seTI7XG4gICAgfSBlbHNlIGlmIChrZXkgPT09IFwiX192X2lzUmVhZG9ubHlcIikge1xuICAgICAgcmV0dXJuIGlzUmVhZG9ubHkyO1xuICAgIH0gZWxzZSBpZiAoa2V5ID09PSBcIl9fdl9pc1NoYWxsb3dcIikge1xuICAgICAgcmV0dXJuIHNoYWxsb3c7XG4gICAgfSBlbHNlIGlmIChrZXkgPT09IFwiX192X3Jhd1wiICYmIHJlY2VpdmVyID09PSAoaXNSZWFkb25seTIgPyBzaGFsbG93ID8gc2hhbGxvd1JlYWRvbmx5TWFwIDogcmVhZG9ubHlNYXAgOiBzaGFsbG93ID8gc2hhbGxvd1JlYWN0aXZlTWFwIDogcmVhY3RpdmVNYXApLmdldCh0YXJnZXQpKSB7XG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cbiAgICBjb25zdCB0YXJnZXRJc0FycmF5ID0gaXNBcnJheSh0YXJnZXQpO1xuICAgIGlmICghaXNSZWFkb25seTIpIHtcbiAgICAgIGlmICh0YXJnZXRJc0FycmF5ICYmIGhhc093bihhcnJheUluc3RydW1lbnRhdGlvbnMsIGtleSkpIHtcbiAgICAgICAgcmV0dXJuIFJlZmxlY3QuZ2V0KGFycmF5SW5zdHJ1bWVudGF0aW9ucywga2V5LCByZWNlaXZlcik7XG4gICAgICB9XG4gICAgICBpZiAoa2V5ID09PSBcImhhc093blByb3BlcnR5XCIpIHtcbiAgICAgICAgcmV0dXJuIGhhc093blByb3BlcnR5O1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCByZXMgPSBSZWZsZWN0LmdldCh0YXJnZXQsIGtleSwgcmVjZWl2ZXIpO1xuICAgIGlmIChpc1N5bWJvbChrZXkpID8gYnVpbHRJblN5bWJvbHMuaGFzKGtleSkgOiBpc05vblRyYWNrYWJsZUtleXMoa2V5KSkge1xuICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgaWYgKCFpc1JlYWRvbmx5Mikge1xuICAgICAgdHJhY2sodGFyZ2V0LCBcImdldFwiLCBrZXkpO1xuICAgIH1cbiAgICBpZiAoc2hhbGxvdykge1xuICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgaWYgKGlzUmVmKHJlcykpIHtcbiAgICAgIHJldHVybiB0YXJnZXRJc0FycmF5ICYmIGlzSW50ZWdlcktleShrZXkpID8gcmVzIDogcmVzLnZhbHVlO1xuICAgIH1cbiAgICBpZiAoaXNPYmplY3QocmVzKSkge1xuICAgICAgcmV0dXJuIGlzUmVhZG9ubHkyID8gcmVhZG9ubHkocmVzKSA6IHJlYWN0aXZlKHJlcyk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG4gIH07XG59XG5jb25zdCBzZXQkMSA9IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVTZXR0ZXIoKTtcbmNvbnN0IHNoYWxsb3dTZXQgPSAvKiBAX19QVVJFX18gKi8gY3JlYXRlU2V0dGVyKHRydWUpO1xuZnVuY3Rpb24gY3JlYXRlU2V0dGVyKHNoYWxsb3cgPSBmYWxzZSkge1xuICByZXR1cm4gZnVuY3Rpb24gc2V0Mih0YXJnZXQsIGtleSwgdmFsdWUsIHJlY2VpdmVyKSB7XG4gICAgbGV0IG9sZFZhbHVlID0gdGFyZ2V0W2tleV07XG4gICAgaWYgKGlzUmVhZG9ubHkob2xkVmFsdWUpICYmIGlzUmVmKG9sZFZhbHVlKSAmJiAhaXNSZWYodmFsdWUpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICghc2hhbGxvdykge1xuICAgICAgaWYgKCFpc1NoYWxsb3codmFsdWUpICYmICFpc1JlYWRvbmx5KHZhbHVlKSkge1xuICAgICAgICBvbGRWYWx1ZSA9IHRvUmF3KG9sZFZhbHVlKTtcbiAgICAgICAgdmFsdWUgPSB0b1Jhdyh2YWx1ZSk7XG4gICAgICB9XG4gICAgICBpZiAoIWlzQXJyYXkodGFyZ2V0KSAmJiBpc1JlZihvbGRWYWx1ZSkgJiYgIWlzUmVmKHZhbHVlKSkge1xuICAgICAgICBvbGRWYWx1ZS52YWx1ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgaGFkS2V5ID0gaXNBcnJheSh0YXJnZXQpICYmIGlzSW50ZWdlcktleShrZXkpID8gTnVtYmVyKGtleSkgPCB0YXJnZXQubGVuZ3RoIDogaGFzT3duKHRhcmdldCwga2V5KTtcbiAgICBjb25zdCByZXN1bHQgPSBSZWZsZWN0LnNldCh0YXJnZXQsIGtleSwgdmFsdWUsIHJlY2VpdmVyKTtcbiAgICBpZiAodGFyZ2V0ID09PSB0b1JhdyhyZWNlaXZlcikpIHtcbiAgICAgIGlmICghaGFkS2V5KSB7XG4gICAgICAgIHRyaWdnZXIodGFyZ2V0LCBcImFkZFwiLCBrZXksIHZhbHVlKTtcbiAgICAgIH0gZWxzZSBpZiAoaGFzQ2hhbmdlZCh2YWx1ZSwgb2xkVmFsdWUpKSB7XG4gICAgICAgIHRyaWdnZXIodGFyZ2V0LCBcInNldFwiLCBrZXksIHZhbHVlLCBvbGRWYWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG59XG5mdW5jdGlvbiBkZWxldGVQcm9wZXJ0eSh0YXJnZXQsIGtleSkge1xuICBjb25zdCBoYWRLZXkgPSBoYXNPd24odGFyZ2V0LCBrZXkpO1xuICBjb25zdCBvbGRWYWx1ZSA9IHRhcmdldFtrZXldO1xuICBjb25zdCByZXN1bHQgPSBSZWZsZWN0LmRlbGV0ZVByb3BlcnR5KHRhcmdldCwga2V5KTtcbiAgaWYgKHJlc3VsdCAmJiBoYWRLZXkpIHtcbiAgICB0cmlnZ2VyKHRhcmdldCwgXCJkZWxldGVcIiwga2V5LCB2b2lkIDAsIG9sZFZhbHVlKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gaGFzJDEodGFyZ2V0LCBrZXkpIHtcbiAgY29uc3QgcmVzdWx0ID0gUmVmbGVjdC5oYXModGFyZ2V0LCBrZXkpO1xuICBpZiAoIWlzU3ltYm9sKGtleSkgfHwgIWJ1aWx0SW5TeW1ib2xzLmhhcyhrZXkpKSB7XG4gICAgdHJhY2sodGFyZ2V0LCBcImhhc1wiLCBrZXkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBvd25LZXlzKHRhcmdldCkge1xuICB0cmFjayh0YXJnZXQsIFwiaXRlcmF0ZVwiLCBpc0FycmF5KHRhcmdldCkgPyBcImxlbmd0aFwiIDogSVRFUkFURV9LRVkpO1xuICByZXR1cm4gUmVmbGVjdC5vd25LZXlzKHRhcmdldCk7XG59XG5jb25zdCBtdXRhYmxlSGFuZGxlcnMgPSB7XG4gIGdldDogZ2V0JDEsXG4gIHNldDogc2V0JDEsXG4gIGRlbGV0ZVByb3BlcnR5LFxuICBoYXM6IGhhcyQxLFxuICBvd25LZXlzXG59O1xuY29uc3QgcmVhZG9ubHlIYW5kbGVycyA9IHtcbiAgZ2V0OiByZWFkb25seUdldCxcbiAgc2V0KHRhcmdldCwga2V5KSB7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIGBTZXQgb3BlcmF0aW9uIG9uIGtleSBcIiR7U3RyaW5nKGtleSl9XCIgZmFpbGVkOiB0YXJnZXQgaXMgcmVhZG9ubHkuYCxcbiAgICAgICAgdGFyZ2V0XG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSxcbiAgZGVsZXRlUHJvcGVydHkodGFyZ2V0LCBrZXkpIHtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgd2FybihcbiAgICAgICAgYERlbGV0ZSBvcGVyYXRpb24gb24ga2V5IFwiJHtTdHJpbmcoa2V5KX1cIiBmYWlsZWQ6IHRhcmdldCBpcyByZWFkb25seS5gLFxuICAgICAgICB0YXJnZXRcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG59O1xuY29uc3Qgc2hhbGxvd1JlYWN0aXZlSGFuZGxlcnMgPSAvKiBAX19QVVJFX18gKi8gZXh0ZW5kKFxuICB7fSxcbiAgbXV0YWJsZUhhbmRsZXJzLFxuICB7XG4gICAgZ2V0OiBzaGFsbG93R2V0LFxuICAgIHNldDogc2hhbGxvd1NldFxuICB9XG4pO1xuY29uc3Qgc2hhbGxvd1JlYWRvbmx5SGFuZGxlcnMgPSAvKiBAX19QVVJFX18gKi8gZXh0ZW5kKFxuICB7fSxcbiAgcmVhZG9ubHlIYW5kbGVycyxcbiAge1xuICAgIGdldDogc2hhbGxvd1JlYWRvbmx5R2V0XG4gIH1cbik7XG5cbmNvbnN0IHRvU2hhbGxvdyA9ICh2YWx1ZSkgPT4gdmFsdWU7XG5jb25zdCBnZXRQcm90byA9ICh2KSA9PiBSZWZsZWN0LmdldFByb3RvdHlwZU9mKHYpO1xuZnVuY3Rpb24gZ2V0KHRhcmdldCwga2V5LCBpc1JlYWRvbmx5ID0gZmFsc2UsIGlzU2hhbGxvdyA9IGZhbHNlKSB7XG4gIHRhcmdldCA9IHRhcmdldFtcIl9fdl9yYXdcIl07XG4gIGNvbnN0IHJhd1RhcmdldCA9IHRvUmF3KHRhcmdldCk7XG4gIGNvbnN0IHJhd0tleSA9IHRvUmF3KGtleSk7XG4gIGlmICghaXNSZWFkb25seSkge1xuICAgIGlmIChrZXkgIT09IHJhd0tleSkge1xuICAgICAgdHJhY2socmF3VGFyZ2V0LCBcImdldFwiLCBrZXkpO1xuICAgIH1cbiAgICB0cmFjayhyYXdUYXJnZXQsIFwiZ2V0XCIsIHJhd0tleSk7XG4gIH1cbiAgY29uc3QgeyBoYXM6IGhhczIgfSA9IGdldFByb3RvKHJhd1RhcmdldCk7XG4gIGNvbnN0IHdyYXAgPSBpc1NoYWxsb3cgPyB0b1NoYWxsb3cgOiBpc1JlYWRvbmx5ID8gdG9SZWFkb25seSA6IHRvUmVhY3RpdmU7XG4gIGlmIChoYXMyLmNhbGwocmF3VGFyZ2V0LCBrZXkpKSB7XG4gICAgcmV0dXJuIHdyYXAodGFyZ2V0LmdldChrZXkpKTtcbiAgfSBlbHNlIGlmIChoYXMyLmNhbGwocmF3VGFyZ2V0LCByYXdLZXkpKSB7XG4gICAgcmV0dXJuIHdyYXAodGFyZ2V0LmdldChyYXdLZXkpKTtcbiAgfSBlbHNlIGlmICh0YXJnZXQgIT09IHJhd1RhcmdldCkge1xuICAgIHRhcmdldC5nZXQoa2V5KTtcbiAgfVxufVxuZnVuY3Rpb24gaGFzKGtleSwgaXNSZWFkb25seSA9IGZhbHNlKSB7XG4gIGNvbnN0IHRhcmdldCA9IHRoaXNbXCJfX3ZfcmF3XCJdO1xuICBjb25zdCByYXdUYXJnZXQgPSB0b1Jhdyh0YXJnZXQpO1xuICBjb25zdCByYXdLZXkgPSB0b1JhdyhrZXkpO1xuICBpZiAoIWlzUmVhZG9ubHkpIHtcbiAgICBpZiAoa2V5ICE9PSByYXdLZXkpIHtcbiAgICAgIHRyYWNrKHJhd1RhcmdldCwgXCJoYXNcIiwga2V5KTtcbiAgICB9XG4gICAgdHJhY2socmF3VGFyZ2V0LCBcImhhc1wiLCByYXdLZXkpO1xuICB9XG4gIHJldHVybiBrZXkgPT09IHJhd0tleSA/IHRhcmdldC5oYXMoa2V5KSA6IHRhcmdldC5oYXMoa2V5KSB8fCB0YXJnZXQuaGFzKHJhd0tleSk7XG59XG5mdW5jdGlvbiBzaXplKHRhcmdldCwgaXNSZWFkb25seSA9IGZhbHNlKSB7XG4gIHRhcmdldCA9IHRhcmdldFtcIl9fdl9yYXdcIl07XG4gICFpc1JlYWRvbmx5ICYmIHRyYWNrKHRvUmF3KHRhcmdldCksIFwiaXRlcmF0ZVwiLCBJVEVSQVRFX0tFWSk7XG4gIHJldHVybiBSZWZsZWN0LmdldCh0YXJnZXQsIFwic2l6ZVwiLCB0YXJnZXQpO1xufVxuZnVuY3Rpb24gYWRkKHZhbHVlKSB7XG4gIHZhbHVlID0gdG9SYXcodmFsdWUpO1xuICBjb25zdCB0YXJnZXQgPSB0b1Jhdyh0aGlzKTtcbiAgY29uc3QgcHJvdG8gPSBnZXRQcm90byh0YXJnZXQpO1xuICBjb25zdCBoYWRLZXkgPSBwcm90by5oYXMuY2FsbCh0YXJnZXQsIHZhbHVlKTtcbiAgaWYgKCFoYWRLZXkpIHtcbiAgICB0YXJnZXQuYWRkKHZhbHVlKTtcbiAgICB0cmlnZ2VyKHRhcmdldCwgXCJhZGRcIiwgdmFsdWUsIHZhbHVlKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn1cbmZ1bmN0aW9uIHNldChrZXksIHZhbHVlKSB7XG4gIHZhbHVlID0gdG9SYXcodmFsdWUpO1xuICBjb25zdCB0YXJnZXQgPSB0b1Jhdyh0aGlzKTtcbiAgY29uc3QgeyBoYXM6IGhhczIsIGdldDogZ2V0MiB9ID0gZ2V0UHJvdG8odGFyZ2V0KTtcbiAgbGV0IGhhZEtleSA9IGhhczIuY2FsbCh0YXJnZXQsIGtleSk7XG4gIGlmICghaGFkS2V5KSB7XG4gICAga2V5ID0gdG9SYXcoa2V5KTtcbiAgICBoYWRLZXkgPSBoYXMyLmNhbGwodGFyZ2V0LCBrZXkpO1xuICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICBjaGVja0lkZW50aXR5S2V5cyh0YXJnZXQsIGhhczIsIGtleSk7XG4gIH1cbiAgY29uc3Qgb2xkVmFsdWUgPSBnZXQyLmNhbGwodGFyZ2V0LCBrZXkpO1xuICB0YXJnZXQuc2V0KGtleSwgdmFsdWUpO1xuICBpZiAoIWhhZEtleSkge1xuICAgIHRyaWdnZXIodGFyZ2V0LCBcImFkZFwiLCBrZXksIHZhbHVlKTtcbiAgfSBlbHNlIGlmIChoYXNDaGFuZ2VkKHZhbHVlLCBvbGRWYWx1ZSkpIHtcbiAgICB0cmlnZ2VyKHRhcmdldCwgXCJzZXRcIiwga2V5LCB2YWx1ZSwgb2xkVmFsdWUpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufVxuZnVuY3Rpb24gZGVsZXRlRW50cnkoa2V5KSB7XG4gIGNvbnN0IHRhcmdldCA9IHRvUmF3KHRoaXMpO1xuICBjb25zdCB7IGhhczogaGFzMiwgZ2V0OiBnZXQyIH0gPSBnZXRQcm90byh0YXJnZXQpO1xuICBsZXQgaGFkS2V5ID0gaGFzMi5jYWxsKHRhcmdldCwga2V5KTtcbiAgaWYgKCFoYWRLZXkpIHtcbiAgICBrZXkgPSB0b1JhdyhrZXkpO1xuICAgIGhhZEtleSA9IGhhczIuY2FsbCh0YXJnZXQsIGtleSk7XG4gIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIGNoZWNrSWRlbnRpdHlLZXlzKHRhcmdldCwgaGFzMiwga2V5KTtcbiAgfVxuICBjb25zdCBvbGRWYWx1ZSA9IGdldDIgPyBnZXQyLmNhbGwodGFyZ2V0LCBrZXkpIDogdm9pZCAwO1xuICBjb25zdCByZXN1bHQgPSB0YXJnZXQuZGVsZXRlKGtleSk7XG4gIGlmIChoYWRLZXkpIHtcbiAgICB0cmlnZ2VyKHRhcmdldCwgXCJkZWxldGVcIiwga2V5LCB2b2lkIDAsIG9sZFZhbHVlKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gY2xlYXIoKSB7XG4gIGNvbnN0IHRhcmdldCA9IHRvUmF3KHRoaXMpO1xuICBjb25zdCBoYWRJdGVtcyA9IHRhcmdldC5zaXplICE9PSAwO1xuICBjb25zdCBvbGRUYXJnZXQgPSAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gaXNNYXAodGFyZ2V0KSA/IG5ldyBNYXAodGFyZ2V0KSA6IG5ldyBTZXQodGFyZ2V0KSA6IHZvaWQgMDtcbiAgY29uc3QgcmVzdWx0ID0gdGFyZ2V0LmNsZWFyKCk7XG4gIGlmIChoYWRJdGVtcykge1xuICAgIHRyaWdnZXIodGFyZ2V0LCBcImNsZWFyXCIsIHZvaWQgMCwgdm9pZCAwLCBvbGRUYXJnZXQpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBjcmVhdGVGb3JFYWNoKGlzUmVhZG9ubHksIGlzU2hhbGxvdykge1xuICByZXR1cm4gZnVuY3Rpb24gZm9yRWFjaChjYWxsYmFjaywgdGhpc0FyZykge1xuICAgIGNvbnN0IG9ic2VydmVkID0gdGhpcztcbiAgICBjb25zdCB0YXJnZXQgPSBvYnNlcnZlZFtcIl9fdl9yYXdcIl07XG4gICAgY29uc3QgcmF3VGFyZ2V0ID0gdG9SYXcodGFyZ2V0KTtcbiAgICBjb25zdCB3cmFwID0gaXNTaGFsbG93ID8gdG9TaGFsbG93IDogaXNSZWFkb25seSA/IHRvUmVhZG9ubHkgOiB0b1JlYWN0aXZlO1xuICAgICFpc1JlYWRvbmx5ICYmIHRyYWNrKHJhd1RhcmdldCwgXCJpdGVyYXRlXCIsIElURVJBVEVfS0VZKTtcbiAgICByZXR1cm4gdGFyZ2V0LmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgIHJldHVybiBjYWxsYmFjay5jYWxsKHRoaXNBcmcsIHdyYXAodmFsdWUpLCB3cmFwKGtleSksIG9ic2VydmVkKTtcbiAgICB9KTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUl0ZXJhYmxlTWV0aG9kKG1ldGhvZCwgaXNSZWFkb25seSwgaXNTaGFsbG93KSB7XG4gIHJldHVybiBmdW5jdGlvbiguLi5hcmdzKSB7XG4gICAgY29uc3QgdGFyZ2V0ID0gdGhpc1tcIl9fdl9yYXdcIl07XG4gICAgY29uc3QgcmF3VGFyZ2V0ID0gdG9SYXcodGFyZ2V0KTtcbiAgICBjb25zdCB0YXJnZXRJc01hcCA9IGlzTWFwKHJhd1RhcmdldCk7XG4gICAgY29uc3QgaXNQYWlyID0gbWV0aG9kID09PSBcImVudHJpZXNcIiB8fCBtZXRob2QgPT09IFN5bWJvbC5pdGVyYXRvciAmJiB0YXJnZXRJc01hcDtcbiAgICBjb25zdCBpc0tleU9ubHkgPSBtZXRob2QgPT09IFwia2V5c1wiICYmIHRhcmdldElzTWFwO1xuICAgIGNvbnN0IGlubmVySXRlcmF0b3IgPSB0YXJnZXRbbWV0aG9kXSguLi5hcmdzKTtcbiAgICBjb25zdCB3cmFwID0gaXNTaGFsbG93ID8gdG9TaGFsbG93IDogaXNSZWFkb25seSA/IHRvUmVhZG9ubHkgOiB0b1JlYWN0aXZlO1xuICAgICFpc1JlYWRvbmx5ICYmIHRyYWNrKFxuICAgICAgcmF3VGFyZ2V0LFxuICAgICAgXCJpdGVyYXRlXCIsXG4gICAgICBpc0tleU9ubHkgPyBNQVBfS0VZX0lURVJBVEVfS0VZIDogSVRFUkFURV9LRVlcbiAgICApO1xuICAgIHJldHVybiB7XG4gICAgICAvLyBpdGVyYXRvciBwcm90b2NvbFxuICAgICAgbmV4dCgpIHtcbiAgICAgICAgY29uc3QgeyB2YWx1ZSwgZG9uZSB9ID0gaW5uZXJJdGVyYXRvci5uZXh0KCk7XG4gICAgICAgIHJldHVybiBkb25lID8geyB2YWx1ZSwgZG9uZSB9IDoge1xuICAgICAgICAgIHZhbHVlOiBpc1BhaXIgPyBbd3JhcCh2YWx1ZVswXSksIHdyYXAodmFsdWVbMV0pXSA6IHdyYXAodmFsdWUpLFxuICAgICAgICAgIGRvbmVcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICAvLyBpdGVyYWJsZSBwcm90b2NvbFxuICAgICAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgIH07XG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVSZWFkb25seU1ldGhvZCh0eXBlKSB7XG4gIHJldHVybiBmdW5jdGlvbiguLi5hcmdzKSB7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgIGNvbnN0IGtleSA9IGFyZ3NbMF0gPyBgb24ga2V5IFwiJHthcmdzWzBdfVwiIGAgOiBgYDtcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgYCR7Y2FwaXRhbGl6ZSh0eXBlKX0gb3BlcmF0aW9uICR7a2V5fWZhaWxlZDogdGFyZ2V0IGlzIHJlYWRvbmx5LmAsXG4gICAgICAgIHRvUmF3KHRoaXMpXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gdHlwZSA9PT0gXCJkZWxldGVcIiA/IGZhbHNlIDogdGhpcztcbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUluc3RydW1lbnRhdGlvbnMoKSB7XG4gIGNvbnN0IG11dGFibGVJbnN0cnVtZW50YXRpb25zMiA9IHtcbiAgICBnZXQoa2V5KSB7XG4gICAgICByZXR1cm4gZ2V0KHRoaXMsIGtleSk7XG4gICAgfSxcbiAgICBnZXQgc2l6ZSgpIHtcbiAgICAgIHJldHVybiBzaXplKHRoaXMpO1xuICAgIH0sXG4gICAgaGFzLFxuICAgIGFkZCxcbiAgICBzZXQsXG4gICAgZGVsZXRlOiBkZWxldGVFbnRyeSxcbiAgICBjbGVhcixcbiAgICBmb3JFYWNoOiBjcmVhdGVGb3JFYWNoKGZhbHNlLCBmYWxzZSlcbiAgfTtcbiAgY29uc3Qgc2hhbGxvd0luc3RydW1lbnRhdGlvbnMyID0ge1xuICAgIGdldChrZXkpIHtcbiAgICAgIHJldHVybiBnZXQodGhpcywga2V5LCBmYWxzZSwgdHJ1ZSk7XG4gICAgfSxcbiAgICBnZXQgc2l6ZSgpIHtcbiAgICAgIHJldHVybiBzaXplKHRoaXMpO1xuICAgIH0sXG4gICAgaGFzLFxuICAgIGFkZCxcbiAgICBzZXQsXG4gICAgZGVsZXRlOiBkZWxldGVFbnRyeSxcbiAgICBjbGVhcixcbiAgICBmb3JFYWNoOiBjcmVhdGVGb3JFYWNoKGZhbHNlLCB0cnVlKVxuICB9O1xuICBjb25zdCByZWFkb25seUluc3RydW1lbnRhdGlvbnMyID0ge1xuICAgIGdldChrZXkpIHtcbiAgICAgIHJldHVybiBnZXQodGhpcywga2V5LCB0cnVlKTtcbiAgICB9LFxuICAgIGdldCBzaXplKCkge1xuICAgICAgcmV0dXJuIHNpemUodGhpcywgdHJ1ZSk7XG4gICAgfSxcbiAgICBoYXMoa2V5KSB7XG4gICAgICByZXR1cm4gaGFzLmNhbGwodGhpcywga2V5LCB0cnVlKTtcbiAgICB9LFxuICAgIGFkZDogY3JlYXRlUmVhZG9ubHlNZXRob2QoXCJhZGRcIiksXG4gICAgc2V0OiBjcmVhdGVSZWFkb25seU1ldGhvZChcInNldFwiKSxcbiAgICBkZWxldGU6IGNyZWF0ZVJlYWRvbmx5TWV0aG9kKFwiZGVsZXRlXCIpLFxuICAgIGNsZWFyOiBjcmVhdGVSZWFkb25seU1ldGhvZChcImNsZWFyXCIpLFxuICAgIGZvckVhY2g6IGNyZWF0ZUZvckVhY2godHJ1ZSwgZmFsc2UpXG4gIH07XG4gIGNvbnN0IHNoYWxsb3dSZWFkb25seUluc3RydW1lbnRhdGlvbnMyID0ge1xuICAgIGdldChrZXkpIHtcbiAgICAgIHJldHVybiBnZXQodGhpcywga2V5LCB0cnVlLCB0cnVlKTtcbiAgICB9LFxuICAgIGdldCBzaXplKCkge1xuICAgICAgcmV0dXJuIHNpemUodGhpcywgdHJ1ZSk7XG4gICAgfSxcbiAgICBoYXMoa2V5KSB7XG4gICAgICByZXR1cm4gaGFzLmNhbGwodGhpcywga2V5LCB0cnVlKTtcbiAgICB9LFxuICAgIGFkZDogY3JlYXRlUmVhZG9ubHlNZXRob2QoXCJhZGRcIiksXG4gICAgc2V0OiBjcmVhdGVSZWFkb25seU1ldGhvZChcInNldFwiKSxcbiAgICBkZWxldGU6IGNyZWF0ZVJlYWRvbmx5TWV0aG9kKFwiZGVsZXRlXCIpLFxuICAgIGNsZWFyOiBjcmVhdGVSZWFkb25seU1ldGhvZChcImNsZWFyXCIpLFxuICAgIGZvckVhY2g6IGNyZWF0ZUZvckVhY2godHJ1ZSwgdHJ1ZSlcbiAgfTtcbiAgY29uc3QgaXRlcmF0b3JNZXRob2RzID0gW1wia2V5c1wiLCBcInZhbHVlc1wiLCBcImVudHJpZXNcIiwgU3ltYm9sLml0ZXJhdG9yXTtcbiAgaXRlcmF0b3JNZXRob2RzLmZvckVhY2goKG1ldGhvZCkgPT4ge1xuICAgIG11dGFibGVJbnN0cnVtZW50YXRpb25zMlttZXRob2RdID0gY3JlYXRlSXRlcmFibGVNZXRob2QoXG4gICAgICBtZXRob2QsXG4gICAgICBmYWxzZSxcbiAgICAgIGZhbHNlXG4gICAgKTtcbiAgICByZWFkb25seUluc3RydW1lbnRhdGlvbnMyW21ldGhvZF0gPSBjcmVhdGVJdGVyYWJsZU1ldGhvZChcbiAgICAgIG1ldGhvZCxcbiAgICAgIHRydWUsXG4gICAgICBmYWxzZVxuICAgICk7XG4gICAgc2hhbGxvd0luc3RydW1lbnRhdGlvbnMyW21ldGhvZF0gPSBjcmVhdGVJdGVyYWJsZU1ldGhvZChcbiAgICAgIG1ldGhvZCxcbiAgICAgIGZhbHNlLFxuICAgICAgdHJ1ZVxuICAgICk7XG4gICAgc2hhbGxvd1JlYWRvbmx5SW5zdHJ1bWVudGF0aW9uczJbbWV0aG9kXSA9IGNyZWF0ZUl0ZXJhYmxlTWV0aG9kKFxuICAgICAgbWV0aG9kLFxuICAgICAgdHJ1ZSxcbiAgICAgIHRydWVcbiAgICApO1xuICB9KTtcbiAgcmV0dXJuIFtcbiAgICBtdXRhYmxlSW5zdHJ1bWVudGF0aW9uczIsXG4gICAgcmVhZG9ubHlJbnN0cnVtZW50YXRpb25zMixcbiAgICBzaGFsbG93SW5zdHJ1bWVudGF0aW9uczIsXG4gICAgc2hhbGxvd1JlYWRvbmx5SW5zdHJ1bWVudGF0aW9uczJcbiAgXTtcbn1cbmNvbnN0IFtcbiAgbXV0YWJsZUluc3RydW1lbnRhdGlvbnMsXG4gIHJlYWRvbmx5SW5zdHJ1bWVudGF0aW9ucyxcbiAgc2hhbGxvd0luc3RydW1lbnRhdGlvbnMsXG4gIHNoYWxsb3dSZWFkb25seUluc3RydW1lbnRhdGlvbnNcbl0gPSAvKiBAX19QVVJFX18gKi8gY3JlYXRlSW5zdHJ1bWVudGF0aW9ucygpO1xuZnVuY3Rpb24gY3JlYXRlSW5zdHJ1bWVudGF0aW9uR2V0dGVyKGlzUmVhZG9ubHksIHNoYWxsb3cpIHtcbiAgY29uc3QgaW5zdHJ1bWVudGF0aW9ucyA9IHNoYWxsb3cgPyBpc1JlYWRvbmx5ID8gc2hhbGxvd1JlYWRvbmx5SW5zdHJ1bWVudGF0aW9ucyA6IHNoYWxsb3dJbnN0cnVtZW50YXRpb25zIDogaXNSZWFkb25seSA/IHJlYWRvbmx5SW5zdHJ1bWVudGF0aW9ucyA6IG11dGFibGVJbnN0cnVtZW50YXRpb25zO1xuICByZXR1cm4gKHRhcmdldCwga2V5LCByZWNlaXZlcikgPT4ge1xuICAgIGlmIChrZXkgPT09IFwiX192X2lzUmVhY3RpdmVcIikge1xuICAgICAgcmV0dXJuICFpc1JlYWRvbmx5O1xuICAgIH0gZWxzZSBpZiAoa2V5ID09PSBcIl9fdl9pc1JlYWRvbmx5XCIpIHtcbiAgICAgIHJldHVybiBpc1JlYWRvbmx5O1xuICAgIH0gZWxzZSBpZiAoa2V5ID09PSBcIl9fdl9yYXdcIikge1xuICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG4gICAgcmV0dXJuIFJlZmxlY3QuZ2V0KFxuICAgICAgaGFzT3duKGluc3RydW1lbnRhdGlvbnMsIGtleSkgJiYga2V5IGluIHRhcmdldCA/IGluc3RydW1lbnRhdGlvbnMgOiB0YXJnZXQsXG4gICAgICBrZXksXG4gICAgICByZWNlaXZlclxuICAgICk7XG4gIH07XG59XG5jb25zdCBtdXRhYmxlQ29sbGVjdGlvbkhhbmRsZXJzID0ge1xuICBnZXQ6IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVJbnN0cnVtZW50YXRpb25HZXR0ZXIoZmFsc2UsIGZhbHNlKVxufTtcbmNvbnN0IHNoYWxsb3dDb2xsZWN0aW9uSGFuZGxlcnMgPSB7XG4gIGdldDogLyogQF9fUFVSRV9fICovIGNyZWF0ZUluc3RydW1lbnRhdGlvbkdldHRlcihmYWxzZSwgdHJ1ZSlcbn07XG5jb25zdCByZWFkb25seUNvbGxlY3Rpb25IYW5kbGVycyA9IHtcbiAgZ2V0OiAvKiBAX19QVVJFX18gKi8gY3JlYXRlSW5zdHJ1bWVudGF0aW9uR2V0dGVyKHRydWUsIGZhbHNlKVxufTtcbmNvbnN0IHNoYWxsb3dSZWFkb25seUNvbGxlY3Rpb25IYW5kbGVycyA9IHtcbiAgZ2V0OiAvKiBAX19QVVJFX18gKi8gY3JlYXRlSW5zdHJ1bWVudGF0aW9uR2V0dGVyKHRydWUsIHRydWUpXG59O1xuZnVuY3Rpb24gY2hlY2tJZGVudGl0eUtleXModGFyZ2V0LCBoYXMyLCBrZXkpIHtcbiAgY29uc3QgcmF3S2V5ID0gdG9SYXcoa2V5KTtcbiAgaWYgKHJhd0tleSAhPT0ga2V5ICYmIGhhczIuY2FsbCh0YXJnZXQsIHJhd0tleSkpIHtcbiAgICBjb25zdCB0eXBlID0gdG9SYXdUeXBlKHRhcmdldCk7XG4gICAgY29uc29sZS53YXJuKFxuICAgICAgYFJlYWN0aXZlICR7dHlwZX0gY29udGFpbnMgYm90aCB0aGUgcmF3IGFuZCByZWFjdGl2ZSB2ZXJzaW9ucyBvZiB0aGUgc2FtZSBvYmplY3Qke3R5cGUgPT09IGBNYXBgID8gYCBhcyBrZXlzYCA6IGBgfSwgd2hpY2ggY2FuIGxlYWQgdG8gaW5jb25zaXN0ZW5jaWVzLiBBdm9pZCBkaWZmZXJlbnRpYXRpbmcgYmV0d2VlbiB0aGUgcmF3IGFuZCByZWFjdGl2ZSB2ZXJzaW9ucyBvZiBhbiBvYmplY3QgYW5kIG9ubHkgdXNlIHRoZSByZWFjdGl2ZSB2ZXJzaW9uIGlmIHBvc3NpYmxlLmBcbiAgICApO1xuICB9XG59XG5cbmNvbnN0IHJlYWN0aXZlTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG5jb25zdCBzaGFsbG93UmVhY3RpdmVNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbmNvbnN0IHJlYWRvbmx5TWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG5jb25zdCBzaGFsbG93UmVhZG9ubHlNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbmZ1bmN0aW9uIHRhcmdldFR5cGVNYXAocmF3VHlwZSkge1xuICBzd2l0Y2ggKHJhd1R5cGUpIHtcbiAgICBjYXNlIFwiT2JqZWN0XCI6XG4gICAgY2FzZSBcIkFycmF5XCI6XG4gICAgICByZXR1cm4gMSAvKiBDT01NT04gKi87XG4gICAgY2FzZSBcIk1hcFwiOlxuICAgIGNhc2UgXCJTZXRcIjpcbiAgICBjYXNlIFwiV2Vha01hcFwiOlxuICAgIGNhc2UgXCJXZWFrU2V0XCI6XG4gICAgICByZXR1cm4gMiAvKiBDT0xMRUNUSU9OICovO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gMCAvKiBJTlZBTElEICovO1xuICB9XG59XG5mdW5jdGlvbiBnZXRUYXJnZXRUeXBlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZVtcIl9fdl9za2lwXCJdIHx8ICFPYmplY3QuaXNFeHRlbnNpYmxlKHZhbHVlKSA/IDAgLyogSU5WQUxJRCAqLyA6IHRhcmdldFR5cGVNYXAodG9SYXdUeXBlKHZhbHVlKSk7XG59XG5mdW5jdGlvbiByZWFjdGl2ZSh0YXJnZXQpIHtcbiAgaWYgKGlzUmVhZG9ubHkodGFyZ2V0KSkge1xuICAgIHJldHVybiB0YXJnZXQ7XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZVJlYWN0aXZlT2JqZWN0KFxuICAgIHRhcmdldCxcbiAgICBmYWxzZSxcbiAgICBtdXRhYmxlSGFuZGxlcnMsXG4gICAgbXV0YWJsZUNvbGxlY3Rpb25IYW5kbGVycyxcbiAgICByZWFjdGl2ZU1hcFxuICApO1xufVxuZnVuY3Rpb24gc2hhbGxvd1JlYWN0aXZlKHRhcmdldCkge1xuICByZXR1cm4gY3JlYXRlUmVhY3RpdmVPYmplY3QoXG4gICAgdGFyZ2V0LFxuICAgIGZhbHNlLFxuICAgIHNoYWxsb3dSZWFjdGl2ZUhhbmRsZXJzLFxuICAgIHNoYWxsb3dDb2xsZWN0aW9uSGFuZGxlcnMsXG4gICAgc2hhbGxvd1JlYWN0aXZlTWFwXG4gICk7XG59XG5mdW5jdGlvbiByZWFkb25seSh0YXJnZXQpIHtcbiAgcmV0dXJuIGNyZWF0ZVJlYWN0aXZlT2JqZWN0KFxuICAgIHRhcmdldCxcbiAgICB0cnVlLFxuICAgIHJlYWRvbmx5SGFuZGxlcnMsXG4gICAgcmVhZG9ubHlDb2xsZWN0aW9uSGFuZGxlcnMsXG4gICAgcmVhZG9ubHlNYXBcbiAgKTtcbn1cbmZ1bmN0aW9uIHNoYWxsb3dSZWFkb25seSh0YXJnZXQpIHtcbiAgcmV0dXJuIGNyZWF0ZVJlYWN0aXZlT2JqZWN0KFxuICAgIHRhcmdldCxcbiAgICB0cnVlLFxuICAgIHNoYWxsb3dSZWFkb25seUhhbmRsZXJzLFxuICAgIHNoYWxsb3dSZWFkb25seUNvbGxlY3Rpb25IYW5kbGVycyxcbiAgICBzaGFsbG93UmVhZG9ubHlNYXBcbiAgKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVJlYWN0aXZlT2JqZWN0KHRhcmdldCwgaXNSZWFkb25seTIsIGJhc2VIYW5kbGVycywgY29sbGVjdGlvbkhhbmRsZXJzLCBwcm94eU1hcCkge1xuICBpZiAoIWlzT2JqZWN0KHRhcmdldCkpIHtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgY29uc29sZS53YXJuKGB2YWx1ZSBjYW5ub3QgYmUgbWFkZSByZWFjdGl2ZTogJHtTdHJpbmcodGFyZ2V0KX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfVxuICBpZiAodGFyZ2V0W1wiX192X3Jhd1wiXSAmJiAhKGlzUmVhZG9ubHkyICYmIHRhcmdldFtcIl9fdl9pc1JlYWN0aXZlXCJdKSkge1xuICAgIHJldHVybiB0YXJnZXQ7XG4gIH1cbiAgY29uc3QgZXhpc3RpbmdQcm94eSA9IHByb3h5TWFwLmdldCh0YXJnZXQpO1xuICBpZiAoZXhpc3RpbmdQcm94eSkge1xuICAgIHJldHVybiBleGlzdGluZ1Byb3h5O1xuICB9XG4gIGNvbnN0IHRhcmdldFR5cGUgPSBnZXRUYXJnZXRUeXBlKHRhcmdldCk7XG4gIGlmICh0YXJnZXRUeXBlID09PSAwIC8qIElOVkFMSUQgKi8pIHtcbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9XG4gIGNvbnN0IHByb3h5ID0gbmV3IFByb3h5KFxuICAgIHRhcmdldCxcbiAgICB0YXJnZXRUeXBlID09PSAyIC8qIENPTExFQ1RJT04gKi8gPyBjb2xsZWN0aW9uSGFuZGxlcnMgOiBiYXNlSGFuZGxlcnNcbiAgKTtcbiAgcHJveHlNYXAuc2V0KHRhcmdldCwgcHJveHkpO1xuICByZXR1cm4gcHJveHk7XG59XG5mdW5jdGlvbiBpc1JlYWN0aXZlKHZhbHVlKSB7XG4gIGlmIChpc1JlYWRvbmx5KHZhbHVlKSkge1xuICAgIHJldHVybiBpc1JlYWN0aXZlKHZhbHVlW1wiX192X3Jhd1wiXSk7XG4gIH1cbiAgcmV0dXJuICEhKHZhbHVlICYmIHZhbHVlW1wiX192X2lzUmVhY3RpdmVcIl0pO1xufVxuZnVuY3Rpb24gaXNSZWFkb25seSh2YWx1ZSkge1xuICByZXR1cm4gISEodmFsdWUgJiYgdmFsdWVbXCJfX3ZfaXNSZWFkb25seVwiXSk7XG59XG5mdW5jdGlvbiBpc1NoYWxsb3codmFsdWUpIHtcbiAgcmV0dXJuICEhKHZhbHVlICYmIHZhbHVlW1wiX192X2lzU2hhbGxvd1wiXSk7XG59XG5mdW5jdGlvbiBpc1Byb3h5KHZhbHVlKSB7XG4gIHJldHVybiBpc1JlYWN0aXZlKHZhbHVlKSB8fCBpc1JlYWRvbmx5KHZhbHVlKTtcbn1cbmZ1bmN0aW9uIHRvUmF3KG9ic2VydmVkKSB7XG4gIGNvbnN0IHJhdyA9IG9ic2VydmVkICYmIG9ic2VydmVkW1wiX192X3Jhd1wiXTtcbiAgcmV0dXJuIHJhdyA/IHRvUmF3KHJhdykgOiBvYnNlcnZlZDtcbn1cbmZ1bmN0aW9uIG1hcmtSYXcodmFsdWUpIHtcbiAgZGVmKHZhbHVlLCBcIl9fdl9za2lwXCIsIHRydWUpO1xuICByZXR1cm4gdmFsdWU7XG59XG5jb25zdCB0b1JlYWN0aXZlID0gKHZhbHVlKSA9PiBpc09iamVjdCh2YWx1ZSkgPyByZWFjdGl2ZSh2YWx1ZSkgOiB2YWx1ZTtcbmNvbnN0IHRvUmVhZG9ubHkgPSAodmFsdWUpID0+IGlzT2JqZWN0KHZhbHVlKSA/IHJlYWRvbmx5KHZhbHVlKSA6IHZhbHVlO1xuXG5mdW5jdGlvbiB0cmFja1JlZlZhbHVlKHJlZjIpIHtcbiAgaWYgKHNob3VsZFRyYWNrICYmIGFjdGl2ZUVmZmVjdCkge1xuICAgIHJlZjIgPSB0b1JhdyhyZWYyKTtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgdHJhY2tFZmZlY3RzKHJlZjIuZGVwIHx8IChyZWYyLmRlcCA9IGNyZWF0ZURlcCgpKSwge1xuICAgICAgICB0YXJnZXQ6IHJlZjIsXG4gICAgICAgIHR5cGU6IFwiZ2V0XCIsXG4gICAgICAgIGtleTogXCJ2YWx1ZVwiXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdHJhY2tFZmZlY3RzKHJlZjIuZGVwIHx8IChyZWYyLmRlcCA9IGNyZWF0ZURlcCgpKSk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiB0cmlnZ2VyUmVmVmFsdWUocmVmMiwgbmV3VmFsKSB7XG4gIHJlZjIgPSB0b1JhdyhyZWYyKTtcbiAgY29uc3QgZGVwID0gcmVmMi5kZXA7XG4gIGlmIChkZXApIHtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgdHJpZ2dlckVmZmVjdHMoZGVwLCB7XG4gICAgICAgIHRhcmdldDogcmVmMixcbiAgICAgICAgdHlwZTogXCJzZXRcIixcbiAgICAgICAga2V5OiBcInZhbHVlXCIsXG4gICAgICAgIG5ld1ZhbHVlOiBuZXdWYWxcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0cmlnZ2VyRWZmZWN0cyhkZXApO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gaXNSZWYocikge1xuICByZXR1cm4gISEociAmJiByLl9fdl9pc1JlZiA9PT0gdHJ1ZSk7XG59XG5mdW5jdGlvbiByZWYodmFsdWUpIHtcbiAgcmV0dXJuIGNyZWF0ZVJlZih2YWx1ZSwgZmFsc2UpO1xufVxuZnVuY3Rpb24gc2hhbGxvd1JlZih2YWx1ZSkge1xuICByZXR1cm4gY3JlYXRlUmVmKHZhbHVlLCB0cnVlKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVJlZihyYXdWYWx1ZSwgc2hhbGxvdykge1xuICBpZiAoaXNSZWYocmF3VmFsdWUpKSB7XG4gICAgcmV0dXJuIHJhd1ZhbHVlO1xuICB9XG4gIHJldHVybiBuZXcgUmVmSW1wbChyYXdWYWx1ZSwgc2hhbGxvdyk7XG59XG5jbGFzcyBSZWZJbXBsIHtcbiAgY29uc3RydWN0b3IodmFsdWUsIF9fdl9pc1NoYWxsb3cpIHtcbiAgICB0aGlzLl9fdl9pc1NoYWxsb3cgPSBfX3ZfaXNTaGFsbG93O1xuICAgIHRoaXMuZGVwID0gdm9pZCAwO1xuICAgIHRoaXMuX192X2lzUmVmID0gdHJ1ZTtcbiAgICB0aGlzLl9yYXdWYWx1ZSA9IF9fdl9pc1NoYWxsb3cgPyB2YWx1ZSA6IHRvUmF3KHZhbHVlKTtcbiAgICB0aGlzLl92YWx1ZSA9IF9fdl9pc1NoYWxsb3cgPyB2YWx1ZSA6IHRvUmVhY3RpdmUodmFsdWUpO1xuICB9XG4gIGdldCB2YWx1ZSgpIHtcbiAgICB0cmFja1JlZlZhbHVlKHRoaXMpO1xuICAgIHJldHVybiB0aGlzLl92YWx1ZTtcbiAgfVxuICBzZXQgdmFsdWUobmV3VmFsKSB7XG4gICAgY29uc3QgdXNlRGlyZWN0VmFsdWUgPSB0aGlzLl9fdl9pc1NoYWxsb3cgfHwgaXNTaGFsbG93KG5ld1ZhbCkgfHwgaXNSZWFkb25seShuZXdWYWwpO1xuICAgIG5ld1ZhbCA9IHVzZURpcmVjdFZhbHVlID8gbmV3VmFsIDogdG9SYXcobmV3VmFsKTtcbiAgICBpZiAoaGFzQ2hhbmdlZChuZXdWYWwsIHRoaXMuX3Jhd1ZhbHVlKSkge1xuICAgICAgdGhpcy5fcmF3VmFsdWUgPSBuZXdWYWw7XG4gICAgICB0aGlzLl92YWx1ZSA9IHVzZURpcmVjdFZhbHVlID8gbmV3VmFsIDogdG9SZWFjdGl2ZShuZXdWYWwpO1xuICAgICAgdHJpZ2dlclJlZlZhbHVlKHRoaXMsIG5ld1ZhbCk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiB0cmlnZ2VyUmVmKHJlZjIpIHtcbiAgdHJpZ2dlclJlZlZhbHVlKHJlZjIsICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyByZWYyLnZhbHVlIDogdm9pZCAwKTtcbn1cbmZ1bmN0aW9uIHVucmVmKHJlZjIpIHtcbiAgcmV0dXJuIGlzUmVmKHJlZjIpID8gcmVmMi52YWx1ZSA6IHJlZjI7XG59XG5mdW5jdGlvbiB0b1ZhbHVlKHNvdXJjZSkge1xuICByZXR1cm4gaXNGdW5jdGlvbihzb3VyY2UpID8gc291cmNlKCkgOiB1bnJlZihzb3VyY2UpO1xufVxuY29uc3Qgc2hhbGxvd1Vud3JhcEhhbmRsZXJzID0ge1xuICBnZXQ6ICh0YXJnZXQsIGtleSwgcmVjZWl2ZXIpID0+IHVucmVmKFJlZmxlY3QuZ2V0KHRhcmdldCwga2V5LCByZWNlaXZlcikpLFxuICBzZXQ6ICh0YXJnZXQsIGtleSwgdmFsdWUsIHJlY2VpdmVyKSA9PiB7XG4gICAgY29uc3Qgb2xkVmFsdWUgPSB0YXJnZXRba2V5XTtcbiAgICBpZiAoaXNSZWYob2xkVmFsdWUpICYmICFpc1JlZih2YWx1ZSkpIHtcbiAgICAgIG9sZFZhbHVlLnZhbHVlID0gdmFsdWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFJlZmxlY3Quc2V0KHRhcmdldCwga2V5LCB2YWx1ZSwgcmVjZWl2ZXIpO1xuICAgIH1cbiAgfVxufTtcbmZ1bmN0aW9uIHByb3h5UmVmcyhvYmplY3RXaXRoUmVmcykge1xuICByZXR1cm4gaXNSZWFjdGl2ZShvYmplY3RXaXRoUmVmcykgPyBvYmplY3RXaXRoUmVmcyA6IG5ldyBQcm94eShvYmplY3RXaXRoUmVmcywgc2hhbGxvd1Vud3JhcEhhbmRsZXJzKTtcbn1cbmNsYXNzIEN1c3RvbVJlZkltcGwge1xuICBjb25zdHJ1Y3RvcihmYWN0b3J5KSB7XG4gICAgdGhpcy5kZXAgPSB2b2lkIDA7XG4gICAgdGhpcy5fX3ZfaXNSZWYgPSB0cnVlO1xuICAgIGNvbnN0IHsgZ2V0LCBzZXQgfSA9IGZhY3RvcnkoXG4gICAgICAoKSA9PiB0cmFja1JlZlZhbHVlKHRoaXMpLFxuICAgICAgKCkgPT4gdHJpZ2dlclJlZlZhbHVlKHRoaXMpXG4gICAgKTtcbiAgICB0aGlzLl9nZXQgPSBnZXQ7XG4gICAgdGhpcy5fc2V0ID0gc2V0O1xuICB9XG4gIGdldCB2YWx1ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0KCk7XG4gIH1cbiAgc2V0IHZhbHVlKG5ld1ZhbCkge1xuICAgIHRoaXMuX3NldChuZXdWYWwpO1xuICB9XG59XG5mdW5jdGlvbiBjdXN0b21SZWYoZmFjdG9yeSkge1xuICByZXR1cm4gbmV3IEN1c3RvbVJlZkltcGwoZmFjdG9yeSk7XG59XG5mdW5jdGlvbiB0b1JlZnMob2JqZWN0KSB7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICFpc1Byb3h5KG9iamVjdCkpIHtcbiAgICBjb25zb2xlLndhcm4oYHRvUmVmcygpIGV4cGVjdHMgYSByZWFjdGl2ZSBvYmplY3QgYnV0IHJlY2VpdmVkIGEgcGxhaW4gb25lLmApO1xuICB9XG4gIGNvbnN0IHJldCA9IGlzQXJyYXkob2JqZWN0KSA/IG5ldyBBcnJheShvYmplY3QubGVuZ3RoKSA6IHt9O1xuICBmb3IgKGNvbnN0IGtleSBpbiBvYmplY3QpIHtcbiAgICByZXRba2V5XSA9IHByb3BlcnR5VG9SZWYob2JqZWN0LCBrZXkpO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5jbGFzcyBPYmplY3RSZWZJbXBsIHtcbiAgY29uc3RydWN0b3IoX29iamVjdCwgX2tleSwgX2RlZmF1bHRWYWx1ZSkge1xuICAgIHRoaXMuX29iamVjdCA9IF9vYmplY3Q7XG4gICAgdGhpcy5fa2V5ID0gX2tleTtcbiAgICB0aGlzLl9kZWZhdWx0VmFsdWUgPSBfZGVmYXVsdFZhbHVlO1xuICAgIHRoaXMuX192X2lzUmVmID0gdHJ1ZTtcbiAgfVxuICBnZXQgdmFsdWUoKSB7XG4gICAgY29uc3QgdmFsID0gdGhpcy5fb2JqZWN0W3RoaXMuX2tleV07XG4gICAgcmV0dXJuIHZhbCA9PT0gdm9pZCAwID8gdGhpcy5fZGVmYXVsdFZhbHVlIDogdmFsO1xuICB9XG4gIHNldCB2YWx1ZShuZXdWYWwpIHtcbiAgICB0aGlzLl9vYmplY3RbdGhpcy5fa2V5XSA9IG5ld1ZhbDtcbiAgfVxuICBnZXQgZGVwKCkge1xuICAgIHJldHVybiBnZXREZXBGcm9tUmVhY3RpdmUodG9SYXcodGhpcy5fb2JqZWN0KSwgdGhpcy5fa2V5KTtcbiAgfVxufVxuY2xhc3MgR2V0dGVyUmVmSW1wbCB7XG4gIGNvbnN0cnVjdG9yKF9nZXR0ZXIpIHtcbiAgICB0aGlzLl9nZXR0ZXIgPSBfZ2V0dGVyO1xuICAgIHRoaXMuX192X2lzUmVmID0gdHJ1ZTtcbiAgICB0aGlzLl9fdl9pc1JlYWRvbmx5ID0gdHJ1ZTtcbiAgfVxuICBnZXQgdmFsdWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldHRlcigpO1xuICB9XG59XG5mdW5jdGlvbiB0b1JlZihzb3VyY2UsIGtleSwgZGVmYXVsdFZhbHVlKSB7XG4gIGlmIChpc1JlZihzb3VyY2UpKSB7XG4gICAgcmV0dXJuIHNvdXJjZTtcbiAgfSBlbHNlIGlmIChpc0Z1bmN0aW9uKHNvdXJjZSkpIHtcbiAgICByZXR1cm4gbmV3IEdldHRlclJlZkltcGwoc291cmNlKTtcbiAgfSBlbHNlIGlmIChpc09iamVjdChzb3VyY2UpICYmIGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgcmV0dXJuIHByb3BlcnR5VG9SZWYoc291cmNlLCBrZXksIGRlZmF1bHRWYWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHJlZihzb3VyY2UpO1xuICB9XG59XG5mdW5jdGlvbiBwcm9wZXJ0eVRvUmVmKHNvdXJjZSwga2V5LCBkZWZhdWx0VmFsdWUpIHtcbiAgY29uc3QgdmFsID0gc291cmNlW2tleV07XG4gIHJldHVybiBpc1JlZih2YWwpID8gdmFsIDogbmV3IE9iamVjdFJlZkltcGwoXG4gICAgc291cmNlLFxuICAgIGtleSxcbiAgICBkZWZhdWx0VmFsdWVcbiAgKTtcbn1cblxuY2xhc3MgQ29tcHV0ZWRSZWZJbXBsIHtcbiAgY29uc3RydWN0b3IoZ2V0dGVyLCBfc2V0dGVyLCBpc1JlYWRvbmx5LCBpc1NTUikge1xuICAgIHRoaXMuX3NldHRlciA9IF9zZXR0ZXI7XG4gICAgdGhpcy5kZXAgPSB2b2lkIDA7XG4gICAgdGhpcy5fX3ZfaXNSZWYgPSB0cnVlO1xuICAgIHRoaXNbXCJfX3ZfaXNSZWFkb25seVwiXSA9IGZhbHNlO1xuICAgIHRoaXMuX2RpcnR5ID0gdHJ1ZTtcbiAgICB0aGlzLmVmZmVjdCA9IG5ldyBSZWFjdGl2ZUVmZmVjdChnZXR0ZXIsICgpID0+IHtcbiAgICAgIGlmICghdGhpcy5fZGlydHkpIHtcbiAgICAgICAgdGhpcy5fZGlydHkgPSB0cnVlO1xuICAgICAgICB0cmlnZ2VyUmVmVmFsdWUodGhpcyk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5lZmZlY3QuY29tcHV0ZWQgPSB0aGlzO1xuICAgIHRoaXMuZWZmZWN0LmFjdGl2ZSA9IHRoaXMuX2NhY2hlYWJsZSA9ICFpc1NTUjtcbiAgICB0aGlzW1wiX192X2lzUmVhZG9ubHlcIl0gPSBpc1JlYWRvbmx5O1xuICB9XG4gIGdldCB2YWx1ZSgpIHtcbiAgICBjb25zdCBzZWxmID0gdG9SYXcodGhpcyk7XG4gICAgdHJhY2tSZWZWYWx1ZShzZWxmKTtcbiAgICBpZiAoc2VsZi5fZGlydHkgfHwgIXNlbGYuX2NhY2hlYWJsZSkge1xuICAgICAgc2VsZi5fZGlydHkgPSBmYWxzZTtcbiAgICAgIHNlbGYuX3ZhbHVlID0gc2VsZi5lZmZlY3QucnVuKCk7XG4gICAgfVxuICAgIHJldHVybiBzZWxmLl92YWx1ZTtcbiAgfVxuICBzZXQgdmFsdWUobmV3VmFsdWUpIHtcbiAgICB0aGlzLl9zZXR0ZXIobmV3VmFsdWUpO1xuICB9XG59XG5mdW5jdGlvbiBjb21wdXRlZChnZXR0ZXJPck9wdGlvbnMsIGRlYnVnT3B0aW9ucywgaXNTU1IgPSBmYWxzZSkge1xuICBsZXQgZ2V0dGVyO1xuICBsZXQgc2V0dGVyO1xuICBjb25zdCBvbmx5R2V0dGVyID0gaXNGdW5jdGlvbihnZXR0ZXJPck9wdGlvbnMpO1xuICBpZiAob25seUdldHRlcikge1xuICAgIGdldHRlciA9IGdldHRlck9yT3B0aW9ucztcbiAgICBzZXR0ZXIgPSAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gKCkgPT4ge1xuICAgICAgY29uc29sZS53YXJuKFwiV3JpdGUgb3BlcmF0aW9uIGZhaWxlZDogY29tcHV0ZWQgdmFsdWUgaXMgcmVhZG9ubHlcIik7XG4gICAgfSA6IE5PT1A7XG4gIH0gZWxzZSB7XG4gICAgZ2V0dGVyID0gZ2V0dGVyT3JPcHRpb25zLmdldDtcbiAgICBzZXR0ZXIgPSBnZXR0ZXJPck9wdGlvbnMuc2V0O1xuICB9XG4gIGNvbnN0IGNSZWYgPSBuZXcgQ29tcHV0ZWRSZWZJbXBsKGdldHRlciwgc2V0dGVyLCBvbmx5R2V0dGVyIHx8ICFzZXR0ZXIsIGlzU1NSKTtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgZGVidWdPcHRpb25zICYmICFpc1NTUikge1xuICAgIGNSZWYuZWZmZWN0Lm9uVHJhY2sgPSBkZWJ1Z09wdGlvbnMub25UcmFjaztcbiAgICBjUmVmLmVmZmVjdC5vblRyaWdnZXIgPSBkZWJ1Z09wdGlvbnMub25UcmlnZ2VyO1xuICB9XG4gIHJldHVybiBjUmVmO1xufVxuXG5jb25zdCB0aWNrID0gLyogQF9fUFVSRV9fICovIFByb21pc2UucmVzb2x2ZSgpO1xuY29uc3QgcXVldWUgPSBbXTtcbmxldCBxdWV1ZWQgPSBmYWxzZTtcbmNvbnN0IHNjaGVkdWxlciA9IChmbikgPT4ge1xuICBxdWV1ZS5wdXNoKGZuKTtcbiAgaWYgKCFxdWV1ZWQpIHtcbiAgICBxdWV1ZWQgPSB0cnVlO1xuICAgIHRpY2sudGhlbihmbHVzaCk7XG4gIH1cbn07XG5jb25zdCBmbHVzaCA9ICgpID0+IHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBxdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgIHF1ZXVlW2ldKCk7XG4gIH1cbiAgcXVldWUubGVuZ3RoID0gMDtcbiAgcXVldWVkID0gZmFsc2U7XG59O1xuY2xhc3MgRGVmZXJyZWRDb21wdXRlZFJlZkltcGwge1xuICBjb25zdHJ1Y3RvcihnZXR0ZXIpIHtcbiAgICB0aGlzLmRlcCA9IHZvaWQgMDtcbiAgICB0aGlzLl9kaXJ0eSA9IHRydWU7XG4gICAgdGhpcy5fX3ZfaXNSZWYgPSB0cnVlO1xuICAgIHRoaXNbXCJfX3ZfaXNSZWFkb25seVwiXSA9IHRydWU7XG4gICAgbGV0IGNvbXBhcmVUYXJnZXQ7XG4gICAgbGV0IGhhc0NvbXBhcmVUYXJnZXQgPSBmYWxzZTtcbiAgICBsZXQgc2NoZWR1bGVkID0gZmFsc2U7XG4gICAgdGhpcy5lZmZlY3QgPSBuZXcgUmVhY3RpdmVFZmZlY3QoZ2V0dGVyLCAoY29tcHV0ZWRUcmlnZ2VyKSA9PiB7XG4gICAgICBpZiAodGhpcy5kZXApIHtcbiAgICAgICAgaWYgKGNvbXB1dGVkVHJpZ2dlcikge1xuICAgICAgICAgIGNvbXBhcmVUYXJnZXQgPSB0aGlzLl92YWx1ZTtcbiAgICAgICAgICBoYXNDb21wYXJlVGFyZ2V0ID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmICghc2NoZWR1bGVkKSB7XG4gICAgICAgICAgY29uc3QgdmFsdWVUb0NvbXBhcmUgPSBoYXNDb21wYXJlVGFyZ2V0ID8gY29tcGFyZVRhcmdldCA6IHRoaXMuX3ZhbHVlO1xuICAgICAgICAgIHNjaGVkdWxlZCA9IHRydWU7XG4gICAgICAgICAgaGFzQ29tcGFyZVRhcmdldCA9IGZhbHNlO1xuICAgICAgICAgIHNjaGVkdWxlcigoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5lZmZlY3QuYWN0aXZlICYmIHRoaXMuX2dldCgpICE9PSB2YWx1ZVRvQ29tcGFyZSkge1xuICAgICAgICAgICAgICB0cmlnZ2VyUmVmVmFsdWUodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzY2hlZHVsZWQgPSBmYWxzZTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGUgb2YgdGhpcy5kZXApIHtcbiAgICAgICAgICBpZiAoZS5jb21wdXRlZCBpbnN0YW5jZW9mIERlZmVycmVkQ29tcHV0ZWRSZWZJbXBsKSB7XG4gICAgICAgICAgICBlLnNjaGVkdWxlcihcbiAgICAgICAgICAgICAgdHJ1ZVxuICAgICAgICAgICAgICAvKiBjb21wdXRlZFRyaWdnZXIgKi9cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLl9kaXJ0eSA9IHRydWU7XG4gICAgfSk7XG4gICAgdGhpcy5lZmZlY3QuY29tcHV0ZWQgPSB0aGlzO1xuICB9XG4gIF9nZXQoKSB7XG4gICAgaWYgKHRoaXMuX2RpcnR5KSB7XG4gICAgICB0aGlzLl9kaXJ0eSA9IGZhbHNlO1xuICAgICAgcmV0dXJuIHRoaXMuX3ZhbHVlID0gdGhpcy5lZmZlY3QucnVuKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl92YWx1ZTtcbiAgfVxuICBnZXQgdmFsdWUoKSB7XG4gICAgdHJhY2tSZWZWYWx1ZSh0aGlzKTtcbiAgICByZXR1cm4gdG9SYXcodGhpcykuX2dldCgpO1xuICB9XG59XG5mdW5jdGlvbiBkZWZlcnJlZENvbXB1dGVkKGdldHRlcikge1xuICByZXR1cm4gbmV3IERlZmVycmVkQ29tcHV0ZWRSZWZJbXBsKGdldHRlcik7XG59XG5cbmV4cG9ydCB7IEVmZmVjdFNjb3BlLCBJVEVSQVRFX0tFWSwgUmVhY3RpdmVFZmZlY3QsIGNvbXB1dGVkLCBjdXN0b21SZWYsIGRlZmVycmVkQ29tcHV0ZWQsIGVmZmVjdCwgZWZmZWN0U2NvcGUsIGVuYWJsZVRyYWNraW5nLCBnZXRDdXJyZW50U2NvcGUsIGlzUHJveHksIGlzUmVhY3RpdmUsIGlzUmVhZG9ubHksIGlzUmVmLCBpc1NoYWxsb3csIG1hcmtSYXcsIG9uU2NvcGVEaXNwb3NlLCBwYXVzZVRyYWNraW5nLCBwcm94eVJlZnMsIHJlYWN0aXZlLCByZWFkb25seSwgcmVmLCByZXNldFRyYWNraW5nLCBzaGFsbG93UmVhY3RpdmUsIHNoYWxsb3dSZWFkb25seSwgc2hhbGxvd1JlZiwgc3RvcCwgdG9SYXcsIHRvUmVmLCB0b1JlZnMsIHRvVmFsdWUsIHRyYWNrLCB0cmlnZ2VyLCB0cmlnZ2VyUmVmLCB1bnJlZiB9O1xuIiwiZnVuY3Rpb24gbWFrZU1hcChzdHIsIGV4cGVjdHNMb3dlckNhc2UpIHtcbiAgY29uc3QgbWFwID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGNvbnN0IGxpc3QgPSBzdHIuc3BsaXQoXCIsXCIpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICBtYXBbbGlzdFtpXV0gPSB0cnVlO1xuICB9XG4gIHJldHVybiBleHBlY3RzTG93ZXJDYXNlID8gKHZhbCkgPT4gISFtYXBbdmFsLnRvTG93ZXJDYXNlKCldIDogKHZhbCkgPT4gISFtYXBbdmFsXTtcbn1cblxuY29uc3QgRU1QVFlfT0JKID0gISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IE9iamVjdC5mcmVlemUoe30pIDoge307XG5jb25zdCBFTVBUWV9BUlIgPSAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gT2JqZWN0LmZyZWV6ZShbXSkgOiBbXTtcbmNvbnN0IE5PT1AgPSAoKSA9PiB7XG59O1xuY29uc3QgTk8gPSAoKSA9PiBmYWxzZTtcbmNvbnN0IG9uUkUgPSAvXm9uW15hLXpdLztcbmNvbnN0IGlzT24gPSAoa2V5KSA9PiBvblJFLnRlc3Qoa2V5KTtcbmNvbnN0IGlzTW9kZWxMaXN0ZW5lciA9IChrZXkpID0+IGtleS5zdGFydHNXaXRoKFwib25VcGRhdGU6XCIpO1xuY29uc3QgZXh0ZW5kID0gT2JqZWN0LmFzc2lnbjtcbmNvbnN0IHJlbW92ZSA9IChhcnIsIGVsKSA9PiB7XG4gIGNvbnN0IGkgPSBhcnIuaW5kZXhPZihlbCk7XG4gIGlmIChpID4gLTEpIHtcbiAgICBhcnIuc3BsaWNlKGksIDEpO1xuICB9XG59O1xuY29uc3QgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuY29uc3QgaGFzT3duID0gKHZhbCwga2V5KSA9PiBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbCwga2V5KTtcbmNvbnN0IGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuY29uc3QgaXNNYXAgPSAodmFsKSA9PiB0b1R5cGVTdHJpbmcodmFsKSA9PT0gXCJbb2JqZWN0IE1hcF1cIjtcbmNvbnN0IGlzU2V0ID0gKHZhbCkgPT4gdG9UeXBlU3RyaW5nKHZhbCkgPT09IFwiW29iamVjdCBTZXRdXCI7XG5jb25zdCBpc0RhdGUgPSAodmFsKSA9PiB0b1R5cGVTdHJpbmcodmFsKSA9PT0gXCJbb2JqZWN0IERhdGVdXCI7XG5jb25zdCBpc1JlZ0V4cCA9ICh2YWwpID0+IHRvVHlwZVN0cmluZyh2YWwpID09PSBcIltvYmplY3QgUmVnRXhwXVwiO1xuY29uc3QgaXNGdW5jdGlvbiA9ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09IFwiZnVuY3Rpb25cIjtcbmNvbnN0IGlzU3RyaW5nID0gKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gXCJzdHJpbmdcIjtcbmNvbnN0IGlzU3ltYm9sID0gKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gXCJzeW1ib2xcIjtcbmNvbnN0IGlzT2JqZWN0ID0gKHZhbCkgPT4gdmFsICE9PSBudWxsICYmIHR5cGVvZiB2YWwgPT09IFwib2JqZWN0XCI7XG5jb25zdCBpc1Byb21pc2UgPSAodmFsKSA9PiB7XG4gIHJldHVybiBpc09iamVjdCh2YWwpICYmIGlzRnVuY3Rpb24odmFsLnRoZW4pICYmIGlzRnVuY3Rpb24odmFsLmNhdGNoKTtcbn07XG5jb25zdCBvYmplY3RUb1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5jb25zdCB0b1R5cGVTdHJpbmcgPSAodmFsdWUpID0+IG9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xuY29uc3QgdG9SYXdUeXBlID0gKHZhbHVlKSA9PiB7XG4gIHJldHVybiB0b1R5cGVTdHJpbmcodmFsdWUpLnNsaWNlKDgsIC0xKTtcbn07XG5jb25zdCBpc1BsYWluT2JqZWN0ID0gKHZhbCkgPT4gdG9UeXBlU3RyaW5nKHZhbCkgPT09IFwiW29iamVjdCBPYmplY3RdXCI7XG5jb25zdCBpc0ludGVnZXJLZXkgPSAoa2V5KSA9PiBpc1N0cmluZyhrZXkpICYmIGtleSAhPT0gXCJOYU5cIiAmJiBrZXlbMF0gIT09IFwiLVwiICYmIFwiXCIgKyBwYXJzZUludChrZXksIDEwKSA9PT0ga2V5O1xuY29uc3QgaXNSZXNlcnZlZFByb3AgPSAvKiBAX19QVVJFX18gKi8gbWFrZU1hcChcbiAgLy8gdGhlIGxlYWRpbmcgY29tbWEgaXMgaW50ZW50aW9uYWwgc28gZW1wdHkgc3RyaW5nIFwiXCIgaXMgYWxzbyBpbmNsdWRlZFxuICBcIixrZXkscmVmLHJlZl9mb3IscmVmX2tleSxvblZub2RlQmVmb3JlTW91bnQsb25Wbm9kZU1vdW50ZWQsb25Wbm9kZUJlZm9yZVVwZGF0ZSxvblZub2RlVXBkYXRlZCxvblZub2RlQmVmb3JlVW5tb3VudCxvblZub2RlVW5tb3VudGVkXCJcbik7XG5jb25zdCBpc0J1aWx0SW5EaXJlY3RpdmUgPSAvKiBAX19QVVJFX18gKi8gbWFrZU1hcChcbiAgXCJiaW5kLGNsb2FrLGVsc2UtaWYsZWxzZSxmb3IsaHRtbCxpZixtb2RlbCxvbixvbmNlLHByZSxzaG93LHNsb3QsdGV4dCxtZW1vXCJcbik7XG5jb25zdCBjYWNoZVN0cmluZ0Z1bmN0aW9uID0gKGZuKSA9PiB7XG4gIGNvbnN0IGNhY2hlID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHJldHVybiAoc3RyKSA9PiB7XG4gICAgY29uc3QgaGl0ID0gY2FjaGVbc3RyXTtcbiAgICByZXR1cm4gaGl0IHx8IChjYWNoZVtzdHJdID0gZm4oc3RyKSk7XG4gIH07XG59O1xuY29uc3QgY2FtZWxpemVSRSA9IC8tKFxcdykvZztcbmNvbnN0IGNhbWVsaXplID0gY2FjaGVTdHJpbmdGdW5jdGlvbigoc3RyKSA9PiB7XG4gIHJldHVybiBzdHIucmVwbGFjZShjYW1lbGl6ZVJFLCAoXywgYykgPT4gYyA/IGMudG9VcHBlckNhc2UoKSA6IFwiXCIpO1xufSk7XG5jb25zdCBoeXBoZW5hdGVSRSA9IC9cXEIoW0EtWl0pL2c7XG5jb25zdCBoeXBoZW5hdGUgPSBjYWNoZVN0cmluZ0Z1bmN0aW9uKFxuICAoc3RyKSA9PiBzdHIucmVwbGFjZShoeXBoZW5hdGVSRSwgXCItJDFcIikudG9Mb3dlckNhc2UoKVxuKTtcbmNvbnN0IGNhcGl0YWxpemUgPSBjYWNoZVN0cmluZ0Z1bmN0aW9uKFxuICAoc3RyKSA9PiBzdHIuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHIuc2xpY2UoMSlcbik7XG5jb25zdCB0b0hhbmRsZXJLZXkgPSBjYWNoZVN0cmluZ0Z1bmN0aW9uKFxuICAoc3RyKSA9PiBzdHIgPyBgb24ke2NhcGl0YWxpemUoc3RyKX1gIDogYGBcbik7XG5jb25zdCBoYXNDaGFuZ2VkID0gKHZhbHVlLCBvbGRWYWx1ZSkgPT4gIU9iamVjdC5pcyh2YWx1ZSwgb2xkVmFsdWUpO1xuY29uc3QgaW52b2tlQXJyYXlGbnMgPSAoZm5zLCBhcmcpID0+IHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBmbnMubGVuZ3RoOyBpKyspIHtcbiAgICBmbnNbaV0oYXJnKTtcbiAgfVxufTtcbmNvbnN0IGRlZiA9IChvYmosIGtleSwgdmFsdWUpID0+IHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIHZhbHVlXG4gIH0pO1xufTtcbmNvbnN0IGxvb3NlVG9OdW1iZXIgPSAodmFsKSA9PiB7XG4gIGNvbnN0IG4gPSBwYXJzZUZsb2F0KHZhbCk7XG4gIHJldHVybiBpc05hTihuKSA/IHZhbCA6IG47XG59O1xuY29uc3QgdG9OdW1iZXIgPSAodmFsKSA9PiB7XG4gIGNvbnN0IG4gPSBpc1N0cmluZyh2YWwpID8gTnVtYmVyKHZhbCkgOiBOYU47XG4gIHJldHVybiBpc05hTihuKSA/IHZhbCA6IG47XG59O1xubGV0IF9nbG9iYWxUaGlzO1xuY29uc3QgZ2V0R2xvYmFsVGhpcyA9ICgpID0+IHtcbiAgcmV0dXJuIF9nbG9iYWxUaGlzIHx8IChfZ2xvYmFsVGhpcyA9IHR5cGVvZiBnbG9iYWxUaGlzICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsVGhpcyA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDoge30pO1xufTtcbmNvbnN0IGlkZW50UkUgPSAvXltfJGEtekEtWlxceEEwLVxcdUZGRkZdW18kYS16QS1aMC05XFx4QTAtXFx1RkZGRl0qJC87XG5mdW5jdGlvbiBnZW5Qcm9wc0FjY2Vzc0V4cChuYW1lKSB7XG4gIHJldHVybiBpZGVudFJFLnRlc3QobmFtZSkgPyBgX19wcm9wcy4ke25hbWV9YCA6IGBfX3Byb3BzWyR7SlNPTi5zdHJpbmdpZnkobmFtZSl9XWA7XG59XG5cbmNvbnN0IFBhdGNoRmxhZ05hbWVzID0ge1xuICBbMV06IGBURVhUYCxcbiAgWzJdOiBgQ0xBU1NgLFxuICBbNF06IGBTVFlMRWAsXG4gIFs4XTogYFBST1BTYCxcbiAgWzE2XTogYEZVTExfUFJPUFNgLFxuICBbMzJdOiBgSFlEUkFURV9FVkVOVFNgLFxuICBbNjRdOiBgU1RBQkxFX0ZSQUdNRU5UYCxcbiAgWzEyOF06IGBLRVlFRF9GUkFHTUVOVGAsXG4gIFsyNTZdOiBgVU5LRVlFRF9GUkFHTUVOVGAsXG4gIFs1MTJdOiBgTkVFRF9QQVRDSGAsXG4gIFsxMDI0XTogYERZTkFNSUNfU0xPVFNgLFxuICBbMjA0OF06IGBERVZfUk9PVF9GUkFHTUVOVGAsXG4gIFstMV06IGBIT0lTVEVEYCxcbiAgWy0yXTogYEJBSUxgXG59O1xuXG5jb25zdCBzbG90RmxhZ3NUZXh0ID0ge1xuICBbMV06IFwiU1RBQkxFXCIsXG4gIFsyXTogXCJEWU5BTUlDXCIsXG4gIFszXTogXCJGT1JXQVJERURcIlxufTtcblxuY29uc3QgR0xPQkFMU19XSElURV9MSVNURUQgPSBcIkluZmluaXR5LHVuZGVmaW5lZCxOYU4saXNGaW5pdGUsaXNOYU4scGFyc2VGbG9hdCxwYXJzZUludCxkZWNvZGVVUkksZGVjb2RlVVJJQ29tcG9uZW50LGVuY29kZVVSSSxlbmNvZGVVUklDb21wb25lbnQsTWF0aCxOdW1iZXIsRGF0ZSxBcnJheSxPYmplY3QsQm9vbGVhbixTdHJpbmcsUmVnRXhwLE1hcCxTZXQsSlNPTixJbnRsLEJpZ0ludCxjb25zb2xlXCI7XG5jb25zdCBpc0dsb2JhbGx5V2hpdGVsaXN0ZWQgPSAvKiBAX19QVVJFX18gKi8gbWFrZU1hcChHTE9CQUxTX1dISVRFX0xJU1RFRCk7XG5cbmNvbnN0IHJhbmdlID0gMjtcbmZ1bmN0aW9uIGdlbmVyYXRlQ29kZUZyYW1lKHNvdXJjZSwgc3RhcnQgPSAwLCBlbmQgPSBzb3VyY2UubGVuZ3RoKSB7XG4gIGxldCBsaW5lcyA9IHNvdXJjZS5zcGxpdCgvKFxccj9cXG4pLyk7XG4gIGNvbnN0IG5ld2xpbmVTZXF1ZW5jZXMgPSBsaW5lcy5maWx0ZXIoKF8sIGlkeCkgPT4gaWR4ICUgMiA9PT0gMSk7XG4gIGxpbmVzID0gbGluZXMuZmlsdGVyKChfLCBpZHgpID0+IGlkeCAlIDIgPT09IDApO1xuICBsZXQgY291bnQgPSAwO1xuICBjb25zdCByZXMgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgIGNvdW50ICs9IGxpbmVzW2ldLmxlbmd0aCArIChuZXdsaW5lU2VxdWVuY2VzW2ldICYmIG5ld2xpbmVTZXF1ZW5jZXNbaV0ubGVuZ3RoIHx8IDApO1xuICAgIGlmIChjb3VudCA+PSBzdGFydCkge1xuICAgICAgZm9yIChsZXQgaiA9IGkgLSByYW5nZTsgaiA8PSBpICsgcmFuZ2UgfHwgZW5kID4gY291bnQ7IGorKykge1xuICAgICAgICBpZiAoaiA8IDAgfHwgaiA+PSBsaW5lcy5sZW5ndGgpXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIGNvbnN0IGxpbmUgPSBqICsgMTtcbiAgICAgICAgcmVzLnB1c2goXG4gICAgICAgICAgYCR7bGluZX0ke1wiIFwiLnJlcGVhdChNYXRoLm1heCgzIC0gU3RyaW5nKGxpbmUpLmxlbmd0aCwgMCkpfXwgICR7bGluZXNbal19YFxuICAgICAgICApO1xuICAgICAgICBjb25zdCBsaW5lTGVuZ3RoID0gbGluZXNbal0ubGVuZ3RoO1xuICAgICAgICBjb25zdCBuZXdMaW5lU2VxTGVuZ3RoID0gbmV3bGluZVNlcXVlbmNlc1tqXSAmJiBuZXdsaW5lU2VxdWVuY2VzW2pdLmxlbmd0aCB8fCAwO1xuICAgICAgICBpZiAoaiA9PT0gaSkge1xuICAgICAgICAgIGNvbnN0IHBhZCA9IHN0YXJ0IC0gKGNvdW50IC0gKGxpbmVMZW5ndGggKyBuZXdMaW5lU2VxTGVuZ3RoKSk7XG4gICAgICAgICAgY29uc3QgbGVuZ3RoID0gTWF0aC5tYXgoXG4gICAgICAgICAgICAxLFxuICAgICAgICAgICAgZW5kID4gY291bnQgPyBsaW5lTGVuZ3RoIC0gcGFkIDogZW5kIC0gc3RhcnRcbiAgICAgICAgICApO1xuICAgICAgICAgIHJlcy5wdXNoKGAgICB8ICBgICsgXCIgXCIucmVwZWF0KHBhZCkgKyBcIl5cIi5yZXBlYXQobGVuZ3RoKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaiA+IGkpIHtcbiAgICAgICAgICBpZiAoZW5kID4gY291bnQpIHtcbiAgICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IE1hdGgubWF4KE1hdGgubWluKGVuZCAtIGNvdW50LCBsaW5lTGVuZ3RoKSwgMSk7XG4gICAgICAgICAgICByZXMucHVzaChgICAgfCAgYCArIFwiXlwiLnJlcGVhdChsZW5ndGgpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY291bnQgKz0gbGluZUxlbmd0aCArIG5ld0xpbmVTZXFMZW5ndGg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzLmpvaW4oXCJcXG5cIik7XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVN0eWxlKHZhbHVlKSB7XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIGNvbnN0IHJlcyA9IHt9O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGl0ZW0gPSB2YWx1ZVtpXTtcbiAgICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSBpc1N0cmluZyhpdGVtKSA/IHBhcnNlU3RyaW5nU3R5bGUoaXRlbSkgOiBub3JtYWxpemVTdHlsZShpdGVtKTtcbiAgICAgIGlmIChub3JtYWxpemVkKSB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIG5vcm1hbGl6ZWQpIHtcbiAgICAgICAgICByZXNba2V5XSA9IG5vcm1hbGl6ZWRba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzO1xuICB9IGVsc2UgaWYgKGlzU3RyaW5nKHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfSBlbHNlIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbn1cbmNvbnN0IGxpc3REZWxpbWl0ZXJSRSA9IC87KD8hW14oXSpcXCkpL2c7XG5jb25zdCBwcm9wZXJ0eURlbGltaXRlclJFID0gLzooW15dKykvO1xuY29uc3Qgc3R5bGVDb21tZW50UkUgPSAvXFwvXFwqW15dKj9cXCpcXC8vZztcbmZ1bmN0aW9uIHBhcnNlU3RyaW5nU3R5bGUoY3NzVGV4dCkge1xuICBjb25zdCByZXQgPSB7fTtcbiAgY3NzVGV4dC5yZXBsYWNlKHN0eWxlQ29tbWVudFJFLCBcIlwiKS5zcGxpdChsaXN0RGVsaW1pdGVyUkUpLmZvckVhY2goKGl0ZW0pID0+IHtcbiAgICBpZiAoaXRlbSkge1xuICAgICAgY29uc3QgdG1wID0gaXRlbS5zcGxpdChwcm9wZXJ0eURlbGltaXRlclJFKTtcbiAgICAgIHRtcC5sZW5ndGggPiAxICYmIChyZXRbdG1wWzBdLnRyaW0oKV0gPSB0bXBbMV0udHJpbSgpKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcmV0O1xufVxuZnVuY3Rpb24gc3RyaW5naWZ5U3R5bGUoc3R5bGVzKSB7XG4gIGxldCByZXQgPSBcIlwiO1xuICBpZiAoIXN0eWxlcyB8fCBpc1N0cmluZyhzdHlsZXMpKSB7XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuICBmb3IgKGNvbnN0IGtleSBpbiBzdHlsZXMpIHtcbiAgICBjb25zdCB2YWx1ZSA9IHN0eWxlc1trZXldO1xuICAgIGNvbnN0IG5vcm1hbGl6ZWRLZXkgPSBrZXkuc3RhcnRzV2l0aChgLS1gKSA/IGtleSA6IGh5cGhlbmF0ZShrZXkpO1xuICAgIGlmIChpc1N0cmluZyh2YWx1ZSkgfHwgdHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiKSB7XG4gICAgICByZXQgKz0gYCR7bm9ybWFsaXplZEtleX06JHt2YWx1ZX07YDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZUNsYXNzKHZhbHVlKSB7XG4gIGxldCByZXMgPSBcIlwiO1xuICBpZiAoaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgcmVzID0gdmFsdWU7XG4gIH0gZWxzZSBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBub3JtYWxpemVkID0gbm9ybWFsaXplQ2xhc3ModmFsdWVbaV0pO1xuICAgICAgaWYgKG5vcm1hbGl6ZWQpIHtcbiAgICAgICAgcmVzICs9IG5vcm1hbGl6ZWQgKyBcIiBcIjtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgZm9yIChjb25zdCBuYW1lIGluIHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWVbbmFtZV0pIHtcbiAgICAgICAgcmVzICs9IG5hbWUgKyBcIiBcIjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlcy50cmltKCk7XG59XG5mdW5jdGlvbiBub3JtYWxpemVQcm9wcyhwcm9wcykge1xuICBpZiAoIXByb3BzKVxuICAgIHJldHVybiBudWxsO1xuICBsZXQgeyBjbGFzczoga2xhc3MsIHN0eWxlIH0gPSBwcm9wcztcbiAgaWYgKGtsYXNzICYmICFpc1N0cmluZyhrbGFzcykpIHtcbiAgICBwcm9wcy5jbGFzcyA9IG5vcm1hbGl6ZUNsYXNzKGtsYXNzKTtcbiAgfVxuICBpZiAoc3R5bGUpIHtcbiAgICBwcm9wcy5zdHlsZSA9IG5vcm1hbGl6ZVN0eWxlKHN0eWxlKTtcbiAgfVxuICByZXR1cm4gcHJvcHM7XG59XG5cbmNvbnN0IEhUTUxfVEFHUyA9IFwiaHRtbCxib2R5LGJhc2UsaGVhZCxsaW5rLG1ldGEsc3R5bGUsdGl0bGUsYWRkcmVzcyxhcnRpY2xlLGFzaWRlLGZvb3RlcixoZWFkZXIsaGdyb3VwLGgxLGgyLGgzLGg0LGg1LGg2LG5hdixzZWN0aW9uLGRpdixkZCxkbCxkdCxmaWdjYXB0aW9uLGZpZ3VyZSxwaWN0dXJlLGhyLGltZyxsaSxtYWluLG9sLHAscHJlLHVsLGEsYixhYmJyLGJkaSxiZG8sYnIsY2l0ZSxjb2RlLGRhdGEsZGZuLGVtLGksa2JkLG1hcmsscSxycCxydCxydWJ5LHMsc2FtcCxzbWFsbCxzcGFuLHN0cm9uZyxzdWIsc3VwLHRpbWUsdSx2YXIsd2JyLGFyZWEsYXVkaW8sbWFwLHRyYWNrLHZpZGVvLGVtYmVkLG9iamVjdCxwYXJhbSxzb3VyY2UsY2FudmFzLHNjcmlwdCxub3NjcmlwdCxkZWwsaW5zLGNhcHRpb24sY29sLGNvbGdyb3VwLHRhYmxlLHRoZWFkLHRib2R5LHRkLHRoLHRyLGJ1dHRvbixkYXRhbGlzdCxmaWVsZHNldCxmb3JtLGlucHV0LGxhYmVsLGxlZ2VuZCxtZXRlcixvcHRncm91cCxvcHRpb24sb3V0cHV0LHByb2dyZXNzLHNlbGVjdCx0ZXh0YXJlYSxkZXRhaWxzLGRpYWxvZyxtZW51LHN1bW1hcnksdGVtcGxhdGUsYmxvY2txdW90ZSxpZnJhbWUsdGZvb3RcIjtcbmNvbnN0IFNWR19UQUdTID0gXCJzdmcsYW5pbWF0ZSxhbmltYXRlTW90aW9uLGFuaW1hdGVUcmFuc2Zvcm0sY2lyY2xlLGNsaXBQYXRoLGNvbG9yLXByb2ZpbGUsZGVmcyxkZXNjLGRpc2NhcmQsZWxsaXBzZSxmZUJsZW5kLGZlQ29sb3JNYXRyaXgsZmVDb21wb25lbnRUcmFuc2ZlcixmZUNvbXBvc2l0ZSxmZUNvbnZvbHZlTWF0cml4LGZlRGlmZnVzZUxpZ2h0aW5nLGZlRGlzcGxhY2VtZW50TWFwLGZlRGlzdGFudExpZ2h0LGZlRHJvcFNoYWRvdyxmZUZsb29kLGZlRnVuY0EsZmVGdW5jQixmZUZ1bmNHLGZlRnVuY1IsZmVHYXVzc2lhbkJsdXIsZmVJbWFnZSxmZU1lcmdlLGZlTWVyZ2VOb2RlLGZlTW9ycGhvbG9neSxmZU9mZnNldCxmZVBvaW50TGlnaHQsZmVTcGVjdWxhckxpZ2h0aW5nLGZlU3BvdExpZ2h0LGZlVGlsZSxmZVR1cmJ1bGVuY2UsZmlsdGVyLGZvcmVpZ25PYmplY3QsZyxoYXRjaCxoYXRjaHBhdGgsaW1hZ2UsbGluZSxsaW5lYXJHcmFkaWVudCxtYXJrZXIsbWFzayxtZXNoLG1lc2hncmFkaWVudCxtZXNocGF0Y2gsbWVzaHJvdyxtZXRhZGF0YSxtcGF0aCxwYXRoLHBhdHRlcm4scG9seWdvbixwb2x5bGluZSxyYWRpYWxHcmFkaWVudCxyZWN0LHNldCxzb2xpZGNvbG9yLHN0b3Asc3dpdGNoLHN5bWJvbCx0ZXh0LHRleHRQYXRoLHRpdGxlLHRzcGFuLHVua25vd24sdXNlLHZpZXdcIjtcbmNvbnN0IFZPSURfVEFHUyA9IFwiYXJlYSxiYXNlLGJyLGNvbCxlbWJlZCxocixpbWcsaW5wdXQsbGluayxtZXRhLHBhcmFtLHNvdXJjZSx0cmFjayx3YnJcIjtcbmNvbnN0IGlzSFRNTFRhZyA9IC8qIEBfX1BVUkVfXyAqLyBtYWtlTWFwKEhUTUxfVEFHUyk7XG5jb25zdCBpc1NWR1RhZyA9IC8qIEBfX1BVUkVfXyAqLyBtYWtlTWFwKFNWR19UQUdTKTtcbmNvbnN0IGlzVm9pZFRhZyA9IC8qIEBfX1BVUkVfXyAqLyBtYWtlTWFwKFZPSURfVEFHUyk7XG5cbmNvbnN0IHNwZWNpYWxCb29sZWFuQXR0cnMgPSBgaXRlbXNjb3BlLGFsbG93ZnVsbHNjcmVlbixmb3Jtbm92YWxpZGF0ZSxpc21hcCxub21vZHVsZSxub3ZhbGlkYXRlLHJlYWRvbmx5YDtcbmNvbnN0IGlzU3BlY2lhbEJvb2xlYW5BdHRyID0gLyogQF9fUFVSRV9fICovIG1ha2VNYXAoc3BlY2lhbEJvb2xlYW5BdHRycyk7XG5jb25zdCBpc0Jvb2xlYW5BdHRyID0gLyogQF9fUFVSRV9fICovIG1ha2VNYXAoXG4gIHNwZWNpYWxCb29sZWFuQXR0cnMgKyBgLGFzeW5jLGF1dG9mb2N1cyxhdXRvcGxheSxjb250cm9scyxkZWZhdWx0LGRlZmVyLGRpc2FibGVkLGhpZGRlbixpbmVydCxsb29wLG9wZW4scmVxdWlyZWQscmV2ZXJzZWQsc2NvcGVkLHNlYW1sZXNzLGNoZWNrZWQsbXV0ZWQsbXVsdGlwbGUsc2VsZWN0ZWRgXG4pO1xuZnVuY3Rpb24gaW5jbHVkZUJvb2xlYW5BdHRyKHZhbHVlKSB7XG4gIHJldHVybiAhIXZhbHVlIHx8IHZhbHVlID09PSBcIlwiO1xufVxuY29uc3QgdW5zYWZlQXR0ckNoYXJSRSA9IC9bPi89XCInXFx1MDAwOVxcdTAwMGFcXHUwMDBjXFx1MDAyMF0vO1xuY29uc3QgYXR0clZhbGlkYXRpb25DYWNoZSA9IHt9O1xuZnVuY3Rpb24gaXNTU1JTYWZlQXR0ck5hbWUobmFtZSkge1xuICBpZiAoYXR0clZhbGlkYXRpb25DYWNoZS5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgIHJldHVybiBhdHRyVmFsaWRhdGlvbkNhY2hlW25hbWVdO1xuICB9XG4gIGNvbnN0IGlzVW5zYWZlID0gdW5zYWZlQXR0ckNoYXJSRS50ZXN0KG5hbWUpO1xuICBpZiAoaXNVbnNhZmUpIHtcbiAgICBjb25zb2xlLmVycm9yKGB1bnNhZmUgYXR0cmlidXRlIG5hbWU6ICR7bmFtZX1gKTtcbiAgfVxuICByZXR1cm4gYXR0clZhbGlkYXRpb25DYWNoZVtuYW1lXSA9ICFpc1Vuc2FmZTtcbn1cbmNvbnN0IHByb3BzVG9BdHRyTWFwID0ge1xuICBhY2NlcHRDaGFyc2V0OiBcImFjY2VwdC1jaGFyc2V0XCIsXG4gIGNsYXNzTmFtZTogXCJjbGFzc1wiLFxuICBodG1sRm9yOiBcImZvclwiLFxuICBodHRwRXF1aXY6IFwiaHR0cC1lcXVpdlwiXG59O1xuY29uc3QgaXNLbm93bkh0bWxBdHRyID0gLyogQF9fUFVSRV9fICovIG1ha2VNYXAoXG4gIGBhY2NlcHQsYWNjZXB0LWNoYXJzZXQsYWNjZXNza2V5LGFjdGlvbixhbGlnbixhbGxvdyxhbHQsYXN5bmMsYXV0b2NhcGl0YWxpemUsYXV0b2NvbXBsZXRlLGF1dG9mb2N1cyxhdXRvcGxheSxiYWNrZ3JvdW5kLGJnY29sb3IsYm9yZGVyLGJ1ZmZlcmVkLGNhcHR1cmUsY2hhbGxlbmdlLGNoYXJzZXQsY2hlY2tlZCxjaXRlLGNsYXNzLGNvZGUsY29kZWJhc2UsY29sb3IsY29scyxjb2xzcGFuLGNvbnRlbnQsY29udGVudGVkaXRhYmxlLGNvbnRleHRtZW51LGNvbnRyb2xzLGNvb3Jkcyxjcm9zc29yaWdpbixjc3AsZGF0YSxkYXRldGltZSxkZWNvZGluZyxkZWZhdWx0LGRlZmVyLGRpcixkaXJuYW1lLGRpc2FibGVkLGRvd25sb2FkLGRyYWdnYWJsZSxkcm9wem9uZSxlbmN0eXBlLGVudGVya2V5aGludCxmb3IsZm9ybSxmb3JtYWN0aW9uLGZvcm1lbmN0eXBlLGZvcm1tZXRob2QsZm9ybW5vdmFsaWRhdGUsZm9ybXRhcmdldCxoZWFkZXJzLGhlaWdodCxoaWRkZW4saGlnaCxocmVmLGhyZWZsYW5nLGh0dHAtZXF1aXYsaWNvbixpZCxpbXBvcnRhbmNlLGluZXJ0LGludGVncml0eSxpc21hcCxpdGVtcHJvcCxrZXl0eXBlLGtpbmQsbGFiZWwsbGFuZyxsYW5ndWFnZSxsb2FkaW5nLGxpc3QsbG9vcCxsb3csbWFuaWZlc3QsbWF4LG1heGxlbmd0aCxtaW5sZW5ndGgsbWVkaWEsbWluLG11bHRpcGxlLG11dGVkLG5hbWUsbm92YWxpZGF0ZSxvcGVuLG9wdGltdW0scGF0dGVybixwaW5nLHBsYWNlaG9sZGVyLHBvc3RlcixwcmVsb2FkLHJhZGlvZ3JvdXAscmVhZG9ubHkscmVmZXJyZXJwb2xpY3kscmVsLHJlcXVpcmVkLHJldmVyc2VkLHJvd3Mscm93c3BhbixzYW5kYm94LHNjb3BlLHNjb3BlZCxzZWxlY3RlZCxzaGFwZSxzaXplLHNpemVzLHNsb3Qsc3BhbixzcGVsbGNoZWNrLHNyYyxzcmNkb2Msc3JjbGFuZyxzcmNzZXQsc3RhcnQsc3RlcCxzdHlsZSxzdW1tYXJ5LHRhYmluZGV4LHRhcmdldCx0aXRsZSx0cmFuc2xhdGUsdHlwZSx1c2VtYXAsdmFsdWUsd2lkdGgsd3JhcGBcbik7XG5jb25zdCBpc0tub3duU3ZnQXR0ciA9IC8qIEBfX1BVUkVfXyAqLyBtYWtlTWFwKFxuICBgeG1sbnMsYWNjZW50LWhlaWdodCxhY2N1bXVsYXRlLGFkZGl0aXZlLGFsaWdubWVudC1iYXNlbGluZSxhbHBoYWJldGljLGFtcGxpdHVkZSxhcmFiaWMtZm9ybSxhc2NlbnQsYXR0cmlidXRlTmFtZSxhdHRyaWJ1dGVUeXBlLGF6aW11dGgsYmFzZUZyZXF1ZW5jeSxiYXNlbGluZS1zaGlmdCxiYXNlUHJvZmlsZSxiYm94LGJlZ2luLGJpYXMsYnksY2FsY01vZGUsY2FwLWhlaWdodCxjbGFzcyxjbGlwLGNsaXBQYXRoVW5pdHMsY2xpcC1wYXRoLGNsaXAtcnVsZSxjb2xvcixjb2xvci1pbnRlcnBvbGF0aW9uLGNvbG9yLWludGVycG9sYXRpb24tZmlsdGVycyxjb2xvci1wcm9maWxlLGNvbG9yLXJlbmRlcmluZyxjb250ZW50U2NyaXB0VHlwZSxjb250ZW50U3R5bGVUeXBlLGNyb3Nzb3JpZ2luLGN1cnNvcixjeCxjeSxkLGRlY2VsZXJhdGUsZGVzY2VudCxkaWZmdXNlQ29uc3RhbnQsZGlyZWN0aW9uLGRpc3BsYXksZGl2aXNvcixkb21pbmFudC1iYXNlbGluZSxkdXIsZHgsZHksZWRnZU1vZGUsZWxldmF0aW9uLGVuYWJsZS1iYWNrZ3JvdW5kLGVuZCxleHBvbmVudCxmaWxsLGZpbGwtb3BhY2l0eSxmaWxsLXJ1bGUsZmlsdGVyLGZpbHRlclJlcyxmaWx0ZXJVbml0cyxmbG9vZC1jb2xvcixmbG9vZC1vcGFjaXR5LGZvbnQtZmFtaWx5LGZvbnQtc2l6ZSxmb250LXNpemUtYWRqdXN0LGZvbnQtc3RyZXRjaCxmb250LXN0eWxlLGZvbnQtdmFyaWFudCxmb250LXdlaWdodCxmb3JtYXQsZnJvbSxmcixmeCxmeSxnMSxnMixnbHlwaC1uYW1lLGdseXBoLW9yaWVudGF0aW9uLWhvcml6b250YWwsZ2x5cGgtb3JpZW50YXRpb24tdmVydGljYWwsZ2x5cGhSZWYsZ3JhZGllbnRUcmFuc2Zvcm0sZ3JhZGllbnRVbml0cyxoYW5naW5nLGhlaWdodCxocmVmLGhyZWZsYW5nLGhvcml6LWFkdi14LGhvcml6LW9yaWdpbi14LGlkLGlkZW9ncmFwaGljLGltYWdlLXJlbmRlcmluZyxpbixpbjIsaW50ZXJjZXB0LGssazEsazIsazMsazQsa2VybmVsTWF0cml4LGtlcm5lbFVuaXRMZW5ndGgsa2VybmluZyxrZXlQb2ludHMsa2V5U3BsaW5lcyxrZXlUaW1lcyxsYW5nLGxlbmd0aEFkanVzdCxsZXR0ZXItc3BhY2luZyxsaWdodGluZy1jb2xvcixsaW1pdGluZ0NvbmVBbmdsZSxsb2NhbCxtYXJrZXItZW5kLG1hcmtlci1taWQsbWFya2VyLXN0YXJ0LG1hcmtlckhlaWdodCxtYXJrZXJVbml0cyxtYXJrZXJXaWR0aCxtYXNrLG1hc2tDb250ZW50VW5pdHMsbWFza1VuaXRzLG1hdGhlbWF0aWNhbCxtYXgsbWVkaWEsbWV0aG9kLG1pbixtb2RlLG5hbWUsbnVtT2N0YXZlcyxvZmZzZXQsb3BhY2l0eSxvcGVyYXRvcixvcmRlcixvcmllbnQsb3JpZW50YXRpb24sb3JpZ2luLG92ZXJmbG93LG92ZXJsaW5lLXBvc2l0aW9uLG92ZXJsaW5lLXRoaWNrbmVzcyxwYW5vc2UtMSxwYWludC1vcmRlcixwYXRoLHBhdGhMZW5ndGgscGF0dGVybkNvbnRlbnRVbml0cyxwYXR0ZXJuVHJhbnNmb3JtLHBhdHRlcm5Vbml0cyxwaW5nLHBvaW50ZXItZXZlbnRzLHBvaW50cyxwb2ludHNBdFgscG9pbnRzQXRZLHBvaW50c0F0WixwcmVzZXJ2ZUFscGhhLHByZXNlcnZlQXNwZWN0UmF0aW8scHJpbWl0aXZlVW5pdHMscixyYWRpdXMscmVmZXJyZXJQb2xpY3kscmVmWCxyZWZZLHJlbCxyZW5kZXJpbmctaW50ZW50LHJlcGVhdENvdW50LHJlcGVhdER1cixyZXF1aXJlZEV4dGVuc2lvbnMscmVxdWlyZWRGZWF0dXJlcyxyZXN0YXJ0LHJlc3VsdCxyb3RhdGUscngscnksc2NhbGUsc2VlZCxzaGFwZS1yZW5kZXJpbmcsc2xvcGUsc3BhY2luZyxzcGVjdWxhckNvbnN0YW50LHNwZWN1bGFyRXhwb25lbnQsc3BlZWQsc3ByZWFkTWV0aG9kLHN0YXJ0T2Zmc2V0LHN0ZERldmlhdGlvbixzdGVtaCxzdGVtdixzdGl0Y2hUaWxlcyxzdG9wLWNvbG9yLHN0b3Atb3BhY2l0eSxzdHJpa2V0aHJvdWdoLXBvc2l0aW9uLHN0cmlrZXRocm91Z2gtdGhpY2tuZXNzLHN0cmluZyxzdHJva2Usc3Ryb2tlLWRhc2hhcnJheSxzdHJva2UtZGFzaG9mZnNldCxzdHJva2UtbGluZWNhcCxzdHJva2UtbGluZWpvaW4sc3Ryb2tlLW1pdGVybGltaXQsc3Ryb2tlLW9wYWNpdHksc3Ryb2tlLXdpZHRoLHN0eWxlLHN1cmZhY2VTY2FsZSxzeXN0ZW1MYW5ndWFnZSx0YWJpbmRleCx0YWJsZVZhbHVlcyx0YXJnZXQsdGFyZ2V0WCx0YXJnZXRZLHRleHQtYW5jaG9yLHRleHQtZGVjb3JhdGlvbix0ZXh0LXJlbmRlcmluZyx0ZXh0TGVuZ3RoLHRvLHRyYW5zZm9ybSx0cmFuc2Zvcm0tb3JpZ2luLHR5cGUsdTEsdTIsdW5kZXJsaW5lLXBvc2l0aW9uLHVuZGVybGluZS10aGlja25lc3MsdW5pY29kZSx1bmljb2RlLWJpZGksdW5pY29kZS1yYW5nZSx1bml0cy1wZXItZW0sdi1hbHBoYWJldGljLHYtaGFuZ2luZyx2LWlkZW9ncmFwaGljLHYtbWF0aGVtYXRpY2FsLHZhbHVlcyx2ZWN0b3ItZWZmZWN0LHZlcnNpb24sdmVydC1hZHYteSx2ZXJ0LW9yaWdpbi14LHZlcnQtb3JpZ2luLXksdmlld0JveCx2aWV3VGFyZ2V0LHZpc2liaWxpdHksd2lkdGgsd2lkdGhzLHdvcmQtc3BhY2luZyx3cml0aW5nLW1vZGUseCx4LWhlaWdodCx4MSx4Mix4Q2hhbm5lbFNlbGVjdG9yLHhsaW5rOmFjdHVhdGUseGxpbms6YXJjcm9sZSx4bGluazpocmVmLHhsaW5rOnJvbGUseGxpbms6c2hvdyx4bGluazp0aXRsZSx4bGluazp0eXBlLHhtbDpiYXNlLHhtbDpsYW5nLHhtbDpzcGFjZSx5LHkxLHkyLHlDaGFubmVsU2VsZWN0b3Iseix6b29tQW5kUGFuYFxuKTtcblxuY29uc3QgZXNjYXBlUkUgPSAvW1wiJyY8Pl0vO1xuZnVuY3Rpb24gZXNjYXBlSHRtbChzdHJpbmcpIHtcbiAgY29uc3Qgc3RyID0gXCJcIiArIHN0cmluZztcbiAgY29uc3QgbWF0Y2ggPSBlc2NhcGVSRS5leGVjKHN0cik7XG4gIGlmICghbWF0Y2gpIHtcbiAgICByZXR1cm4gc3RyO1xuICB9XG4gIGxldCBodG1sID0gXCJcIjtcbiAgbGV0IGVzY2FwZWQ7XG4gIGxldCBpbmRleDtcbiAgbGV0IGxhc3RJbmRleCA9IDA7XG4gIGZvciAoaW5kZXggPSBtYXRjaC5pbmRleDsgaW5kZXggPCBzdHIubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgc3dpdGNoIChzdHIuY2hhckNvZGVBdChpbmRleCkpIHtcbiAgICAgIGNhc2UgMzQ6XG4gICAgICAgIGVzY2FwZWQgPSBcIiZxdW90O1wiO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMzg6XG4gICAgICAgIGVzY2FwZWQgPSBcIiZhbXA7XCI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzOTpcbiAgICAgICAgZXNjYXBlZCA9IFwiJiMzOTtcIjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDYwOlxuICAgICAgICBlc2NhcGVkID0gXCImbHQ7XCI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSA2MjpcbiAgICAgICAgZXNjYXBlZCA9IFwiJmd0O1wiO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAobGFzdEluZGV4ICE9PSBpbmRleCkge1xuICAgICAgaHRtbCArPSBzdHIuc2xpY2UobGFzdEluZGV4LCBpbmRleCk7XG4gICAgfVxuICAgIGxhc3RJbmRleCA9IGluZGV4ICsgMTtcbiAgICBodG1sICs9IGVzY2FwZWQ7XG4gIH1cbiAgcmV0dXJuIGxhc3RJbmRleCAhPT0gaW5kZXggPyBodG1sICsgc3RyLnNsaWNlKGxhc3RJbmRleCwgaW5kZXgpIDogaHRtbDtcbn1cbmNvbnN0IGNvbW1lbnRTdHJpcFJFID0gL14tPz58PCEtLXwtLT58LS0hPnw8IS0kL2c7XG5mdW5jdGlvbiBlc2NhcGVIdG1sQ29tbWVudChzcmMpIHtcbiAgcmV0dXJuIHNyYy5yZXBsYWNlKGNvbW1lbnRTdHJpcFJFLCBcIlwiKTtcbn1cblxuZnVuY3Rpb24gbG9vc2VDb21wYXJlQXJyYXlzKGEsIGIpIHtcbiAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aClcbiAgICByZXR1cm4gZmFsc2U7XG4gIGxldCBlcXVhbCA9IHRydWU7XG4gIGZvciAobGV0IGkgPSAwOyBlcXVhbCAmJiBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgIGVxdWFsID0gbG9vc2VFcXVhbChhW2ldLCBiW2ldKTtcbiAgfVxuICByZXR1cm4gZXF1YWw7XG59XG5mdW5jdGlvbiBsb29zZUVxdWFsKGEsIGIpIHtcbiAgaWYgKGEgPT09IGIpXG4gICAgcmV0dXJuIHRydWU7XG4gIGxldCBhVmFsaWRUeXBlID0gaXNEYXRlKGEpO1xuICBsZXQgYlZhbGlkVHlwZSA9IGlzRGF0ZShiKTtcbiAgaWYgKGFWYWxpZFR5cGUgfHwgYlZhbGlkVHlwZSkge1xuICAgIHJldHVybiBhVmFsaWRUeXBlICYmIGJWYWxpZFR5cGUgPyBhLmdldFRpbWUoKSA9PT0gYi5nZXRUaW1lKCkgOiBmYWxzZTtcbiAgfVxuICBhVmFsaWRUeXBlID0gaXNTeW1ib2woYSk7XG4gIGJWYWxpZFR5cGUgPSBpc1N5bWJvbChiKTtcbiAgaWYgKGFWYWxpZFR5cGUgfHwgYlZhbGlkVHlwZSkge1xuICAgIHJldHVybiBhID09PSBiO1xuICB9XG4gIGFWYWxpZFR5cGUgPSBpc0FycmF5KGEpO1xuICBiVmFsaWRUeXBlID0gaXNBcnJheShiKTtcbiAgaWYgKGFWYWxpZFR5cGUgfHwgYlZhbGlkVHlwZSkge1xuICAgIHJldHVybiBhVmFsaWRUeXBlICYmIGJWYWxpZFR5cGUgPyBsb29zZUNvbXBhcmVBcnJheXMoYSwgYikgOiBmYWxzZTtcbiAgfVxuICBhVmFsaWRUeXBlID0gaXNPYmplY3QoYSk7XG4gIGJWYWxpZFR5cGUgPSBpc09iamVjdChiKTtcbiAgaWYgKGFWYWxpZFR5cGUgfHwgYlZhbGlkVHlwZSkge1xuICAgIGlmICghYVZhbGlkVHlwZSB8fCAhYlZhbGlkVHlwZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBhS2V5c0NvdW50ID0gT2JqZWN0LmtleXMoYSkubGVuZ3RoO1xuICAgIGNvbnN0IGJLZXlzQ291bnQgPSBPYmplY3Qua2V5cyhiKS5sZW5ndGg7XG4gICAgaWYgKGFLZXlzQ291bnQgIT09IGJLZXlzQ291bnQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBrZXkgaW4gYSkge1xuICAgICAgY29uc3QgYUhhc0tleSA9IGEuaGFzT3duUHJvcGVydHkoa2V5KTtcbiAgICAgIGNvbnN0IGJIYXNLZXkgPSBiLmhhc093blByb3BlcnR5KGtleSk7XG4gICAgICBpZiAoYUhhc0tleSAmJiAhYkhhc0tleSB8fCAhYUhhc0tleSAmJiBiSGFzS2V5IHx8ICFsb29zZUVxdWFsKGFba2V5XSwgYltrZXldKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBTdHJpbmcoYSkgPT09IFN0cmluZyhiKTtcbn1cbmZ1bmN0aW9uIGxvb3NlSW5kZXhPZihhcnIsIHZhbCkge1xuICByZXR1cm4gYXJyLmZpbmRJbmRleCgoaXRlbSkgPT4gbG9vc2VFcXVhbChpdGVtLCB2YWwpKTtcbn1cblxuY29uc3QgdG9EaXNwbGF5U3RyaW5nID0gKHZhbCkgPT4ge1xuICByZXR1cm4gaXNTdHJpbmcodmFsKSA/IHZhbCA6IHZhbCA9PSBudWxsID8gXCJcIiA6IGlzQXJyYXkodmFsKSB8fCBpc09iamVjdCh2YWwpICYmICh2YWwudG9TdHJpbmcgPT09IG9iamVjdFRvU3RyaW5nIHx8ICFpc0Z1bmN0aW9uKHZhbC50b1N0cmluZykpID8gSlNPTi5zdHJpbmdpZnkodmFsLCByZXBsYWNlciwgMikgOiBTdHJpbmcodmFsKTtcbn07XG5jb25zdCByZXBsYWNlciA9IChfa2V5LCB2YWwpID0+IHtcbiAgaWYgKHZhbCAmJiB2YWwuX192X2lzUmVmKSB7XG4gICAgcmV0dXJuIHJlcGxhY2VyKF9rZXksIHZhbC52YWx1ZSk7XG4gIH0gZWxzZSBpZiAoaXNNYXAodmFsKSkge1xuICAgIHJldHVybiB7XG4gICAgICBbYE1hcCgke3ZhbC5zaXplfSlgXTogWy4uLnZhbC5lbnRyaWVzKCldLnJlZHVjZSgoZW50cmllcywgW2tleSwgdmFsMl0pID0+IHtcbiAgICAgICAgZW50cmllc1tgJHtrZXl9ID0+YF0gPSB2YWwyO1xuICAgICAgICByZXR1cm4gZW50cmllcztcbiAgICAgIH0sIHt9KVxuICAgIH07XG4gIH0gZWxzZSBpZiAoaXNTZXQodmFsKSkge1xuICAgIHJldHVybiB7XG4gICAgICBbYFNldCgke3ZhbC5zaXplfSlgXTogWy4uLnZhbC52YWx1ZXMoKV1cbiAgICB9O1xuICB9IGVsc2UgaWYgKGlzT2JqZWN0KHZhbCkgJiYgIWlzQXJyYXkodmFsKSAmJiAhaXNQbGFpbk9iamVjdCh2YWwpKSB7XG4gICAgcmV0dXJuIFN0cmluZyh2YWwpO1xuICB9XG4gIHJldHVybiB2YWw7XG59O1xuXG5leHBvcnQgeyBFTVBUWV9BUlIsIEVNUFRZX09CSiwgTk8sIE5PT1AsIFBhdGNoRmxhZ05hbWVzLCBjYW1lbGl6ZSwgY2FwaXRhbGl6ZSwgZGVmLCBlc2NhcGVIdG1sLCBlc2NhcGVIdG1sQ29tbWVudCwgZXh0ZW5kLCBnZW5Qcm9wc0FjY2Vzc0V4cCwgZ2VuZXJhdGVDb2RlRnJhbWUsIGdldEdsb2JhbFRoaXMsIGhhc0NoYW5nZWQsIGhhc093biwgaHlwaGVuYXRlLCBpbmNsdWRlQm9vbGVhbkF0dHIsIGludm9rZUFycmF5Rm5zLCBpc0FycmF5LCBpc0Jvb2xlYW5BdHRyLCBpc0J1aWx0SW5EaXJlY3RpdmUsIGlzRGF0ZSwgaXNGdW5jdGlvbiwgaXNHbG9iYWxseVdoaXRlbGlzdGVkLCBpc0hUTUxUYWcsIGlzSW50ZWdlcktleSwgaXNLbm93bkh0bWxBdHRyLCBpc0tub3duU3ZnQXR0ciwgaXNNYXAsIGlzTW9kZWxMaXN0ZW5lciwgaXNPYmplY3QsIGlzT24sIGlzUGxhaW5PYmplY3QsIGlzUHJvbWlzZSwgaXNSZWdFeHAsIGlzUmVzZXJ2ZWRQcm9wLCBpc1NTUlNhZmVBdHRyTmFtZSwgaXNTVkdUYWcsIGlzU2V0LCBpc1NwZWNpYWxCb29sZWFuQXR0ciwgaXNTdHJpbmcsIGlzU3ltYm9sLCBpc1ZvaWRUYWcsIGxvb3NlRXF1YWwsIGxvb3NlSW5kZXhPZiwgbG9vc2VUb051bWJlciwgbWFrZU1hcCwgbm9ybWFsaXplQ2xhc3MsIG5vcm1hbGl6ZVByb3BzLCBub3JtYWxpemVTdHlsZSwgb2JqZWN0VG9TdHJpbmcsIHBhcnNlU3RyaW5nU3R5bGUsIHByb3BzVG9BdHRyTWFwLCByZW1vdmUsIHNsb3RGbGFnc1RleHQsIHN0cmluZ2lmeVN0eWxlLCB0b0Rpc3BsYXlTdHJpbmcsIHRvSGFuZGxlcktleSwgdG9OdW1iZXIsIHRvUmF3VHlwZSwgdG9UeXBlU3RyaW5nIH07XG4iLCJleHBvcnRzLmludGVyb3BEZWZhdWx0ID0gZnVuY3Rpb24gKGEpIHtcbiAgcmV0dXJuIGEgJiYgYS5fX2VzTW9kdWxlID8gYSA6IHtkZWZhdWx0OiBhfTtcbn07XG5cbmV4cG9ydHMuZGVmaW5lSW50ZXJvcEZsYWcgPSBmdW5jdGlvbiAoYSkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYSwgJ19fZXNNb2R1bGUnLCB7dmFsdWU6IHRydWV9KTtcbn07XG5cbmV4cG9ydHMuZXhwb3J0QWxsID0gZnVuY3Rpb24gKHNvdXJjZSwgZGVzdCkge1xuICBPYmplY3Qua2V5cyhzb3VyY2UpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIGlmIChrZXkgPT09ICdkZWZhdWx0JyB8fCBrZXkgPT09ICdfX2VzTW9kdWxlJyB8fCBkZXN0Lmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZGVzdCwga2V5LCB7XG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2Vba2V5XTtcbiAgICAgIH0sXG4gICAgfSk7XG4gIH0pO1xuXG4gIHJldHVybiBkZXN0O1xufTtcblxuZXhwb3J0cy5leHBvcnQgPSBmdW5jdGlvbiAoZGVzdCwgZGVzdE5hbWUsIGdldCkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZGVzdCwgZGVzdE5hbWUsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZ2V0LFxuICB9KTtcbn07XG4iLCJpbXBvcnQgdHlwZSB7IFBsYXNtb0NTVUksIFBsYXNtb0NTVUlBbmNob3IsIFBsYXNtb0NTVUlNb3VudFN0YXRlIH0gZnJvbSBcIn50eXBlXCJcblxuYXN5bmMgZnVuY3Rpb24gY3JlYXRlU2hhZG93RE9NPFQ+KE1vdW50OiBQbGFzbW9DU1VJPFQ+KSB7XG4gIGNvbnN0IHNoYWRvd0hvc3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwicGxhc21vLWNzdWlcIilcblxuICBjb25zdCBzaGFkb3dSb290ID1cbiAgICB0eXBlb2YgTW91bnQuY3JlYXRlU2hhZG93Um9vdCA9PT0gXCJmdW5jdGlvblwiXG4gICAgICA/IGF3YWl0IE1vdW50LmNyZWF0ZVNoYWRvd1Jvb3Qoc2hhZG93SG9zdClcbiAgICAgIDogc2hhZG93SG9zdC5hdHRhY2hTaGFkb3coeyBtb2RlOiBcIm9wZW5cIiB9KVxuXG4gIGNvbnN0IHNoYWRvd0NvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIilcblxuICBzaGFkb3dDb250YWluZXIuaWQgPSBcInBsYXNtby1zaGFkb3ctY29udGFpbmVyXCJcbiAgc2hhZG93Q29udGFpbmVyLnN0eWxlLnpJbmRleCA9IFwiMjE0NzQ4MzY0N1wiXG4gIHNoYWRvd0NvbnRhaW5lci5zdHlsZS5wb3NpdGlvbiA9IFwicmVsYXRpdmVcIlxuXG4gIHNoYWRvd1Jvb3QuYXBwZW5kQ2hpbGQoc2hhZG93Q29udGFpbmVyKVxuXG4gIHJldHVybiB7XG4gICAgc2hhZG93SG9zdCxcbiAgICBzaGFkb3dSb290LFxuICAgIHNoYWRvd0NvbnRhaW5lclxuICB9XG59XG5cbmV4cG9ydCB0eXBlIFBsYXNtb0NTVUlTaGFkb3dET00gPSBBd2FpdGVkPFJldHVyblR5cGU8dHlwZW9mIGNyZWF0ZVNoYWRvd0RPTT4+XG5cbmFzeW5jIGZ1bmN0aW9uIGluamVjdEFuY2hvcjxUPihcbiAgTW91bnQ6IFBsYXNtb0NTVUk8VD4sXG4gIGFuY2hvcjogUGxhc21vQ1NVSUFuY2hvcixcbiAgeyBzaGFkb3dIb3N0LCBzaGFkb3dSb290IH06IFBsYXNtb0NTVUlTaGFkb3dET00sXG4gIG1vdW50U3RhdGU/OiBQbGFzbW9DU1VJTW91bnRTdGF0ZVxuKSB7XG4gIGlmICh0eXBlb2YgTW91bnQuZ2V0U3R5bGUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGNvbnN0IHNmY1N0eWxlQ29udGVudCA9XG4gICAgICB0eXBlb2YgTW91bnQuZ2V0U2ZjU3R5bGVDb250ZW50ID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgPyBhd2FpdCBNb3VudC5nZXRTZmNTdHlsZUNvbnRlbnQoKVxuICAgICAgICA6IFwiXCJcbiAgICBzaGFkb3dSb290LnByZXBlbmQoYXdhaXQgTW91bnQuZ2V0U3R5bGUoeyAuLi5hbmNob3IsIHNmY1N0eWxlQ29udGVudCB9KSlcbiAgfVxuXG4gIGlmICh0eXBlb2YgTW91bnQuZ2V0U2hhZG93SG9zdElkID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBzaGFkb3dIb3N0LmlkID0gYXdhaXQgTW91bnQuZ2V0U2hhZG93SG9zdElkKGFuY2hvcilcbiAgfVxuXG4gIGlmICh0eXBlb2YgTW91bnQubW91bnRTaGFkb3dIb3N0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBhd2FpdCBNb3VudC5tb3VudFNoYWRvd0hvc3Qoe1xuICAgICAgc2hhZG93SG9zdCxcbiAgICAgIGFuY2hvcixcbiAgICAgIG1vdW50U3RhdGVcbiAgICB9KVxuICB9IGVsc2UgaWYgKGFuY2hvci50eXBlID09PSBcImlubGluZVwiKSB7XG4gICAgYW5jaG9yLmVsZW1lbnQuaW5zZXJ0QWRqYWNlbnRFbGVtZW50KFwiYWZ0ZXJlbmRcIiwgc2hhZG93SG9zdClcbiAgfSBlbHNlIHtcbiAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQucHJlcGVuZChzaGFkb3dIb3N0KVxuICB9XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjcmVhdGVTaGFkb3dDb250YWluZXI8VD4oXG4gIE1vdW50OiBQbGFzbW9DU1VJPFQ+LFxuICBhbmNob3I6IFBsYXNtb0NTVUlBbmNob3IsXG4gIG1vdW50U3RhdGU/OiBQbGFzbW9DU1VJTW91bnRTdGF0ZVxuKSB7XG4gIGNvbnN0IHNoYWRvd0RvbSA9IGF3YWl0IGNyZWF0ZVNoYWRvd0RPTShNb3VudClcblxuICBtb3VudFN0YXRlPy5ob3N0U2V0LmFkZChzaGFkb3dEb20uc2hhZG93SG9zdClcbiAgbW91bnRTdGF0ZT8uaG9zdE1hcC5zZXQoc2hhZG93RG9tLnNoYWRvd0hvc3QsIGFuY2hvcilcblxuICBhd2FpdCBpbmplY3RBbmNob3IoTW91bnQsIGFuY2hvciwgc2hhZG93RG9tLCBtb3VudFN0YXRlKVxuXG4gIHJldHVybiBzaGFkb3dEb20uc2hhZG93Q29udGFpbmVyXG59XG5cbmNvbnN0IGlzVmlzaWJsZSA9IChlbDogRWxlbWVudCkgPT4ge1xuICBpZiAoIWVsKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgY29uc3QgZWxlbWVudFJlY3QgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuICBjb25zdCBlbGVtZW50U3R5bGUgPSBnbG9iYWxUaGlzLmdldENvbXB1dGVkU3R5bGUoZWwpXG5cbiAgLy8gY29uc29sZS5sb2coZWxlbWVudFJlY3QsIGVsZW1lbnRTdHlsZSlcblxuICBpZiAoZWxlbWVudFN0eWxlLmRpc3BsYXkgPT09IFwibm9uZVwiKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBpZiAoZWxlbWVudFN0eWxlLnZpc2liaWxpdHkgPT09IFwiaGlkZGVuXCIpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIGlmIChlbGVtZW50U3R5bGUub3BhY2l0eSA9PT0gXCIwXCIpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIGlmIChcbiAgICBlbGVtZW50UmVjdC53aWR0aCA9PT0gMCAmJlxuICAgIGVsZW1lbnRSZWN0LmhlaWdodCA9PT0gMCAmJlxuICAgIGVsZW1lbnRTdHlsZS5vdmVyZmxvdyAhPT0gXCJoaWRkZW5cIlxuICApIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIC8vIENoZWNrIGlmIHRoZSBlbGVtZW50IGlzIGlycmV2b2NhYmx5IG9mZi1zY3JlZW46XG4gIGlmIChcbiAgICBlbGVtZW50UmVjdC54ICsgZWxlbWVudFJlY3Qud2lkdGggPCAwIHx8XG4gICAgZWxlbWVudFJlY3QueSArIGVsZW1lbnRSZWN0LmhlaWdodCA8IDBcbiAgKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICByZXR1cm4gdHJ1ZVxufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQW5jaG9yT2JzZXJ2ZXI8VD4oTW91bnQ6IFBsYXNtb0NTVUk8VD4pIHtcbiAgY29uc3QgbW91bnRTdGF0ZTogUGxhc21vQ1NVSU1vdW50U3RhdGUgPSB7XG4gICAgZG9jdW1lbnQ6IGRvY3VtZW50IHx8IHdpbmRvdy5kb2N1bWVudCxcbiAgICBvYnNlcnZlcjogbnVsbCxcblxuICAgIG1vdW50SW50ZXJ2YWw6IG51bGwsXG5cbiAgICBpc01vdW50aW5nOiBmYWxzZSxcbiAgICBpc011dGF0ZWQ6IGZhbHNlLFxuXG4gICAgaG9zdFNldDogbmV3IFNldCgpLFxuICAgIGhvc3RNYXA6IG5ldyBXZWFrTWFwKCksXG5cbiAgICBvdmVybGF5VGFyZ2V0TGlzdDogW11cbiAgfVxuXG4gIGNvbnN0IGlzTW91bnRlZCA9IChlbDogRWxlbWVudCB8IG51bGwpID0+XG4gICAgZWw/LmlkXG4gICAgICA/ICEhZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZWwuaWQpXG4gICAgICA6IGVsPy5nZXRSb290Tm9kZSh7IGNvbXBvc2VkOiB0cnVlIH0pID09PSBtb3VudFN0YXRlLmRvY3VtZW50XG5cbiAgY29uc3QgaGFzSW5saW5lQW5jaG9yID0gdHlwZW9mIE1vdW50LmdldElubGluZUFuY2hvciA9PT0gXCJmdW5jdGlvblwiXG4gIGNvbnN0IGhhc092ZXJsYXlBbmNob3IgPSB0eXBlb2YgTW91bnQuZ2V0T3ZlcmxheUFuY2hvciA9PT0gXCJmdW5jdGlvblwiXG5cbiAgY29uc3QgaGFzSW5saW5lQW5jaG9yTGlzdCA9IHR5cGVvZiBNb3VudC5nZXRJbmxpbmVBbmNob3JMaXN0ID09PSBcImZ1bmN0aW9uXCJcbiAgY29uc3QgaGFzT3ZlcmxheUFuY2hvckxpc3QgPSB0eXBlb2YgTW91bnQuZ2V0T3ZlcmxheUFuY2hvckxpc3QgPT09IFwiZnVuY3Rpb25cIlxuXG4gIGNvbnN0IHNob3VsZE9ic2VydmUgPVxuICAgIGhhc0lubGluZUFuY2hvciB8fFxuICAgIGhhc092ZXJsYXlBbmNob3IgfHxcbiAgICBoYXNJbmxpbmVBbmNob3JMaXN0IHx8XG4gICAgaGFzT3ZlcmxheUFuY2hvckxpc3RcblxuICBpZiAoIXNob3VsZE9ic2VydmUpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgYXN5bmMgZnVuY3Rpb24gbW91bnRBbmNob3JzKHJlbmRlcjogKGFuY2hvcj86IFBsYXNtb0NTVUlBbmNob3IpID0+IHZvaWQpIHtcbiAgICBtb3VudFN0YXRlLmlzTW91bnRpbmcgPSB0cnVlXG5cbiAgICBjb25zdCBtb3VudGVkSW5saW5lQW5jaG9yU2V0ID0gbmV3IFdlYWtTZXQoKVxuXG4gICAgLy8gVGhlcmUgc2hvdWxkIG9ubHkgYmUgMSBvdmVybGF5IG1vdW50XG4gICAgbGV0IG92ZXJsYXlIb3N0OiBFbGVtZW50ID0gbnVsbFxuXG4gICAgLy8gR28gdGhyb3VnaCBtb3VudGVkIHNldHMgYW5kIGNoZWNrIGlmIHRoZXkgYXJlIHN0aWxsIG1vdW50ZWRcbiAgICBmb3IgKGNvbnN0IGVsIG9mIG1vdW50U3RhdGUuaG9zdFNldCkge1xuICAgICAgaWYgKGlzTW91bnRlZChlbCkpIHtcbiAgICAgICAgY29uc3QgYW5jaG9yID0gbW91bnRTdGF0ZS5ob3N0TWFwLmdldChlbClcbiAgICAgICAgaWYgKCEhYW5jaG9yKSB7XG4gICAgICAgICAgaWYgKGFuY2hvci50eXBlID09PSBcImlubGluZVwiKSB7XG4gICAgICAgICAgICBtb3VudGVkSW5saW5lQW5jaG9yU2V0LmFkZChhbmNob3IuZWxlbWVudClcbiAgICAgICAgICB9IGVsc2UgaWYgKGFuY2hvci50eXBlID09PSBcIm92ZXJsYXlcIikge1xuICAgICAgICAgICAgb3ZlcmxheUhvc3QgPSBlbFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbW91bnRTdGF0ZS5ob3N0U2V0LmRlbGV0ZShlbClcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBbaW5saW5lQW5jaG9yLCBpbmxpbmVBbmNob3JMaXN0LCBvdmVybGF5QW5jaG9yLCBvdmVybGF5QW5jaG9yTGlzdF0gPVxuICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICBoYXNJbmxpbmVBbmNob3IgPyBNb3VudC5nZXRJbmxpbmVBbmNob3IoKSA6IG51bGwsXG4gICAgICAgIGhhc0lubGluZUFuY2hvckxpc3QgPyBNb3VudC5nZXRJbmxpbmVBbmNob3JMaXN0KCkgOiBudWxsLFxuICAgICAgICBoYXNPdmVybGF5QW5jaG9yID8gTW91bnQuZ2V0T3ZlcmxheUFuY2hvcigpIDogbnVsbCxcbiAgICAgICAgaGFzT3ZlcmxheUFuY2hvckxpc3QgPyBNb3VudC5nZXRPdmVybGF5QW5jaG9yTGlzdCgpIDogbnVsbFxuICAgICAgXSlcblxuICAgIGNvbnN0IHJlbmRlckxpc3Q6IFBsYXNtb0NTVUlBbmNob3JbXSA9IFtdXG5cbiAgICBpZiAoISFpbmxpbmVBbmNob3IgJiYgIW1vdW50ZWRJbmxpbmVBbmNob3JTZXQuaGFzKGlubGluZUFuY2hvcikpIHtcbiAgICAgIHJlbmRlckxpc3QucHVzaCh7XG4gICAgICAgIGVsZW1lbnQ6IGlubGluZUFuY2hvcixcbiAgICAgICAgdHlwZTogXCJpbmxpbmVcIlxuICAgICAgfSlcbiAgICB9XG5cbiAgICBpZiAoKGlubGluZUFuY2hvckxpc3Q/Lmxlbmd0aCB8fCAwKSA+IDApIHtcbiAgICAgIGlubGluZUFuY2hvckxpc3QuZm9yRWFjaCgoaW5saW5lQW5jaG9yKSA9PiB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBpbmxpbmVBbmNob3IgaW5zdGFuY2VvZiBFbGVtZW50ICYmXG4gICAgICAgICAgIW1vdW50ZWRJbmxpbmVBbmNob3JTZXQuaGFzKGlubGluZUFuY2hvcilcbiAgICAgICAgKSB7XG4gICAgICAgICAgcmVuZGVyTGlzdC5wdXNoKHtcbiAgICAgICAgICAgIGVsZW1lbnQ6IGlubGluZUFuY2hvcixcbiAgICAgICAgICAgIHR5cGU6IFwiaW5saW5lXCJcbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cblxuICAgIGNvbnN0IG92ZXJsYXlUYXJnZXRMaXN0ID0gW11cblxuICAgIGlmICghIW92ZXJsYXlBbmNob3IgJiYgaXNWaXNpYmxlKG92ZXJsYXlBbmNob3IpKSB7XG4gICAgICBvdmVybGF5VGFyZ2V0TGlzdC5wdXNoKG92ZXJsYXlBbmNob3IpXG4gICAgfVxuXG4gICAgaWYgKChvdmVybGF5QW5jaG9yTGlzdD8ubGVuZ3RoIHx8IDApID4gMCkge1xuICAgICAgb3ZlcmxheUFuY2hvckxpc3QuZm9yRWFjaCgoZWwpID0+IHtcbiAgICAgICAgaWYgKGVsIGluc3RhbmNlb2YgRWxlbWVudCAmJiBpc1Zpc2libGUoZWwpKSB7XG4gICAgICAgICAgb3ZlcmxheVRhcmdldExpc3QucHVzaChlbClcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG5cbiAgICBpZiAob3ZlcmxheVRhcmdldExpc3QubGVuZ3RoID4gMCkge1xuICAgICAgbW91bnRTdGF0ZS5vdmVybGF5VGFyZ2V0TGlzdCA9IG92ZXJsYXlUYXJnZXRMaXN0XG4gICAgICBpZiAoIW92ZXJsYXlIb3N0KSB7XG4gICAgICAgIHJlbmRlckxpc3QucHVzaCh7XG4gICAgICAgICAgZWxlbWVudDogZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LFxuICAgICAgICAgIHR5cGU6IFwib3ZlcmxheVwiXG4gICAgICAgIH0pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBmb3JjZSByZS1yZW5kZXJcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgb3ZlcmxheUhvc3Q/LnJlbW92ZSgpXG4gICAgICBtb3VudFN0YXRlLmhvc3RTZXQuZGVsZXRlKG92ZXJsYXlIb3N0KVxuICAgIH1cblxuICAgIGF3YWl0IFByb21pc2UuYWxsKHJlbmRlckxpc3QubWFwKHJlbmRlcikpXG5cbiAgICBpZiAobW91bnRTdGF0ZS5pc011dGF0ZWQpIHtcbiAgICAgIG1vdW50U3RhdGUuaXNNdXRhdGVkID0gZmFsc2VcbiAgICAgIGF3YWl0IG1vdW50QW5jaG9ycyhyZW5kZXIpXG4gICAgfVxuXG4gICAgbW91bnRTdGF0ZS5pc01vdW50aW5nID0gZmFsc2VcbiAgfVxuXG4gIGNvbnN0IHN0YXJ0ID0gKHJlbmRlcjogKGFuY2hvcj86IFBsYXNtb0NTVUlBbmNob3IpID0+IHZvaWQpID0+IHtcbiAgICBtb3VudFN0YXRlLm9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoKCkgPT4ge1xuICAgICAgaWYgKG1vdW50U3RhdGUuaXNNb3VudGluZykge1xuICAgICAgICBtb3VudFN0YXRlLmlzTXV0YXRlZCA9IHRydWVcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICBtb3VudEFuY2hvcnMocmVuZGVyKVxuICAgIH0pXG5cbiAgICAvLyBOZWVkIHRvIHdhdGNoIHRoZSBzdWJ0cmVlIGZvciBzaGFkb3dET01cbiAgICBtb3VudFN0YXRlLm9ic2VydmVyLm9ic2VydmUoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCB7XG4gICAgICBjaGlsZExpc3Q6IHRydWUsXG4gICAgICBzdWJ0cmVlOiB0cnVlXG4gICAgfSlcblxuICAgIG1vdW50U3RhdGUubW91bnRJbnRlcnZhbCA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgIGlmIChtb3VudFN0YXRlLmlzTW91bnRpbmcpIHtcbiAgICAgICAgbW91bnRTdGF0ZS5pc011dGF0ZWQgPSB0cnVlXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgbW91bnRBbmNob3JzKHJlbmRlcilcbiAgICB9LCAxNDIpXG4gIH1cblxuICByZXR1cm4ge1xuICAgIHN0YXJ0LFxuICAgIG1vdW50U3RhdGVcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgY3JlYXRlUmVuZGVyID0gPFQ+KFxuICBNb3VudDogUGxhc21vQ1NVSTxUPixcbiAgY29udGFpbmVyczogW1QsIFRdLFxuICBtb3VudFN0YXRlPzogUGxhc21vQ1NVSU1vdW50U3RhdGUsXG4gIHJlbmRlckZ4PzogKGFuY2hvcjogUGxhc21vQ1NVSUFuY2hvciwgcm9vdENvbnRhaW5lcjogRWxlbWVudCkgPT4gUHJvbWlzZTx2b2lkPlxuKSA9PiB7XG4gIGNvbnN0IGNyZWF0ZVJvb3RDb250YWluZXIgPSAoYW5jaG9yOiBQbGFzbW9DU1VJQW5jaG9yKSA9PlxuICAgIHR5cGVvZiBNb3VudC5nZXRSb290Q29udGFpbmVyID09PSBcImZ1bmN0aW9uXCJcbiAgICAgID8gTW91bnQuZ2V0Um9vdENvbnRhaW5lcih7XG4gICAgICAgICAgYW5jaG9yLFxuICAgICAgICAgIG1vdW50U3RhdGVcbiAgICAgICAgfSlcbiAgICAgIDogY3JlYXRlU2hhZG93Q29udGFpbmVyKE1vdW50LCBhbmNob3IsIG1vdW50U3RhdGUpXG5cbiAgaWYgKHR5cGVvZiBNb3VudC5yZW5kZXIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHJldHVybiAoYW5jaG9yOiBQbGFzbW9DU1VJQW5jaG9yKSA9PlxuICAgICAgTW91bnQucmVuZGVyKFxuICAgICAgICB7XG4gICAgICAgICAgYW5jaG9yLFxuICAgICAgICAgIGNyZWF0ZVJvb3RDb250YWluZXJcbiAgICAgICAgfSxcbiAgICAgICAgLi4uY29udGFpbmVyc1xuICAgICAgKVxuICB9XG5cbiAgcmV0dXJuIGFzeW5jIChhbmNob3I6IFBsYXNtb0NTVUlBbmNob3IpID0+IHtcbiAgICBjb25zdCByb290Q29udGFpbmVyID0gYXdhaXQgY3JlYXRlUm9vdENvbnRhaW5lcihhbmNob3IpXG4gICAgcmV0dXJuIHJlbmRlckZ4KGFuY2hvciwgcm9vdENvbnRhaW5lcilcbiAgfVxufVxuIiwiaW1wb3J0IHR5cGUgeyBQbGFzbW9DU1VJQ29udGFpbmVyUHJvcHMgfSBmcm9tIFwifnR5cGVcIlxuXG5leHBvcnQgY29uc3QgY3JlYXRlT3ZlcmxheUNTVUlDb250YWluZXIgPSAocHJvcHM6IFBsYXNtb0NTVUlDb250YWluZXJQcm9wcykgPT4ge1xuICBjb25zdCBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpXG4gIGNvbnRhaW5lci5jbGFzc05hbWUgPSBcInBsYXNtby1jc3VpLWNvbnRhaW5lclwiXG4gIGNvbnRhaW5lci5pZCA9IHByb3BzLmlkXG5cbiAgY29udGFpbmVyLnN0eWxlLmNzc1RleHQgPSBgXG4gICAgZGlzcGxheTogZmxleDtcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgdG9wOiAwcHg7XG4gICAgbGVmdDogMHB4O1xuICBgXG5cbiAgaWYgKHByb3BzLmFuY2hvci50eXBlID09PSBcIm92ZXJsYXlcIikge1xuICAgIGNvbnN0IHVwZGF0ZVBvc2l0aW9uID0gYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcmVjdCA9IHByb3BzLmFuY2hvci5lbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG5cbiAgICAgIGlmICghcmVjdCkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgY29uc3QgcG9zID0ge1xuICAgICAgICBsZWZ0OiByZWN0LmxlZnQgKyB3aW5kb3cuc2Nyb2xsWCxcbiAgICAgICAgdG9wOiByZWN0LnRvcCArIHdpbmRvdy5zY3JvbGxZXG4gICAgICB9XG5cbiAgICAgIGNvbnRhaW5lci5zdHlsZS50b3AgPSBgJHtwb3MudG9wfXB4YFxuICAgICAgY29udGFpbmVyLnN0eWxlLmxlZnQgPSBgJHtwb3MubGVmdH1weGBcbiAgICB9XG5cbiAgICB1cGRhdGVQb3NpdGlvbigpXG5cbiAgICBwcm9wcy53YXRjaE92ZXJsYXlBbmNob3I/Lih1cGRhdGVQb3NpdGlvbilcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCB1cGRhdGVQb3NpdGlvbilcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCB1cGRhdGVQb3NpdGlvbilcbiAgfVxuXG4gIHJldHVybiBjb250YWluZXJcbn1cblxuZXhwb3J0IGNvbnN0IGNyZWF0ZUlubGluZUNTVUlDb250YWluZXIgPSAocHJvcHM6IFBsYXNtb0NTVUlDb250YWluZXJQcm9wcykgPT4ge1xuICBjb25zdCBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpXG4gIGNvbnRhaW5lci5jbGFzc05hbWUgPSBcInBsYXNtby1jc3VpLWNvbnRhaW5lclwiXG4gIGNvbnRhaW5lci5pZCA9IFwicGxhc21vLWlubGluZVwiXG5cbiAgY29udGFpbmVyLnN0eWxlLmNzc1RleHQgPSBgXG4gICAgZGlzcGxheTogZmxleDtcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgdG9wOiAwcHg7XG4gICAgbGVmdDogMHB4O1xuICBgXG5cbiAgcmV0dXJuIGNvbnRhaW5lclxufVxuIiwiZ2xvYmFsVGhpcy5fX1ZVRV9PUFRJT05TX0FQSV9fID0gdHJ1ZVxuZ2xvYmFsVGhpcy5fX1ZVRV9QUk9EX0RFVlRPT0xTX18gPSBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCJcbiIsbnVsbF0sIm5hbWVzIjpbXSwidmVyc2lvbiI6MywiZmlsZSI6InBsYXNtby1pbmxpbmUuZDU3YjZlOWYuanMubWFwIn0=
 globalThis.define=__define;  })(globalThis.define);